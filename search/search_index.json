{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FPL Squad Optimizer","text":"<p>This project provides a Python-based solution to optimize Fantasy Premier League (FPL) squad selection using Integer Linear Programming (ILP). It fetches player, team, and fixture data from the official FPL API, calculates Expected Points (xP) for all players, and then uses an optimization algorithm to build the highest-scoring 15-player squad within a specified budget and team limits.</p> <p>This project aims to provide a free and open-source xP prediction algorithm, that is directly integrated with a solver. It only uses freely available data from the FPL API.</p> <p>This has obvious limitations compared to algorithms and solvers which can use pay-walled data (such as Opta, FBREF, FFH), but we give the user flexibility to adjust the algorithm using a configuration file.</p> <p>The introduction of defensive contribution points in 25/26, in particular, causes an issues because the FPL API currently return '0' defensive contribution points, and does not provide any historic data. Once the season starts, these points will be taken into account by the algorithm</p>"},{"location":"#features","title":"\u2728 Features","text":"<ul> <li>FPL Data Integration: Fetches up-to-date player, team, and fixture information directly from the official FPL API</li> <li>Expected Points (xP) Prediction: Calculates a player's expected points based on historical performance, team strengths, opponent difficulty (Fixture Difficulty Rating - FDR), and expected minutes played</li> <li>Granular Expected Minutes: Refined logic to predict player minutes, especially for those with low historical play, ensuring more realistic xP values</li> <li>Multi-Gameweek Optimization: Optimize your squad over multiple upcoming gameweeks to plan for future fixtures</li> <li>Configurable Parameters: Easily adjust probabilities, low-minute penalties, chip usage, player exclusion, xP thresholds, budget, and team limits via a dedicated configuration file</li> </ul>"},{"location":"#how-it-works","title":"\ud83d\ude80 How It Works","text":"<p>The project is structured into three main components:</p> <p><code>config.py</code></p> <p>Contains all configuration variables needed by the solver and predictor:</p> <ul> <li>FPL scoring rules</li> <li>Player statistics</li> <li>Squad constraints</li> </ul> <p><code>xp_predictor.py</code></p> <p>Calculates expected points (xP) for each player over multiple gameweeks</p> <p>Accounts for:</p> <ul> <li>Minutes played probability (with confidence adjustments)</li> <li>Clean sheet probability</li> <li>Goal-scoring probability</li> <li>Assist probability</li> <li>Bonus points probability</li> <li>Defensive contributions (new for 2025/26)</li> <li>Historical reliability (reduces xP for unproven players)</li> </ul> <p><code>solver.py</code></p> <p>Core optimization engine using xP-calculated player data</p> <p>Features:</p> <ul> <li>Sets up Integer Linear Programming (ILP) using PuLP</li> <li>Defines squad constraints (size, positions, budget, team limits)</li> <li>Maximizes total expected points</li> <li>Prints detailed squad summary and breakdown position, and a team-by-team player count.</li> </ul>"},{"location":"#setup-and-installation","title":"\ud83d\udee0\ufe0f Setup and Installation","text":"<p>To get the FPL Squad Optimizer running on your local machine, follow these steps:</p> <ol> <li>Clone the Repository (if applicable):</li> </ol> <pre><code>git clone git@github.com:thomaszwagerman/fpl-solver.git\ncd fpl-solver\n</code></pre> <ol> <li>Create a Virtual Environment (Recommended):</li> </ol> <pre><code>python -m venv venv\nsource venv/bin/activate\n</code></pre> <ol> <li>Install locally:    Install <code>fpl-solver</code> locally:</li> </ol> <pre><code>pip install .\n</code></pre>"},{"location":"#usage","title":"\ud83d\ude80 Usage","text":"<p>Once you have set up the environment and installed the dependencies, you can run the optimizer from your terminal:</p> <pre><code>python run_solver.py\n</code></pre> <p>The script will:</p> <ol> <li>Initialize the FPL Predictor to fetch the latest data</li> <li>Calculate expected points for all players over the number of gameweeks specified in <code>config.py</code></li> <li>Run the optimization solver</li> <li>Print the optimal 15-player squad, its total cost, and total expected points</li> </ol>"},{"location":"#configuration","title":"\u2699\ufe0f Configuration","text":"<p>All key parameters are located in <code>config.py</code>. You can modify these values to experiment with different scenarios:</p>"},{"location":"#core-settings","title":"Core Settings","text":"<ul> <li><code>OPTIMIZATION_GAMEWEEKS</code>: Number of gameweeks to optimize for (e.g., <code>1</code> or <code>3</code>)</li> <li><code>BUDGET</code>: Total FPL budget in millions (default: <code>100.0</code>)</li> <li><code>MAX_PLAYERS_PER_TEAM</code>: Maximum players from one team (default: <code>3</code>)</li> <li><code>FPL_POINTS</code>: Dictionary of points for all FPL events</li> </ul>"},{"location":"#minutes-thresholds","title":"Minutes Thresholds","text":"<ul> <li><code>MIN_MINUTES_THRESHOLD</code>: Minutes for reliable per-90 stats</li> <li><code>VERY_LOW_MINUTES_THRESHOLD</code>: Minutes before heavy regression</li> <li><code>DEFAULT_SUB_MINUTES</code>: Expected minutes for rotation players (15.0)</li> <li><code>DEFAULT_UNKNOWN_PLAYER_MINUTES</code>: Minutes for unproven players (1.0)</li> </ul>"},{"location":"#performance-adjustments","title":"Performance Adjustments","text":"<ul> <li>Negative Event Probabilities:</li> <li><code>YELLOW_CARD_PROB</code>: Yellow card probability</li> <li><code>RED_CARD_PROB</code>: Red card probability</li> <li><code>PENALTY_MISS_PROB</code>: Penalty miss probability</li> <li> <p><code>OWN_GOAL_PROB</code>: Own goal probability</p> </li> <li> <p><code>XP_CONFIDENCE_FACTORS</code>:</p> </li> <li>Very low minutes (&lt;450): 0.25x</li> <li>Low minutes (&lt;2500): 0.50x</li> <li>Proven (\u22652500): 1.00x</li> </ul>"},{"location":"#output","title":"\ud83d\udcca Output","text":"<p>The script will output a detailed summary of your optimized FPL squad to the console, similar to this:</p> <pre><code>--- FPL Optimized Squad ---\nTotal Cost: \u00a3XX.Xm\nTotal Expected Points: XXX.XX\n\n--- Goalkeepers ---\n   name        team  cost  expected_points\n...\n\n--- Defenders ---\n   name        team  cost  expected_points\n...\n\n--- Midfielders ---\n   name        team  cost  expected_points\n...\n\n--- Forwards ---\n   name        team  cost  expected_points\n...\n\n--- Team Breakdown ---\nteam\nTeam A    3\nTeam B    2\n...\n</code></pre>"},{"location":"#future-improvements","title":"\ud83d\udca1 Future Improvements","text":"<ul> <li>Improved Data Source: The FPL API is limited in the type of data it provides, we cannot really calculate defensive contributions</li> <li>Captaincy and Vice-Captaincy Selection: Integrate logic to select the best captain and vice-captain for double points</li> <li>Transfer Optimization: Add functionality to suggest optimal transfers week-to-week, considering free transfers and hits</li> <li>Chip Uses: Chip usage is currently not a feature</li> </ul>"},{"location":"config/","title":"Configuration","text":"<p>The <code>config.py</code> file centralizes all configurable parameters for the FPL Expected Points Predictor and Solver. This allows for easy adjustment of FPL scoring rules, thresholds, and optimization settings without modifying the core logic of the predictor or optimizer.</p>"},{"location":"config/#fpl-point-system-fpl_points","title":"FPL Point System (<code>FPL_POINTS</code>)","text":"<p>A dictionary defining the points awarded for various events in Fantasy Premier League. These values are based on the 2025/26 season rules as specified.</p> Key Description Default Value <code>appearance_points_lt_60</code> Points for playing up to 60 minutes. <code>1</code> <code>appearance_points_gte_60</code> Points for playing 60 minutes or more (excluding stoppage time). <code>2</code> <code>goal_gk</code> Points for each goal scored by a goalkeeper. <code>10</code> <code>goal_def</code> Points for each goal scored by a defender. <code>6</code> <code>goal_mid</code> Points for each goal scored by a midfielder. <code>5</code> <code>goal_fwd</code> Points for each goal scored by a forward. <code>4</code> <code>assist_points</code> Points for each goal assist. <code>3</code> <code>clean_sheet_gk_def</code> Points for a clean sheet by a goalkeeper or defender. <code>4</code> <code>clean_sheet_mid</code> Points for a clean sheet by a midfielder (New for 2025/26 rules). <code>1</code> <code>saves_3_points</code> Points for every 3 shot saves by a goalkeeper. <code>1</code> <code>cbit_def_points</code> For accumulating 10 or more Clearances, Blocks, Interceptions (CBI) &amp; Tackles (defenders). <code>2</code> <code>cbirt_mid_fwd_prob</code> For accumulating 12 or more Clearances, Blocks, Interceptions (CBI), Tackles &amp; Recoveries (midfielders &amp; forwards). <code>2</code> <code>penalty_save_points</code> For each penalty save. <code>5</code> <code>conceded_2_goals_deduction</code> Per 2 goals conceded by a goalkeeper or defender. <code>-1</code> <code>yellow_card_deduction</code> For each yellow card. <code>-1</code> <code>red_card_deduction</code> For each red card. <code>-3</code> <code>penalty_miss_deduction</code> For each penalty miss. <code>-2</code> <code>own_goal_deduction</code> For each own goal. <code>-2</code> <code>bonus_points_scaling_factor</code> A small factor to convert BPS score to expected bonus points (Model specific heuristic). <code>0.005</code>"},{"location":"config/#thresholds-for-minutes-played","title":"Thresholds for Minutes Played","text":"<p>These constants define thresholds used in predicting player minutes and assessing the reliability of per-90 statistics.</p> <ul> <li> <p><code>MIN_MINUTES_THRESHOLD</code>: Players must have played at least this many minutes for their per-90 stats to be considered reliable.</p> </li> <li> <p>Default: <code>2500</code></p> </li> <li> <p><code>VERY_LOW_MINUTES_THRESHOLD</code>: Players below this minute threshold will have their per-90 stats effectively zeroed out, indicating they are unlikely to play significant minutes.</p> </li> <li> <p>Default: <code>450</code></p> </li> </ul>"},{"location":"config/#probabilities-for-minor-negative-events","title":"Probabilities for Minor Negative Events","text":"<p>These probabilities are used in the xP calculation for rare negative events.</p> <ul> <li> <p><code>YELLOW_CARD_PROB</code>: Probability of a player receiving a yellow card in a given match.</p> </li> <li> <p>Default: <code>0.05</code></p> </li> <li> <p><code>RED_CARD_PROB</code>: Probability of a player receiving a red card in a given match.</p> </li> <li> <p>Default: <code>0.005</code></p> </li> <li> <p><code>PENALTY_MISS_PROB</code>: Probability of a player missing a penalty.</p> </li> <li> <p>Default: <code>0.01</code></p> </li> <li> <p><code>OWN_GOAL_PROB</code>: Probability of a player scoring an own goal.</p> </li> <li> <p>Default: <code>0.002</code></p> </li> </ul>"},{"location":"config/#default-expected-minutes","title":"Default Expected Minutes","text":"<ul> <li> <p><code>DEFAULT_SUB_MINUTES</code>: Default average minutes assigned to players who typically come on as substitutes.</p> </li> <li> <p>Default: <code>15.0</code></p> </li> <li> <p><code>DEFAULT_UNKNOWN_PLAYER_MINUTES</code>: Default expected minutes for new players or those with very sparse historical data.</p> </li> <li> <p>Default: <code>1.0</code></p> </li> </ul>"},{"location":"config/#xp-confidence-factors","title":"xP Confidence Factors","text":"<p>These factors are applied to scale expected points based on a player's historical minutes, helping to discourage selection of unproven players.</p> <ul> <li><code>very_low_minutes</code>: Applied to players with less than <code>VERY_LOW_MINUTES_THRESHOLD</code> minutes.</li> <li> <p>Default: <code>0.25</code> (reduces xP by 75%)</p> </li> <li> <p><code>low_minutes</code>: Applied to players with less than <code>MIN_MINUTES_THRESHOLD</code> minutes.</p> </li> <li> <p>Default: <code>0.5</code> (reduces xP by 50%)</p> </li> <li> <p><code>proven</code>: Applied to players with more than <code>MIN_MINUTES_THRESHOLD</code> minutes.</p> </li> <li>Default: <code>1.0</code> (no reduction)</li> </ul>"},{"location":"config/#solver-configuration","title":"Solver Configuration","text":"<p>These parameters control the behavior of the <code>FPLOptimizer</code>.</p> <ul> <li> <p><code>OPTIMIZATION_GAMEWEEKS</code>: The number of upcoming gameweeks the solver will consider for xP calculation (e.g., <code>1</code> for the next gameweek, <code>3</code> for the next three).</p> </li> <li> <p>Default: <code>3</code></p> </li> <li> <p><code>BUDGET</code>: Your total FPL budget in millions of pounds (e.g., <code>100.0</code>).</p> </li> <li> <p>Default: <code>100.0</code></p> </li> <li> <p><code>MAX_PLAYERS_PER_TEAM</code>: The maximum number of players you want from any single Premier League team (FPL limit is usually <code>3</code>).</p> </li> <li> <p>Default: <code>3</code></p> </li> </ul>"},{"location":"config/#chip-configuration-chip_allowances","title":"Chip Configuration (<code>CHIP_ALLOWANCES</code>)","text":"<p>A dictionary specifying the maximum number of times each FPL chip can be used within the <code>OPTIMIZATION_GAMEWEEKS</code> horizon.</p> Chip Name Description Default Allowance <code>free_hit</code> Free Hit chip allowance. <code>0</code> <code>wildcard</code> Wildcard chip allowance. <code>0</code> <code>bench_boost</code> Bench Boost chip allowance. <code>1</code> <code>triple_captain</code> Triple Captain chip allowance. <code>0</code>"},{"location":"config/#transfer-rules","title":"Transfer Rules","text":"<p>These constants define the rules governing transfers between gameweeks.</p> <ul> <li> <p><code>INITIAL_FREE_TRANSFERS</code>: The number of free transfers available at the start of the optimization horizon (typically Gameweek 1).</p> </li> <li> <p>Default: <code>1</code></p> </li> <li> <p><code>MAX_FREE_TRANSFERS_SAVED</code>: The maximum number of free transfers that can be saved for future gameweeks.</p> </li> <li> <p>Default: <code>5</code></p> </li> <li> <p><code>POINTS_PER_HIT</code>: The points deduction incurred for each transfer made beyond the available free transfers.</p> </li> <li> <p>Default: <code>4</code></p> </li> </ul>"},{"location":"config/#player-exclusion-configuration","title":"Player Exclusion Configuration","text":"<p>These lists allow you to explicitly exclude certain players from being considered by the predictor and optimizer.</p> Variable Description Default Value Example <code>EXCLUDED_PLAYERS_BY_ID</code> A list of FPL player IDs to exclude. <code>[]</code> (empty list) <code>[123, 456]</code> <code>EXCLUDED_PLAYERS_BY_NAME</code> A list of player full names (case-sensitive) to exclude. Ensure names match exactly as they appear in the FPL data. <code>[\"Kepa Arrizabalaga Revuelta\", \"Christian N\u00f8rgaard\"]</code> <code>[\"Erling Haaland\", \"Mohamed Salah\"]</code> <code>EXCLUDED_PLAYERS_BY_TEAM_AND_POSITION</code> A list of dictionaries, each specifying a team and position from which all players should be excluded. <code>[]</code> (empty list) <code>[{\"team\": \"Man City\", \"position\": \"GK\"}, {\"team\": \"Arsenal\", \"position\": \"FWD\"}]</code>"},{"location":"config/#enforced-player-configuration","title":"Enforced Player Configuration","text":"<p>These lists allow you to explicitly enforce certain players or player types to be included in the optimized squad.</p> Variable Description Default Value Example <code>ENFORCED_PLAYERS_BY_ID</code> A list of FPL player IDs to enforce in the squad for the entire optimization horizon. <code>[]</code> (empty list) <code>[101, 202]</code> <code>ENFORCED_PLAYERS_BY_NAME</code> A list of player full names (case-sensitive) to enforce in the squad. <code>[]</code> (empty list) <code>[\"Mohamed Salah\", \"Erling Haaland\"]</code> <code>ENFORCED_PLAYERS_BY_TEAM_AND_POSITION</code> A list of dictionaries, each specifying a team and position from which at least one player must be enforced. You can also specify <code>min_players</code> to enforce more than one. <code>[]</code> (empty list) <code>[{\"team\": \"Liverpool\", \"position\": \"DEF\", \"min_players\": 1}, {\"team\": \"Man City\", \"position\": \"MID\", \"min_players\": 2}]</code>"},{"location":"autoapi/run_solver/","title":"run_solver","text":"<p>Entry point script for running the FPL Solver. This script should be run from the command line.</p>"},{"location":"autoapi/run_solver/#run_solver.main","title":"<code>main()</code>","text":"<p>Run the FPL Solver with configured settings.</p> Source code in <code>run_solver.py</code> <pre><code>def main():\n    \"\"\"Run the FPL Solver with configured settings.\"\"\"\n    print(\"Initializing FPL Predictor to fetch data and calculate xP...\")\n    predictor = FPLPredictor(gameweeks_to_predict=OPTIMIZATION_GAMEWEEKS)\n\n    print(\"Getting player data for optimizer...\")\n    player_data_list = predictor.get_players_for_optimizer()\n\n    print(\"Converting player data to DataFrame...\")\n    player_data_df = pd.DataFrame(player_data_list)\n\n    print(\"Initializing and running optimizer...\")\n    optimizer = FPLOptimizer(player_data=player_data_df)\n\n    # Solve the optimization problem\n    if optimizer.solve(\n        budget=BUDGET,\n        max_players_per_team=MAX_PLAYERS_PER_TEAM,\n        chip_allowances=CHIP_ALLOWANCES,\n        num_gameweeks=OPTIMIZATION_GAMEWEEKS\n    ):\n        print(\"\\nOptimal solution found! Printing summary...\")\n        optimizer.print_overall_summary()\n\n        # Get the range of gameweeks optimized over from the history\n        if optimizer.selected_squad_history:\n            first_gw = min(\n                int(k.replace(\"GW\", \"\"))\n                for k in optimizer.selected_squad_history.keys()\n            )\n            last_gw = max(\n                int(k.replace(\"GW\", \"\"))\n                for k in optimizer.selected_squad_history.keys()\n            )\n            print(\"\\n--- Detailed Squad Summary for Each Optimized Gameweek ---\")\n            for gw_num in range(first_gw, last_gw + 1):\n                optimizer.print_squad_summary(gameweek=gw_num)\n        else:\n            print(\"\\nNo detailed per-gameweek summary available as no optimal solution was found.\")\n    else:\n        print(\"\\nCould not find an optimal FPL squad with the given parameters.\")\n        print(\"Consider adjusting the settings in fpl_config.py:\")\n        print(\"- BUDGET\")\n        print(\"- MAX_PLAYERS_PER_TEAM\")\n        print(\"- CHIP_ALLOWANCES\")\n        print(\"- OPTIMIZATION_GAMEWEEKS\")\n        print(\"Also, check that enough eligible players are available in each position category.\")\n</code></pre>"},{"location":"autoapi/summary/","title":"Summary","text":"<ul> <li>build<ul> <li>lib<ul> <li>build<ul> <li>lib<ul> <li>fpl_solver<ul> <li>cache_manager</li> <li>config</li> <li>logger</li> <li>solver</li> <li>xp_predictor</li> </ul> </li> </ul> </li> </ul> </li> <li>fpl_solver<ul> <li>cache_manager</li> <li>config</li> <li>logger</li> <li>solver</li> <li>xp_predictor</li> </ul> </li> </ul> </li> </ul> </li> <li>fpl_solver<ul> <li>cache_manager</li> <li>logger</li> <li>solver</li> <li>xp_predictor</li> </ul> </li> <li>run_solver</li> </ul>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/","title":"fpl_solver","text":"<p>FPL Solver package initialization. This package provides tools for Fantasy Premier League optimization.</p>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/#build.lib.build.lib.fpl_solver.cache_manager","title":"<code>cache_manager</code>","text":"<p>Cache manager for FPL API responses.</p> <p>This module provides functionality to cache API responses locally and manage their expiry.</p>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/#build.lib.build.lib.fpl_solver.cache_manager.CacheManager","title":"<code>CacheManager</code>","text":"Source code in <code>build/lib/build/lib/fpl_solver/cache_manager.py</code> <pre><code>class CacheManager:\n    def __init__(self, cache_dir: str, cache_expiry_hours: int = 3):\n        \"\"\"\n        Initialize the cache manager.\n\n        Args:\n            cache_dir: Directory to store cache files\n            cache_expiry_hours: Number of hours after which cache should be considered stale\n        \"\"\"\n        self.cache_dir = cache_dir\n        self.cache_expiry = timedelta(hours=cache_expiry_hours)\n\n        # Create cache directory if it doesn't exist\n        if not os.path.exists(cache_dir):\n            os.makedirs(cache_dir)\n\n    def _get_cache_path(self, endpoint: str) -&gt; str:\n        \"\"\"Get the full path for a cache file.\"\"\"\n        return os.path.join(self.cache_dir, f\"{endpoint}.json\")\n\n    def get_cached_response(self, endpoint: str) -&gt; Optional[Dict[str, Any]]:\n        \"\"\"\n        Retrieve cached response if it exists and is not expired.\n\n        Args:\n            endpoint: API endpoint identifier (e.g., 'static' or 'fixtures')\n\n        Returns:\n            Cached data if valid, None otherwise\n        \"\"\"\n        cache_path = self._get_cache_path(endpoint)\n\n        if not os.path.exists(cache_path):\n            return None\n\n        try:\n            with open(cache_path, 'r') as f:\n                cached_data = json.load(f)\n\n            # Check if cache has expired\n            cached_time = datetime.fromtimestamp(cached_data['cached_at'])\n            if datetime.now() - cached_time &gt; self.cache_expiry:\n                return None\n\n            return cached_data['data']\n\n        except (json.JSONDecodeError, KeyError, ValueError) as e:\n            # If there's any issue with the cache file, ignore it\n            return None\n\n    def save_response(self, endpoint: str, data: Dict[str, Any]) -&gt; None:\n        \"\"\"\n        Save API response to cache.\n\n        Args:\n            endpoint: API endpoint identifier\n            data: Response data to cache\n        \"\"\"\n        cache_path = self._get_cache_path(endpoint)\n\n        cache_data = {\n            'cached_at': time.time(),\n            'data': data\n        }\n\n        with open(cache_path, 'w') as f:\n            json.dump(cache_data, f)\n\n    def clear_cache(self) -&gt; None:\n        \"\"\"Clear all cached data.\"\"\"\n        for filename in os.listdir(self.cache_dir):\n            if filename.endswith('.json'):\n                os.remove(os.path.join(self.cache_dir, filename))\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/#build.lib.build.lib.fpl_solver.cache_manager.CacheManager.__init__","title":"<code>__init__(cache_dir, cache_expiry_hours=3)</code>","text":"<p>Initialize the cache manager.</p> <p>Parameters:</p> Name Type Description Default <code>cache_dir</code> <code>str</code> <p>Directory to store cache files</p> required <code>cache_expiry_hours</code> <code>int</code> <p>Number of hours after which cache should be considered stale</p> <code>3</code> Source code in <code>build/lib/build/lib/fpl_solver/cache_manager.py</code> <pre><code>def __init__(self, cache_dir: str, cache_expiry_hours: int = 3):\n    \"\"\"\n    Initialize the cache manager.\n\n    Args:\n        cache_dir: Directory to store cache files\n        cache_expiry_hours: Number of hours after which cache should be considered stale\n    \"\"\"\n    self.cache_dir = cache_dir\n    self.cache_expiry = timedelta(hours=cache_expiry_hours)\n\n    # Create cache directory if it doesn't exist\n    if not os.path.exists(cache_dir):\n        os.makedirs(cache_dir)\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/#build.lib.build.lib.fpl_solver.cache_manager.CacheManager.clear_cache","title":"<code>clear_cache()</code>","text":"<p>Clear all cached data.</p> Source code in <code>build/lib/build/lib/fpl_solver/cache_manager.py</code> <pre><code>def clear_cache(self) -&gt; None:\n    \"\"\"Clear all cached data.\"\"\"\n    for filename in os.listdir(self.cache_dir):\n        if filename.endswith('.json'):\n            os.remove(os.path.join(self.cache_dir, filename))\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/#build.lib.build.lib.fpl_solver.cache_manager.CacheManager.get_cached_response","title":"<code>get_cached_response(endpoint)</code>","text":"<p>Retrieve cached response if it exists and is not expired.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>API endpoint identifier (e.g., 'static' or 'fixtures')</p> required <p>Returns:</p> Type Description <code>Optional[Dict[str, Any]]</code> <p>Cached data if valid, None otherwise</p> Source code in <code>build/lib/build/lib/fpl_solver/cache_manager.py</code> <pre><code>def get_cached_response(self, endpoint: str) -&gt; Optional[Dict[str, Any]]:\n    \"\"\"\n    Retrieve cached response if it exists and is not expired.\n\n    Args:\n        endpoint: API endpoint identifier (e.g., 'static' or 'fixtures')\n\n    Returns:\n        Cached data if valid, None otherwise\n    \"\"\"\n    cache_path = self._get_cache_path(endpoint)\n\n    if not os.path.exists(cache_path):\n        return None\n\n    try:\n        with open(cache_path, 'r') as f:\n            cached_data = json.load(f)\n\n        # Check if cache has expired\n        cached_time = datetime.fromtimestamp(cached_data['cached_at'])\n        if datetime.now() - cached_time &gt; self.cache_expiry:\n            return None\n\n        return cached_data['data']\n\n    except (json.JSONDecodeError, KeyError, ValueError) as e:\n        # If there's any issue with the cache file, ignore it\n        return None\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/#build.lib.build.lib.fpl_solver.cache_manager.CacheManager.save_response","title":"<code>save_response(endpoint, data)</code>","text":"<p>Save API response to cache.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>API endpoint identifier</p> required <code>data</code> <code>Dict[str, Any]</code> <p>Response data to cache</p> required Source code in <code>build/lib/build/lib/fpl_solver/cache_manager.py</code> <pre><code>def save_response(self, endpoint: str, data: Dict[str, Any]) -&gt; None:\n    \"\"\"\n    Save API response to cache.\n\n    Args:\n        endpoint: API endpoint identifier\n        data: Response data to cache\n    \"\"\"\n    cache_path = self._get_cache_path(endpoint)\n\n    cache_data = {\n        'cached_at': time.time(),\n        'data': data\n    }\n\n    with open(cache_path, 'w') as f:\n        json.dump(cache_data, f)\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/#build.lib.build.lib.fpl_solver.config","title":"<code>config</code>","text":"<p>fpl_config.py</p> <p>Configuration settings for the FPL Expected Points Predictor and Solver. This file centralizes all constants related to FPL scoring, thresholds, and optimization parameters.</p>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/#build.lib.build.lib.fpl_solver.logger","title":"<code>logger</code>","text":"<p>Logging configuration for the FPL Solver package.</p>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/#build.lib.build.lib.fpl_solver.logger.setup_logger","title":"<code>setup_logger(name, level=None)</code>","text":"<p>Set up a logger with consistent formatting and optional level override.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the logger</p> required <code>level</code> <code>Optional[int]</code> <p>Optional logging level override. If None, uses INFO</p> <code>None</code> <p>Returns:</p> Type Description <code>Logger</code> <p>logging.Logger: Configured logger instance</p> Source code in <code>build/lib/build/lib/fpl_solver/logger.py</code> <pre><code>def setup_logger(name: str, level: Optional[int] = None) -&gt; logging.Logger:\n    \"\"\"\n    Set up a logger with consistent formatting and optional level override.\n\n    Args:\n        name: The name of the logger\n        level: Optional logging level override. If None, uses INFO\n\n    Returns:\n        logging.Logger: Configured logger instance\n    \"\"\"\n    logger = logging.getLogger(name)\n\n    if not logger.handlers:  # Only add handler if logger doesn't have one\n        handler = logging.StreamHandler(sys.stdout)\n        formatter = logging.Formatter(\n            '%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n            datefmt='%Y-%m-%d %H:%M:%S'\n        )\n        handler.setFormatter(formatter)\n        logger.addHandler(handler)\n\n    logger.setLevel(level or logging.INFO)\n    return logger\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/#build.lib.build.lib.fpl_solver.solver","title":"<code>solver</code>","text":"<p>FPL Squad Optimizer using PuLP for Integer Linear Programming (ILP).</p> <p>This module provides optimization functionality to select the best possible FPL squad over multiple gameweeks, considering transfer constraints and chips.</p>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/#build.lib.build.lib.fpl_solver.solver.FPLOptimizer","title":"<code>FPLOptimizer</code>","text":"<p>A class to optimize Fantasy Premier League (FPL) squad selection using Integer Linear Programming (ILP).</p> <p>The optimizer aims to select a 15-player squad (2 GKs, 5 DEFs, 5 MIDs, 3 FWDs) within a budget, with a maximum number of players from any single team, to maximize the total expected points.</p> Source code in <code>build/lib/build/lib/fpl_solver/solver.py</code> <pre><code>class FPLOptimizer:\n    \"\"\"\n    A class to optimize Fantasy Premier League (FPL) squad selection\n    using Integer Linear Programming (ILP).\n\n    The optimizer aims to select a 15-player squad (2 GKs, 5 DEFs, 5 MIDs, 3 FWDs)\n    within a budget, with a maximum number of players from any single team,\n    to maximize the total expected points.\n    \"\"\"\n\n    def __init__(self, player_data: pd.DataFrame):\n        \"\"\"\n        Initializes the FPLOptimizer with player data.\n\n        Args:\n            player_data (pd.DataFrame): A DataFrame containing player information\n                                        with columns: 'name', 'team', 'position',\n                                        'cost', 'expected_points_by_gw' (a dict of xP per GW).\n        \"\"\"\n        required_columns = [\"name\", \"team\", \"position\", \"cost\", \"expected_points_by_gw\"]\n        if not all(col in player_data.columns for col in required_columns):\n            missing_cols = [\n                col for col in required_columns if col not in player_data.columns\n            ]\n            raise ValueError(\n                f\"player_data DataFrame must contain {required_columns} columns. Missing: {missing_cols}\"\n            )\n\n        self.player_data = player_data\n        self.problem = None\n        self.selected_squad_history = {}  # To store squad for each gameweek\n        self.total_cost = 0\n        self.total_expected_points = 0\n        self.total_transfer_hits = 0\n\n        # --- Process Enforced Players ---\n        self.enforced_player_indices = set()\n        self.enforced_team_pos_requirements = []\n\n        print(\"\\n--- Processing Enforced Players ---\")\n\n        # Enforce by Player ID\n        for player_id in ENFORCED_PLAYERS_BY_ID:\n            found_player = self.player_data[self.player_data[\"id\"] == player_id]\n            if not found_player.empty:\n                player_idx = found_player.index[0]\n                self.enforced_player_indices.add(player_idx)\n                print(\n                    f\"Enforcing player by ID: {found_player.loc[player_idx, 'name']} (ID: {player_id})\"\n                )\n            else:\n                print(\n                    f\"Warning: Enforced player with ID {player_id} not found in data.\"\n                )\n\n        # Enforce by Player Name\n        for player_name in ENFORCED_PLAYERS_BY_NAME:\n            found_player = self.player_data[self.player_data[\"name\"] == player_name]\n            if not found_player.empty:\n                player_idx = found_player.index[0]\n                self.enforced_player_indices.add(player_idx)\n                print(f\"Enforcing player by name: {player_name}\")\n            else:\n                print(f\"Warning: Enforced player '{player_name}' not found in data.\")\n\n        # Enforce by Team and Position\n        for requirement in ENFORCED_PLAYERS_BY_TEAM_AND_POSITION:\n            team = requirement.get(\"team\")\n            position = requirement.get(\"position\")\n            if team and position:\n                # Validate team and position exist in data\n                if team not in self.player_data[\"team\"].unique():\n                    print(\n                        f\"Warning: Enforced team '{team}' for position '{position}' not found in data.\"\n                    )\n                    continue\n                if position not in self.player_data[\"position\"].unique():\n                    print(\n                        f\"Warning: Enforced position '{position}' for team '{team}' not found in data.\"\n                    )\n                    continue\n\n                self.enforced_team_pos_requirements.append((team, position))\n                print(f\"Enforcing at least one {position} from {team}.\")\n            else:\n                print(\n                    f\"Warning: Invalid enforced team/position requirement: {requirement}\"\n                )\n\n        if not (\n            self.enforced_player_indices\n            or self.enforced_team_pos_requirements\n            or ENFORCED_PLAYERS_BY_ID\n            or ENFORCED_PLAYERS_BY_NAME\n            or ENFORCED_PLAYERS_BY_TEAM_AND_POSITION\n        ):\n            print(\"No players or team/position combinations are enforced.\")\n        print(\"-----------------------------------\\n\")\n\n    def solve(\n        self,\n        budget: float,\n        max_players_per_team: int,\n        chip_allowances: dict,\n        num_gameweeks: int,\n    ) -&gt; bool:\n        \"\"\"\n        Solves the FPL optimization problem using PuLP.\n\n        Args:\n            budget (float): The maximum budget in millions of pounds.\n            max_players_per_team (int): The maximum number of players allowed from\n                                        any single Premier League team.\n            chip_allowances (dict): A dictionary specifying the maximum usage for each chip.\n            num_gameweeks (int): The number of gameweeks to optimize over.\n\n        Returns:\n            bool: True if a solution was found, False otherwise.\n        \"\"\"\n        self.problem = LpProblem(\"FPL Squad Multi-Week Optimization\", LpMaximize)\n\n        # Decision variables for player selection, indexed by player and gameweek\n        player_vars = LpVariable.dicts(\n            \"Player\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n        )\n        starting_xi_vars = LpVariable.dicts(\n            \"StartingXI\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n        )\n        captain_var = LpVariable.dicts(\n            \"Captain\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n        )\n\n        # Binary variables for chip usage, indexed by gameweek\n        use_bench_boost = LpVariable.dicts(\n            \"Use_Bench_Boost\", range(num_gameweeks), 0, 1, LpBinary\n        )\n        use_triple_captain = LpVariable.dicts(\n            \"Use_Triple_Captain\", range(num_gameweeks), 0, 1, LpBinary\n        )\n\n        # Transfer variables\n        transfer_in_vars = LpVariable.dicts(\n            \"Transfer_In\",\n            (self.player_data.index, range(1, num_gameweeks)),\n            0,\n            1,\n            LpBinary,\n        )\n        transfer_out_vars = LpVariable.dicts(\n            \"Transfer_Out\",\n            (self.player_data.index, range(1, num_gameweeks)),\n            0,\n            1,\n            LpBinary,\n        )\n\n        # Total transfers made in a gameweek (absolute count)\n        transfers_made = LpVariable.dicts(\n            \"Transfers_Made\", range(1, num_gameweeks), 0, None, LpInteger\n        )\n        # Free transfers available at the start of a gameweek\n        free_transfers_available = LpVariable.dicts(\n            \"Free_Transfers_Available\",\n            range(num_gameweeks),\n            0,\n            MAX_FREE_TRANSFERS_SAVED + 1,\n            LpInteger,\n        )\n        # Number of transfer hits taken in a gameweek\n        transfer_hits = LpVariable.dicts(\n            \"Transfer_Hits\", range(1, num_gameweeks), 0, None, LpInteger\n        )\n\n        # Auxiliary variables for linearizing chip effects\n        is_bench_player = LpVariable.dicts(\n            \"Is_Bench_Player\",\n            (self.player_data.index, range(num_gameweeks)),\n            0,\n            1,\n            LpBinary,\n        )\n        actual_bench_boost_points = LpVariable.dicts(\n            \"Actual_Bench_Boost_Points\",\n            (self.player_data.index, range(num_gameweeks)),\n            0,\n            None,\n            LpContinuous,\n        )\n        actual_triple_captain_bonus = LpVariable.dicts(\n            \"Actual_Triple_Captain_Bonus\",\n            (self.player_data.index, range(num_gameweeks)),\n            0,\n            None,\n            LpContinuous,\n        )\n\n        # --- Objective Function ---\n        total_objective_points = []\n\n        # Get the first gameweek number from the player data to correctly index expected_points_by_gw\n        first_gw_key = next(\n            iter(\n                self.player_data.loc[\n                    self.player_data.index[0], \"expected_points_by_gw\"\n                ].keys()\n            )\n        )\n        current_gameweek_number_start = int(first_gw_key)\n\n        for w in range(num_gameweeks):\n            # The actual gameweek number (1-indexed)\n            gw_actual = current_gameweek_number_start + w\n\n            # Base expected points from the selected starting 11 for this gameweek\n            base_points_expression_gw = lpSum(\n                self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n                * starting_xi_vars[i][w]\n                for i in self.player_data.index\n            )\n            total_objective_points.append(base_points_expression_gw)\n\n            # Regular Captaincy points (additional 1x for captain)\n            captain_points_bonus_gw = lpSum(\n                self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n                * captain_var[i][w]\n                for i in self.player_data.index\n            )\n            total_objective_points.append(captain_points_bonus_gw)\n\n            # Define auxiliary variables and constraints for chips for each gameweek\n            for i in self.player_data.index:\n                # Use gameweek-specific player xP for chip calculations\n                player_xp = self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n\n                # Bench Boost auxiliary variables and constraints\n                self.problem += (\n                    is_bench_player[i][w] &lt;= player_vars[i][w],\n                    f\"IsBench_Squad_{i}_{w}\",\n                )\n                self.problem += (\n                    is_bench_player[i][w] &lt;= 1 - starting_xi_vars[i][w],\n                    f\"IsBench_NotStarter_{i}_{w}\",\n                )\n                self.problem += (\n                    is_bench_player[i][w]\n                    &gt;= player_vars[i][w] + (1 - starting_xi_vars[i][w]) - 1,\n                    f\"IsBench_Logical_{i}_{w}\",\n                )\n\n                self.problem += (\n                    actual_bench_boost_points[i][w]\n                    &lt;= player_xp * is_bench_player[i][w],\n                    f\"BenchBoost_Contr_1_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_bench_boost_points[i][w] &lt;= player_xp * use_bench_boost[w],\n                    f\"BenchBoost_Contr_2_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_bench_boost_points[i][w]\n                    &gt;= player_xp * (is_bench_player[i][w] + use_bench_boost[w] - 1),\n                    f\"BenchBoost_Contr_3_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_bench_boost_points[i][w] &gt;= 0,\n                    f\"BenchBoost_Contr_4_{i}_{w}\",\n                )\n\n                # Triple Captain auxiliary variables and constraints\n                # Changed player_xp * 2 to player_xp to reflect additional 1x bonus\n                self.problem += (\n                    actual_triple_captain_bonus[i][w] &lt;= player_xp * captain_var[i][w],\n                    f\"TripleCaptain_Contr_1_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_triple_captain_bonus[i][w]\n                    &lt;= player_xp * use_triple_captain[w],\n                    f\"TripleCaptain_Contr_2_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_triple_captain_bonus[i][w]\n                    &gt;= player_xp * (captain_var[i][w] + use_triple_captain[w] - 1),\n                    f\"TripleCaptain_Contr_3_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_triple_captain_bonus[i][w] &gt;= 0,\n                    f\"TripleCaptain_Contr_4_{i}_{w}\",\n                )\n\n            # Add points from bench boost and triple captain bonus for this gameweek\n            total_bench_boost_points_gw = lpSum(\n                actual_bench_boost_points[i][w] for i in self.player_data.index\n            )\n            total_triple_captain_bonus_points_gw = lpSum(\n                actual_triple_captain_bonus[i][w] for i in self.player_data.index\n            )\n\n            total_objective_points.append(total_bench_boost_points_gw)\n            total_objective_points.append(total_triple_captain_bonus_points_gw)\n\n        # Subtract transfer hits from the total objective\n        total_objective_points.append(\n            -POINTS_PER_HIT * lpSum(transfer_hits[w] for w in range(1, num_gameweeks))\n        )\n\n        self.problem += (\n            lpSum(total_objective_points),\n            \"Total Expected Points Over Gameweeks\",\n        )\n\n        # --- Constraints ---\n\n        # Apply constraints for each gameweek\n        for w in range(num_gameweeks):\n            # 1. Select exactly 15 players for the squad\n            self.problem += (\n                lpSum(player_vars[i][w] for i in self.player_data.index) == 15,\n                f\"Total_Players_GW{w}\",\n            )\n\n            # 2. Squad position constraints (2 GKs, 5 DEFs, 5 MIDs, 3 FWDs)\n            gks = self.player_data[self.player_data[\"position\"] == \"GK\"].index\n            defs = self.player_data[self.player_data[\"position\"] == \"DEF\"].index\n            mids = self.player_data[self.player_data[\"position\"] == \"MID\"].index\n            fwds = self.player_data[self.player_data[\"position\"] == \"FWD\"].index\n\n            self.problem += (\n                lpSum(player_vars[i][w] for i in gks) == 2,\n                f\"Goalkeepers_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(player_vars[i][w] for i in defs) == 5,\n                f\"Defenders_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(player_vars[i][w] for i in mids) == 5,\n                f\"Midfielders_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(player_vars[i][w] for i in fwds) == 3,\n                f\"Forwards_Count_GW{w}\",\n            )\n\n            # 3. Budget constraint\n            # This applies to the cost of the squad for the current gameweek.\n            self.problem += (\n                lpSum(\n                    self.player_data.loc[i, \"cost\"] * player_vars[i][w]\n                    for i in self.player_data.index\n                )\n                &lt;= budget,\n                f\"Total_Budget_GW{w}\",\n            )\n\n            # 4. Maximum players per team constraint\n            for team in self.player_data[\"team\"].unique():\n                team_players = self.player_data[self.player_data[\"team\"] == team].index\n                self.problem += (\n                    lpSum(player_vars[i][w] for i in team_players)\n                    &lt;= max_players_per_team,\n                    f\"Max_Players_from_{team}_GW{w}\",\n                )\n\n            # 5. Starting XI constraints\n            # 5.1 Select exactly 11 players for the starting XI\n            self.problem += (\n                lpSum(starting_xi_vars[i][w] for i in self.player_data.index) == 11,\n                f\"Total_Starting_XI_Players_GW{w}\",\n            )\n\n            # 5.2 A player can only be in the starting XI if they are in the squad\n            for i in self.player_data.index:\n                self.problem += (\n                    starting_xi_vars[i][w] &lt;= player_vars[i][w],\n                    f\"StartingXI_in_Squad_{i}_{w}\",\n                )\n\n            # 5.3 Starting XI position constraints (FPL allows flexible formations, so use minimums)\n            self.problem += (\n                lpSum(starting_xi_vars[i][w] for i in gks) == 1,\n                f\"Starting_Goalkeepers_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(starting_xi_vars[i][w] for i in defs) &gt;= 3,\n                f\"Min_Starting_Defenders_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(starting_xi_vars[i][w] for i in mids) &gt;= 2,\n                f\"Min_Starting_Midfielders_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(starting_xi_vars[i][w] for i in fwds) &gt;= 1,\n                f\"Min_Starting_Forwards_Count_GW{w}\",\n            )\n\n            # 6. Captain Constraints\n            # 6.1 Select exactly one captain from the starting XI\n            self.problem += (\n                lpSum(captain_var[i][w] for i in self.player_data.index) == 1,\n                f\"One_Captain_GW{w}\",\n            )\n\n            # 6.2 A player can only be captain if they are in the starting XI\n            for i in self.player_data.index:\n                self.problem += (\n                    captain_var[i][w] &lt;= starting_xi_vars[i][w],\n                    f\"Captain_in_StartingXI_{i}_{w}\",\n                )\n\n            # --- Enforced Player Constraints---\n            for player_idx in self.enforced_player_indices:\n                self.problem += (\n                    player_vars[player_idx][w] == 1,\n                    f\"Enforce_Player_{self.player_data.loc[player_idx, 'name']}_GW{w}\",\n                )\n\n            for team, position in self.enforced_team_pos_requirements:\n                # Filter players for the current team and position\n                team_pos_players = self.player_data[\n                    (self.player_data[\"team\"] == team)\n                    &amp; (self.player_data[\"position\"] == position)\n                ].index\n                if not team_pos_players.empty:\n                    self.problem += (\n                        lpSum(player_vars[i][w] for i in team_pos_players) &gt;= 1,\n                        f\"Enforce_One_{position}_from_{team}_GW{w}\",\n                    )\n                else:\n                    print(\n                        f\"Warning: No players found for enforced requirement: at least one {position} from {team} for GW{gw_actual}.\"\n                    )\n\n        # --- Chip Usage Constraints (TOTAL usage over all gameweeks) ---\n        # These constraints should be outside the per-gameweek loop to avoid duplicates.\n        self.problem += (\n            lpSum(use_bench_boost[j] for j in range(num_gameweeks))\n            &lt;= chip_allowances.get(\"bench_boost\", 0),\n            f\"Max_Bench_Boost_Usage_Total\",\n        )\n        self.problem += (\n            lpSum(use_triple_captain[j] for j in range(num_gameweeks))\n            &lt;= chip_allowances.get(\"triple_captain\", 0),\n            f\"Max_Triple_Captain_Usage_Total\",\n        )\n\n        # --- Inter-Gameweek Constraints (Transfers and Transfer Rules) ---\n        # Initialize free transfers for GW0 (first gameweek of optimization horizon)\n        # This assumes the optimization starts at GW0, and it has INITIAL_FREE_TRANSFERS.\n        # If the model starts at an arbitrary GW, this would need to be an input.\n        self.problem += (\n            free_transfers_available[0] == INITIAL_FREE_TRANSFERS,\n            f\"Initial_Free_Transfers_GW0\",\n        )\n\n        for w in range(1, num_gameweeks):\n            # Calculate total transfers made in this gameweek\n            self.problem += (\n                transfers_made[w]\n                == lpSum(transfer_in_vars[i][w] for i in self.player_data.index),\n                f\"Transfers_Made_GW{w}\",\n            )\n            # Total transfers in must equal total transfers out for each gameweek after the first\n            self.problem += (\n                lpSum(transfer_in_vars[i][w] for i in self.player_data.index)\n                == lpSum(transfer_out_vars[i][w] for i in self.player_data.index),\n                f\"Transfers_In_Equals_Out_GW{w}\",\n            )\n\n            # Calculate free transfers available for the current gameweek (w)\n            # Free transfers for GW_w = min(free transfers from GW_w-1 - transfers made in GW_w + 1, MAX_FREE_TRANSFERS_SAVED + 1)\n            # The + 1 in MAX_FREE_TRANSFERS_SAVED + 1 is because MAX_FREE_TRANSFERS_SAVED implies how many can be *saved*,\n            # so if you save 1, you have 1 (current) + 1 (saved) = 2.\n            self.problem += (\n                free_transfers_available[w]\n                &lt;= free_transfers_available[w - 1] - transfers_made[w] + 1,\n                f\"Free_Transfers_Calc_1_GW{w}\",\n            )\n            self.problem += (\n                free_transfers_available[w] &lt;= MAX_FREE_TRANSFERS_SAVED + 1,\n                f\"Free_Transfers_Calc_2_GW{w}\",\n            )\n            self.problem += (\n                free_transfers_available[w] &gt;= 0,  # Cannot have negative free transfers\n                f\"Free_Transfers_Non_Negative_GW{w}\",\n            )\n\n            # Calculate transfer hits\n            # transfer_hits[w] = max(0, transfers_made[w] - free_transfers_available_at_start_of_gw_w)\n            # This needs to be linearized. If transfers_made[w] &gt; free_transfers_available[w-1], then hit.\n            # free_transfers_available[w-1] represents transfers available *before* making transfers for GW_w\n            self.problem += (\n                transfer_hits[w] &gt;= transfers_made[w] - free_transfers_available[w - 1],\n                f\"Transfer_Hits_Calc_1_GW{w}\",\n            )\n            self.problem += (\n                transfer_hits[w] &gt;= 0,\n                f\"Transfer_Hits_Calc_2_GW{w}\",\n            )\n\n            for i in self.player_data.index:\n                # Squad continuity: player_vars[i][w] (in squad at start of GW w)\n                #                 = player_vars[i][w-1] (in squad at start of GW w-1)\n                #                 - transfer_out_vars[i][w] (transferred out for GW w)\n                #                 + transfer_in_vars[i][w] (transferred in for GW w)\n                self.problem += (\n                    player_vars[i][w]\n                    == player_vars[i][w - 1]\n                    - transfer_out_vars[i][w]\n                    + transfer_in_vars[i][w],\n                    f\"Squad_Continuity_{i}_GW{w}\",\n                )\n                # A player cannot be transferred in and out in the same gameweek\n                self.problem += (\n                    transfer_in_vars[i][w] + transfer_out_vars[i][w] &lt;= 1,\n                    f\"No_Simultaneous_Transfer_{i}_{w}\",\n                )\n\n        try:\n            # The solver is called with the GLPK_CMD solver\n            self.problem.solve(PULP_CBC_CMD(msg=0))  # msg=0 suppresses verbose output\n        except Exception as e:\n            print(f\"Error solving the problem: {e}\")\n            return False\n\n        if LpStatus[self.problem.status] == \"Optimal\":\n            print(\"Optimization successful! Optimal solution found.\")\n\n            self.selected_squad_history = {}\n            self.total_transfer_hits = 0\n            for w in range(num_gameweeks):\n                # The actual gameweek number (1-indexed)\n                gw_actual = current_gameweek_number_start + w\n\n                # Get selected players for the current gameweek\n                selected_squad_gw = self.player_data[\n                    [player_vars[i][w].varValue == 1 for i in self.player_data.index]\n                ].copy()\n\n                # Get starter and captain info for this gameweek\n                is_starter_series_gw = pd.Series(\n                    [\n                        starting_xi_vars[i][w].varValue == 1\n                        for i in self.player_data.index\n                    ],\n                    index=self.player_data.index,\n                )\n                is_captain_series_gw = pd.Series(\n                    [captain_var[i][w].varValue == 1 for i in self.player_data.index],\n                    index=self.player_data.index,\n                )\n\n                selected_squad_gw[\"is_starter\"] = is_starter_series_gw.loc[\n                    selected_squad_gw.index\n                ]\n                selected_squad_gw[\"is_captain\"] = is_captain_series_gw.loc[\n                    selected_squad_gw.index\n                ]\n\n                transfers_in_gw = 0\n                transfers_out_gw = 0\n                hits_gw = 0\n\n                # Store transfer details for gameweeks &gt; 0\n                if (\n                    w &gt; 0\n                ):  # Check for transfers only from GW1 onwards (index 1 in 0-indexed loop)\n                    transfer_in_flags = pd.Series(\n                        [\n                            transfer_in_vars[i][w].varValue == 1\n                            for i in self.player_data.index\n                        ],\n                        index=self.player_data.index,\n                    )\n                    transfer_out_flags = pd.Series(\n                        [\n                            transfer_out_vars[i][w].varValue == 1\n                            for i in self.player_data.index\n                        ],\n                        index=self.player_data.index,\n                    )\n\n                    selected_squad_gw[\"transfer_in\"] = transfer_in_flags.loc[\n                        selected_squad_gw.index\n                    ]\n                    selected_squad_gw[\"transfer_out\"] = transfer_out_flags.loc[\n                        selected_squad_gw.index\n                    ]\n\n                    transfers_in_gw = int(round(transfer_in_flags.sum()))\n                    transfers_out_gw = int(round(transfer_out_flags.sum()))\n                    hits_gw = int(round(transfer_hits[w].varValue))\n                    self.total_transfer_hits += hits_gw\n                else:\n                    selected_squad_gw[\"transfer_in\"] = False  # No transfers in for GW0\n                    selected_squad_gw[\"transfer_out\"] = (\n                        False  # No transfers out for GW0\n                    )\n\n                self.selected_squad_history[f\"GW{gw_actual}\"] = {\n                    \"squad\": selected_squad_gw,\n                    \"total_cost\": selected_squad_gw[\"cost\"].sum(),\n                    \"expected_points_from_xi\": sum(\n                        self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n                        * starting_xi_vars[i][w].varValue\n                        for i in self.player_data.index\n                    ),\n                    \"bench_boost_used\": bool(use_bench_boost[w].varValue),\n                    \"triple_captain_used\": bool(use_triple_captain[w].varValue),\n                    \"total_bench_boost_points\": value(\n                        lpSum(\n                            actual_bench_boost_points[i][w]\n                            for i in self.player_data.index\n                        )\n                    ),\n                    \"total_triple_captain_bonus\": value(\n                        lpSum(\n                            actual_triple_captain_bonus[i][w]\n                            for i in self.player_data.index\n                        )\n                    ),\n                    \"transfers_in_count\": transfers_in_gw,\n                    \"transfers_out_count\": transfers_out_gw,\n                    \"transfer_hits\": hits_gw,  # New\n                    \"free_transfers_available_next_gw\": (\n                        int(round(free_transfers_available[w].varValue))\n                        if w &lt; num_gameweeks - 1\n                        else 0\n                    ),  # Free transfers available *after* this GW's transfers are made\n                }\n\n            # Overall totals\n            self.total_cost = self.selected_squad_history[\n                f\"GW{current_gameweek_number_start + num_gameweeks - 1}\"\n            ][\n                \"total_cost\"\n            ]  # Cost of final squad\n            self.total_expected_points = value(\n                self.problem.objective\n            )  # Total objective value from solver\n            self.used_chips = {\n                f\"GW{current_gameweek_number_start + w}\": {\n                    \"bench_boost\": bool(use_bench_boost[w].varValue),\n                    \"triple_captain\": bool(use_triple_captain[w].varValue),\n                }\n                for w in range(num_gameweeks)\n            }\n\n            return True\n        else:\n            print(f\"No optimal solution found. Status: {LpStatus[self.problem.status]}\")\n            self.selected_squad_history = {}\n            self.total_cost = 0\n            self.total_expected_points = 0\n            self.used_chips = {}\n            self.total_transfer_hits = 0\n            return False\n\n    def get_selected_squad(self, gameweek: int = None) -&gt; pd.DataFrame | None:\n        \"\"\"\n        Returns the selected squad for a specific gameweek (1-indexed).\n        If no gameweek is specified, returns the squad for the last optimized gameweek.\n        \"\"\"\n        if not self.selected_squad_history:\n            return None\n\n        # Get the first GW key to determine the range of available GWs\n        first_gw_in_history = min(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n        last_gw_in_history = max(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n\n        if gameweek is None:\n            return self.selected_squad_history[f\"GW{last_gw_in_history}\"][\"squad\"]\n\n        if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n            print(\n                f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n            )\n            return None\n\n        return self.selected_squad_history.get(f\"GW{gameweek}\", {}).get(\"squad\")\n\n    def get_total_cost(self, gameweek: int = None) -&gt; float:\n        \"\"\"\n        Returns the total cost for a specific gameweek (1-indexed).\n        If no gameweek is specified, returns the cost of the squad in the last optimized gameweek.\n        \"\"\"\n        if not self.selected_squad_history:\n            return 0\n        first_gw_in_history = min(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n        last_gw_in_history = max(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n\n        if gameweek is None:\n            return self.selected_squad_history[f\"GW{last_gw_in_history}\"][\"total_cost\"]\n\n        if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n            print(\n                f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n            )\n            return 0  # Or raise an error\n\n        return self.selected_squad_history.get(f\"GW{gameweek}\", {}).get(\"total_cost\", 0)\n\n    def get_total_expected_points(self) -&gt; float:\n        \"\"\"\n        Returns the overall total expected points across all optimized gameweeks.\n        \"\"\"\n        return self.total_expected_points\n\n    def get_gameweek_summary(self, gameweek: int):\n        \"\"\"\n        Returns a dictionary summary for a specific gameweek.\n        \"\"\"\n        if not self.selected_squad_history:\n            return None\n        first_gw_in_history = min(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n        last_gw_in_history = max(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n\n        if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n            print(\n                f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n            )\n            return None\n\n        return self.selected_squad_history.get(f\"GW{gameweek}\")\n\n    def print_squad_summary(self, gameweek: int):\n        \"\"\"\n        Prints a formatted summary of the selected squad for a specific gameweek.\n        \"\"\"\n        if not self.selected_squad_history:\n            print(\"No squad has been selected yet. Run the 'solve' method first.\")\n            return\n\n        gw_data = self.get_gameweek_summary(gameweek)\n        if not gw_data:\n            return  # get_gameweek_summary already prints error message\n\n        selected_squad = gw_data[\"squad\"]\n        total_cost = gw_data[\"total_cost\"]\n        expected_points_from_xi = gw_data[\"expected_points_from_xi\"]\n        bench_boost_used = gw_data[\"bench_boost_used\"]\n        triple_captain_used = gw_data[\"triple_captain_used\"]\n        total_bench_boost_points = gw_data[\"total_bench_boost_points\"]\n        total_triple_captain_bonus = gw_data[\"total_triple_captain_bonus\"]\n        transfers_in_count = gw_data[\"transfers_in_count\"]  # New\n        transfers_out_count = gw_data[\"transfers_out_count\"]  # New\n        transfer_hits_taken = gw_data[\"transfer_hits\"]  # New\n        free_transfers_available_next_gw = gw_data[\n            \"free_transfers_available_next_gw\"\n        ]  # New\n\n        print(f\"\\n--- FPL Optimized Squad for Gameweek {gameweek} ---\")\n        print(f\"Squad Cost: \u00a3{total_cost:.1f}m\")\n        print(f\"Expected Points (Starting XI): {expected_points_from_xi:.2f}\")\n        print(\n            f\"Total Expected Points for GW{gameweek} (including chips): {expected_points_from_xi + total_bench_boost_points + total_triple_captain_bonus:.2f}\"\n        )\n        print(\"\\n--- Chips Used This Gameweek ---\")\n        if bench_boost_used:\n            print(f\"- Bench Boost (Added {total_bench_boost_points:.2f} points)\")\n        if triple_captain_used:\n            print(\n                f\"- Triple Captain (Added {total_triple_captain_bonus:.2f} bonus points)\"\n            )\n        if not (bench_boost_used or triple_captain_used):\n            print(\"No chips used this gameweek.\")\n\n        print(\"\\n--- Goalkeepers (Starting XI marked with *) ---\")\n        for index, row in selected_squad[selected_squad[\"position\"] == \"GK\"].iterrows():\n            starter_str = \"*\" if row[\"is_starter\"] else \"\"\n            captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n            transfer_status = \"\"\n            if row[\"transfer_in\"]:\n                transfer_status = \"(IN)\"\n            elif row[\"transfer_out\"]:\n                transfer_status = \"(OUT)\"\n\n            # Access gameweek-specific xP correctly\n            player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n            print(\n                f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n            )\n        print(\"\\n--- Defenders (Starting XI marked with *) ---\")\n        for index, row in selected_squad[\n            selected_squad[\"position\"] == \"DEF\"\n        ].iterrows():\n            starter_str = \"*\" if row[\"is_starter\"] else \"\"\n            captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n            transfer_status = \"\"\n            if row[\"transfer_in\"]:\n                transfer_status = \"(IN)\"\n            elif row[\"transfer_out\"]:\n                transfer_status = \"(OUT)\"\n\n            player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n            print(\n                f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n            )\n        print(\"\\n--- Midfielders (Starting XI marked with *) ---\")\n        for index, row in selected_squad[\n            selected_squad[\"position\"] == \"MID\"\n        ].iterrows():\n            starter_str = \"*\" if row[\"is_starter\"] else \"\"\n            captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n            transfer_status = \"\"\n            if row[\"transfer_in\"]:\n                transfer_status = \"(IN)\"\n            elif row[\"transfer_out\"]:\n                transfer_status = \"(OUT)\"\n\n            player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n            print(\n                f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n            )\n        print(\"\\n--- Forwards (Starting XI marked with *) ---\")\n        for index, row in selected_squad[\n            selected_squad[\"position\"] == \"FWD\"\n        ].iterrows():\n            starter_str = \"*\" if row[\"is_starter\"] else \"\"\n            captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n            transfer_status = \"\"\n            if row[\"transfer_in\"]:\n                transfer_status = \"(IN)\"\n            elif row[\"transfer_out\"]:\n                transfer_status = \"(OUT)\"\n\n            player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n            print(\n                f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n            )\n\n        print(f\"\\n--- Team Breakdown for GW{gameweek} ---\")\n        print(selected_squad[\"team\"].value_counts())\n\n        # Transfers are relevant from Gameweek 2 (index 1) onwards in the optimization horizon\n        # For display, if the current GW is the initial one (GW1 in the current context), no transfers are made\n        # If it's a subsequent GW, check if transfers occurred.\n        first_gw_in_history = min(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n        if (\n            gameweek &gt;= first_gw_in_history\n        ):  # Changed from &gt; to &gt;=, to show initial free transfers\n            # Display transfer info for this gameweek\n            print(\n                f\"  Transfers In: {transfers_in_count}, Transfers Out: {transfers_out_count}\"\n            )\n            print(\n                f\"  Transfer Hits: {transfer_hits_taken} (-{transfer_hits_taken * POINTS_PER_HIT} points)\"\n            )\n            # Only show free transfers for the *next* gameweek if it's not the last gameweek in the horizon\n            if gameweek &lt; max(\n                int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n            ):\n                print(\n                    f\"  Free Transfers Available for Next GW: {free_transfers_available_next_gw}\"\n                )\n        print(\"---------------------------\\n\")\n\n    def print_overall_summary(self):\n        \"\"\"\n        Prints an overall summary of the multi-week optimization results.\n        \"\"\"\n        if not self.selected_squad_history:\n            print(\"No optimization results to summarize.\")\n            return\n\n        print(\"\\n=== Overall Multi-Week FPL Optimization Summary ===\")\n        print(\n            f\"Total Expected Points Across All Gameweeks: {self.total_expected_points:.2f}\"\n        )\n\n        # Get the latest gameweek's cost\n        last_gw_key = max(\n            self.selected_squad_history.keys(), key=lambda k: int(k.replace(\"GW\", \"\"))\n        )\n        print(\n            f\"Squad Cost ({last_gw_key}): \u00a3{self.selected_squad_history[last_gw_key]['total_cost']:.1f}m\"\n        )\n        print(\n            f\"Total Transfer Hits Taken: {self.total_transfer_hits} (-{self.total_transfer_hits * POINTS_PER_HIT} points)\"\n        )\n\n        print(\"\\n--- Chip Usage Across Gameweeks ---\")\n        # Ensure consistent order by sorting gameweek keys\n        sorted_gw_keys = sorted(\n            self.used_chips.keys(), key=lambda k: int(k.replace(\"GW\", \"\"))\n        )\n        for gw_str in sorted_gw_keys:\n            chips = self.used_chips[gw_str]\n            chip_summary = []\n            if chips[\"bench_boost\"]:\n                chip_summary.append(\"Bench Boost\")\n            if chips[\"triple_captain\"]:\n                chip_summary.append(\"Triple Captain\")\n\n            if chip_summary:\n                print(f\"{gw_str}: {', '.join(chip_summary)}\")\n            else:\n                print(f\"{gw_str}: No chips used\")\n\n        print(\"\\n--- Gameweek-by-Gameweek Summary ---\")\n        # Iterate and print basic summary for each gameweek\n        for gw_str in sorted_gw_keys:\n            gw_data = self.selected_squad_history[gw_str]\n            print(f\"\\n--- {gw_str} ---\")\n            print(f\"  Squad Cost: \u00a3{gw_data['total_cost']:.1f}m\")\n            print(\n                f\"  Expected Points (Starting XI): {gw_data['expected_points_from_xi']:.2f}\"\n            )\n            print(\n                f\"  Total GW Points (incl. chips): {gw_data['expected_points_from_xi'] + gw_data['total_bench_boost_points'] + gw_data['total_triple_captain_bonus']:.2f}\"\n            )\n\n            # Display transfer info for this gameweek\n            transfers_in_count = gw_data[\"transfers_in_count\"]\n            transfers_out_count = gw_data[\"transfers_out_count\"]\n            transfer_hits_taken = gw_data[\"transfer_hits\"]\n            free_transfers_available_next_gw = gw_data[\n                \"free_transfers_available_next_gw\"\n            ]\n\n            print(\n                f\"  Transfers In: {transfers_in_count}, Transfers Out: {transfers_out_count}\"\n            )\n            print(\n                f\"  Transfer Hits: {transfer_hits_taken} (-{transfer_hits_taken * POINTS_PER_HIT} points)\"\n            )\n            # Only show free transfers for the *next* gameweek if it's not the last gameweek in the horizon\n            if int(gw_str.replace(\"GW\", \"\")) &lt; max(\n                int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n            ):\n                print(\n                    f\"  Free Transfers Available for Next GW: {free_transfers_available_next_gw}\"\n                )\n            print(\"-----------------------------------\")\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/#build.lib.build.lib.fpl_solver.solver.FPLOptimizer.__init__","title":"<code>__init__(player_data)</code>","text":"<p>Initializes the FPLOptimizer with player data.</p> <p>Parameters:</p> Name Type Description Default <code>player_data</code> <code>DataFrame</code> <p>A DataFrame containing player information                         with columns: 'name', 'team', 'position',                         'cost', 'expected_points_by_gw' (a dict of xP per GW).</p> required Source code in <code>build/lib/build/lib/fpl_solver/solver.py</code> <pre><code>def __init__(self, player_data: pd.DataFrame):\n    \"\"\"\n    Initializes the FPLOptimizer with player data.\n\n    Args:\n        player_data (pd.DataFrame): A DataFrame containing player information\n                                    with columns: 'name', 'team', 'position',\n                                    'cost', 'expected_points_by_gw' (a dict of xP per GW).\n    \"\"\"\n    required_columns = [\"name\", \"team\", \"position\", \"cost\", \"expected_points_by_gw\"]\n    if not all(col in player_data.columns for col in required_columns):\n        missing_cols = [\n            col for col in required_columns if col not in player_data.columns\n        ]\n        raise ValueError(\n            f\"player_data DataFrame must contain {required_columns} columns. Missing: {missing_cols}\"\n        )\n\n    self.player_data = player_data\n    self.problem = None\n    self.selected_squad_history = {}  # To store squad for each gameweek\n    self.total_cost = 0\n    self.total_expected_points = 0\n    self.total_transfer_hits = 0\n\n    # --- Process Enforced Players ---\n    self.enforced_player_indices = set()\n    self.enforced_team_pos_requirements = []\n\n    print(\"\\n--- Processing Enforced Players ---\")\n\n    # Enforce by Player ID\n    for player_id in ENFORCED_PLAYERS_BY_ID:\n        found_player = self.player_data[self.player_data[\"id\"] == player_id]\n        if not found_player.empty:\n            player_idx = found_player.index[0]\n            self.enforced_player_indices.add(player_idx)\n            print(\n                f\"Enforcing player by ID: {found_player.loc[player_idx, 'name']} (ID: {player_id})\"\n            )\n        else:\n            print(\n                f\"Warning: Enforced player with ID {player_id} not found in data.\"\n            )\n\n    # Enforce by Player Name\n    for player_name in ENFORCED_PLAYERS_BY_NAME:\n        found_player = self.player_data[self.player_data[\"name\"] == player_name]\n        if not found_player.empty:\n            player_idx = found_player.index[0]\n            self.enforced_player_indices.add(player_idx)\n            print(f\"Enforcing player by name: {player_name}\")\n        else:\n            print(f\"Warning: Enforced player '{player_name}' not found in data.\")\n\n    # Enforce by Team and Position\n    for requirement in ENFORCED_PLAYERS_BY_TEAM_AND_POSITION:\n        team = requirement.get(\"team\")\n        position = requirement.get(\"position\")\n        if team and position:\n            # Validate team and position exist in data\n            if team not in self.player_data[\"team\"].unique():\n                print(\n                    f\"Warning: Enforced team '{team}' for position '{position}' not found in data.\"\n                )\n                continue\n            if position not in self.player_data[\"position\"].unique():\n                print(\n                    f\"Warning: Enforced position '{position}' for team '{team}' not found in data.\"\n                )\n                continue\n\n            self.enforced_team_pos_requirements.append((team, position))\n            print(f\"Enforcing at least one {position} from {team}.\")\n        else:\n            print(\n                f\"Warning: Invalid enforced team/position requirement: {requirement}\"\n            )\n\n    if not (\n        self.enforced_player_indices\n        or self.enforced_team_pos_requirements\n        or ENFORCED_PLAYERS_BY_ID\n        or ENFORCED_PLAYERS_BY_NAME\n        or ENFORCED_PLAYERS_BY_TEAM_AND_POSITION\n    ):\n        print(\"No players or team/position combinations are enforced.\")\n    print(\"-----------------------------------\\n\")\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/#build.lib.build.lib.fpl_solver.solver.FPLOptimizer.get_gameweek_summary","title":"<code>get_gameweek_summary(gameweek)</code>","text":"<p>Returns a dictionary summary for a specific gameweek.</p> Source code in <code>build/lib/build/lib/fpl_solver/solver.py</code> <pre><code>def get_gameweek_summary(self, gameweek: int):\n    \"\"\"\n    Returns a dictionary summary for a specific gameweek.\n    \"\"\"\n    if not self.selected_squad_history:\n        return None\n    first_gw_in_history = min(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n    last_gw_in_history = max(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n\n    if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n        print(\n            f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n        )\n        return None\n\n    return self.selected_squad_history.get(f\"GW{gameweek}\")\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/#build.lib.build.lib.fpl_solver.solver.FPLOptimizer.get_selected_squad","title":"<code>get_selected_squad(gameweek=None)</code>","text":"<p>Returns the selected squad for a specific gameweek (1-indexed). If no gameweek is specified, returns the squad for the last optimized gameweek.</p> Source code in <code>build/lib/build/lib/fpl_solver/solver.py</code> <pre><code>def get_selected_squad(self, gameweek: int = None) -&gt; pd.DataFrame | None:\n    \"\"\"\n    Returns the selected squad for a specific gameweek (1-indexed).\n    If no gameweek is specified, returns the squad for the last optimized gameweek.\n    \"\"\"\n    if not self.selected_squad_history:\n        return None\n\n    # Get the first GW key to determine the range of available GWs\n    first_gw_in_history = min(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n    last_gw_in_history = max(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n\n    if gameweek is None:\n        return self.selected_squad_history[f\"GW{last_gw_in_history}\"][\"squad\"]\n\n    if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n        print(\n            f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n        )\n        return None\n\n    return self.selected_squad_history.get(f\"GW{gameweek}\", {}).get(\"squad\")\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/#build.lib.build.lib.fpl_solver.solver.FPLOptimizer.get_total_cost","title":"<code>get_total_cost(gameweek=None)</code>","text":"<p>Returns the total cost for a specific gameweek (1-indexed). If no gameweek is specified, returns the cost of the squad in the last optimized gameweek.</p> Source code in <code>build/lib/build/lib/fpl_solver/solver.py</code> <pre><code>def get_total_cost(self, gameweek: int = None) -&gt; float:\n    \"\"\"\n    Returns the total cost for a specific gameweek (1-indexed).\n    If no gameweek is specified, returns the cost of the squad in the last optimized gameweek.\n    \"\"\"\n    if not self.selected_squad_history:\n        return 0\n    first_gw_in_history = min(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n    last_gw_in_history = max(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n\n    if gameweek is None:\n        return self.selected_squad_history[f\"GW{last_gw_in_history}\"][\"total_cost\"]\n\n    if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n        print(\n            f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n        )\n        return 0  # Or raise an error\n\n    return self.selected_squad_history.get(f\"GW{gameweek}\", {}).get(\"total_cost\", 0)\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/#build.lib.build.lib.fpl_solver.solver.FPLOptimizer.get_total_expected_points","title":"<code>get_total_expected_points()</code>","text":"<p>Returns the overall total expected points across all optimized gameweeks.</p> Source code in <code>build/lib/build/lib/fpl_solver/solver.py</code> <pre><code>def get_total_expected_points(self) -&gt; float:\n    \"\"\"\n    Returns the overall total expected points across all optimized gameweeks.\n    \"\"\"\n    return self.total_expected_points\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/#build.lib.build.lib.fpl_solver.solver.FPLOptimizer.print_overall_summary","title":"<code>print_overall_summary()</code>","text":"<p>Prints an overall summary of the multi-week optimization results.</p> Source code in <code>build/lib/build/lib/fpl_solver/solver.py</code> <pre><code>def print_overall_summary(self):\n    \"\"\"\n    Prints an overall summary of the multi-week optimization results.\n    \"\"\"\n    if not self.selected_squad_history:\n        print(\"No optimization results to summarize.\")\n        return\n\n    print(\"\\n=== Overall Multi-Week FPL Optimization Summary ===\")\n    print(\n        f\"Total Expected Points Across All Gameweeks: {self.total_expected_points:.2f}\"\n    )\n\n    # Get the latest gameweek's cost\n    last_gw_key = max(\n        self.selected_squad_history.keys(), key=lambda k: int(k.replace(\"GW\", \"\"))\n    )\n    print(\n        f\"Squad Cost ({last_gw_key}): \u00a3{self.selected_squad_history[last_gw_key]['total_cost']:.1f}m\"\n    )\n    print(\n        f\"Total Transfer Hits Taken: {self.total_transfer_hits} (-{self.total_transfer_hits * POINTS_PER_HIT} points)\"\n    )\n\n    print(\"\\n--- Chip Usage Across Gameweeks ---\")\n    # Ensure consistent order by sorting gameweek keys\n    sorted_gw_keys = sorted(\n        self.used_chips.keys(), key=lambda k: int(k.replace(\"GW\", \"\"))\n    )\n    for gw_str in sorted_gw_keys:\n        chips = self.used_chips[gw_str]\n        chip_summary = []\n        if chips[\"bench_boost\"]:\n            chip_summary.append(\"Bench Boost\")\n        if chips[\"triple_captain\"]:\n            chip_summary.append(\"Triple Captain\")\n\n        if chip_summary:\n            print(f\"{gw_str}: {', '.join(chip_summary)}\")\n        else:\n            print(f\"{gw_str}: No chips used\")\n\n    print(\"\\n--- Gameweek-by-Gameweek Summary ---\")\n    # Iterate and print basic summary for each gameweek\n    for gw_str in sorted_gw_keys:\n        gw_data = self.selected_squad_history[gw_str]\n        print(f\"\\n--- {gw_str} ---\")\n        print(f\"  Squad Cost: \u00a3{gw_data['total_cost']:.1f}m\")\n        print(\n            f\"  Expected Points (Starting XI): {gw_data['expected_points_from_xi']:.2f}\"\n        )\n        print(\n            f\"  Total GW Points (incl. chips): {gw_data['expected_points_from_xi'] + gw_data['total_bench_boost_points'] + gw_data['total_triple_captain_bonus']:.2f}\"\n        )\n\n        # Display transfer info for this gameweek\n        transfers_in_count = gw_data[\"transfers_in_count\"]\n        transfers_out_count = gw_data[\"transfers_out_count\"]\n        transfer_hits_taken = gw_data[\"transfer_hits\"]\n        free_transfers_available_next_gw = gw_data[\n            \"free_transfers_available_next_gw\"\n        ]\n\n        print(\n            f\"  Transfers In: {transfers_in_count}, Transfers Out: {transfers_out_count}\"\n        )\n        print(\n            f\"  Transfer Hits: {transfer_hits_taken} (-{transfer_hits_taken * POINTS_PER_HIT} points)\"\n        )\n        # Only show free transfers for the *next* gameweek if it's not the last gameweek in the horizon\n        if int(gw_str.replace(\"GW\", \"\")) &lt; max(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        ):\n            print(\n                f\"  Free Transfers Available for Next GW: {free_transfers_available_next_gw}\"\n            )\n        print(\"-----------------------------------\")\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/#build.lib.build.lib.fpl_solver.solver.FPLOptimizer.print_squad_summary","title":"<code>print_squad_summary(gameweek)</code>","text":"<p>Prints a formatted summary of the selected squad for a specific gameweek.</p> Source code in <code>build/lib/build/lib/fpl_solver/solver.py</code> <pre><code>def print_squad_summary(self, gameweek: int):\n    \"\"\"\n    Prints a formatted summary of the selected squad for a specific gameweek.\n    \"\"\"\n    if not self.selected_squad_history:\n        print(\"No squad has been selected yet. Run the 'solve' method first.\")\n        return\n\n    gw_data = self.get_gameweek_summary(gameweek)\n    if not gw_data:\n        return  # get_gameweek_summary already prints error message\n\n    selected_squad = gw_data[\"squad\"]\n    total_cost = gw_data[\"total_cost\"]\n    expected_points_from_xi = gw_data[\"expected_points_from_xi\"]\n    bench_boost_used = gw_data[\"bench_boost_used\"]\n    triple_captain_used = gw_data[\"triple_captain_used\"]\n    total_bench_boost_points = gw_data[\"total_bench_boost_points\"]\n    total_triple_captain_bonus = gw_data[\"total_triple_captain_bonus\"]\n    transfers_in_count = gw_data[\"transfers_in_count\"]  # New\n    transfers_out_count = gw_data[\"transfers_out_count\"]  # New\n    transfer_hits_taken = gw_data[\"transfer_hits\"]  # New\n    free_transfers_available_next_gw = gw_data[\n        \"free_transfers_available_next_gw\"\n    ]  # New\n\n    print(f\"\\n--- FPL Optimized Squad for Gameweek {gameweek} ---\")\n    print(f\"Squad Cost: \u00a3{total_cost:.1f}m\")\n    print(f\"Expected Points (Starting XI): {expected_points_from_xi:.2f}\")\n    print(\n        f\"Total Expected Points for GW{gameweek} (including chips): {expected_points_from_xi + total_bench_boost_points + total_triple_captain_bonus:.2f}\"\n    )\n    print(\"\\n--- Chips Used This Gameweek ---\")\n    if bench_boost_used:\n        print(f\"- Bench Boost (Added {total_bench_boost_points:.2f} points)\")\n    if triple_captain_used:\n        print(\n            f\"- Triple Captain (Added {total_triple_captain_bonus:.2f} bonus points)\"\n        )\n    if not (bench_boost_used or triple_captain_used):\n        print(\"No chips used this gameweek.\")\n\n    print(\"\\n--- Goalkeepers (Starting XI marked with *) ---\")\n    for index, row in selected_squad[selected_squad[\"position\"] == \"GK\"].iterrows():\n        starter_str = \"*\" if row[\"is_starter\"] else \"\"\n        captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n        transfer_status = \"\"\n        if row[\"transfer_in\"]:\n            transfer_status = \"(IN)\"\n        elif row[\"transfer_out\"]:\n            transfer_status = \"(OUT)\"\n\n        # Access gameweek-specific xP correctly\n        player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n        print(\n            f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n        )\n    print(\"\\n--- Defenders (Starting XI marked with *) ---\")\n    for index, row in selected_squad[\n        selected_squad[\"position\"] == \"DEF\"\n    ].iterrows():\n        starter_str = \"*\" if row[\"is_starter\"] else \"\"\n        captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n        transfer_status = \"\"\n        if row[\"transfer_in\"]:\n            transfer_status = \"(IN)\"\n        elif row[\"transfer_out\"]:\n            transfer_status = \"(OUT)\"\n\n        player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n        print(\n            f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n        )\n    print(\"\\n--- Midfielders (Starting XI marked with *) ---\")\n    for index, row in selected_squad[\n        selected_squad[\"position\"] == \"MID\"\n    ].iterrows():\n        starter_str = \"*\" if row[\"is_starter\"] else \"\"\n        captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n        transfer_status = \"\"\n        if row[\"transfer_in\"]:\n            transfer_status = \"(IN)\"\n        elif row[\"transfer_out\"]:\n            transfer_status = \"(OUT)\"\n\n        player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n        print(\n            f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n        )\n    print(\"\\n--- Forwards (Starting XI marked with *) ---\")\n    for index, row in selected_squad[\n        selected_squad[\"position\"] == \"FWD\"\n    ].iterrows():\n        starter_str = \"*\" if row[\"is_starter\"] else \"\"\n        captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n        transfer_status = \"\"\n        if row[\"transfer_in\"]:\n            transfer_status = \"(IN)\"\n        elif row[\"transfer_out\"]:\n            transfer_status = \"(OUT)\"\n\n        player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n        print(\n            f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n        )\n\n    print(f\"\\n--- Team Breakdown for GW{gameweek} ---\")\n    print(selected_squad[\"team\"].value_counts())\n\n    # Transfers are relevant from Gameweek 2 (index 1) onwards in the optimization horizon\n    # For display, if the current GW is the initial one (GW1 in the current context), no transfers are made\n    # If it's a subsequent GW, check if transfers occurred.\n    first_gw_in_history = min(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n    if (\n        gameweek &gt;= first_gw_in_history\n    ):  # Changed from &gt; to &gt;=, to show initial free transfers\n        # Display transfer info for this gameweek\n        print(\n            f\"  Transfers In: {transfers_in_count}, Transfers Out: {transfers_out_count}\"\n        )\n        print(\n            f\"  Transfer Hits: {transfer_hits_taken} (-{transfer_hits_taken * POINTS_PER_HIT} points)\"\n        )\n        # Only show free transfers for the *next* gameweek if it's not the last gameweek in the horizon\n        if gameweek &lt; max(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        ):\n            print(\n                f\"  Free Transfers Available for Next GW: {free_transfers_available_next_gw}\"\n            )\n    print(\"---------------------------\\n\")\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/#build.lib.build.lib.fpl_solver.solver.FPLOptimizer.solve","title":"<code>solve(budget, max_players_per_team, chip_allowances, num_gameweeks)</code>","text":"<p>Solves the FPL optimization problem using PuLP.</p> <p>Parameters:</p> Name Type Description Default <code>budget</code> <code>float</code> <p>The maximum budget in millions of pounds.</p> required <code>max_players_per_team</code> <code>int</code> <p>The maximum number of players allowed from                         any single Premier League team.</p> required <code>chip_allowances</code> <code>dict</code> <p>A dictionary specifying the maximum usage for each chip.</p> required <code>num_gameweeks</code> <code>int</code> <p>The number of gameweeks to optimize over.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if a solution was found, False otherwise.</p> Source code in <code>build/lib/build/lib/fpl_solver/solver.py</code> <pre><code>def solve(\n    self,\n    budget: float,\n    max_players_per_team: int,\n    chip_allowances: dict,\n    num_gameweeks: int,\n) -&gt; bool:\n    \"\"\"\n    Solves the FPL optimization problem using PuLP.\n\n    Args:\n        budget (float): The maximum budget in millions of pounds.\n        max_players_per_team (int): The maximum number of players allowed from\n                                    any single Premier League team.\n        chip_allowances (dict): A dictionary specifying the maximum usage for each chip.\n        num_gameweeks (int): The number of gameweeks to optimize over.\n\n    Returns:\n        bool: True if a solution was found, False otherwise.\n    \"\"\"\n    self.problem = LpProblem(\"FPL Squad Multi-Week Optimization\", LpMaximize)\n\n    # Decision variables for player selection, indexed by player and gameweek\n    player_vars = LpVariable.dicts(\n        \"Player\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n    )\n    starting_xi_vars = LpVariable.dicts(\n        \"StartingXI\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n    )\n    captain_var = LpVariable.dicts(\n        \"Captain\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n    )\n\n    # Binary variables for chip usage, indexed by gameweek\n    use_bench_boost = LpVariable.dicts(\n        \"Use_Bench_Boost\", range(num_gameweeks), 0, 1, LpBinary\n    )\n    use_triple_captain = LpVariable.dicts(\n        \"Use_Triple_Captain\", range(num_gameweeks), 0, 1, LpBinary\n    )\n\n    # Transfer variables\n    transfer_in_vars = LpVariable.dicts(\n        \"Transfer_In\",\n        (self.player_data.index, range(1, num_gameweeks)),\n        0,\n        1,\n        LpBinary,\n    )\n    transfer_out_vars = LpVariable.dicts(\n        \"Transfer_Out\",\n        (self.player_data.index, range(1, num_gameweeks)),\n        0,\n        1,\n        LpBinary,\n    )\n\n    # Total transfers made in a gameweek (absolute count)\n    transfers_made = LpVariable.dicts(\n        \"Transfers_Made\", range(1, num_gameweeks), 0, None, LpInteger\n    )\n    # Free transfers available at the start of a gameweek\n    free_transfers_available = LpVariable.dicts(\n        \"Free_Transfers_Available\",\n        range(num_gameweeks),\n        0,\n        MAX_FREE_TRANSFERS_SAVED + 1,\n        LpInteger,\n    )\n    # Number of transfer hits taken in a gameweek\n    transfer_hits = LpVariable.dicts(\n        \"Transfer_Hits\", range(1, num_gameweeks), 0, None, LpInteger\n    )\n\n    # Auxiliary variables for linearizing chip effects\n    is_bench_player = LpVariable.dicts(\n        \"Is_Bench_Player\",\n        (self.player_data.index, range(num_gameweeks)),\n        0,\n        1,\n        LpBinary,\n    )\n    actual_bench_boost_points = LpVariable.dicts(\n        \"Actual_Bench_Boost_Points\",\n        (self.player_data.index, range(num_gameweeks)),\n        0,\n        None,\n        LpContinuous,\n    )\n    actual_triple_captain_bonus = LpVariable.dicts(\n        \"Actual_Triple_Captain_Bonus\",\n        (self.player_data.index, range(num_gameweeks)),\n        0,\n        None,\n        LpContinuous,\n    )\n\n    # --- Objective Function ---\n    total_objective_points = []\n\n    # Get the first gameweek number from the player data to correctly index expected_points_by_gw\n    first_gw_key = next(\n        iter(\n            self.player_data.loc[\n                self.player_data.index[0], \"expected_points_by_gw\"\n            ].keys()\n        )\n    )\n    current_gameweek_number_start = int(first_gw_key)\n\n    for w in range(num_gameweeks):\n        # The actual gameweek number (1-indexed)\n        gw_actual = current_gameweek_number_start + w\n\n        # Base expected points from the selected starting 11 for this gameweek\n        base_points_expression_gw = lpSum(\n            self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n            * starting_xi_vars[i][w]\n            for i in self.player_data.index\n        )\n        total_objective_points.append(base_points_expression_gw)\n\n        # Regular Captaincy points (additional 1x for captain)\n        captain_points_bonus_gw = lpSum(\n            self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n            * captain_var[i][w]\n            for i in self.player_data.index\n        )\n        total_objective_points.append(captain_points_bonus_gw)\n\n        # Define auxiliary variables and constraints for chips for each gameweek\n        for i in self.player_data.index:\n            # Use gameweek-specific player xP for chip calculations\n            player_xp = self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n\n            # Bench Boost auxiliary variables and constraints\n            self.problem += (\n                is_bench_player[i][w] &lt;= player_vars[i][w],\n                f\"IsBench_Squad_{i}_{w}\",\n            )\n            self.problem += (\n                is_bench_player[i][w] &lt;= 1 - starting_xi_vars[i][w],\n                f\"IsBench_NotStarter_{i}_{w}\",\n            )\n            self.problem += (\n                is_bench_player[i][w]\n                &gt;= player_vars[i][w] + (1 - starting_xi_vars[i][w]) - 1,\n                f\"IsBench_Logical_{i}_{w}\",\n            )\n\n            self.problem += (\n                actual_bench_boost_points[i][w]\n                &lt;= player_xp * is_bench_player[i][w],\n                f\"BenchBoost_Contr_1_{i}_{w}\",\n            )\n            self.problem += (\n                actual_bench_boost_points[i][w] &lt;= player_xp * use_bench_boost[w],\n                f\"BenchBoost_Contr_2_{i}_{w}\",\n            )\n            self.problem += (\n                actual_bench_boost_points[i][w]\n                &gt;= player_xp * (is_bench_player[i][w] + use_bench_boost[w] - 1),\n                f\"BenchBoost_Contr_3_{i}_{w}\",\n            )\n            self.problem += (\n                actual_bench_boost_points[i][w] &gt;= 0,\n                f\"BenchBoost_Contr_4_{i}_{w}\",\n            )\n\n            # Triple Captain auxiliary variables and constraints\n            # Changed player_xp * 2 to player_xp to reflect additional 1x bonus\n            self.problem += (\n                actual_triple_captain_bonus[i][w] &lt;= player_xp * captain_var[i][w],\n                f\"TripleCaptain_Contr_1_{i}_{w}\",\n            )\n            self.problem += (\n                actual_triple_captain_bonus[i][w]\n                &lt;= player_xp * use_triple_captain[w],\n                f\"TripleCaptain_Contr_2_{i}_{w}\",\n            )\n            self.problem += (\n                actual_triple_captain_bonus[i][w]\n                &gt;= player_xp * (captain_var[i][w] + use_triple_captain[w] - 1),\n                f\"TripleCaptain_Contr_3_{i}_{w}\",\n            )\n            self.problem += (\n                actual_triple_captain_bonus[i][w] &gt;= 0,\n                f\"TripleCaptain_Contr_4_{i}_{w}\",\n            )\n\n        # Add points from bench boost and triple captain bonus for this gameweek\n        total_bench_boost_points_gw = lpSum(\n            actual_bench_boost_points[i][w] for i in self.player_data.index\n        )\n        total_triple_captain_bonus_points_gw = lpSum(\n            actual_triple_captain_bonus[i][w] for i in self.player_data.index\n        )\n\n        total_objective_points.append(total_bench_boost_points_gw)\n        total_objective_points.append(total_triple_captain_bonus_points_gw)\n\n    # Subtract transfer hits from the total objective\n    total_objective_points.append(\n        -POINTS_PER_HIT * lpSum(transfer_hits[w] for w in range(1, num_gameweeks))\n    )\n\n    self.problem += (\n        lpSum(total_objective_points),\n        \"Total Expected Points Over Gameweeks\",\n    )\n\n    # --- Constraints ---\n\n    # Apply constraints for each gameweek\n    for w in range(num_gameweeks):\n        # 1. Select exactly 15 players for the squad\n        self.problem += (\n            lpSum(player_vars[i][w] for i in self.player_data.index) == 15,\n            f\"Total_Players_GW{w}\",\n        )\n\n        # 2. Squad position constraints (2 GKs, 5 DEFs, 5 MIDs, 3 FWDs)\n        gks = self.player_data[self.player_data[\"position\"] == \"GK\"].index\n        defs = self.player_data[self.player_data[\"position\"] == \"DEF\"].index\n        mids = self.player_data[self.player_data[\"position\"] == \"MID\"].index\n        fwds = self.player_data[self.player_data[\"position\"] == \"FWD\"].index\n\n        self.problem += (\n            lpSum(player_vars[i][w] for i in gks) == 2,\n            f\"Goalkeepers_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(player_vars[i][w] for i in defs) == 5,\n            f\"Defenders_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(player_vars[i][w] for i in mids) == 5,\n            f\"Midfielders_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(player_vars[i][w] for i in fwds) == 3,\n            f\"Forwards_Count_GW{w}\",\n        )\n\n        # 3. Budget constraint\n        # This applies to the cost of the squad for the current gameweek.\n        self.problem += (\n            lpSum(\n                self.player_data.loc[i, \"cost\"] * player_vars[i][w]\n                for i in self.player_data.index\n            )\n            &lt;= budget,\n            f\"Total_Budget_GW{w}\",\n        )\n\n        # 4. Maximum players per team constraint\n        for team in self.player_data[\"team\"].unique():\n            team_players = self.player_data[self.player_data[\"team\"] == team].index\n            self.problem += (\n                lpSum(player_vars[i][w] for i in team_players)\n                &lt;= max_players_per_team,\n                f\"Max_Players_from_{team}_GW{w}\",\n            )\n\n        # 5. Starting XI constraints\n        # 5.1 Select exactly 11 players for the starting XI\n        self.problem += (\n            lpSum(starting_xi_vars[i][w] for i in self.player_data.index) == 11,\n            f\"Total_Starting_XI_Players_GW{w}\",\n        )\n\n        # 5.2 A player can only be in the starting XI if they are in the squad\n        for i in self.player_data.index:\n            self.problem += (\n                starting_xi_vars[i][w] &lt;= player_vars[i][w],\n                f\"StartingXI_in_Squad_{i}_{w}\",\n            )\n\n        # 5.3 Starting XI position constraints (FPL allows flexible formations, so use minimums)\n        self.problem += (\n            lpSum(starting_xi_vars[i][w] for i in gks) == 1,\n            f\"Starting_Goalkeepers_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(starting_xi_vars[i][w] for i in defs) &gt;= 3,\n            f\"Min_Starting_Defenders_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(starting_xi_vars[i][w] for i in mids) &gt;= 2,\n            f\"Min_Starting_Midfielders_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(starting_xi_vars[i][w] for i in fwds) &gt;= 1,\n            f\"Min_Starting_Forwards_Count_GW{w}\",\n        )\n\n        # 6. Captain Constraints\n        # 6.1 Select exactly one captain from the starting XI\n        self.problem += (\n            lpSum(captain_var[i][w] for i in self.player_data.index) == 1,\n            f\"One_Captain_GW{w}\",\n        )\n\n        # 6.2 A player can only be captain if they are in the starting XI\n        for i in self.player_data.index:\n            self.problem += (\n                captain_var[i][w] &lt;= starting_xi_vars[i][w],\n                f\"Captain_in_StartingXI_{i}_{w}\",\n            )\n\n        # --- Enforced Player Constraints---\n        for player_idx in self.enforced_player_indices:\n            self.problem += (\n                player_vars[player_idx][w] == 1,\n                f\"Enforce_Player_{self.player_data.loc[player_idx, 'name']}_GW{w}\",\n            )\n\n        for team, position in self.enforced_team_pos_requirements:\n            # Filter players for the current team and position\n            team_pos_players = self.player_data[\n                (self.player_data[\"team\"] == team)\n                &amp; (self.player_data[\"position\"] == position)\n            ].index\n            if not team_pos_players.empty:\n                self.problem += (\n                    lpSum(player_vars[i][w] for i in team_pos_players) &gt;= 1,\n                    f\"Enforce_One_{position}_from_{team}_GW{w}\",\n                )\n            else:\n                print(\n                    f\"Warning: No players found for enforced requirement: at least one {position} from {team} for GW{gw_actual}.\"\n                )\n\n    # --- Chip Usage Constraints (TOTAL usage over all gameweeks) ---\n    # These constraints should be outside the per-gameweek loop to avoid duplicates.\n    self.problem += (\n        lpSum(use_bench_boost[j] for j in range(num_gameweeks))\n        &lt;= chip_allowances.get(\"bench_boost\", 0),\n        f\"Max_Bench_Boost_Usage_Total\",\n    )\n    self.problem += (\n        lpSum(use_triple_captain[j] for j in range(num_gameweeks))\n        &lt;= chip_allowances.get(\"triple_captain\", 0),\n        f\"Max_Triple_Captain_Usage_Total\",\n    )\n\n    # --- Inter-Gameweek Constraints (Transfers and Transfer Rules) ---\n    # Initialize free transfers for GW0 (first gameweek of optimization horizon)\n    # This assumes the optimization starts at GW0, and it has INITIAL_FREE_TRANSFERS.\n    # If the model starts at an arbitrary GW, this would need to be an input.\n    self.problem += (\n        free_transfers_available[0] == INITIAL_FREE_TRANSFERS,\n        f\"Initial_Free_Transfers_GW0\",\n    )\n\n    for w in range(1, num_gameweeks):\n        # Calculate total transfers made in this gameweek\n        self.problem += (\n            transfers_made[w]\n            == lpSum(transfer_in_vars[i][w] for i in self.player_data.index),\n            f\"Transfers_Made_GW{w}\",\n        )\n        # Total transfers in must equal total transfers out for each gameweek after the first\n        self.problem += (\n            lpSum(transfer_in_vars[i][w] for i in self.player_data.index)\n            == lpSum(transfer_out_vars[i][w] for i in self.player_data.index),\n            f\"Transfers_In_Equals_Out_GW{w}\",\n        )\n\n        # Calculate free transfers available for the current gameweek (w)\n        # Free transfers for GW_w = min(free transfers from GW_w-1 - transfers made in GW_w + 1, MAX_FREE_TRANSFERS_SAVED + 1)\n        # The + 1 in MAX_FREE_TRANSFERS_SAVED + 1 is because MAX_FREE_TRANSFERS_SAVED implies how many can be *saved*,\n        # so if you save 1, you have 1 (current) + 1 (saved) = 2.\n        self.problem += (\n            free_transfers_available[w]\n            &lt;= free_transfers_available[w - 1] - transfers_made[w] + 1,\n            f\"Free_Transfers_Calc_1_GW{w}\",\n        )\n        self.problem += (\n            free_transfers_available[w] &lt;= MAX_FREE_TRANSFERS_SAVED + 1,\n            f\"Free_Transfers_Calc_2_GW{w}\",\n        )\n        self.problem += (\n            free_transfers_available[w] &gt;= 0,  # Cannot have negative free transfers\n            f\"Free_Transfers_Non_Negative_GW{w}\",\n        )\n\n        # Calculate transfer hits\n        # transfer_hits[w] = max(0, transfers_made[w] - free_transfers_available_at_start_of_gw_w)\n        # This needs to be linearized. If transfers_made[w] &gt; free_transfers_available[w-1], then hit.\n        # free_transfers_available[w-1] represents transfers available *before* making transfers for GW_w\n        self.problem += (\n            transfer_hits[w] &gt;= transfers_made[w] - free_transfers_available[w - 1],\n            f\"Transfer_Hits_Calc_1_GW{w}\",\n        )\n        self.problem += (\n            transfer_hits[w] &gt;= 0,\n            f\"Transfer_Hits_Calc_2_GW{w}\",\n        )\n\n        for i in self.player_data.index:\n            # Squad continuity: player_vars[i][w] (in squad at start of GW w)\n            #                 = player_vars[i][w-1] (in squad at start of GW w-1)\n            #                 - transfer_out_vars[i][w] (transferred out for GW w)\n            #                 + transfer_in_vars[i][w] (transferred in for GW w)\n            self.problem += (\n                player_vars[i][w]\n                == player_vars[i][w - 1]\n                - transfer_out_vars[i][w]\n                + transfer_in_vars[i][w],\n                f\"Squad_Continuity_{i}_GW{w}\",\n            )\n            # A player cannot be transferred in and out in the same gameweek\n            self.problem += (\n                transfer_in_vars[i][w] + transfer_out_vars[i][w] &lt;= 1,\n                f\"No_Simultaneous_Transfer_{i}_{w}\",\n            )\n\n    try:\n        # The solver is called with the GLPK_CMD solver\n        self.problem.solve(PULP_CBC_CMD(msg=0))  # msg=0 suppresses verbose output\n    except Exception as e:\n        print(f\"Error solving the problem: {e}\")\n        return False\n\n    if LpStatus[self.problem.status] == \"Optimal\":\n        print(\"Optimization successful! Optimal solution found.\")\n\n        self.selected_squad_history = {}\n        self.total_transfer_hits = 0\n        for w in range(num_gameweeks):\n            # The actual gameweek number (1-indexed)\n            gw_actual = current_gameweek_number_start + w\n\n            # Get selected players for the current gameweek\n            selected_squad_gw = self.player_data[\n                [player_vars[i][w].varValue == 1 for i in self.player_data.index]\n            ].copy()\n\n            # Get starter and captain info for this gameweek\n            is_starter_series_gw = pd.Series(\n                [\n                    starting_xi_vars[i][w].varValue == 1\n                    for i in self.player_data.index\n                ],\n                index=self.player_data.index,\n            )\n            is_captain_series_gw = pd.Series(\n                [captain_var[i][w].varValue == 1 for i in self.player_data.index],\n                index=self.player_data.index,\n            )\n\n            selected_squad_gw[\"is_starter\"] = is_starter_series_gw.loc[\n                selected_squad_gw.index\n            ]\n            selected_squad_gw[\"is_captain\"] = is_captain_series_gw.loc[\n                selected_squad_gw.index\n            ]\n\n            transfers_in_gw = 0\n            transfers_out_gw = 0\n            hits_gw = 0\n\n            # Store transfer details for gameweeks &gt; 0\n            if (\n                w &gt; 0\n            ):  # Check for transfers only from GW1 onwards (index 1 in 0-indexed loop)\n                transfer_in_flags = pd.Series(\n                    [\n                        transfer_in_vars[i][w].varValue == 1\n                        for i in self.player_data.index\n                    ],\n                    index=self.player_data.index,\n                )\n                transfer_out_flags = pd.Series(\n                    [\n                        transfer_out_vars[i][w].varValue == 1\n                        for i in self.player_data.index\n                    ],\n                    index=self.player_data.index,\n                )\n\n                selected_squad_gw[\"transfer_in\"] = transfer_in_flags.loc[\n                    selected_squad_gw.index\n                ]\n                selected_squad_gw[\"transfer_out\"] = transfer_out_flags.loc[\n                    selected_squad_gw.index\n                ]\n\n                transfers_in_gw = int(round(transfer_in_flags.sum()))\n                transfers_out_gw = int(round(transfer_out_flags.sum()))\n                hits_gw = int(round(transfer_hits[w].varValue))\n                self.total_transfer_hits += hits_gw\n            else:\n                selected_squad_gw[\"transfer_in\"] = False  # No transfers in for GW0\n                selected_squad_gw[\"transfer_out\"] = (\n                    False  # No transfers out for GW0\n                )\n\n            self.selected_squad_history[f\"GW{gw_actual}\"] = {\n                \"squad\": selected_squad_gw,\n                \"total_cost\": selected_squad_gw[\"cost\"].sum(),\n                \"expected_points_from_xi\": sum(\n                    self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n                    * starting_xi_vars[i][w].varValue\n                    for i in self.player_data.index\n                ),\n                \"bench_boost_used\": bool(use_bench_boost[w].varValue),\n                \"triple_captain_used\": bool(use_triple_captain[w].varValue),\n                \"total_bench_boost_points\": value(\n                    lpSum(\n                        actual_bench_boost_points[i][w]\n                        for i in self.player_data.index\n                    )\n                ),\n                \"total_triple_captain_bonus\": value(\n                    lpSum(\n                        actual_triple_captain_bonus[i][w]\n                        for i in self.player_data.index\n                    )\n                ),\n                \"transfers_in_count\": transfers_in_gw,\n                \"transfers_out_count\": transfers_out_gw,\n                \"transfer_hits\": hits_gw,  # New\n                \"free_transfers_available_next_gw\": (\n                    int(round(free_transfers_available[w].varValue))\n                    if w &lt; num_gameweeks - 1\n                    else 0\n                ),  # Free transfers available *after* this GW's transfers are made\n            }\n\n        # Overall totals\n        self.total_cost = self.selected_squad_history[\n            f\"GW{current_gameweek_number_start + num_gameweeks - 1}\"\n        ][\n            \"total_cost\"\n        ]  # Cost of final squad\n        self.total_expected_points = value(\n            self.problem.objective\n        )  # Total objective value from solver\n        self.used_chips = {\n            f\"GW{current_gameweek_number_start + w}\": {\n                \"bench_boost\": bool(use_bench_boost[w].varValue),\n                \"triple_captain\": bool(use_triple_captain[w].varValue),\n            }\n            for w in range(num_gameweeks)\n        }\n\n        return True\n    else:\n        print(f\"No optimal solution found. Status: {LpStatus[self.problem.status]}\")\n        self.selected_squad_history = {}\n        self.total_cost = 0\n        self.total_expected_points = 0\n        self.used_chips = {}\n        self.total_transfer_hits = 0\n        return False\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/#build.lib.build.lib.fpl_solver.xp_predictor","title":"<code>xp_predictor</code>","text":"<p>FPL Expected Points (xP) Predictor Module.</p> <p>This module provides functionality to predict Fantasy Premier League (FPL) points for players based on historical data, team strengths, and fixture difficulty.</p>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/#build.lib.build.lib.fpl_solver.xp_predictor.FPLPredictor","title":"<code>FPLPredictor</code>","text":"<p>Predictive algorithm for Expected Points (xP) in Fantasy Premier League, using real data from the FPL API.</p> <p>This class handles: - Fetching and processing FPL API data - Calculating expected points based on multiple factors - Managing player exclusions and filtering - Providing fixture and player data for optimization</p> <p>Attributes:</p> Name Type Description <code>gameweeks_to_predict</code> <code>int</code> <p>Number of future gameweeks to analyze</p> <code>players_data</code> <code>Dict</code> <p>Player statistics and information</p> <code>teams_data</code> <code>Dict</code> <p>Team statistics and attributes</p> <code>fixtures_data</code> <code>Dict</code> <p>Upcoming and historical match data</p> <code>all_players_xp_calculated_data</code> <code>List</code> <p>Processed xP calculations</p> Source code in <code>build/lib/build/lib/fpl_solver/xp_predictor.py</code> <pre><code>class FPLPredictor:\n    \"\"\"\n    Predictive algorithm for Expected Points (xP) in Fantasy Premier League,\n    using real data from the FPL API.\n\n    This class handles:\n    - Fetching and processing FPL API data\n    - Calculating expected points based on multiple factors\n    - Managing player exclusions and filtering\n    - Providing fixture and player data for optimization\n\n    Attributes:\n        gameweeks_to_predict (int): Number of future gameweeks to analyze\n        players_data (Dict): Player statistics and information\n        teams_data (Dict): Team statistics and attributes\n        fixtures_data (Dict): Upcoming and historical match data\n        all_players_xp_calculated_data (List): Processed xP calculations\n    \"\"\"\n\n    def __init__(self, gameweeks_to_predict: int = 1):\n        \"\"\"\n        Initialize the FPLPredictor with data structures and fetch initial data.\n\n        Args:\n            gameweeks_to_predict: Number of upcoming gameweeks to calculate\n                                expected points for. Default is 1 (next gameweek).\n\n        Raises:\n            ValueError: If gameweeks_to_predict is not a positive integer\n        \"\"\"\n        self.logger = setup_logger(__name__)\n        if not isinstance(gameweeks_to_predict, int) or gameweeks_to_predict &lt; 1:\n            msg = f\"gameweeks_to_predict must be a positive integer, got {gameweeks_to_predict}\"\n            self.logger.error(msg)\n            raise ValueError(msg)\n\n        self.gameweeks_to_predict = gameweeks_to_predict\n        self.logger.info(f\"Initializing FPL Predictor for {gameweeks_to_predict} gameweek(s)\")\n\n        # Initialize cache manager\n        cache_dir = os.path.join(os.path.dirname(__file__), 'cache')\n        self.cache_manager = CacheManager(cache_dir)\n\n        # Configuration and static data\n        self.fpl_points: Dict[str, float] = FPL_POINTS\n        self.position_definitions: Dict[int, str] = {\n            1: \"GK\",\n            2: \"DEF\",\n            3: \"MID\",\n            4: \"FWD\",\n        }\n\n        # Data structures for FPL information\n        self.players_data: Dict[int, Dict] = {}\n        self.teams_data: Dict[int, Dict] = {}\n        self.fixtures_data: Dict[int, Dict] = {}\n        self.all_players_xp_calculated_data: List[Dict] = []\n\n        # Initialize data\n        try:\n            self._fetch_fpl_data()\n            self._calculate_all_players_xp()\n        except Exception as e:\n            self.logger.error(f\"Failed to initialize FPL Predictor: {str(e)}\")\n            raise\n\n    def _fetch_fpl_data(self) -&gt; None:\n        \"\"\"\n        Fetch and process data from the FPL API.\n\n        This method retrieves player, team, and fixture data from the FPL API,\n        processes it, and stores it in the appropriate data structures. It also\n        applies any configured player exclusions.\n\n        Raises:\n            requests.RequestException: If API requests fail\n            ValueError: If required data is missing from API response\n            Exception: For other unexpected errors\n        \"\"\"\n        self.logger.info(\"Fetching FPL data from API...\")\n\n        try:\n            # Helper function to fetch from API with caching\n            def fetch_api_data(url: str, endpoint: str) -&gt; dict:\n                # Try to get from cache first\n                cached_data = self.cache_manager.get_cached_response(endpoint)\n                if cached_data is not None:\n                    self.logger.info(f\"Using cached {endpoint} data\")\n                    return cached_data\n\n                # If not in cache or expired, fetch from API\n                try:\n                    self.logger.info(f\"Fetching {endpoint} data from API\")\n                    response = requests.get(url, timeout=10)\n                    response.raise_for_status()\n                    data = response.json()\n\n                    # Cache the response\n                    self.cache_manager.save_response(endpoint, data)\n                    return data\n\n                except requests.RequestException as e:\n                    self.logger.error(f\"Failed to fetch {endpoint} data: {str(e)}\")\n                    raise\n\n            # Fetch both endpoints\n            static_data = fetch_api_data(\n                \"https://fantasy.premierleague.com/api/bootstrap-static/\",\n                \"static\"\n            )\n            fixtures_data = fetch_api_data(\n                \"https://fantasy.premierleague.com/api/fixtures/\",\n                \"fixtures\"\n            )\n\n            # Process players data\n            if \"elements\" not in static_data:\n                raise ValueError(\"No player elements found in API response\")\n\n            self.logger.info(f\"Processing {len(static_data['elements'])} players...\")\n\n            def process_player_data(element: Dict) -&gt; Tuple[int, Dict]:\n                \"\"\"Helper function to process individual player data\"\"\"\n                try:\n                    player_id = element[\"id\"]\n                    return player_id, {\n                        \"name\": f\"{element['first_name']} {element['second_name']}\",\n                        \"web_name\": element[\"web_name\"],\n                        \"team_id\": element[\"team\"],\n                        \"element_type\": element[\"element_type\"],\n                        \"position\": self.position_definitions.get(\n                            element[\"element_type\"], \"Unknown\"\n                        ),\n                        \"cost_pence\": element[\"now_cost\"],\n                        \"status\": element[\"status\"],\n                        \"news\": element[\"news\"],\n                        \"total_points\": element[\"total_points\"],\n                        \"minutes\": element[\"minutes\"],\n                        \"goals_scored\": element[\"goals_scored\"],\n                        \"assists\": element[\"assists\"],\n                        \"clean_sheets\": element[\"clean_sheets\"],\n                        \"goals_conceded\": element[\"goals_conceded\"],\n                        \"penalties_saved\": element[\"penalties_saved\"],\n                        \"penalties_missed\": element[\"penalties_missed\"],\n                        \"yellow_cards\": element[\"yellow_cards\"],\n                        \"red_cards\": element[\"red_cards\"],\n                        \"own_goals\": element[\"own_goals\"],\n                        \"saves\": element[\"saves\"],\n                        \"bonus\": element[\"bonus\"],\n                        \"bps\": element[\"bps\"],\n                        \"threat\": float(element.get(\"threat\", 0)),\n                        \"creativity\": float(element.get(\"creativity\", 0)),\n                        \"influence\": float(element.get(\"influence\", 0)),\n                        \"form\": float(element.get(\"form\", 0)),\n                        \"points_per_game\": float(element.get(\"points_per_game\", 0)),\n                        \"value_season\": float(element.get(\"value_season\", 0)),\n                        \"value_form\": float(element.get(\"value_form\", 0)),\n                        \"ict_index\": float(element.get(\"ict_index\", 0)),\n                        \"defensive_contribution\": float(element.get(\"defensive_contribution\", 0)),\n                    }\n                except KeyError as e:\n                    self.logger.warning(f\"Missing required field for player: {str(e)}\")\n                    return None\n                except ValueError as e:\n                    self.logger.warning(f\"Invalid numeric value for player {element.get('id')}: {str(e)}\")\n                    return None\n\n            # Process all players with error handling\n            for element in static_data[\"elements\"]:\n                result = process_player_data(element)\n                if result:\n                    player_id, player_data = result\n                    self.players_data[player_id] = player_data\n\n            # Apply Player Exclusions\n            def apply_player_exclusions() -&gt; Dict[int, Dict]:\n                \"\"\"Apply configured player exclusions and return filtered player data\"\"\"\n                initial_count = len(self.players_data)\n                players_to_keep = {}\n\n                for player_id, player_info in self.players_data.items():\n                    # Track exclusion reason if player is excluded\n                    exclusion_reason = None\n\n                    # Check ID exclusions\n                    if player_id in EXCLUDED_PLAYERS_BY_ID:\n                        exclusion_reason = f\"ID exclusion: {player_id}\"\n\n                    # Check name exclusions\n                    elif player_info[\"name\"] in EXCLUDED_PLAYERS_BY_NAME:\n                        exclusion_reason = f\"Name exclusion: {player_info['name']}\"\n\n                    # Check team/position exclusions\n                    else:\n                        team_name = self.teams_data.get(player_info[\"team_id\"], {}).get(\"name\")\n                        for rule in EXCLUDED_PLAYERS_BY_TEAM_AND_POSITION:\n                            if (team_name == rule.get(\"team\") and \n                                player_info[\"position\"] == rule.get(\"position\")):\n                                exclusion_reason = f\"Team/Position exclusion: {team_name}/{player_info['position']}\"\n                                break\n\n                    # Log exclusion or keep player\n                    if exclusion_reason:\n                        self.logger.info(\n                            f\"Excluding player {player_info['name']} - {exclusion_reason}\"\n                        )\n                    else:\n                        players_to_keep[player_id] = player_info\n\n                filtered_count = len(players_to_keep)\n                self.logger.info(\n                    f\"Player filtering complete. {initial_count - filtered_count} \"\n                    f\"players excluded. {filtered_count} players remaining.\"\n                )\n                return players_to_keep\n\n            self.players_data = apply_player_exclusions()\n\n            # Process teams data\n            if \"teams\" not in static_data:\n                raise ValueError(\"No team data found in API response\")\n\n            self.logger.info(f\"Processing {len(static_data['teams'])} teams...\")\n\n            def process_team_data(team: Dict) -&gt; Tuple[int, Dict]:\n                \"\"\"Helper function to process individual team data\"\"\"\n                try:\n                    return team[\"id\"], {\n                        \"name\": team[\"name\"],\n                        \"short_name\": team[\"short_name\"],\n                        \"strength\": team[\"strength\"],\n                        \"strength_overall_home\": team[\"strength_overall_home\"],\n                        \"strength_overall_away\": team[\"strength_overall_away\"],\n                        \"strength_attack_home\": team[\"strength_attack_home\"],\n                        \"strength_attack_away\": team[\"strength_attack_away\"],\n                        \"strength_defence_home\": team[\"strength_defence_home\"],\n                        \"strength_defence_away\": team[\"strength_defence_away\"],\n                    }\n                except KeyError as e:\n                    self.logger.warning(f\"Missing required field for team: {str(e)}\")\n                    return None\n\n            # Process all teams with error handling\n            for team in static_data[\"teams\"]:\n                result = process_team_data(team)\n                if result:\n                    team_id, team_data = result\n                    self.teams_data[team_id] = team_data\n\n            # Process fixtures data\n            self.logger.info(f\"Processing {len(fixtures_data)} fixtures...\")\n\n            def process_fixture_data(fixture: Dict) -&gt; Tuple[int, Dict]:\n                \"\"\"Helper function to process individual fixture data\"\"\"\n                try:\n                    fixture_id = fixture[\"id\"]\n                    # Validate required fields\n                    required_fields = [\"team_h\", \"team_a\", \"event\", \"finished\"]\n                    if not all(field in fixture for field in required_fields):\n                        missing = [f for f in required_fields if f not in fixture]\n                        raise KeyError(f\"Missing required fields: {', '.join(missing)}\")\n                    return fixture_id, fixture\n                except KeyError as e:\n                    self.logger.warning(f\"Invalid fixture data: {str(e)}\")\n                    return None\n\n            # Process all fixtures with error handling\n            for fixture in fixtures_data:\n                result = process_fixture_data(fixture)\n                if result:\n                    fixture_id, fixture_data = result\n                    self.fixtures_data[fixture_id] = fixture_data\n\n            self.logger.info(\"FPL data fetched and processed successfully.\")\n\n        except requests.exceptions.RequestException as e:\n            self.logger.error(f\"Failed to fetch FPL data: {str(e)}\")\n            self._reset_data_structures()\n            raise\n        except ValueError as e:\n            self.logger.error(f\"Invalid data received from FPL API: {str(e)}\")\n            self._reset_data_structures()\n            raise\n        except Exception as e:\n            self.logger.error(f\"Unexpected error during data processing: {str(e)}\")\n            self._reset_data_structures()\n            raise\n\n    def _reset_data_structures(self) -&gt; None:\n        \"\"\"Reset all data structures to empty state\"\"\"\n        self.players_data = {}\n        self.teams_data = {}\n        self.fixtures_data = {}\n\n    def _get_team_strength(self, team_id, is_home):\n        \"\"\"Get team strength based on home/away status.\"\"\"\n        team = self.teams_data.get(team_id, {})\n        if is_home:\n            return team.get(\"strength_overall_home\", 1000)  # Default if not found\n        return team.get(\"strength_overall_away\", 1000)  # Default if not found\n\n    def _predict_minutes(self, player_id):\n        \"\"\"\n        Predicts expected minutes for a player based on historical data.\n        More sophisticated logic for handling very low minute players.\n        \"\"\"\n        player = self.players_data.get(player_id)\n        if not player:\n            return 0.0\n\n        status = player[\"status\"]\n        news = player[\"news\"].lower()\n        minutes_played = player[\"minutes\"]\n\n        # 1. Unavailable players (injured, suspended, doubtful)\n        if status != \"a\" or any(\n            x in news\n            for x in [\n                \"injured\",\n                \"doubtful\",\n                \"suspension\",\n                \"red card\",\n                \"expected back\",\n            ]\n        ):\n            return 0.0\n\n        # 2. Players with significant minutes (starters/key rotation)\n        if minutes_played &gt;= MIN_MINUTES_THRESHOLD:\n            # Average minutes per game started (assuming most minutes come from starts)\n            # This is a heuristic; real FPL API doesn't give starts directly.\n            # We assume a player with &gt; MIN_MINUTES_THRESHOLD plays ~80-90 minutes when on pitch.\n            # So, (minutes_played / number_of_appearances) is a rough proxy.\n            # For simplicity, let's use a cap of 90 minutes.\n            if player[\"total_points\"] &gt; 0:  # Player has played at least one game\n                avg_minutes_per_appearance = minutes_played / (\n                    player[\"total_points\"] / player[\"points_per_game\"]\n                )\n                return min(avg_minutes_per_appearance, 90.0)\n            return 70.0  # Reasonable default for established player with points but no clear avg\n\n        # 3. Players with very low minutes (rarely play, new, youth)\n        if minutes_played &lt; VERY_LOW_MINUTES_THRESHOLD:\n            # If news suggests they might get a chance, assign default sub minutes.\n            # Otherwise, very low expected minutes or zero.\n            if any(x in news for x in [\"return imminent\", \"close to return\"]):\n                return DEFAULT_SUB_MINUTES  # Might get some minutes\n            return DEFAULT_UNKNOWN_PLAYER_MINUTES  # Very unlikely to play significant minutes\n\n        # 4. Players with some minutes but below significant threshold (regular subs)\n        return DEFAULT_SUB_MINUTES\n\n    def _calculate_expected_goals(self, team_attack_strength, opp_defence_strength):\n        \"\"\"\n        Calculates expected goals for a team based on its attack strength and\n        opponent's defensive strength. This is a simplified heuristic.\n        \"\"\"\n        # A simple ratio model: Higher attack strength and lower opponent defense means more goals\n        # Normalization factor can be adjusted based on average league goals\n        expected_goals = (\n            team_attack_strength / opp_defence_strength\n        ) * 1.5  # 1.5 is an arbitrary scaling factor\n        return max(0.0, expected_goals)\n\n    def _calculate_expected_conceded_goals(\n        self, team_defence_strength, opp_attack_strength\n    ):\n        \"\"\"\n        Calculates expected goals conceded by a team based on its defense strength\n        and opponent's attacking strength.\n        \"\"\"\n        # A simple ratio model: Higher opponent attack and lower team defense means more conceded goals\n        expected_conceded_goals = (\n            opp_attack_strength / team_defence_strength\n        ) * 1.5  # 1.5 is an arbitrary scaling factor\n        return max(0.0, expected_conceded_goals)\n\n    def calculate_xp_for_player(self, player_id, fixture_id):\n        \"\"\"\n        Calculates Expected Points (xP) for a single player in a given fixture.\n        Considers various factors: minutes, goals, assists, clean sheets, saves,\n        bonus points, and negative events, adjusted for fixture difficulty.\n        \"\"\"\n        player = self.players_data.get(player_id)\n        fixture = self.fixtures_data.get(fixture_id)\n\n        if not player or not fixture:\n            return {\"xp\": 0.0, \"reason\": \"Player or fixture data missing.\"}\n\n        # Handle unavailable players\n        if (\n            player[\"status\"] != \"a\"\n        ):  # 'd' for doubtful, 'i' for injured, 's' for suspended\n            return {\"xp\": 0.0, \"reason\": f\"Player status: {player['status']}\"}\n        if any(\n            x in player[\"news\"].lower()\n            for x in [\"injured\", \"doubtful\", \"suspension\", \"red card\"]\n        ):\n            return {\"xp\": 0.0, \"reason\": f\"Player news: {player['news']}\"}\n\n        # Predict minutes\n        expected_minutes = self._predict_minutes(player_id)\n        if expected_minutes &lt; 1.0:  # If expected to play very little or none\n            return {\"xp\": 0.0, \"reason\": \"Expected minutes too low.\"}\n\n        xp = 0.0\n        position = player[\"position\"]\n        # Use 'team_h' for home team ID\n        is_home_fixture = player[\"team_id\"] == fixture[\"team_h\"]\n\n        # Determine attacking and defensive strengths for the fixture\n        player_team_strength_attack = (\n            self.teams_data.get(fixture[\"team_h\"], {}).get(\n                \"strength_attack_home\"\n            )  # Use 'team_h'\n            if is_home_fixture\n            else self.teams_data.get(fixture[\"team_a\"], {}).get(\n                \"strength_attack_away\"\n            )  # Use 'team_a'\n        )\n        player_team_strength_defence = (\n            self.teams_data.get(fixture[\"team_h\"], {}).get(\n                \"strength_defence_home\"\n            )  # Use 'team_h'\n            if is_home_fixture\n            else self.teams_data.get(fixture[\"team_a\"], {}).get(\n                \"strength_defence_away\"\n            )  # Use 'team_a'\n        )\n        opponent_team_strength_attack = (\n            self.teams_data.get(fixture[\"team_a\"], {}).get(\n                \"strength_attack_away\"\n            )  # Use 'team_a'\n            if is_home_fixture\n            else self.teams_data.get(fixture[\"team_h\"], {}).get(\n                \"strength_attack_home\"\n            )  # Use 'team_h'\n        )\n        opponent_team_strength_defence = (\n            self.teams_data.get(fixture[\"team_a\"], {}).get(\n                \"strength_defence_away\"\n            )  # Use 'team_a'\n            if is_home_fixture\n            else self.teams_data.get(fixture[\"team_h\"], {}).get(\n                \"strength_defence_home\"\n            )  # Use 'team_h'\n        )\n\n        if None in [\n            player_team_strength_attack,\n            player_team_strength_defence,\n            opponent_team_strength_attack,\n            opponent_team_strength_defence,\n        ]:\n            # Fallback if strength data is missing (shouldn't happen with robust data fetch)\n            return {\"xp\": 0.0, \"reason\": \"Team strength data missing for fixture.\"}\n\n        # Apply confidence factor based on historical minutes\n        minutes_played = player.get(\"minutes\", 0)\n        confidence_factor = XP_CONFIDENCE_FACTORS[\"proven\"]  # Default to proven player\n        if minutes_played &lt; VERY_LOW_MINUTES_THRESHOLD:\n            confidence_factor = XP_CONFIDENCE_FACTORS[\"very_low_minutes\"]\n        elif minutes_played &lt; MIN_MINUTES_THRESHOLD:\n            confidence_factor = XP_CONFIDENCE_FACTORS[\"low_minutes\"]\n\n        # 1. Appearance points\n        if expected_minutes &gt;= 60:\n            xp += self.fpl_points[\"appearance_points_gte_60\"]\n        elif expected_minutes &gt; 0:\n            xp += self.fpl_points[\"appearance_points_lt_60\"]\n\n        # 2. Expected Goals (scaled by historical goals per 90 and opponent difficulty)\n        # Use player's form and total goals as a basis\n        goals_per_90_hist = (\n            (player[\"goals_scored\"] / player[\"minutes\"] * 90)\n            if player[\"minutes\"] &gt; 0\n            else 0.0\n        )\n        expected_team_goals = self._calculate_expected_goals(\n            player_team_strength_attack, opponent_team_strength_defence\n        )\n\n        expected_goals_player_contribution = (\n            (goals_per_90_hist / 90.0) * expected_minutes * (expected_team_goals / 1.5)\n        )  # Scale player's goal contribution by team's expected goals\n\n        if position == \"GK\":\n            xp += expected_goals_player_contribution * self.fpl_points[\"goal_gk\"]\n        elif position == \"DEF\":\n            xp += expected_goals_player_contribution * self.fpl_points[\"goal_def\"]\n        elif position == \"MID\":\n            xp += expected_goals_player_contribution * self.fpl_points[\"goal_mid\"]\n        elif position == \"FWD\":\n            xp += expected_goals_player_contribution * self.fpl_points[\"goal_fwd\"]\n\n        # 3. Expected Assists (scaled by historical assists per 90 and opponent difficulty)\n        assists_per_90_hist = (\n            (player[\"assists\"] / player[\"minutes\"] * 90)\n            if player[\"minutes\"] &gt; 0\n            else 0.0\n        )\n        # Assuming team's attacking strength correlates with assist opportunities\n        expected_assists_player_contribution = (\n            (assists_per_90_hist / 90.0)\n            * expected_minutes\n            * (expected_team_goals / 1.5)\n        )  # Similarly scale by team's expected goals\n        xp += expected_assists_player_contribution * self.fpl_points[\"assist_points\"]\n\n        # 4. Expected Clean Sheets (for GKs/DEFs/MIDs) and Conceded Goals deduction\n        expected_conceded = self._calculate_expected_conceded_goals(\n            player_team_strength_defence, opponent_team_strength_attack\n        )\n\n        # Probability of clean sheet\n        # Simplified: higher team defense / lower opponent attack -&gt; higher CS prob\n        # Use logistic or sigmoid for probability\n        cs_prob = 1.0 / (\n            1.0 + math.exp(expected_conceded - 1.0)\n        )  # Sigmoid centered at 1 goal\n\n        if position in [\"GK\", \"DEF\"]:\n            xp += cs_prob * self.fpl_points[\"clean_sheet_gk_def\"]\n\n            # Conceded goals deduction: Apply penalty for every 2 goals conceded *probability*\n            # For simplicity, calculate expected deduction: (expected_conceded / 2) * deduction\n            xp += (expected_conceded / 2.0) * self.fpl_points[\n                \"conceded_2_goals_deduction\"\n            ]\n        elif position == \"MID\":\n            xp += cs_prob * self.fpl_points[\"clean_sheet_mid\"]\n\n        # 5. Expected Saves (for GKs)\n        if position == \"GK\":\n            saves_per_90_hist = (\n                (player[\"saves\"] / player[\"minutes\"] * 90)\n                if player[\"minutes\"] &gt; 0\n                else 0.0\n            )\n            # Expected saves scaled by opponent's attacking strength (more attacking -&gt; more shots -&gt; more saves)\n            expected_saves_player_contribution = (\n                (saves_per_90_hist / 90.0)\n                * expected_minutes\n                * (opponent_team_strength_attack / player_team_strength_defence)\n            )\n            xp += (expected_saves_player_contribution / 3.0) * self.fpl_points[\n                \"saves_3_points\"\n            ]  # Using the new config point value\n\n            # Penalty saves (low probability, use historical rate)\n            penalty_saves_hist_per_game = (\n                player[\"penalties_saved\"] / (player[\"minutes\"] / 90.0)\n                if player[\"minutes\"] &gt; 0\n                else 0.0\n            )\n            xp += (\n                penalty_saves_hist_per_game\n                * (expected_minutes / 90.0)\n                * self.fpl_points[\"penalty_save_points\"]\n            )\n\n        # 6. Expected Bonus Points\n        # Use BPS (Bonus Points System) as a proxy. Scale player's average BPS by form and expected minutes.\n        bps_per_90_hist = (\n            (player[\"bps\"] / player[\"minutes\"] * 90) if player[\"minutes\"] &gt; 0 else 0.0\n        )\n        expected_bps = (bps_per_90_hist / 90.0) * expected_minutes * player[\"form\"]\n        xp += expected_bps * self.fpl_points[\"bonus_points_scaling_factor\"]\n\n        # 7. Minor Negative Events (Probabilistic)\n        # These are rare, so a simple probability based on expected minutes.\n        xp += (expected_minutes / 90.0) * (\n            self.fpl_points[\"yellow_card_deduction\"] * YELLOW_CARD_PROB\n            + self.fpl_points[\"red_card_deduction\"] * RED_CARD_PROB\n            + self.fpl_points[\"own_goal_deduction\"] * OWN_GOAL_PROB\n            + self.fpl_points[\"penalty_miss_deduction\"] * PENALTY_MISS_PROB\n        )\n\n        # 8. Defensive Contribution Points (for 2025/26 season)\n        # Use actual defensive_contribution data from API\n        defensive_contribution_per_90 = (\n            (player[\"defensive_contribution\"] / player[\"minutes\"] * 90)\n            if player[\"minutes\"] &gt; 0\n            else 0.0\n        )\n        expected_defensive_contribution = (defensive_contribution_per_90 / 90.0) * expected_minutes\n\n        # Award defensive contribution points based on position thresholds\n        if position in [\"DEF\", \"MID\", \"FWD\"]:  # Goalkeepers do not earn defensive contribution points\n            xp += expected_defensive_contribution * self.fpl_points[\"defensive_contribution_points\"]\n\n        # Apply confidence factor to final xP\n        xp = xp * confidence_factor\n\n        return {\"xp\": round(xp, 2), \"reason\": \"Success\", \"confidence\": confidence_factor}\n\n    def _calculate_all_players_xp(self):\n        \"\"\"\n        Calculates the Expected Points (xP) for all players over multiple upcoming gameweeks\n        and populates self.all_players_xp_calculated_data with xP per gameweek.\n        \"\"\"\n        print(\n            f\"Calculating xP for all players over {self.gameweeks_to_predict} gameweek(s)...\"\n        )\n\n        # Get all upcoming fixtures and sort them by gameweek\n        all_upcoming_fixtures_items = sorted(\n            [\n                (fid, fdict)\n                for fid, fdict in self.fixtures_data.items()\n                if not fdict[\"finished\"]\n            ],\n            key=lambda item: item[1][\"event\"],\n        )\n\n        if not all_upcoming_fixtures_items:\n            print(\"No upcoming fixtures found. Cannot calculate xP.\")\n            return\n\n        # Determine the current gameweek (the gameweek of the earliest upcoming fixture)\n        current_gameweek = all_upcoming_fixtures_items[0][1][\"event\"]\n        target_gameweeks = range(\n            current_gameweek, current_gameweek + self.gameweeks_to_predict\n        )\n\n        # Create a mapping of team_id_code to a list of their fixtures within the target gameweeks\n        team_fixtures_in_range = {team_code: [] for team_code in self.teams_data.keys()}\n        for fixture_id, fixture_data in all_upcoming_fixtures_items:\n            if fixture_data[\"event\"] in target_gameweeks:\n                home_team_code = fixture_data[\"team_h\"]\n                away_team_code = fixture_data[\"team_a\"]\n\n                team_fixtures_in_range[home_team_code].append(fixture_id)\n                team_fixtures_in_range[away_team_code].append(fixture_id)\n\n        # Calculate total xP for each player across the specified gameweeks\n        for player_id, player_data in self.players_data.items():\n            player_team_code = player_data[\"team_id\"]\n            player_position = player_data[\"position\"]\n\n            # Calculate xP for each relevant fixture and store by gameweek\n            expected_points_by_gw = {}\n            for fixture_id in team_fixtures_in_range.get(player_team_code, []):\n                fixture_gameweek = self.fixtures_data[fixture_id][\"event\"]\n                xp_result_single_gw = self.calculate_xp_for_player(\n                    player_id, fixture_id\n                )\n                if xp_result_single_gw and xp_result_single_gw[\"xp\"] is not None:\n                    if fixture_gameweek not in expected_points_by_gw:\n                        expected_points_by_gw[fixture_gameweek] = 0.0\n                    expected_points_by_gw[fixture_gameweek] += xp_result_single_gw[\"xp\"]\n\n            # Ensure all target gameweeks are present, even if xP is 0 for a given GW\n            for gw in target_gameweeks:\n                if gw not in expected_points_by_gw:\n                    expected_points_by_gw[gw] = 0.0\n\n            # Sort the dictionary by gameweek for consistent output\n            expected_points_by_gw = dict(sorted(expected_points_by_gw.items()))\n\n            # Prepare data for the optimizer\n            player_cost_m = player_data[\"cost_pence\"] / 10.0\n            team_name_full = self.teams_data.get(player_team_code, {}).get(\n                \"name\", \"Unknown Team\"\n            )\n\n            self.all_players_xp_calculated_data.append(\n                {\n                    \"name\": player_data[\"name\"],\n                    \"web_name\": player_data[\"web_name\"],\n                    \"team\": team_name_full,\n                    \"position\": player_position,\n                    \"cost\": player_cost_m,\n                    \"expected_points_by_gw\": expected_points_by_gw,  # Changed key and format\n                }\n            )\n        print(\"xP calculation for all players complete.\")\n\n    def get_upcoming_fixtures(self, limit=None):\n        \"\"\"\n        Returns a list of upcoming fixtures, sorted by gameweek and kickoff time.\n        Optionally limits the number of fixtures returned.\n        \"\"\"\n        upcoming = []\n        now = datetime.now()\n\n        # Sort all fixtures by gameweek and then by kickoff time\n        sorted_fixtures = sorted(\n            self.fixtures_data.values(),\n            key=lambda x: (\n                x.get(\"event\", 0),\n                x.get(\"kickoff_time\", \"9999-12-31T00:00:00Z\"),\n            ),\n        )\n\n        current_gameweek = None\n        for fixture_data in sorted_fixtures:\n            # Determine current gameweek from the earliest upcoming fixture\n            if not fixture_data[\"finished\"] and current_gameweek is None:\n                current_gameweek = fixture_data.get(\"event\", 0)\n\n            # Filter for upcoming fixtures within the prediction horizon\n            if (\n                fixture_data.get(\"event\", 0) &lt; current_gameweek  # Skip past gameweeks\n                or fixture_data.get(\"event\", 0)\n                &gt;= current_gameweek + self.gameweeks_to_predict\n            ):\n                continue  # Skip fixtures outside the prediction horizon\n\n            home_team_name = self.teams_data.get(\n                fixture_data[\"team_h\"], {}\n            ).get(  # Use 'team_h'\n                \"name\", \"Unknown\"\n            )\n            away_team_name = self.teams_data.get(\n                fixture_data[\"team_a\"], {}\n            ).get(  # Use 'team_a'\n                \"name\", \"Unknown\"\n            )\n\n            # Only add fixtures that are not finished\n            if not fixture_data[\"finished\"]:\n                upcoming.append(\n                    {\n                        \"fixture_id\": fixture_data[\"id\"],\n                        \"gameweek\": fixture_data.get(\"event\"),\n                        \"home_team_id\": fixture_data[\"team_h\"],  # Use 'team_h'\n                        \"away_team_id\": fixture_data[\"team_a\"],  # Use 'team_a'\n                        \"match\": f\"{home_team_name} vs {away_team_name}\",\n                        \"kickoff_time\": fixture_data.get(\"kickoff_time\"),\n                        \"home_team_difficulty\": fixture_data[\"team_h_difficulty\"],\n                        \"away_team_difficulty\": fixture_data[\"team_a_difficulty\"],\n                    }\n                )\n            if limit is not None and len(upcoming) &gt;= limit:\n                break\n        return upcoming\n\n    def get_players_for_optimizer(self):\n        \"\"\"\n        Returns the list of player data with calculated xP per gameweek,\n        formatted for the FPLOptimizer.\n        \"\"\"\n        return self.all_players_xp_calculated_data\n\n    def clear_cache(self):\n        \"\"\"\n        Clear all cached API responses. Use this when you want to force fresh data\n        from the FPL API.\n        \"\"\"\n        self.cache_manager.clear_cache()\n        self.logger.info(\"Cleared API response cache\")\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/#build.lib.build.lib.fpl_solver.xp_predictor.FPLPredictor.__init__","title":"<code>__init__(gameweeks_to_predict=1)</code>","text":"<p>Initialize the FPLPredictor with data structures and fetch initial data.</p> <p>Parameters:</p> Name Type Description Default <code>gameweeks_to_predict</code> <code>int</code> <p>Number of upcoming gameweeks to calculate                 expected points for. Default is 1 (next gameweek).</p> <code>1</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If gameweeks_to_predict is not a positive integer</p> Source code in <code>build/lib/build/lib/fpl_solver/xp_predictor.py</code> <pre><code>def __init__(self, gameweeks_to_predict: int = 1):\n    \"\"\"\n    Initialize the FPLPredictor with data structures and fetch initial data.\n\n    Args:\n        gameweeks_to_predict: Number of upcoming gameweeks to calculate\n                            expected points for. Default is 1 (next gameweek).\n\n    Raises:\n        ValueError: If gameweeks_to_predict is not a positive integer\n    \"\"\"\n    self.logger = setup_logger(__name__)\n    if not isinstance(gameweeks_to_predict, int) or gameweeks_to_predict &lt; 1:\n        msg = f\"gameweeks_to_predict must be a positive integer, got {gameweeks_to_predict}\"\n        self.logger.error(msg)\n        raise ValueError(msg)\n\n    self.gameweeks_to_predict = gameweeks_to_predict\n    self.logger.info(f\"Initializing FPL Predictor for {gameweeks_to_predict} gameweek(s)\")\n\n    # Initialize cache manager\n    cache_dir = os.path.join(os.path.dirname(__file__), 'cache')\n    self.cache_manager = CacheManager(cache_dir)\n\n    # Configuration and static data\n    self.fpl_points: Dict[str, float] = FPL_POINTS\n    self.position_definitions: Dict[int, str] = {\n        1: \"GK\",\n        2: \"DEF\",\n        3: \"MID\",\n        4: \"FWD\",\n    }\n\n    # Data structures for FPL information\n    self.players_data: Dict[int, Dict] = {}\n    self.teams_data: Dict[int, Dict] = {}\n    self.fixtures_data: Dict[int, Dict] = {}\n    self.all_players_xp_calculated_data: List[Dict] = []\n\n    # Initialize data\n    try:\n        self._fetch_fpl_data()\n        self._calculate_all_players_xp()\n    except Exception as e:\n        self.logger.error(f\"Failed to initialize FPL Predictor: {str(e)}\")\n        raise\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/#build.lib.build.lib.fpl_solver.xp_predictor.FPLPredictor.calculate_xp_for_player","title":"<code>calculate_xp_for_player(player_id, fixture_id)</code>","text":"<p>Calculates Expected Points (xP) for a single player in a given fixture. Considers various factors: minutes, goals, assists, clean sheets, saves, bonus points, and negative events, adjusted for fixture difficulty.</p> Source code in <code>build/lib/build/lib/fpl_solver/xp_predictor.py</code> <pre><code>def calculate_xp_for_player(self, player_id, fixture_id):\n    \"\"\"\n    Calculates Expected Points (xP) for a single player in a given fixture.\n    Considers various factors: minutes, goals, assists, clean sheets, saves,\n    bonus points, and negative events, adjusted for fixture difficulty.\n    \"\"\"\n    player = self.players_data.get(player_id)\n    fixture = self.fixtures_data.get(fixture_id)\n\n    if not player or not fixture:\n        return {\"xp\": 0.0, \"reason\": \"Player or fixture data missing.\"}\n\n    # Handle unavailable players\n    if (\n        player[\"status\"] != \"a\"\n    ):  # 'd' for doubtful, 'i' for injured, 's' for suspended\n        return {\"xp\": 0.0, \"reason\": f\"Player status: {player['status']}\"}\n    if any(\n        x in player[\"news\"].lower()\n        for x in [\"injured\", \"doubtful\", \"suspension\", \"red card\"]\n    ):\n        return {\"xp\": 0.0, \"reason\": f\"Player news: {player['news']}\"}\n\n    # Predict minutes\n    expected_minutes = self._predict_minutes(player_id)\n    if expected_minutes &lt; 1.0:  # If expected to play very little or none\n        return {\"xp\": 0.0, \"reason\": \"Expected minutes too low.\"}\n\n    xp = 0.0\n    position = player[\"position\"]\n    # Use 'team_h' for home team ID\n    is_home_fixture = player[\"team_id\"] == fixture[\"team_h\"]\n\n    # Determine attacking and defensive strengths for the fixture\n    player_team_strength_attack = (\n        self.teams_data.get(fixture[\"team_h\"], {}).get(\n            \"strength_attack_home\"\n        )  # Use 'team_h'\n        if is_home_fixture\n        else self.teams_data.get(fixture[\"team_a\"], {}).get(\n            \"strength_attack_away\"\n        )  # Use 'team_a'\n    )\n    player_team_strength_defence = (\n        self.teams_data.get(fixture[\"team_h\"], {}).get(\n            \"strength_defence_home\"\n        )  # Use 'team_h'\n        if is_home_fixture\n        else self.teams_data.get(fixture[\"team_a\"], {}).get(\n            \"strength_defence_away\"\n        )  # Use 'team_a'\n    )\n    opponent_team_strength_attack = (\n        self.teams_data.get(fixture[\"team_a\"], {}).get(\n            \"strength_attack_away\"\n        )  # Use 'team_a'\n        if is_home_fixture\n        else self.teams_data.get(fixture[\"team_h\"], {}).get(\n            \"strength_attack_home\"\n        )  # Use 'team_h'\n    )\n    opponent_team_strength_defence = (\n        self.teams_data.get(fixture[\"team_a\"], {}).get(\n            \"strength_defence_away\"\n        )  # Use 'team_a'\n        if is_home_fixture\n        else self.teams_data.get(fixture[\"team_h\"], {}).get(\n            \"strength_defence_home\"\n        )  # Use 'team_h'\n    )\n\n    if None in [\n        player_team_strength_attack,\n        player_team_strength_defence,\n        opponent_team_strength_attack,\n        opponent_team_strength_defence,\n    ]:\n        # Fallback if strength data is missing (shouldn't happen with robust data fetch)\n        return {\"xp\": 0.0, \"reason\": \"Team strength data missing for fixture.\"}\n\n    # Apply confidence factor based on historical minutes\n    minutes_played = player.get(\"minutes\", 0)\n    confidence_factor = XP_CONFIDENCE_FACTORS[\"proven\"]  # Default to proven player\n    if minutes_played &lt; VERY_LOW_MINUTES_THRESHOLD:\n        confidence_factor = XP_CONFIDENCE_FACTORS[\"very_low_minutes\"]\n    elif minutes_played &lt; MIN_MINUTES_THRESHOLD:\n        confidence_factor = XP_CONFIDENCE_FACTORS[\"low_minutes\"]\n\n    # 1. Appearance points\n    if expected_minutes &gt;= 60:\n        xp += self.fpl_points[\"appearance_points_gte_60\"]\n    elif expected_minutes &gt; 0:\n        xp += self.fpl_points[\"appearance_points_lt_60\"]\n\n    # 2. Expected Goals (scaled by historical goals per 90 and opponent difficulty)\n    # Use player's form and total goals as a basis\n    goals_per_90_hist = (\n        (player[\"goals_scored\"] / player[\"minutes\"] * 90)\n        if player[\"minutes\"] &gt; 0\n        else 0.0\n    )\n    expected_team_goals = self._calculate_expected_goals(\n        player_team_strength_attack, opponent_team_strength_defence\n    )\n\n    expected_goals_player_contribution = (\n        (goals_per_90_hist / 90.0) * expected_minutes * (expected_team_goals / 1.5)\n    )  # Scale player's goal contribution by team's expected goals\n\n    if position == \"GK\":\n        xp += expected_goals_player_contribution * self.fpl_points[\"goal_gk\"]\n    elif position == \"DEF\":\n        xp += expected_goals_player_contribution * self.fpl_points[\"goal_def\"]\n    elif position == \"MID\":\n        xp += expected_goals_player_contribution * self.fpl_points[\"goal_mid\"]\n    elif position == \"FWD\":\n        xp += expected_goals_player_contribution * self.fpl_points[\"goal_fwd\"]\n\n    # 3. Expected Assists (scaled by historical assists per 90 and opponent difficulty)\n    assists_per_90_hist = (\n        (player[\"assists\"] / player[\"minutes\"] * 90)\n        if player[\"minutes\"] &gt; 0\n        else 0.0\n    )\n    # Assuming team's attacking strength correlates with assist opportunities\n    expected_assists_player_contribution = (\n        (assists_per_90_hist / 90.0)\n        * expected_minutes\n        * (expected_team_goals / 1.5)\n    )  # Similarly scale by team's expected goals\n    xp += expected_assists_player_contribution * self.fpl_points[\"assist_points\"]\n\n    # 4. Expected Clean Sheets (for GKs/DEFs/MIDs) and Conceded Goals deduction\n    expected_conceded = self._calculate_expected_conceded_goals(\n        player_team_strength_defence, opponent_team_strength_attack\n    )\n\n    # Probability of clean sheet\n    # Simplified: higher team defense / lower opponent attack -&gt; higher CS prob\n    # Use logistic or sigmoid for probability\n    cs_prob = 1.0 / (\n        1.0 + math.exp(expected_conceded - 1.0)\n    )  # Sigmoid centered at 1 goal\n\n    if position in [\"GK\", \"DEF\"]:\n        xp += cs_prob * self.fpl_points[\"clean_sheet_gk_def\"]\n\n        # Conceded goals deduction: Apply penalty for every 2 goals conceded *probability*\n        # For simplicity, calculate expected deduction: (expected_conceded / 2) * deduction\n        xp += (expected_conceded / 2.0) * self.fpl_points[\n            \"conceded_2_goals_deduction\"\n        ]\n    elif position == \"MID\":\n        xp += cs_prob * self.fpl_points[\"clean_sheet_mid\"]\n\n    # 5. Expected Saves (for GKs)\n    if position == \"GK\":\n        saves_per_90_hist = (\n            (player[\"saves\"] / player[\"minutes\"] * 90)\n            if player[\"minutes\"] &gt; 0\n            else 0.0\n        )\n        # Expected saves scaled by opponent's attacking strength (more attacking -&gt; more shots -&gt; more saves)\n        expected_saves_player_contribution = (\n            (saves_per_90_hist / 90.0)\n            * expected_minutes\n            * (opponent_team_strength_attack / player_team_strength_defence)\n        )\n        xp += (expected_saves_player_contribution / 3.0) * self.fpl_points[\n            \"saves_3_points\"\n        ]  # Using the new config point value\n\n        # Penalty saves (low probability, use historical rate)\n        penalty_saves_hist_per_game = (\n            player[\"penalties_saved\"] / (player[\"minutes\"] / 90.0)\n            if player[\"minutes\"] &gt; 0\n            else 0.0\n        )\n        xp += (\n            penalty_saves_hist_per_game\n            * (expected_minutes / 90.0)\n            * self.fpl_points[\"penalty_save_points\"]\n        )\n\n    # 6. Expected Bonus Points\n    # Use BPS (Bonus Points System) as a proxy. Scale player's average BPS by form and expected minutes.\n    bps_per_90_hist = (\n        (player[\"bps\"] / player[\"minutes\"] * 90) if player[\"minutes\"] &gt; 0 else 0.0\n    )\n    expected_bps = (bps_per_90_hist / 90.0) * expected_minutes * player[\"form\"]\n    xp += expected_bps * self.fpl_points[\"bonus_points_scaling_factor\"]\n\n    # 7. Minor Negative Events (Probabilistic)\n    # These are rare, so a simple probability based on expected minutes.\n    xp += (expected_minutes / 90.0) * (\n        self.fpl_points[\"yellow_card_deduction\"] * YELLOW_CARD_PROB\n        + self.fpl_points[\"red_card_deduction\"] * RED_CARD_PROB\n        + self.fpl_points[\"own_goal_deduction\"] * OWN_GOAL_PROB\n        + self.fpl_points[\"penalty_miss_deduction\"] * PENALTY_MISS_PROB\n    )\n\n    # 8. Defensive Contribution Points (for 2025/26 season)\n    # Use actual defensive_contribution data from API\n    defensive_contribution_per_90 = (\n        (player[\"defensive_contribution\"] / player[\"minutes\"] * 90)\n        if player[\"minutes\"] &gt; 0\n        else 0.0\n    )\n    expected_defensive_contribution = (defensive_contribution_per_90 / 90.0) * expected_minutes\n\n    # Award defensive contribution points based on position thresholds\n    if position in [\"DEF\", \"MID\", \"FWD\"]:  # Goalkeepers do not earn defensive contribution points\n        xp += expected_defensive_contribution * self.fpl_points[\"defensive_contribution_points\"]\n\n    # Apply confidence factor to final xP\n    xp = xp * confidence_factor\n\n    return {\"xp\": round(xp, 2), \"reason\": \"Success\", \"confidence\": confidence_factor}\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/#build.lib.build.lib.fpl_solver.xp_predictor.FPLPredictor.clear_cache","title":"<code>clear_cache()</code>","text":"<p>Clear all cached API responses. Use this when you want to force fresh data from the FPL API.</p> Source code in <code>build/lib/build/lib/fpl_solver/xp_predictor.py</code> <pre><code>def clear_cache(self):\n    \"\"\"\n    Clear all cached API responses. Use this when you want to force fresh data\n    from the FPL API.\n    \"\"\"\n    self.cache_manager.clear_cache()\n    self.logger.info(\"Cleared API response cache\")\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/#build.lib.build.lib.fpl_solver.xp_predictor.FPLPredictor.get_players_for_optimizer","title":"<code>get_players_for_optimizer()</code>","text":"<p>Returns the list of player data with calculated xP per gameweek, formatted for the FPLOptimizer.</p> Source code in <code>build/lib/build/lib/fpl_solver/xp_predictor.py</code> <pre><code>def get_players_for_optimizer(self):\n    \"\"\"\n    Returns the list of player data with calculated xP per gameweek,\n    formatted for the FPLOptimizer.\n    \"\"\"\n    return self.all_players_xp_calculated_data\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/#build.lib.build.lib.fpl_solver.xp_predictor.FPLPredictor.get_upcoming_fixtures","title":"<code>get_upcoming_fixtures(limit=None)</code>","text":"<p>Returns a list of upcoming fixtures, sorted by gameweek and kickoff time. Optionally limits the number of fixtures returned.</p> Source code in <code>build/lib/build/lib/fpl_solver/xp_predictor.py</code> <pre><code>def get_upcoming_fixtures(self, limit=None):\n    \"\"\"\n    Returns a list of upcoming fixtures, sorted by gameweek and kickoff time.\n    Optionally limits the number of fixtures returned.\n    \"\"\"\n    upcoming = []\n    now = datetime.now()\n\n    # Sort all fixtures by gameweek and then by kickoff time\n    sorted_fixtures = sorted(\n        self.fixtures_data.values(),\n        key=lambda x: (\n            x.get(\"event\", 0),\n            x.get(\"kickoff_time\", \"9999-12-31T00:00:00Z\"),\n        ),\n    )\n\n    current_gameweek = None\n    for fixture_data in sorted_fixtures:\n        # Determine current gameweek from the earliest upcoming fixture\n        if not fixture_data[\"finished\"] and current_gameweek is None:\n            current_gameweek = fixture_data.get(\"event\", 0)\n\n        # Filter for upcoming fixtures within the prediction horizon\n        if (\n            fixture_data.get(\"event\", 0) &lt; current_gameweek  # Skip past gameweeks\n            or fixture_data.get(\"event\", 0)\n            &gt;= current_gameweek + self.gameweeks_to_predict\n        ):\n            continue  # Skip fixtures outside the prediction horizon\n\n        home_team_name = self.teams_data.get(\n            fixture_data[\"team_h\"], {}\n        ).get(  # Use 'team_h'\n            \"name\", \"Unknown\"\n        )\n        away_team_name = self.teams_data.get(\n            fixture_data[\"team_a\"], {}\n        ).get(  # Use 'team_a'\n            \"name\", \"Unknown\"\n        )\n\n        # Only add fixtures that are not finished\n        if not fixture_data[\"finished\"]:\n            upcoming.append(\n                {\n                    \"fixture_id\": fixture_data[\"id\"],\n                    \"gameweek\": fixture_data.get(\"event\"),\n                    \"home_team_id\": fixture_data[\"team_h\"],  # Use 'team_h'\n                    \"away_team_id\": fixture_data[\"team_a\"],  # Use 'team_a'\n                    \"match\": f\"{home_team_name} vs {away_team_name}\",\n                    \"kickoff_time\": fixture_data.get(\"kickoff_time\"),\n                    \"home_team_difficulty\": fixture_data[\"team_h_difficulty\"],\n                    \"away_team_difficulty\": fixture_data[\"team_a_difficulty\"],\n                }\n            )\n        if limit is not None and len(upcoming) &gt;= limit:\n            break\n    return upcoming\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/cache_manager/","title":"cache_manager","text":"<p>Cache manager for FPL API responses.</p> <p>This module provides functionality to cache API responses locally and manage their expiry.</p>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/cache_manager/#build.lib.build.lib.fpl_solver.cache_manager.CacheManager","title":"<code>CacheManager</code>","text":"Source code in <code>build/lib/build/lib/fpl_solver/cache_manager.py</code> <pre><code>class CacheManager:\n    def __init__(self, cache_dir: str, cache_expiry_hours: int = 3):\n        \"\"\"\n        Initialize the cache manager.\n\n        Args:\n            cache_dir: Directory to store cache files\n            cache_expiry_hours: Number of hours after which cache should be considered stale\n        \"\"\"\n        self.cache_dir = cache_dir\n        self.cache_expiry = timedelta(hours=cache_expiry_hours)\n\n        # Create cache directory if it doesn't exist\n        if not os.path.exists(cache_dir):\n            os.makedirs(cache_dir)\n\n    def _get_cache_path(self, endpoint: str) -&gt; str:\n        \"\"\"Get the full path for a cache file.\"\"\"\n        return os.path.join(self.cache_dir, f\"{endpoint}.json\")\n\n    def get_cached_response(self, endpoint: str) -&gt; Optional[Dict[str, Any]]:\n        \"\"\"\n        Retrieve cached response if it exists and is not expired.\n\n        Args:\n            endpoint: API endpoint identifier (e.g., 'static' or 'fixtures')\n\n        Returns:\n            Cached data if valid, None otherwise\n        \"\"\"\n        cache_path = self._get_cache_path(endpoint)\n\n        if not os.path.exists(cache_path):\n            return None\n\n        try:\n            with open(cache_path, 'r') as f:\n                cached_data = json.load(f)\n\n            # Check if cache has expired\n            cached_time = datetime.fromtimestamp(cached_data['cached_at'])\n            if datetime.now() - cached_time &gt; self.cache_expiry:\n                return None\n\n            return cached_data['data']\n\n        except (json.JSONDecodeError, KeyError, ValueError) as e:\n            # If there's any issue with the cache file, ignore it\n            return None\n\n    def save_response(self, endpoint: str, data: Dict[str, Any]) -&gt; None:\n        \"\"\"\n        Save API response to cache.\n\n        Args:\n            endpoint: API endpoint identifier\n            data: Response data to cache\n        \"\"\"\n        cache_path = self._get_cache_path(endpoint)\n\n        cache_data = {\n            'cached_at': time.time(),\n            'data': data\n        }\n\n        with open(cache_path, 'w') as f:\n            json.dump(cache_data, f)\n\n    def clear_cache(self) -&gt; None:\n        \"\"\"Clear all cached data.\"\"\"\n        for filename in os.listdir(self.cache_dir):\n            if filename.endswith('.json'):\n                os.remove(os.path.join(self.cache_dir, filename))\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/cache_manager/#build.lib.build.lib.fpl_solver.cache_manager.CacheManager.__init__","title":"<code>__init__(cache_dir, cache_expiry_hours=3)</code>","text":"<p>Initialize the cache manager.</p> <p>Parameters:</p> Name Type Description Default <code>cache_dir</code> <code>str</code> <p>Directory to store cache files</p> required <code>cache_expiry_hours</code> <code>int</code> <p>Number of hours after which cache should be considered stale</p> <code>3</code> Source code in <code>build/lib/build/lib/fpl_solver/cache_manager.py</code> <pre><code>def __init__(self, cache_dir: str, cache_expiry_hours: int = 3):\n    \"\"\"\n    Initialize the cache manager.\n\n    Args:\n        cache_dir: Directory to store cache files\n        cache_expiry_hours: Number of hours after which cache should be considered stale\n    \"\"\"\n    self.cache_dir = cache_dir\n    self.cache_expiry = timedelta(hours=cache_expiry_hours)\n\n    # Create cache directory if it doesn't exist\n    if not os.path.exists(cache_dir):\n        os.makedirs(cache_dir)\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/cache_manager/#build.lib.build.lib.fpl_solver.cache_manager.CacheManager.clear_cache","title":"<code>clear_cache()</code>","text":"<p>Clear all cached data.</p> Source code in <code>build/lib/build/lib/fpl_solver/cache_manager.py</code> <pre><code>def clear_cache(self) -&gt; None:\n    \"\"\"Clear all cached data.\"\"\"\n    for filename in os.listdir(self.cache_dir):\n        if filename.endswith('.json'):\n            os.remove(os.path.join(self.cache_dir, filename))\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/cache_manager/#build.lib.build.lib.fpl_solver.cache_manager.CacheManager.get_cached_response","title":"<code>get_cached_response(endpoint)</code>","text":"<p>Retrieve cached response if it exists and is not expired.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>API endpoint identifier (e.g., 'static' or 'fixtures')</p> required <p>Returns:</p> Type Description <code>Optional[Dict[str, Any]]</code> <p>Cached data if valid, None otherwise</p> Source code in <code>build/lib/build/lib/fpl_solver/cache_manager.py</code> <pre><code>def get_cached_response(self, endpoint: str) -&gt; Optional[Dict[str, Any]]:\n    \"\"\"\n    Retrieve cached response if it exists and is not expired.\n\n    Args:\n        endpoint: API endpoint identifier (e.g., 'static' or 'fixtures')\n\n    Returns:\n        Cached data if valid, None otherwise\n    \"\"\"\n    cache_path = self._get_cache_path(endpoint)\n\n    if not os.path.exists(cache_path):\n        return None\n\n    try:\n        with open(cache_path, 'r') as f:\n            cached_data = json.load(f)\n\n        # Check if cache has expired\n        cached_time = datetime.fromtimestamp(cached_data['cached_at'])\n        if datetime.now() - cached_time &gt; self.cache_expiry:\n            return None\n\n        return cached_data['data']\n\n    except (json.JSONDecodeError, KeyError, ValueError) as e:\n        # If there's any issue with the cache file, ignore it\n        return None\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/cache_manager/#build.lib.build.lib.fpl_solver.cache_manager.CacheManager.save_response","title":"<code>save_response(endpoint, data)</code>","text":"<p>Save API response to cache.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>API endpoint identifier</p> required <code>data</code> <code>Dict[str, Any]</code> <p>Response data to cache</p> required Source code in <code>build/lib/build/lib/fpl_solver/cache_manager.py</code> <pre><code>def save_response(self, endpoint: str, data: Dict[str, Any]) -&gt; None:\n    \"\"\"\n    Save API response to cache.\n\n    Args:\n        endpoint: API endpoint identifier\n        data: Response data to cache\n    \"\"\"\n    cache_path = self._get_cache_path(endpoint)\n\n    cache_data = {\n        'cached_at': time.time(),\n        'data': data\n    }\n\n    with open(cache_path, 'w') as f:\n        json.dump(cache_data, f)\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/config/","title":"config","text":"<p>fpl_config.py</p> <p>Configuration settings for the FPL Expected Points Predictor and Solver. This file centralizes all constants related to FPL scoring, thresholds, and optimization parameters.</p>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/logger/","title":"logger","text":"<p>Logging configuration for the FPL Solver package.</p>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/logger/#build.lib.build.lib.fpl_solver.logger.setup_logger","title":"<code>setup_logger(name, level=None)</code>","text":"<p>Set up a logger with consistent formatting and optional level override.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the logger</p> required <code>level</code> <code>Optional[int]</code> <p>Optional logging level override. If None, uses INFO</p> <code>None</code> <p>Returns:</p> Type Description <code>Logger</code> <p>logging.Logger: Configured logger instance</p> Source code in <code>build/lib/build/lib/fpl_solver/logger.py</code> <pre><code>def setup_logger(name: str, level: Optional[int] = None) -&gt; logging.Logger:\n    \"\"\"\n    Set up a logger with consistent formatting and optional level override.\n\n    Args:\n        name: The name of the logger\n        level: Optional logging level override. If None, uses INFO\n\n    Returns:\n        logging.Logger: Configured logger instance\n    \"\"\"\n    logger = logging.getLogger(name)\n\n    if not logger.handlers:  # Only add handler if logger doesn't have one\n        handler = logging.StreamHandler(sys.stdout)\n        formatter = logging.Formatter(\n            '%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n            datefmt='%Y-%m-%d %H:%M:%S'\n        )\n        handler.setFormatter(formatter)\n        logger.addHandler(handler)\n\n    logger.setLevel(level or logging.INFO)\n    return logger\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/solver/","title":"solver","text":"<p>FPL Squad Optimizer using PuLP for Integer Linear Programming (ILP).</p> <p>This module provides optimization functionality to select the best possible FPL squad over multiple gameweeks, considering transfer constraints and chips.</p>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/solver/#build.lib.build.lib.fpl_solver.solver.FPLOptimizer","title":"<code>FPLOptimizer</code>","text":"<p>A class to optimize Fantasy Premier League (FPL) squad selection using Integer Linear Programming (ILP).</p> <p>The optimizer aims to select a 15-player squad (2 GKs, 5 DEFs, 5 MIDs, 3 FWDs) within a budget, with a maximum number of players from any single team, to maximize the total expected points.</p> Source code in <code>build/lib/build/lib/fpl_solver/solver.py</code> <pre><code>class FPLOptimizer:\n    \"\"\"\n    A class to optimize Fantasy Premier League (FPL) squad selection\n    using Integer Linear Programming (ILP).\n\n    The optimizer aims to select a 15-player squad (2 GKs, 5 DEFs, 5 MIDs, 3 FWDs)\n    within a budget, with a maximum number of players from any single team,\n    to maximize the total expected points.\n    \"\"\"\n\n    def __init__(self, player_data: pd.DataFrame):\n        \"\"\"\n        Initializes the FPLOptimizer with player data.\n\n        Args:\n            player_data (pd.DataFrame): A DataFrame containing player information\n                                        with columns: 'name', 'team', 'position',\n                                        'cost', 'expected_points_by_gw' (a dict of xP per GW).\n        \"\"\"\n        required_columns = [\"name\", \"team\", \"position\", \"cost\", \"expected_points_by_gw\"]\n        if not all(col in player_data.columns for col in required_columns):\n            missing_cols = [\n                col for col in required_columns if col not in player_data.columns\n            ]\n            raise ValueError(\n                f\"player_data DataFrame must contain {required_columns} columns. Missing: {missing_cols}\"\n            )\n\n        self.player_data = player_data\n        self.problem = None\n        self.selected_squad_history = {}  # To store squad for each gameweek\n        self.total_cost = 0\n        self.total_expected_points = 0\n        self.total_transfer_hits = 0\n\n        # --- Process Enforced Players ---\n        self.enforced_player_indices = set()\n        self.enforced_team_pos_requirements = []\n\n        print(\"\\n--- Processing Enforced Players ---\")\n\n        # Enforce by Player ID\n        for player_id in ENFORCED_PLAYERS_BY_ID:\n            found_player = self.player_data[self.player_data[\"id\"] == player_id]\n            if not found_player.empty:\n                player_idx = found_player.index[0]\n                self.enforced_player_indices.add(player_idx)\n                print(\n                    f\"Enforcing player by ID: {found_player.loc[player_idx, 'name']} (ID: {player_id})\"\n                )\n            else:\n                print(\n                    f\"Warning: Enforced player with ID {player_id} not found in data.\"\n                )\n\n        # Enforce by Player Name\n        for player_name in ENFORCED_PLAYERS_BY_NAME:\n            found_player = self.player_data[self.player_data[\"name\"] == player_name]\n            if not found_player.empty:\n                player_idx = found_player.index[0]\n                self.enforced_player_indices.add(player_idx)\n                print(f\"Enforcing player by name: {player_name}\")\n            else:\n                print(f\"Warning: Enforced player '{player_name}' not found in data.\")\n\n        # Enforce by Team and Position\n        for requirement in ENFORCED_PLAYERS_BY_TEAM_AND_POSITION:\n            team = requirement.get(\"team\")\n            position = requirement.get(\"position\")\n            if team and position:\n                # Validate team and position exist in data\n                if team not in self.player_data[\"team\"].unique():\n                    print(\n                        f\"Warning: Enforced team '{team}' for position '{position}' not found in data.\"\n                    )\n                    continue\n                if position not in self.player_data[\"position\"].unique():\n                    print(\n                        f\"Warning: Enforced position '{position}' for team '{team}' not found in data.\"\n                    )\n                    continue\n\n                self.enforced_team_pos_requirements.append((team, position))\n                print(f\"Enforcing at least one {position} from {team}.\")\n            else:\n                print(\n                    f\"Warning: Invalid enforced team/position requirement: {requirement}\"\n                )\n\n        if not (\n            self.enforced_player_indices\n            or self.enforced_team_pos_requirements\n            or ENFORCED_PLAYERS_BY_ID\n            or ENFORCED_PLAYERS_BY_NAME\n            or ENFORCED_PLAYERS_BY_TEAM_AND_POSITION\n        ):\n            print(\"No players or team/position combinations are enforced.\")\n        print(\"-----------------------------------\\n\")\n\n    def solve(\n        self,\n        budget: float,\n        max_players_per_team: int,\n        chip_allowances: dict,\n        num_gameweeks: int,\n    ) -&gt; bool:\n        \"\"\"\n        Solves the FPL optimization problem using PuLP.\n\n        Args:\n            budget (float): The maximum budget in millions of pounds.\n            max_players_per_team (int): The maximum number of players allowed from\n                                        any single Premier League team.\n            chip_allowances (dict): A dictionary specifying the maximum usage for each chip.\n            num_gameweeks (int): The number of gameweeks to optimize over.\n\n        Returns:\n            bool: True if a solution was found, False otherwise.\n        \"\"\"\n        self.problem = LpProblem(\"FPL Squad Multi-Week Optimization\", LpMaximize)\n\n        # Decision variables for player selection, indexed by player and gameweek\n        player_vars = LpVariable.dicts(\n            \"Player\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n        )\n        starting_xi_vars = LpVariable.dicts(\n            \"StartingXI\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n        )\n        captain_var = LpVariable.dicts(\n            \"Captain\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n        )\n\n        # Binary variables for chip usage, indexed by gameweek\n        use_bench_boost = LpVariable.dicts(\n            \"Use_Bench_Boost\", range(num_gameweeks), 0, 1, LpBinary\n        )\n        use_triple_captain = LpVariable.dicts(\n            \"Use_Triple_Captain\", range(num_gameweeks), 0, 1, LpBinary\n        )\n\n        # Transfer variables\n        transfer_in_vars = LpVariable.dicts(\n            \"Transfer_In\",\n            (self.player_data.index, range(1, num_gameweeks)),\n            0,\n            1,\n            LpBinary,\n        )\n        transfer_out_vars = LpVariable.dicts(\n            \"Transfer_Out\",\n            (self.player_data.index, range(1, num_gameweeks)),\n            0,\n            1,\n            LpBinary,\n        )\n\n        # Total transfers made in a gameweek (absolute count)\n        transfers_made = LpVariable.dicts(\n            \"Transfers_Made\", range(1, num_gameweeks), 0, None, LpInteger\n        )\n        # Free transfers available at the start of a gameweek\n        free_transfers_available = LpVariable.dicts(\n            \"Free_Transfers_Available\",\n            range(num_gameweeks),\n            0,\n            MAX_FREE_TRANSFERS_SAVED + 1,\n            LpInteger,\n        )\n        # Number of transfer hits taken in a gameweek\n        transfer_hits = LpVariable.dicts(\n            \"Transfer_Hits\", range(1, num_gameweeks), 0, None, LpInteger\n        )\n\n        # Auxiliary variables for linearizing chip effects\n        is_bench_player = LpVariable.dicts(\n            \"Is_Bench_Player\",\n            (self.player_data.index, range(num_gameweeks)),\n            0,\n            1,\n            LpBinary,\n        )\n        actual_bench_boost_points = LpVariable.dicts(\n            \"Actual_Bench_Boost_Points\",\n            (self.player_data.index, range(num_gameweeks)),\n            0,\n            None,\n            LpContinuous,\n        )\n        actual_triple_captain_bonus = LpVariable.dicts(\n            \"Actual_Triple_Captain_Bonus\",\n            (self.player_data.index, range(num_gameweeks)),\n            0,\n            None,\n            LpContinuous,\n        )\n\n        # --- Objective Function ---\n        total_objective_points = []\n\n        # Get the first gameweek number from the player data to correctly index expected_points_by_gw\n        first_gw_key = next(\n            iter(\n                self.player_data.loc[\n                    self.player_data.index[0], \"expected_points_by_gw\"\n                ].keys()\n            )\n        )\n        current_gameweek_number_start = int(first_gw_key)\n\n        for w in range(num_gameweeks):\n            # The actual gameweek number (1-indexed)\n            gw_actual = current_gameweek_number_start + w\n\n            # Base expected points from the selected starting 11 for this gameweek\n            base_points_expression_gw = lpSum(\n                self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n                * starting_xi_vars[i][w]\n                for i in self.player_data.index\n            )\n            total_objective_points.append(base_points_expression_gw)\n\n            # Regular Captaincy points (additional 1x for captain)\n            captain_points_bonus_gw = lpSum(\n                self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n                * captain_var[i][w]\n                for i in self.player_data.index\n            )\n            total_objective_points.append(captain_points_bonus_gw)\n\n            # Define auxiliary variables and constraints for chips for each gameweek\n            for i in self.player_data.index:\n                # Use gameweek-specific player xP for chip calculations\n                player_xp = self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n\n                # Bench Boost auxiliary variables and constraints\n                self.problem += (\n                    is_bench_player[i][w] &lt;= player_vars[i][w],\n                    f\"IsBench_Squad_{i}_{w}\",\n                )\n                self.problem += (\n                    is_bench_player[i][w] &lt;= 1 - starting_xi_vars[i][w],\n                    f\"IsBench_NotStarter_{i}_{w}\",\n                )\n                self.problem += (\n                    is_bench_player[i][w]\n                    &gt;= player_vars[i][w] + (1 - starting_xi_vars[i][w]) - 1,\n                    f\"IsBench_Logical_{i}_{w}\",\n                )\n\n                self.problem += (\n                    actual_bench_boost_points[i][w]\n                    &lt;= player_xp * is_bench_player[i][w],\n                    f\"BenchBoost_Contr_1_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_bench_boost_points[i][w] &lt;= player_xp * use_bench_boost[w],\n                    f\"BenchBoost_Contr_2_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_bench_boost_points[i][w]\n                    &gt;= player_xp * (is_bench_player[i][w] + use_bench_boost[w] - 1),\n                    f\"BenchBoost_Contr_3_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_bench_boost_points[i][w] &gt;= 0,\n                    f\"BenchBoost_Contr_4_{i}_{w}\",\n                )\n\n                # Triple Captain auxiliary variables and constraints\n                # Changed player_xp * 2 to player_xp to reflect additional 1x bonus\n                self.problem += (\n                    actual_triple_captain_bonus[i][w] &lt;= player_xp * captain_var[i][w],\n                    f\"TripleCaptain_Contr_1_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_triple_captain_bonus[i][w]\n                    &lt;= player_xp * use_triple_captain[w],\n                    f\"TripleCaptain_Contr_2_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_triple_captain_bonus[i][w]\n                    &gt;= player_xp * (captain_var[i][w] + use_triple_captain[w] - 1),\n                    f\"TripleCaptain_Contr_3_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_triple_captain_bonus[i][w] &gt;= 0,\n                    f\"TripleCaptain_Contr_4_{i}_{w}\",\n                )\n\n            # Add points from bench boost and triple captain bonus for this gameweek\n            total_bench_boost_points_gw = lpSum(\n                actual_bench_boost_points[i][w] for i in self.player_data.index\n            )\n            total_triple_captain_bonus_points_gw = lpSum(\n                actual_triple_captain_bonus[i][w] for i in self.player_data.index\n            )\n\n            total_objective_points.append(total_bench_boost_points_gw)\n            total_objective_points.append(total_triple_captain_bonus_points_gw)\n\n        # Subtract transfer hits from the total objective\n        total_objective_points.append(\n            -POINTS_PER_HIT * lpSum(transfer_hits[w] for w in range(1, num_gameweeks))\n        )\n\n        self.problem += (\n            lpSum(total_objective_points),\n            \"Total Expected Points Over Gameweeks\",\n        )\n\n        # --- Constraints ---\n\n        # Apply constraints for each gameweek\n        for w in range(num_gameweeks):\n            # 1. Select exactly 15 players for the squad\n            self.problem += (\n                lpSum(player_vars[i][w] for i in self.player_data.index) == 15,\n                f\"Total_Players_GW{w}\",\n            )\n\n            # 2. Squad position constraints (2 GKs, 5 DEFs, 5 MIDs, 3 FWDs)\n            gks = self.player_data[self.player_data[\"position\"] == \"GK\"].index\n            defs = self.player_data[self.player_data[\"position\"] == \"DEF\"].index\n            mids = self.player_data[self.player_data[\"position\"] == \"MID\"].index\n            fwds = self.player_data[self.player_data[\"position\"] == \"FWD\"].index\n\n            self.problem += (\n                lpSum(player_vars[i][w] for i in gks) == 2,\n                f\"Goalkeepers_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(player_vars[i][w] for i in defs) == 5,\n                f\"Defenders_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(player_vars[i][w] for i in mids) == 5,\n                f\"Midfielders_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(player_vars[i][w] for i in fwds) == 3,\n                f\"Forwards_Count_GW{w}\",\n            )\n\n            # 3. Budget constraint\n            # This applies to the cost of the squad for the current gameweek.\n            self.problem += (\n                lpSum(\n                    self.player_data.loc[i, \"cost\"] * player_vars[i][w]\n                    for i in self.player_data.index\n                )\n                &lt;= budget,\n                f\"Total_Budget_GW{w}\",\n            )\n\n            # 4. Maximum players per team constraint\n            for team in self.player_data[\"team\"].unique():\n                team_players = self.player_data[self.player_data[\"team\"] == team].index\n                self.problem += (\n                    lpSum(player_vars[i][w] for i in team_players)\n                    &lt;= max_players_per_team,\n                    f\"Max_Players_from_{team}_GW{w}\",\n                )\n\n            # 5. Starting XI constraints\n            # 5.1 Select exactly 11 players for the starting XI\n            self.problem += (\n                lpSum(starting_xi_vars[i][w] for i in self.player_data.index) == 11,\n                f\"Total_Starting_XI_Players_GW{w}\",\n            )\n\n            # 5.2 A player can only be in the starting XI if they are in the squad\n            for i in self.player_data.index:\n                self.problem += (\n                    starting_xi_vars[i][w] &lt;= player_vars[i][w],\n                    f\"StartingXI_in_Squad_{i}_{w}\",\n                )\n\n            # 5.3 Starting XI position constraints (FPL allows flexible formations, so use minimums)\n            self.problem += (\n                lpSum(starting_xi_vars[i][w] for i in gks) == 1,\n                f\"Starting_Goalkeepers_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(starting_xi_vars[i][w] for i in defs) &gt;= 3,\n                f\"Min_Starting_Defenders_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(starting_xi_vars[i][w] for i in mids) &gt;= 2,\n                f\"Min_Starting_Midfielders_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(starting_xi_vars[i][w] for i in fwds) &gt;= 1,\n                f\"Min_Starting_Forwards_Count_GW{w}\",\n            )\n\n            # 6. Captain Constraints\n            # 6.1 Select exactly one captain from the starting XI\n            self.problem += (\n                lpSum(captain_var[i][w] for i in self.player_data.index) == 1,\n                f\"One_Captain_GW{w}\",\n            )\n\n            # 6.2 A player can only be captain if they are in the starting XI\n            for i in self.player_data.index:\n                self.problem += (\n                    captain_var[i][w] &lt;= starting_xi_vars[i][w],\n                    f\"Captain_in_StartingXI_{i}_{w}\",\n                )\n\n            # --- Enforced Player Constraints---\n            for player_idx in self.enforced_player_indices:\n                self.problem += (\n                    player_vars[player_idx][w] == 1,\n                    f\"Enforce_Player_{self.player_data.loc[player_idx, 'name']}_GW{w}\",\n                )\n\n            for team, position in self.enforced_team_pos_requirements:\n                # Filter players for the current team and position\n                team_pos_players = self.player_data[\n                    (self.player_data[\"team\"] == team)\n                    &amp; (self.player_data[\"position\"] == position)\n                ].index\n                if not team_pos_players.empty:\n                    self.problem += (\n                        lpSum(player_vars[i][w] for i in team_pos_players) &gt;= 1,\n                        f\"Enforce_One_{position}_from_{team}_GW{w}\",\n                    )\n                else:\n                    print(\n                        f\"Warning: No players found for enforced requirement: at least one {position} from {team} for GW{gw_actual}.\"\n                    )\n\n        # --- Chip Usage Constraints (TOTAL usage over all gameweeks) ---\n        # These constraints should be outside the per-gameweek loop to avoid duplicates.\n        self.problem += (\n            lpSum(use_bench_boost[j] for j in range(num_gameweeks))\n            &lt;= chip_allowances.get(\"bench_boost\", 0),\n            f\"Max_Bench_Boost_Usage_Total\",\n        )\n        self.problem += (\n            lpSum(use_triple_captain[j] for j in range(num_gameweeks))\n            &lt;= chip_allowances.get(\"triple_captain\", 0),\n            f\"Max_Triple_Captain_Usage_Total\",\n        )\n\n        # --- Inter-Gameweek Constraints (Transfers and Transfer Rules) ---\n        # Initialize free transfers for GW0 (first gameweek of optimization horizon)\n        # This assumes the optimization starts at GW0, and it has INITIAL_FREE_TRANSFERS.\n        # If the model starts at an arbitrary GW, this would need to be an input.\n        self.problem += (\n            free_transfers_available[0] == INITIAL_FREE_TRANSFERS,\n            f\"Initial_Free_Transfers_GW0\",\n        )\n\n        for w in range(1, num_gameweeks):\n            # Calculate total transfers made in this gameweek\n            self.problem += (\n                transfers_made[w]\n                == lpSum(transfer_in_vars[i][w] for i in self.player_data.index),\n                f\"Transfers_Made_GW{w}\",\n            )\n            # Total transfers in must equal total transfers out for each gameweek after the first\n            self.problem += (\n                lpSum(transfer_in_vars[i][w] for i in self.player_data.index)\n                == lpSum(transfer_out_vars[i][w] for i in self.player_data.index),\n                f\"Transfers_In_Equals_Out_GW{w}\",\n            )\n\n            # Calculate free transfers available for the current gameweek (w)\n            # Free transfers for GW_w = min(free transfers from GW_w-1 - transfers made in GW_w + 1, MAX_FREE_TRANSFERS_SAVED + 1)\n            # The + 1 in MAX_FREE_TRANSFERS_SAVED + 1 is because MAX_FREE_TRANSFERS_SAVED implies how many can be *saved*,\n            # so if you save 1, you have 1 (current) + 1 (saved) = 2.\n            self.problem += (\n                free_transfers_available[w]\n                &lt;= free_transfers_available[w - 1] - transfers_made[w] + 1,\n                f\"Free_Transfers_Calc_1_GW{w}\",\n            )\n            self.problem += (\n                free_transfers_available[w] &lt;= MAX_FREE_TRANSFERS_SAVED + 1,\n                f\"Free_Transfers_Calc_2_GW{w}\",\n            )\n            self.problem += (\n                free_transfers_available[w] &gt;= 0,  # Cannot have negative free transfers\n                f\"Free_Transfers_Non_Negative_GW{w}\",\n            )\n\n            # Calculate transfer hits\n            # transfer_hits[w] = max(0, transfers_made[w] - free_transfers_available_at_start_of_gw_w)\n            # This needs to be linearized. If transfers_made[w] &gt; free_transfers_available[w-1], then hit.\n            # free_transfers_available[w-1] represents transfers available *before* making transfers for GW_w\n            self.problem += (\n                transfer_hits[w] &gt;= transfers_made[w] - free_transfers_available[w - 1],\n                f\"Transfer_Hits_Calc_1_GW{w}\",\n            )\n            self.problem += (\n                transfer_hits[w] &gt;= 0,\n                f\"Transfer_Hits_Calc_2_GW{w}\",\n            )\n\n            for i in self.player_data.index:\n                # Squad continuity: player_vars[i][w] (in squad at start of GW w)\n                #                 = player_vars[i][w-1] (in squad at start of GW w-1)\n                #                 - transfer_out_vars[i][w] (transferred out for GW w)\n                #                 + transfer_in_vars[i][w] (transferred in for GW w)\n                self.problem += (\n                    player_vars[i][w]\n                    == player_vars[i][w - 1]\n                    - transfer_out_vars[i][w]\n                    + transfer_in_vars[i][w],\n                    f\"Squad_Continuity_{i}_GW{w}\",\n                )\n                # A player cannot be transferred in and out in the same gameweek\n                self.problem += (\n                    transfer_in_vars[i][w] + transfer_out_vars[i][w] &lt;= 1,\n                    f\"No_Simultaneous_Transfer_{i}_{w}\",\n                )\n\n        try:\n            # The solver is called with the GLPK_CMD solver\n            self.problem.solve(PULP_CBC_CMD(msg=0))  # msg=0 suppresses verbose output\n        except Exception as e:\n            print(f\"Error solving the problem: {e}\")\n            return False\n\n        if LpStatus[self.problem.status] == \"Optimal\":\n            print(\"Optimization successful! Optimal solution found.\")\n\n            self.selected_squad_history = {}\n            self.total_transfer_hits = 0\n            for w in range(num_gameweeks):\n                # The actual gameweek number (1-indexed)\n                gw_actual = current_gameweek_number_start + w\n\n                # Get selected players for the current gameweek\n                selected_squad_gw = self.player_data[\n                    [player_vars[i][w].varValue == 1 for i in self.player_data.index]\n                ].copy()\n\n                # Get starter and captain info for this gameweek\n                is_starter_series_gw = pd.Series(\n                    [\n                        starting_xi_vars[i][w].varValue == 1\n                        for i in self.player_data.index\n                    ],\n                    index=self.player_data.index,\n                )\n                is_captain_series_gw = pd.Series(\n                    [captain_var[i][w].varValue == 1 for i in self.player_data.index],\n                    index=self.player_data.index,\n                )\n\n                selected_squad_gw[\"is_starter\"] = is_starter_series_gw.loc[\n                    selected_squad_gw.index\n                ]\n                selected_squad_gw[\"is_captain\"] = is_captain_series_gw.loc[\n                    selected_squad_gw.index\n                ]\n\n                transfers_in_gw = 0\n                transfers_out_gw = 0\n                hits_gw = 0\n\n                # Store transfer details for gameweeks &gt; 0\n                if (\n                    w &gt; 0\n                ):  # Check for transfers only from GW1 onwards (index 1 in 0-indexed loop)\n                    transfer_in_flags = pd.Series(\n                        [\n                            transfer_in_vars[i][w].varValue == 1\n                            for i in self.player_data.index\n                        ],\n                        index=self.player_data.index,\n                    )\n                    transfer_out_flags = pd.Series(\n                        [\n                            transfer_out_vars[i][w].varValue == 1\n                            for i in self.player_data.index\n                        ],\n                        index=self.player_data.index,\n                    )\n\n                    selected_squad_gw[\"transfer_in\"] = transfer_in_flags.loc[\n                        selected_squad_gw.index\n                    ]\n                    selected_squad_gw[\"transfer_out\"] = transfer_out_flags.loc[\n                        selected_squad_gw.index\n                    ]\n\n                    transfers_in_gw = int(round(transfer_in_flags.sum()))\n                    transfers_out_gw = int(round(transfer_out_flags.sum()))\n                    hits_gw = int(round(transfer_hits[w].varValue))\n                    self.total_transfer_hits += hits_gw\n                else:\n                    selected_squad_gw[\"transfer_in\"] = False  # No transfers in for GW0\n                    selected_squad_gw[\"transfer_out\"] = (\n                        False  # No transfers out for GW0\n                    )\n\n                self.selected_squad_history[f\"GW{gw_actual}\"] = {\n                    \"squad\": selected_squad_gw,\n                    \"total_cost\": selected_squad_gw[\"cost\"].sum(),\n                    \"expected_points_from_xi\": sum(\n                        self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n                        * starting_xi_vars[i][w].varValue\n                        for i in self.player_data.index\n                    ),\n                    \"bench_boost_used\": bool(use_bench_boost[w].varValue),\n                    \"triple_captain_used\": bool(use_triple_captain[w].varValue),\n                    \"total_bench_boost_points\": value(\n                        lpSum(\n                            actual_bench_boost_points[i][w]\n                            for i in self.player_data.index\n                        )\n                    ),\n                    \"total_triple_captain_bonus\": value(\n                        lpSum(\n                            actual_triple_captain_bonus[i][w]\n                            for i in self.player_data.index\n                        )\n                    ),\n                    \"transfers_in_count\": transfers_in_gw,\n                    \"transfers_out_count\": transfers_out_gw,\n                    \"transfer_hits\": hits_gw,  # New\n                    \"free_transfers_available_next_gw\": (\n                        int(round(free_transfers_available[w].varValue))\n                        if w &lt; num_gameweeks - 1\n                        else 0\n                    ),  # Free transfers available *after* this GW's transfers are made\n                }\n\n            # Overall totals\n            self.total_cost = self.selected_squad_history[\n                f\"GW{current_gameweek_number_start + num_gameweeks - 1}\"\n            ][\n                \"total_cost\"\n            ]  # Cost of final squad\n            self.total_expected_points = value(\n                self.problem.objective\n            )  # Total objective value from solver\n            self.used_chips = {\n                f\"GW{current_gameweek_number_start + w}\": {\n                    \"bench_boost\": bool(use_bench_boost[w].varValue),\n                    \"triple_captain\": bool(use_triple_captain[w].varValue),\n                }\n                for w in range(num_gameweeks)\n            }\n\n            return True\n        else:\n            print(f\"No optimal solution found. Status: {LpStatus[self.problem.status]}\")\n            self.selected_squad_history = {}\n            self.total_cost = 0\n            self.total_expected_points = 0\n            self.used_chips = {}\n            self.total_transfer_hits = 0\n            return False\n\n    def get_selected_squad(self, gameweek: int = None) -&gt; pd.DataFrame | None:\n        \"\"\"\n        Returns the selected squad for a specific gameweek (1-indexed).\n        If no gameweek is specified, returns the squad for the last optimized gameweek.\n        \"\"\"\n        if not self.selected_squad_history:\n            return None\n\n        # Get the first GW key to determine the range of available GWs\n        first_gw_in_history = min(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n        last_gw_in_history = max(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n\n        if gameweek is None:\n            return self.selected_squad_history[f\"GW{last_gw_in_history}\"][\"squad\"]\n\n        if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n            print(\n                f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n            )\n            return None\n\n        return self.selected_squad_history.get(f\"GW{gameweek}\", {}).get(\"squad\")\n\n    def get_total_cost(self, gameweek: int = None) -&gt; float:\n        \"\"\"\n        Returns the total cost for a specific gameweek (1-indexed).\n        If no gameweek is specified, returns the cost of the squad in the last optimized gameweek.\n        \"\"\"\n        if not self.selected_squad_history:\n            return 0\n        first_gw_in_history = min(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n        last_gw_in_history = max(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n\n        if gameweek is None:\n            return self.selected_squad_history[f\"GW{last_gw_in_history}\"][\"total_cost\"]\n\n        if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n            print(\n                f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n            )\n            return 0  # Or raise an error\n\n        return self.selected_squad_history.get(f\"GW{gameweek}\", {}).get(\"total_cost\", 0)\n\n    def get_total_expected_points(self) -&gt; float:\n        \"\"\"\n        Returns the overall total expected points across all optimized gameweeks.\n        \"\"\"\n        return self.total_expected_points\n\n    def get_gameweek_summary(self, gameweek: int):\n        \"\"\"\n        Returns a dictionary summary for a specific gameweek.\n        \"\"\"\n        if not self.selected_squad_history:\n            return None\n        first_gw_in_history = min(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n        last_gw_in_history = max(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n\n        if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n            print(\n                f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n            )\n            return None\n\n        return self.selected_squad_history.get(f\"GW{gameweek}\")\n\n    def print_squad_summary(self, gameweek: int):\n        \"\"\"\n        Prints a formatted summary of the selected squad for a specific gameweek.\n        \"\"\"\n        if not self.selected_squad_history:\n            print(\"No squad has been selected yet. Run the 'solve' method first.\")\n            return\n\n        gw_data = self.get_gameweek_summary(gameweek)\n        if not gw_data:\n            return  # get_gameweek_summary already prints error message\n\n        selected_squad = gw_data[\"squad\"]\n        total_cost = gw_data[\"total_cost\"]\n        expected_points_from_xi = gw_data[\"expected_points_from_xi\"]\n        bench_boost_used = gw_data[\"bench_boost_used\"]\n        triple_captain_used = gw_data[\"triple_captain_used\"]\n        total_bench_boost_points = gw_data[\"total_bench_boost_points\"]\n        total_triple_captain_bonus = gw_data[\"total_triple_captain_bonus\"]\n        transfers_in_count = gw_data[\"transfers_in_count\"]  # New\n        transfers_out_count = gw_data[\"transfers_out_count\"]  # New\n        transfer_hits_taken = gw_data[\"transfer_hits\"]  # New\n        free_transfers_available_next_gw = gw_data[\n            \"free_transfers_available_next_gw\"\n        ]  # New\n\n        print(f\"\\n--- FPL Optimized Squad for Gameweek {gameweek} ---\")\n        print(f\"Squad Cost: \u00a3{total_cost:.1f}m\")\n        print(f\"Expected Points (Starting XI): {expected_points_from_xi:.2f}\")\n        print(\n            f\"Total Expected Points for GW{gameweek} (including chips): {expected_points_from_xi + total_bench_boost_points + total_triple_captain_bonus:.2f}\"\n        )\n        print(\"\\n--- Chips Used This Gameweek ---\")\n        if bench_boost_used:\n            print(f\"- Bench Boost (Added {total_bench_boost_points:.2f} points)\")\n        if triple_captain_used:\n            print(\n                f\"- Triple Captain (Added {total_triple_captain_bonus:.2f} bonus points)\"\n            )\n        if not (bench_boost_used or triple_captain_used):\n            print(\"No chips used this gameweek.\")\n\n        print(\"\\n--- Goalkeepers (Starting XI marked with *) ---\")\n        for index, row in selected_squad[selected_squad[\"position\"] == \"GK\"].iterrows():\n            starter_str = \"*\" if row[\"is_starter\"] else \"\"\n            captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n            transfer_status = \"\"\n            if row[\"transfer_in\"]:\n                transfer_status = \"(IN)\"\n            elif row[\"transfer_out\"]:\n                transfer_status = \"(OUT)\"\n\n            # Access gameweek-specific xP correctly\n            player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n            print(\n                f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n            )\n        print(\"\\n--- Defenders (Starting XI marked with *) ---\")\n        for index, row in selected_squad[\n            selected_squad[\"position\"] == \"DEF\"\n        ].iterrows():\n            starter_str = \"*\" if row[\"is_starter\"] else \"\"\n            captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n            transfer_status = \"\"\n            if row[\"transfer_in\"]:\n                transfer_status = \"(IN)\"\n            elif row[\"transfer_out\"]:\n                transfer_status = \"(OUT)\"\n\n            player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n            print(\n                f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n            )\n        print(\"\\n--- Midfielders (Starting XI marked with *) ---\")\n        for index, row in selected_squad[\n            selected_squad[\"position\"] == \"MID\"\n        ].iterrows():\n            starter_str = \"*\" if row[\"is_starter\"] else \"\"\n            captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n            transfer_status = \"\"\n            if row[\"transfer_in\"]:\n                transfer_status = \"(IN)\"\n            elif row[\"transfer_out\"]:\n                transfer_status = \"(OUT)\"\n\n            player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n            print(\n                f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n            )\n        print(\"\\n--- Forwards (Starting XI marked with *) ---\")\n        for index, row in selected_squad[\n            selected_squad[\"position\"] == \"FWD\"\n        ].iterrows():\n            starter_str = \"*\" if row[\"is_starter\"] else \"\"\n            captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n            transfer_status = \"\"\n            if row[\"transfer_in\"]:\n                transfer_status = \"(IN)\"\n            elif row[\"transfer_out\"]:\n                transfer_status = \"(OUT)\"\n\n            player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n            print(\n                f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n            )\n\n        print(f\"\\n--- Team Breakdown for GW{gameweek} ---\")\n        print(selected_squad[\"team\"].value_counts())\n\n        # Transfers are relevant from Gameweek 2 (index 1) onwards in the optimization horizon\n        # For display, if the current GW is the initial one (GW1 in the current context), no transfers are made\n        # If it's a subsequent GW, check if transfers occurred.\n        first_gw_in_history = min(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n        if (\n            gameweek &gt;= first_gw_in_history\n        ):  # Changed from &gt; to &gt;=, to show initial free transfers\n            # Display transfer info for this gameweek\n            print(\n                f\"  Transfers In: {transfers_in_count}, Transfers Out: {transfers_out_count}\"\n            )\n            print(\n                f\"  Transfer Hits: {transfer_hits_taken} (-{transfer_hits_taken * POINTS_PER_HIT} points)\"\n            )\n            # Only show free transfers for the *next* gameweek if it's not the last gameweek in the horizon\n            if gameweek &lt; max(\n                int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n            ):\n                print(\n                    f\"  Free Transfers Available for Next GW: {free_transfers_available_next_gw}\"\n                )\n        print(\"---------------------------\\n\")\n\n    def print_overall_summary(self):\n        \"\"\"\n        Prints an overall summary of the multi-week optimization results.\n        \"\"\"\n        if not self.selected_squad_history:\n            print(\"No optimization results to summarize.\")\n            return\n\n        print(\"\\n=== Overall Multi-Week FPL Optimization Summary ===\")\n        print(\n            f\"Total Expected Points Across All Gameweeks: {self.total_expected_points:.2f}\"\n        )\n\n        # Get the latest gameweek's cost\n        last_gw_key = max(\n            self.selected_squad_history.keys(), key=lambda k: int(k.replace(\"GW\", \"\"))\n        )\n        print(\n            f\"Squad Cost ({last_gw_key}): \u00a3{self.selected_squad_history[last_gw_key]['total_cost']:.1f}m\"\n        )\n        print(\n            f\"Total Transfer Hits Taken: {self.total_transfer_hits} (-{self.total_transfer_hits * POINTS_PER_HIT} points)\"\n        )\n\n        print(\"\\n--- Chip Usage Across Gameweeks ---\")\n        # Ensure consistent order by sorting gameweek keys\n        sorted_gw_keys = sorted(\n            self.used_chips.keys(), key=lambda k: int(k.replace(\"GW\", \"\"))\n        )\n        for gw_str in sorted_gw_keys:\n            chips = self.used_chips[gw_str]\n            chip_summary = []\n            if chips[\"bench_boost\"]:\n                chip_summary.append(\"Bench Boost\")\n            if chips[\"triple_captain\"]:\n                chip_summary.append(\"Triple Captain\")\n\n            if chip_summary:\n                print(f\"{gw_str}: {', '.join(chip_summary)}\")\n            else:\n                print(f\"{gw_str}: No chips used\")\n\n        print(\"\\n--- Gameweek-by-Gameweek Summary ---\")\n        # Iterate and print basic summary for each gameweek\n        for gw_str in sorted_gw_keys:\n            gw_data = self.selected_squad_history[gw_str]\n            print(f\"\\n--- {gw_str} ---\")\n            print(f\"  Squad Cost: \u00a3{gw_data['total_cost']:.1f}m\")\n            print(\n                f\"  Expected Points (Starting XI): {gw_data['expected_points_from_xi']:.2f}\"\n            )\n            print(\n                f\"  Total GW Points (incl. chips): {gw_data['expected_points_from_xi'] + gw_data['total_bench_boost_points'] + gw_data['total_triple_captain_bonus']:.2f}\"\n            )\n\n            # Display transfer info for this gameweek\n            transfers_in_count = gw_data[\"transfers_in_count\"]\n            transfers_out_count = gw_data[\"transfers_out_count\"]\n            transfer_hits_taken = gw_data[\"transfer_hits\"]\n            free_transfers_available_next_gw = gw_data[\n                \"free_transfers_available_next_gw\"\n            ]\n\n            print(\n                f\"  Transfers In: {transfers_in_count}, Transfers Out: {transfers_out_count}\"\n            )\n            print(\n                f\"  Transfer Hits: {transfer_hits_taken} (-{transfer_hits_taken * POINTS_PER_HIT} points)\"\n            )\n            # Only show free transfers for the *next* gameweek if it's not the last gameweek in the horizon\n            if int(gw_str.replace(\"GW\", \"\")) &lt; max(\n                int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n            ):\n                print(\n                    f\"  Free Transfers Available for Next GW: {free_transfers_available_next_gw}\"\n                )\n            print(\"-----------------------------------\")\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/solver/#build.lib.build.lib.fpl_solver.solver.FPLOptimizer.__init__","title":"<code>__init__(player_data)</code>","text":"<p>Initializes the FPLOptimizer with player data.</p> <p>Parameters:</p> Name Type Description Default <code>player_data</code> <code>DataFrame</code> <p>A DataFrame containing player information                         with columns: 'name', 'team', 'position',                         'cost', 'expected_points_by_gw' (a dict of xP per GW).</p> required Source code in <code>build/lib/build/lib/fpl_solver/solver.py</code> <pre><code>def __init__(self, player_data: pd.DataFrame):\n    \"\"\"\n    Initializes the FPLOptimizer with player data.\n\n    Args:\n        player_data (pd.DataFrame): A DataFrame containing player information\n                                    with columns: 'name', 'team', 'position',\n                                    'cost', 'expected_points_by_gw' (a dict of xP per GW).\n    \"\"\"\n    required_columns = [\"name\", \"team\", \"position\", \"cost\", \"expected_points_by_gw\"]\n    if not all(col in player_data.columns for col in required_columns):\n        missing_cols = [\n            col for col in required_columns if col not in player_data.columns\n        ]\n        raise ValueError(\n            f\"player_data DataFrame must contain {required_columns} columns. Missing: {missing_cols}\"\n        )\n\n    self.player_data = player_data\n    self.problem = None\n    self.selected_squad_history = {}  # To store squad for each gameweek\n    self.total_cost = 0\n    self.total_expected_points = 0\n    self.total_transfer_hits = 0\n\n    # --- Process Enforced Players ---\n    self.enforced_player_indices = set()\n    self.enforced_team_pos_requirements = []\n\n    print(\"\\n--- Processing Enforced Players ---\")\n\n    # Enforce by Player ID\n    for player_id in ENFORCED_PLAYERS_BY_ID:\n        found_player = self.player_data[self.player_data[\"id\"] == player_id]\n        if not found_player.empty:\n            player_idx = found_player.index[0]\n            self.enforced_player_indices.add(player_idx)\n            print(\n                f\"Enforcing player by ID: {found_player.loc[player_idx, 'name']} (ID: {player_id})\"\n            )\n        else:\n            print(\n                f\"Warning: Enforced player with ID {player_id} not found in data.\"\n            )\n\n    # Enforce by Player Name\n    for player_name in ENFORCED_PLAYERS_BY_NAME:\n        found_player = self.player_data[self.player_data[\"name\"] == player_name]\n        if not found_player.empty:\n            player_idx = found_player.index[0]\n            self.enforced_player_indices.add(player_idx)\n            print(f\"Enforcing player by name: {player_name}\")\n        else:\n            print(f\"Warning: Enforced player '{player_name}' not found in data.\")\n\n    # Enforce by Team and Position\n    for requirement in ENFORCED_PLAYERS_BY_TEAM_AND_POSITION:\n        team = requirement.get(\"team\")\n        position = requirement.get(\"position\")\n        if team and position:\n            # Validate team and position exist in data\n            if team not in self.player_data[\"team\"].unique():\n                print(\n                    f\"Warning: Enforced team '{team}' for position '{position}' not found in data.\"\n                )\n                continue\n            if position not in self.player_data[\"position\"].unique():\n                print(\n                    f\"Warning: Enforced position '{position}' for team '{team}' not found in data.\"\n                )\n                continue\n\n            self.enforced_team_pos_requirements.append((team, position))\n            print(f\"Enforcing at least one {position} from {team}.\")\n        else:\n            print(\n                f\"Warning: Invalid enforced team/position requirement: {requirement}\"\n            )\n\n    if not (\n        self.enforced_player_indices\n        or self.enforced_team_pos_requirements\n        or ENFORCED_PLAYERS_BY_ID\n        or ENFORCED_PLAYERS_BY_NAME\n        or ENFORCED_PLAYERS_BY_TEAM_AND_POSITION\n    ):\n        print(\"No players or team/position combinations are enforced.\")\n    print(\"-----------------------------------\\n\")\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/solver/#build.lib.build.lib.fpl_solver.solver.FPLOptimizer.get_gameweek_summary","title":"<code>get_gameweek_summary(gameweek)</code>","text":"<p>Returns a dictionary summary for a specific gameweek.</p> Source code in <code>build/lib/build/lib/fpl_solver/solver.py</code> <pre><code>def get_gameweek_summary(self, gameweek: int):\n    \"\"\"\n    Returns a dictionary summary for a specific gameweek.\n    \"\"\"\n    if not self.selected_squad_history:\n        return None\n    first_gw_in_history = min(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n    last_gw_in_history = max(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n\n    if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n        print(\n            f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n        )\n        return None\n\n    return self.selected_squad_history.get(f\"GW{gameweek}\")\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/solver/#build.lib.build.lib.fpl_solver.solver.FPLOptimizer.get_selected_squad","title":"<code>get_selected_squad(gameweek=None)</code>","text":"<p>Returns the selected squad for a specific gameweek (1-indexed). If no gameweek is specified, returns the squad for the last optimized gameweek.</p> Source code in <code>build/lib/build/lib/fpl_solver/solver.py</code> <pre><code>def get_selected_squad(self, gameweek: int = None) -&gt; pd.DataFrame | None:\n    \"\"\"\n    Returns the selected squad for a specific gameweek (1-indexed).\n    If no gameweek is specified, returns the squad for the last optimized gameweek.\n    \"\"\"\n    if not self.selected_squad_history:\n        return None\n\n    # Get the first GW key to determine the range of available GWs\n    first_gw_in_history = min(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n    last_gw_in_history = max(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n\n    if gameweek is None:\n        return self.selected_squad_history[f\"GW{last_gw_in_history}\"][\"squad\"]\n\n    if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n        print(\n            f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n        )\n        return None\n\n    return self.selected_squad_history.get(f\"GW{gameweek}\", {}).get(\"squad\")\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/solver/#build.lib.build.lib.fpl_solver.solver.FPLOptimizer.get_total_cost","title":"<code>get_total_cost(gameweek=None)</code>","text":"<p>Returns the total cost for a specific gameweek (1-indexed). If no gameweek is specified, returns the cost of the squad in the last optimized gameweek.</p> Source code in <code>build/lib/build/lib/fpl_solver/solver.py</code> <pre><code>def get_total_cost(self, gameweek: int = None) -&gt; float:\n    \"\"\"\n    Returns the total cost for a specific gameweek (1-indexed).\n    If no gameweek is specified, returns the cost of the squad in the last optimized gameweek.\n    \"\"\"\n    if not self.selected_squad_history:\n        return 0\n    first_gw_in_history = min(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n    last_gw_in_history = max(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n\n    if gameweek is None:\n        return self.selected_squad_history[f\"GW{last_gw_in_history}\"][\"total_cost\"]\n\n    if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n        print(\n            f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n        )\n        return 0  # Or raise an error\n\n    return self.selected_squad_history.get(f\"GW{gameweek}\", {}).get(\"total_cost\", 0)\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/solver/#build.lib.build.lib.fpl_solver.solver.FPLOptimizer.get_total_expected_points","title":"<code>get_total_expected_points()</code>","text":"<p>Returns the overall total expected points across all optimized gameweeks.</p> Source code in <code>build/lib/build/lib/fpl_solver/solver.py</code> <pre><code>def get_total_expected_points(self) -&gt; float:\n    \"\"\"\n    Returns the overall total expected points across all optimized gameweeks.\n    \"\"\"\n    return self.total_expected_points\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/solver/#build.lib.build.lib.fpl_solver.solver.FPLOptimizer.print_overall_summary","title":"<code>print_overall_summary()</code>","text":"<p>Prints an overall summary of the multi-week optimization results.</p> Source code in <code>build/lib/build/lib/fpl_solver/solver.py</code> <pre><code>def print_overall_summary(self):\n    \"\"\"\n    Prints an overall summary of the multi-week optimization results.\n    \"\"\"\n    if not self.selected_squad_history:\n        print(\"No optimization results to summarize.\")\n        return\n\n    print(\"\\n=== Overall Multi-Week FPL Optimization Summary ===\")\n    print(\n        f\"Total Expected Points Across All Gameweeks: {self.total_expected_points:.2f}\"\n    )\n\n    # Get the latest gameweek's cost\n    last_gw_key = max(\n        self.selected_squad_history.keys(), key=lambda k: int(k.replace(\"GW\", \"\"))\n    )\n    print(\n        f\"Squad Cost ({last_gw_key}): \u00a3{self.selected_squad_history[last_gw_key]['total_cost']:.1f}m\"\n    )\n    print(\n        f\"Total Transfer Hits Taken: {self.total_transfer_hits} (-{self.total_transfer_hits * POINTS_PER_HIT} points)\"\n    )\n\n    print(\"\\n--- Chip Usage Across Gameweeks ---\")\n    # Ensure consistent order by sorting gameweek keys\n    sorted_gw_keys = sorted(\n        self.used_chips.keys(), key=lambda k: int(k.replace(\"GW\", \"\"))\n    )\n    for gw_str in sorted_gw_keys:\n        chips = self.used_chips[gw_str]\n        chip_summary = []\n        if chips[\"bench_boost\"]:\n            chip_summary.append(\"Bench Boost\")\n        if chips[\"triple_captain\"]:\n            chip_summary.append(\"Triple Captain\")\n\n        if chip_summary:\n            print(f\"{gw_str}: {', '.join(chip_summary)}\")\n        else:\n            print(f\"{gw_str}: No chips used\")\n\n    print(\"\\n--- Gameweek-by-Gameweek Summary ---\")\n    # Iterate and print basic summary for each gameweek\n    for gw_str in sorted_gw_keys:\n        gw_data = self.selected_squad_history[gw_str]\n        print(f\"\\n--- {gw_str} ---\")\n        print(f\"  Squad Cost: \u00a3{gw_data['total_cost']:.1f}m\")\n        print(\n            f\"  Expected Points (Starting XI): {gw_data['expected_points_from_xi']:.2f}\"\n        )\n        print(\n            f\"  Total GW Points (incl. chips): {gw_data['expected_points_from_xi'] + gw_data['total_bench_boost_points'] + gw_data['total_triple_captain_bonus']:.2f}\"\n        )\n\n        # Display transfer info for this gameweek\n        transfers_in_count = gw_data[\"transfers_in_count\"]\n        transfers_out_count = gw_data[\"transfers_out_count\"]\n        transfer_hits_taken = gw_data[\"transfer_hits\"]\n        free_transfers_available_next_gw = gw_data[\n            \"free_transfers_available_next_gw\"\n        ]\n\n        print(\n            f\"  Transfers In: {transfers_in_count}, Transfers Out: {transfers_out_count}\"\n        )\n        print(\n            f\"  Transfer Hits: {transfer_hits_taken} (-{transfer_hits_taken * POINTS_PER_HIT} points)\"\n        )\n        # Only show free transfers for the *next* gameweek if it's not the last gameweek in the horizon\n        if int(gw_str.replace(\"GW\", \"\")) &lt; max(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        ):\n            print(\n                f\"  Free Transfers Available for Next GW: {free_transfers_available_next_gw}\"\n            )\n        print(\"-----------------------------------\")\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/solver/#build.lib.build.lib.fpl_solver.solver.FPLOptimizer.print_squad_summary","title":"<code>print_squad_summary(gameweek)</code>","text":"<p>Prints a formatted summary of the selected squad for a specific gameweek.</p> Source code in <code>build/lib/build/lib/fpl_solver/solver.py</code> <pre><code>def print_squad_summary(self, gameweek: int):\n    \"\"\"\n    Prints a formatted summary of the selected squad for a specific gameweek.\n    \"\"\"\n    if not self.selected_squad_history:\n        print(\"No squad has been selected yet. Run the 'solve' method first.\")\n        return\n\n    gw_data = self.get_gameweek_summary(gameweek)\n    if not gw_data:\n        return  # get_gameweek_summary already prints error message\n\n    selected_squad = gw_data[\"squad\"]\n    total_cost = gw_data[\"total_cost\"]\n    expected_points_from_xi = gw_data[\"expected_points_from_xi\"]\n    bench_boost_used = gw_data[\"bench_boost_used\"]\n    triple_captain_used = gw_data[\"triple_captain_used\"]\n    total_bench_boost_points = gw_data[\"total_bench_boost_points\"]\n    total_triple_captain_bonus = gw_data[\"total_triple_captain_bonus\"]\n    transfers_in_count = gw_data[\"transfers_in_count\"]  # New\n    transfers_out_count = gw_data[\"transfers_out_count\"]  # New\n    transfer_hits_taken = gw_data[\"transfer_hits\"]  # New\n    free_transfers_available_next_gw = gw_data[\n        \"free_transfers_available_next_gw\"\n    ]  # New\n\n    print(f\"\\n--- FPL Optimized Squad for Gameweek {gameweek} ---\")\n    print(f\"Squad Cost: \u00a3{total_cost:.1f}m\")\n    print(f\"Expected Points (Starting XI): {expected_points_from_xi:.2f}\")\n    print(\n        f\"Total Expected Points for GW{gameweek} (including chips): {expected_points_from_xi + total_bench_boost_points + total_triple_captain_bonus:.2f}\"\n    )\n    print(\"\\n--- Chips Used This Gameweek ---\")\n    if bench_boost_used:\n        print(f\"- Bench Boost (Added {total_bench_boost_points:.2f} points)\")\n    if triple_captain_used:\n        print(\n            f\"- Triple Captain (Added {total_triple_captain_bonus:.2f} bonus points)\"\n        )\n    if not (bench_boost_used or triple_captain_used):\n        print(\"No chips used this gameweek.\")\n\n    print(\"\\n--- Goalkeepers (Starting XI marked with *) ---\")\n    for index, row in selected_squad[selected_squad[\"position\"] == \"GK\"].iterrows():\n        starter_str = \"*\" if row[\"is_starter\"] else \"\"\n        captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n        transfer_status = \"\"\n        if row[\"transfer_in\"]:\n            transfer_status = \"(IN)\"\n        elif row[\"transfer_out\"]:\n            transfer_status = \"(OUT)\"\n\n        # Access gameweek-specific xP correctly\n        player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n        print(\n            f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n        )\n    print(\"\\n--- Defenders (Starting XI marked with *) ---\")\n    for index, row in selected_squad[\n        selected_squad[\"position\"] == \"DEF\"\n    ].iterrows():\n        starter_str = \"*\" if row[\"is_starter\"] else \"\"\n        captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n        transfer_status = \"\"\n        if row[\"transfer_in\"]:\n            transfer_status = \"(IN)\"\n        elif row[\"transfer_out\"]:\n            transfer_status = \"(OUT)\"\n\n        player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n        print(\n            f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n        )\n    print(\"\\n--- Midfielders (Starting XI marked with *) ---\")\n    for index, row in selected_squad[\n        selected_squad[\"position\"] == \"MID\"\n    ].iterrows():\n        starter_str = \"*\" if row[\"is_starter\"] else \"\"\n        captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n        transfer_status = \"\"\n        if row[\"transfer_in\"]:\n            transfer_status = \"(IN)\"\n        elif row[\"transfer_out\"]:\n            transfer_status = \"(OUT)\"\n\n        player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n        print(\n            f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n        )\n    print(\"\\n--- Forwards (Starting XI marked with *) ---\")\n    for index, row in selected_squad[\n        selected_squad[\"position\"] == \"FWD\"\n    ].iterrows():\n        starter_str = \"*\" if row[\"is_starter\"] else \"\"\n        captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n        transfer_status = \"\"\n        if row[\"transfer_in\"]:\n            transfer_status = \"(IN)\"\n        elif row[\"transfer_out\"]:\n            transfer_status = \"(OUT)\"\n\n        player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n        print(\n            f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n        )\n\n    print(f\"\\n--- Team Breakdown for GW{gameweek} ---\")\n    print(selected_squad[\"team\"].value_counts())\n\n    # Transfers are relevant from Gameweek 2 (index 1) onwards in the optimization horizon\n    # For display, if the current GW is the initial one (GW1 in the current context), no transfers are made\n    # If it's a subsequent GW, check if transfers occurred.\n    first_gw_in_history = min(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n    if (\n        gameweek &gt;= first_gw_in_history\n    ):  # Changed from &gt; to &gt;=, to show initial free transfers\n        # Display transfer info for this gameweek\n        print(\n            f\"  Transfers In: {transfers_in_count}, Transfers Out: {transfers_out_count}\"\n        )\n        print(\n            f\"  Transfer Hits: {transfer_hits_taken} (-{transfer_hits_taken * POINTS_PER_HIT} points)\"\n        )\n        # Only show free transfers for the *next* gameweek if it's not the last gameweek in the horizon\n        if gameweek &lt; max(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        ):\n            print(\n                f\"  Free Transfers Available for Next GW: {free_transfers_available_next_gw}\"\n            )\n    print(\"---------------------------\\n\")\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/solver/#build.lib.build.lib.fpl_solver.solver.FPLOptimizer.solve","title":"<code>solve(budget, max_players_per_team, chip_allowances, num_gameweeks)</code>","text":"<p>Solves the FPL optimization problem using PuLP.</p> <p>Parameters:</p> Name Type Description Default <code>budget</code> <code>float</code> <p>The maximum budget in millions of pounds.</p> required <code>max_players_per_team</code> <code>int</code> <p>The maximum number of players allowed from                         any single Premier League team.</p> required <code>chip_allowances</code> <code>dict</code> <p>A dictionary specifying the maximum usage for each chip.</p> required <code>num_gameweeks</code> <code>int</code> <p>The number of gameweeks to optimize over.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if a solution was found, False otherwise.</p> Source code in <code>build/lib/build/lib/fpl_solver/solver.py</code> <pre><code>def solve(\n    self,\n    budget: float,\n    max_players_per_team: int,\n    chip_allowances: dict,\n    num_gameweeks: int,\n) -&gt; bool:\n    \"\"\"\n    Solves the FPL optimization problem using PuLP.\n\n    Args:\n        budget (float): The maximum budget in millions of pounds.\n        max_players_per_team (int): The maximum number of players allowed from\n                                    any single Premier League team.\n        chip_allowances (dict): A dictionary specifying the maximum usage for each chip.\n        num_gameweeks (int): The number of gameweeks to optimize over.\n\n    Returns:\n        bool: True if a solution was found, False otherwise.\n    \"\"\"\n    self.problem = LpProblem(\"FPL Squad Multi-Week Optimization\", LpMaximize)\n\n    # Decision variables for player selection, indexed by player and gameweek\n    player_vars = LpVariable.dicts(\n        \"Player\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n    )\n    starting_xi_vars = LpVariable.dicts(\n        \"StartingXI\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n    )\n    captain_var = LpVariable.dicts(\n        \"Captain\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n    )\n\n    # Binary variables for chip usage, indexed by gameweek\n    use_bench_boost = LpVariable.dicts(\n        \"Use_Bench_Boost\", range(num_gameweeks), 0, 1, LpBinary\n    )\n    use_triple_captain = LpVariable.dicts(\n        \"Use_Triple_Captain\", range(num_gameweeks), 0, 1, LpBinary\n    )\n\n    # Transfer variables\n    transfer_in_vars = LpVariable.dicts(\n        \"Transfer_In\",\n        (self.player_data.index, range(1, num_gameweeks)),\n        0,\n        1,\n        LpBinary,\n    )\n    transfer_out_vars = LpVariable.dicts(\n        \"Transfer_Out\",\n        (self.player_data.index, range(1, num_gameweeks)),\n        0,\n        1,\n        LpBinary,\n    )\n\n    # Total transfers made in a gameweek (absolute count)\n    transfers_made = LpVariable.dicts(\n        \"Transfers_Made\", range(1, num_gameweeks), 0, None, LpInteger\n    )\n    # Free transfers available at the start of a gameweek\n    free_transfers_available = LpVariable.dicts(\n        \"Free_Transfers_Available\",\n        range(num_gameweeks),\n        0,\n        MAX_FREE_TRANSFERS_SAVED + 1,\n        LpInteger,\n    )\n    # Number of transfer hits taken in a gameweek\n    transfer_hits = LpVariable.dicts(\n        \"Transfer_Hits\", range(1, num_gameweeks), 0, None, LpInteger\n    )\n\n    # Auxiliary variables for linearizing chip effects\n    is_bench_player = LpVariable.dicts(\n        \"Is_Bench_Player\",\n        (self.player_data.index, range(num_gameweeks)),\n        0,\n        1,\n        LpBinary,\n    )\n    actual_bench_boost_points = LpVariable.dicts(\n        \"Actual_Bench_Boost_Points\",\n        (self.player_data.index, range(num_gameweeks)),\n        0,\n        None,\n        LpContinuous,\n    )\n    actual_triple_captain_bonus = LpVariable.dicts(\n        \"Actual_Triple_Captain_Bonus\",\n        (self.player_data.index, range(num_gameweeks)),\n        0,\n        None,\n        LpContinuous,\n    )\n\n    # --- Objective Function ---\n    total_objective_points = []\n\n    # Get the first gameweek number from the player data to correctly index expected_points_by_gw\n    first_gw_key = next(\n        iter(\n            self.player_data.loc[\n                self.player_data.index[0], \"expected_points_by_gw\"\n            ].keys()\n        )\n    )\n    current_gameweek_number_start = int(first_gw_key)\n\n    for w in range(num_gameweeks):\n        # The actual gameweek number (1-indexed)\n        gw_actual = current_gameweek_number_start + w\n\n        # Base expected points from the selected starting 11 for this gameweek\n        base_points_expression_gw = lpSum(\n            self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n            * starting_xi_vars[i][w]\n            for i in self.player_data.index\n        )\n        total_objective_points.append(base_points_expression_gw)\n\n        # Regular Captaincy points (additional 1x for captain)\n        captain_points_bonus_gw = lpSum(\n            self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n            * captain_var[i][w]\n            for i in self.player_data.index\n        )\n        total_objective_points.append(captain_points_bonus_gw)\n\n        # Define auxiliary variables and constraints for chips for each gameweek\n        for i in self.player_data.index:\n            # Use gameweek-specific player xP for chip calculations\n            player_xp = self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n\n            # Bench Boost auxiliary variables and constraints\n            self.problem += (\n                is_bench_player[i][w] &lt;= player_vars[i][w],\n                f\"IsBench_Squad_{i}_{w}\",\n            )\n            self.problem += (\n                is_bench_player[i][w] &lt;= 1 - starting_xi_vars[i][w],\n                f\"IsBench_NotStarter_{i}_{w}\",\n            )\n            self.problem += (\n                is_bench_player[i][w]\n                &gt;= player_vars[i][w] + (1 - starting_xi_vars[i][w]) - 1,\n                f\"IsBench_Logical_{i}_{w}\",\n            )\n\n            self.problem += (\n                actual_bench_boost_points[i][w]\n                &lt;= player_xp * is_bench_player[i][w],\n                f\"BenchBoost_Contr_1_{i}_{w}\",\n            )\n            self.problem += (\n                actual_bench_boost_points[i][w] &lt;= player_xp * use_bench_boost[w],\n                f\"BenchBoost_Contr_2_{i}_{w}\",\n            )\n            self.problem += (\n                actual_bench_boost_points[i][w]\n                &gt;= player_xp * (is_bench_player[i][w] + use_bench_boost[w] - 1),\n                f\"BenchBoost_Contr_3_{i}_{w}\",\n            )\n            self.problem += (\n                actual_bench_boost_points[i][w] &gt;= 0,\n                f\"BenchBoost_Contr_4_{i}_{w}\",\n            )\n\n            # Triple Captain auxiliary variables and constraints\n            # Changed player_xp * 2 to player_xp to reflect additional 1x bonus\n            self.problem += (\n                actual_triple_captain_bonus[i][w] &lt;= player_xp * captain_var[i][w],\n                f\"TripleCaptain_Contr_1_{i}_{w}\",\n            )\n            self.problem += (\n                actual_triple_captain_bonus[i][w]\n                &lt;= player_xp * use_triple_captain[w],\n                f\"TripleCaptain_Contr_2_{i}_{w}\",\n            )\n            self.problem += (\n                actual_triple_captain_bonus[i][w]\n                &gt;= player_xp * (captain_var[i][w] + use_triple_captain[w] - 1),\n                f\"TripleCaptain_Contr_3_{i}_{w}\",\n            )\n            self.problem += (\n                actual_triple_captain_bonus[i][w] &gt;= 0,\n                f\"TripleCaptain_Contr_4_{i}_{w}\",\n            )\n\n        # Add points from bench boost and triple captain bonus for this gameweek\n        total_bench_boost_points_gw = lpSum(\n            actual_bench_boost_points[i][w] for i in self.player_data.index\n        )\n        total_triple_captain_bonus_points_gw = lpSum(\n            actual_triple_captain_bonus[i][w] for i in self.player_data.index\n        )\n\n        total_objective_points.append(total_bench_boost_points_gw)\n        total_objective_points.append(total_triple_captain_bonus_points_gw)\n\n    # Subtract transfer hits from the total objective\n    total_objective_points.append(\n        -POINTS_PER_HIT * lpSum(transfer_hits[w] for w in range(1, num_gameweeks))\n    )\n\n    self.problem += (\n        lpSum(total_objective_points),\n        \"Total Expected Points Over Gameweeks\",\n    )\n\n    # --- Constraints ---\n\n    # Apply constraints for each gameweek\n    for w in range(num_gameweeks):\n        # 1. Select exactly 15 players for the squad\n        self.problem += (\n            lpSum(player_vars[i][w] for i in self.player_data.index) == 15,\n            f\"Total_Players_GW{w}\",\n        )\n\n        # 2. Squad position constraints (2 GKs, 5 DEFs, 5 MIDs, 3 FWDs)\n        gks = self.player_data[self.player_data[\"position\"] == \"GK\"].index\n        defs = self.player_data[self.player_data[\"position\"] == \"DEF\"].index\n        mids = self.player_data[self.player_data[\"position\"] == \"MID\"].index\n        fwds = self.player_data[self.player_data[\"position\"] == \"FWD\"].index\n\n        self.problem += (\n            lpSum(player_vars[i][w] for i in gks) == 2,\n            f\"Goalkeepers_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(player_vars[i][w] for i in defs) == 5,\n            f\"Defenders_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(player_vars[i][w] for i in mids) == 5,\n            f\"Midfielders_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(player_vars[i][w] for i in fwds) == 3,\n            f\"Forwards_Count_GW{w}\",\n        )\n\n        # 3. Budget constraint\n        # This applies to the cost of the squad for the current gameweek.\n        self.problem += (\n            lpSum(\n                self.player_data.loc[i, \"cost\"] * player_vars[i][w]\n                for i in self.player_data.index\n            )\n            &lt;= budget,\n            f\"Total_Budget_GW{w}\",\n        )\n\n        # 4. Maximum players per team constraint\n        for team in self.player_data[\"team\"].unique():\n            team_players = self.player_data[self.player_data[\"team\"] == team].index\n            self.problem += (\n                lpSum(player_vars[i][w] for i in team_players)\n                &lt;= max_players_per_team,\n                f\"Max_Players_from_{team}_GW{w}\",\n            )\n\n        # 5. Starting XI constraints\n        # 5.1 Select exactly 11 players for the starting XI\n        self.problem += (\n            lpSum(starting_xi_vars[i][w] for i in self.player_data.index) == 11,\n            f\"Total_Starting_XI_Players_GW{w}\",\n        )\n\n        # 5.2 A player can only be in the starting XI if they are in the squad\n        for i in self.player_data.index:\n            self.problem += (\n                starting_xi_vars[i][w] &lt;= player_vars[i][w],\n                f\"StartingXI_in_Squad_{i}_{w}\",\n            )\n\n        # 5.3 Starting XI position constraints (FPL allows flexible formations, so use minimums)\n        self.problem += (\n            lpSum(starting_xi_vars[i][w] for i in gks) == 1,\n            f\"Starting_Goalkeepers_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(starting_xi_vars[i][w] for i in defs) &gt;= 3,\n            f\"Min_Starting_Defenders_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(starting_xi_vars[i][w] for i in mids) &gt;= 2,\n            f\"Min_Starting_Midfielders_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(starting_xi_vars[i][w] for i in fwds) &gt;= 1,\n            f\"Min_Starting_Forwards_Count_GW{w}\",\n        )\n\n        # 6. Captain Constraints\n        # 6.1 Select exactly one captain from the starting XI\n        self.problem += (\n            lpSum(captain_var[i][w] for i in self.player_data.index) == 1,\n            f\"One_Captain_GW{w}\",\n        )\n\n        # 6.2 A player can only be captain if they are in the starting XI\n        for i in self.player_data.index:\n            self.problem += (\n                captain_var[i][w] &lt;= starting_xi_vars[i][w],\n                f\"Captain_in_StartingXI_{i}_{w}\",\n            )\n\n        # --- Enforced Player Constraints---\n        for player_idx in self.enforced_player_indices:\n            self.problem += (\n                player_vars[player_idx][w] == 1,\n                f\"Enforce_Player_{self.player_data.loc[player_idx, 'name']}_GW{w}\",\n            )\n\n        for team, position in self.enforced_team_pos_requirements:\n            # Filter players for the current team and position\n            team_pos_players = self.player_data[\n                (self.player_data[\"team\"] == team)\n                &amp; (self.player_data[\"position\"] == position)\n            ].index\n            if not team_pos_players.empty:\n                self.problem += (\n                    lpSum(player_vars[i][w] for i in team_pos_players) &gt;= 1,\n                    f\"Enforce_One_{position}_from_{team}_GW{w}\",\n                )\n            else:\n                print(\n                    f\"Warning: No players found for enforced requirement: at least one {position} from {team} for GW{gw_actual}.\"\n                )\n\n    # --- Chip Usage Constraints (TOTAL usage over all gameweeks) ---\n    # These constraints should be outside the per-gameweek loop to avoid duplicates.\n    self.problem += (\n        lpSum(use_bench_boost[j] for j in range(num_gameweeks))\n        &lt;= chip_allowances.get(\"bench_boost\", 0),\n        f\"Max_Bench_Boost_Usage_Total\",\n    )\n    self.problem += (\n        lpSum(use_triple_captain[j] for j in range(num_gameweeks))\n        &lt;= chip_allowances.get(\"triple_captain\", 0),\n        f\"Max_Triple_Captain_Usage_Total\",\n    )\n\n    # --- Inter-Gameweek Constraints (Transfers and Transfer Rules) ---\n    # Initialize free transfers for GW0 (first gameweek of optimization horizon)\n    # This assumes the optimization starts at GW0, and it has INITIAL_FREE_TRANSFERS.\n    # If the model starts at an arbitrary GW, this would need to be an input.\n    self.problem += (\n        free_transfers_available[0] == INITIAL_FREE_TRANSFERS,\n        f\"Initial_Free_Transfers_GW0\",\n    )\n\n    for w in range(1, num_gameweeks):\n        # Calculate total transfers made in this gameweek\n        self.problem += (\n            transfers_made[w]\n            == lpSum(transfer_in_vars[i][w] for i in self.player_data.index),\n            f\"Transfers_Made_GW{w}\",\n        )\n        # Total transfers in must equal total transfers out for each gameweek after the first\n        self.problem += (\n            lpSum(transfer_in_vars[i][w] for i in self.player_data.index)\n            == lpSum(transfer_out_vars[i][w] for i in self.player_data.index),\n            f\"Transfers_In_Equals_Out_GW{w}\",\n        )\n\n        # Calculate free transfers available for the current gameweek (w)\n        # Free transfers for GW_w = min(free transfers from GW_w-1 - transfers made in GW_w + 1, MAX_FREE_TRANSFERS_SAVED + 1)\n        # The + 1 in MAX_FREE_TRANSFERS_SAVED + 1 is because MAX_FREE_TRANSFERS_SAVED implies how many can be *saved*,\n        # so if you save 1, you have 1 (current) + 1 (saved) = 2.\n        self.problem += (\n            free_transfers_available[w]\n            &lt;= free_transfers_available[w - 1] - transfers_made[w] + 1,\n            f\"Free_Transfers_Calc_1_GW{w}\",\n        )\n        self.problem += (\n            free_transfers_available[w] &lt;= MAX_FREE_TRANSFERS_SAVED + 1,\n            f\"Free_Transfers_Calc_2_GW{w}\",\n        )\n        self.problem += (\n            free_transfers_available[w] &gt;= 0,  # Cannot have negative free transfers\n            f\"Free_Transfers_Non_Negative_GW{w}\",\n        )\n\n        # Calculate transfer hits\n        # transfer_hits[w] = max(0, transfers_made[w] - free_transfers_available_at_start_of_gw_w)\n        # This needs to be linearized. If transfers_made[w] &gt; free_transfers_available[w-1], then hit.\n        # free_transfers_available[w-1] represents transfers available *before* making transfers for GW_w\n        self.problem += (\n            transfer_hits[w] &gt;= transfers_made[w] - free_transfers_available[w - 1],\n            f\"Transfer_Hits_Calc_1_GW{w}\",\n        )\n        self.problem += (\n            transfer_hits[w] &gt;= 0,\n            f\"Transfer_Hits_Calc_2_GW{w}\",\n        )\n\n        for i in self.player_data.index:\n            # Squad continuity: player_vars[i][w] (in squad at start of GW w)\n            #                 = player_vars[i][w-1] (in squad at start of GW w-1)\n            #                 - transfer_out_vars[i][w] (transferred out for GW w)\n            #                 + transfer_in_vars[i][w] (transferred in for GW w)\n            self.problem += (\n                player_vars[i][w]\n                == player_vars[i][w - 1]\n                - transfer_out_vars[i][w]\n                + transfer_in_vars[i][w],\n                f\"Squad_Continuity_{i}_GW{w}\",\n            )\n            # A player cannot be transferred in and out in the same gameweek\n            self.problem += (\n                transfer_in_vars[i][w] + transfer_out_vars[i][w] &lt;= 1,\n                f\"No_Simultaneous_Transfer_{i}_{w}\",\n            )\n\n    try:\n        # The solver is called with the GLPK_CMD solver\n        self.problem.solve(PULP_CBC_CMD(msg=0))  # msg=0 suppresses verbose output\n    except Exception as e:\n        print(f\"Error solving the problem: {e}\")\n        return False\n\n    if LpStatus[self.problem.status] == \"Optimal\":\n        print(\"Optimization successful! Optimal solution found.\")\n\n        self.selected_squad_history = {}\n        self.total_transfer_hits = 0\n        for w in range(num_gameweeks):\n            # The actual gameweek number (1-indexed)\n            gw_actual = current_gameweek_number_start + w\n\n            # Get selected players for the current gameweek\n            selected_squad_gw = self.player_data[\n                [player_vars[i][w].varValue == 1 for i in self.player_data.index]\n            ].copy()\n\n            # Get starter and captain info for this gameweek\n            is_starter_series_gw = pd.Series(\n                [\n                    starting_xi_vars[i][w].varValue == 1\n                    for i in self.player_data.index\n                ],\n                index=self.player_data.index,\n            )\n            is_captain_series_gw = pd.Series(\n                [captain_var[i][w].varValue == 1 for i in self.player_data.index],\n                index=self.player_data.index,\n            )\n\n            selected_squad_gw[\"is_starter\"] = is_starter_series_gw.loc[\n                selected_squad_gw.index\n            ]\n            selected_squad_gw[\"is_captain\"] = is_captain_series_gw.loc[\n                selected_squad_gw.index\n            ]\n\n            transfers_in_gw = 0\n            transfers_out_gw = 0\n            hits_gw = 0\n\n            # Store transfer details for gameweeks &gt; 0\n            if (\n                w &gt; 0\n            ):  # Check for transfers only from GW1 onwards (index 1 in 0-indexed loop)\n                transfer_in_flags = pd.Series(\n                    [\n                        transfer_in_vars[i][w].varValue == 1\n                        for i in self.player_data.index\n                    ],\n                    index=self.player_data.index,\n                )\n                transfer_out_flags = pd.Series(\n                    [\n                        transfer_out_vars[i][w].varValue == 1\n                        for i in self.player_data.index\n                    ],\n                    index=self.player_data.index,\n                )\n\n                selected_squad_gw[\"transfer_in\"] = transfer_in_flags.loc[\n                    selected_squad_gw.index\n                ]\n                selected_squad_gw[\"transfer_out\"] = transfer_out_flags.loc[\n                    selected_squad_gw.index\n                ]\n\n                transfers_in_gw = int(round(transfer_in_flags.sum()))\n                transfers_out_gw = int(round(transfer_out_flags.sum()))\n                hits_gw = int(round(transfer_hits[w].varValue))\n                self.total_transfer_hits += hits_gw\n            else:\n                selected_squad_gw[\"transfer_in\"] = False  # No transfers in for GW0\n                selected_squad_gw[\"transfer_out\"] = (\n                    False  # No transfers out for GW0\n                )\n\n            self.selected_squad_history[f\"GW{gw_actual}\"] = {\n                \"squad\": selected_squad_gw,\n                \"total_cost\": selected_squad_gw[\"cost\"].sum(),\n                \"expected_points_from_xi\": sum(\n                    self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n                    * starting_xi_vars[i][w].varValue\n                    for i in self.player_data.index\n                ),\n                \"bench_boost_used\": bool(use_bench_boost[w].varValue),\n                \"triple_captain_used\": bool(use_triple_captain[w].varValue),\n                \"total_bench_boost_points\": value(\n                    lpSum(\n                        actual_bench_boost_points[i][w]\n                        for i in self.player_data.index\n                    )\n                ),\n                \"total_triple_captain_bonus\": value(\n                    lpSum(\n                        actual_triple_captain_bonus[i][w]\n                        for i in self.player_data.index\n                    )\n                ),\n                \"transfers_in_count\": transfers_in_gw,\n                \"transfers_out_count\": transfers_out_gw,\n                \"transfer_hits\": hits_gw,  # New\n                \"free_transfers_available_next_gw\": (\n                    int(round(free_transfers_available[w].varValue))\n                    if w &lt; num_gameweeks - 1\n                    else 0\n                ),  # Free transfers available *after* this GW's transfers are made\n            }\n\n        # Overall totals\n        self.total_cost = self.selected_squad_history[\n            f\"GW{current_gameweek_number_start + num_gameweeks - 1}\"\n        ][\n            \"total_cost\"\n        ]  # Cost of final squad\n        self.total_expected_points = value(\n            self.problem.objective\n        )  # Total objective value from solver\n        self.used_chips = {\n            f\"GW{current_gameweek_number_start + w}\": {\n                \"bench_boost\": bool(use_bench_boost[w].varValue),\n                \"triple_captain\": bool(use_triple_captain[w].varValue),\n            }\n            for w in range(num_gameweeks)\n        }\n\n        return True\n    else:\n        print(f\"No optimal solution found. Status: {LpStatus[self.problem.status]}\")\n        self.selected_squad_history = {}\n        self.total_cost = 0\n        self.total_expected_points = 0\n        self.used_chips = {}\n        self.total_transfer_hits = 0\n        return False\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/xp_predictor/","title":"xp_predictor","text":"<p>FPL Expected Points (xP) Predictor Module.</p> <p>This module provides functionality to predict Fantasy Premier League (FPL) points for players based on historical data, team strengths, and fixture difficulty.</p>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/xp_predictor/#build.lib.build.lib.fpl_solver.xp_predictor.FPLPredictor","title":"<code>FPLPredictor</code>","text":"<p>Predictive algorithm for Expected Points (xP) in Fantasy Premier League, using real data from the FPL API.</p> <p>This class handles: - Fetching and processing FPL API data - Calculating expected points based on multiple factors - Managing player exclusions and filtering - Providing fixture and player data for optimization</p> <p>Attributes:</p> Name Type Description <code>gameweeks_to_predict</code> <code>int</code> <p>Number of future gameweeks to analyze</p> <code>players_data</code> <code>Dict</code> <p>Player statistics and information</p> <code>teams_data</code> <code>Dict</code> <p>Team statistics and attributes</p> <code>fixtures_data</code> <code>Dict</code> <p>Upcoming and historical match data</p> <code>all_players_xp_calculated_data</code> <code>List</code> <p>Processed xP calculations</p> Source code in <code>build/lib/build/lib/fpl_solver/xp_predictor.py</code> <pre><code>class FPLPredictor:\n    \"\"\"\n    Predictive algorithm for Expected Points (xP) in Fantasy Premier League,\n    using real data from the FPL API.\n\n    This class handles:\n    - Fetching and processing FPL API data\n    - Calculating expected points based on multiple factors\n    - Managing player exclusions and filtering\n    - Providing fixture and player data for optimization\n\n    Attributes:\n        gameweeks_to_predict (int): Number of future gameweeks to analyze\n        players_data (Dict): Player statistics and information\n        teams_data (Dict): Team statistics and attributes\n        fixtures_data (Dict): Upcoming and historical match data\n        all_players_xp_calculated_data (List): Processed xP calculations\n    \"\"\"\n\n    def __init__(self, gameweeks_to_predict: int = 1):\n        \"\"\"\n        Initialize the FPLPredictor with data structures and fetch initial data.\n\n        Args:\n            gameweeks_to_predict: Number of upcoming gameweeks to calculate\n                                expected points for. Default is 1 (next gameweek).\n\n        Raises:\n            ValueError: If gameweeks_to_predict is not a positive integer\n        \"\"\"\n        self.logger = setup_logger(__name__)\n        if not isinstance(gameweeks_to_predict, int) or gameweeks_to_predict &lt; 1:\n            msg = f\"gameweeks_to_predict must be a positive integer, got {gameweeks_to_predict}\"\n            self.logger.error(msg)\n            raise ValueError(msg)\n\n        self.gameweeks_to_predict = gameweeks_to_predict\n        self.logger.info(f\"Initializing FPL Predictor for {gameweeks_to_predict} gameweek(s)\")\n\n        # Initialize cache manager\n        cache_dir = os.path.join(os.path.dirname(__file__), 'cache')\n        self.cache_manager = CacheManager(cache_dir)\n\n        # Configuration and static data\n        self.fpl_points: Dict[str, float] = FPL_POINTS\n        self.position_definitions: Dict[int, str] = {\n            1: \"GK\",\n            2: \"DEF\",\n            3: \"MID\",\n            4: \"FWD\",\n        }\n\n        # Data structures for FPL information\n        self.players_data: Dict[int, Dict] = {}\n        self.teams_data: Dict[int, Dict] = {}\n        self.fixtures_data: Dict[int, Dict] = {}\n        self.all_players_xp_calculated_data: List[Dict] = []\n\n        # Initialize data\n        try:\n            self._fetch_fpl_data()\n            self._calculate_all_players_xp()\n        except Exception as e:\n            self.logger.error(f\"Failed to initialize FPL Predictor: {str(e)}\")\n            raise\n\n    def _fetch_fpl_data(self) -&gt; None:\n        \"\"\"\n        Fetch and process data from the FPL API.\n\n        This method retrieves player, team, and fixture data from the FPL API,\n        processes it, and stores it in the appropriate data structures. It also\n        applies any configured player exclusions.\n\n        Raises:\n            requests.RequestException: If API requests fail\n            ValueError: If required data is missing from API response\n            Exception: For other unexpected errors\n        \"\"\"\n        self.logger.info(\"Fetching FPL data from API...\")\n\n        try:\n            # Helper function to fetch from API with caching\n            def fetch_api_data(url: str, endpoint: str) -&gt; dict:\n                # Try to get from cache first\n                cached_data = self.cache_manager.get_cached_response(endpoint)\n                if cached_data is not None:\n                    self.logger.info(f\"Using cached {endpoint} data\")\n                    return cached_data\n\n                # If not in cache or expired, fetch from API\n                try:\n                    self.logger.info(f\"Fetching {endpoint} data from API\")\n                    response = requests.get(url, timeout=10)\n                    response.raise_for_status()\n                    data = response.json()\n\n                    # Cache the response\n                    self.cache_manager.save_response(endpoint, data)\n                    return data\n\n                except requests.RequestException as e:\n                    self.logger.error(f\"Failed to fetch {endpoint} data: {str(e)}\")\n                    raise\n\n            # Fetch both endpoints\n            static_data = fetch_api_data(\n                \"https://fantasy.premierleague.com/api/bootstrap-static/\",\n                \"static\"\n            )\n            fixtures_data = fetch_api_data(\n                \"https://fantasy.premierleague.com/api/fixtures/\",\n                \"fixtures\"\n            )\n\n            # Process players data\n            if \"elements\" not in static_data:\n                raise ValueError(\"No player elements found in API response\")\n\n            self.logger.info(f\"Processing {len(static_data['elements'])} players...\")\n\n            def process_player_data(element: Dict) -&gt; Tuple[int, Dict]:\n                \"\"\"Helper function to process individual player data\"\"\"\n                try:\n                    player_id = element[\"id\"]\n                    return player_id, {\n                        \"name\": f\"{element['first_name']} {element['second_name']}\",\n                        \"web_name\": element[\"web_name\"],\n                        \"team_id\": element[\"team\"],\n                        \"element_type\": element[\"element_type\"],\n                        \"position\": self.position_definitions.get(\n                            element[\"element_type\"], \"Unknown\"\n                        ),\n                        \"cost_pence\": element[\"now_cost\"],\n                        \"status\": element[\"status\"],\n                        \"news\": element[\"news\"],\n                        \"total_points\": element[\"total_points\"],\n                        \"minutes\": element[\"minutes\"],\n                        \"goals_scored\": element[\"goals_scored\"],\n                        \"assists\": element[\"assists\"],\n                        \"clean_sheets\": element[\"clean_sheets\"],\n                        \"goals_conceded\": element[\"goals_conceded\"],\n                        \"penalties_saved\": element[\"penalties_saved\"],\n                        \"penalties_missed\": element[\"penalties_missed\"],\n                        \"yellow_cards\": element[\"yellow_cards\"],\n                        \"red_cards\": element[\"red_cards\"],\n                        \"own_goals\": element[\"own_goals\"],\n                        \"saves\": element[\"saves\"],\n                        \"bonus\": element[\"bonus\"],\n                        \"bps\": element[\"bps\"],\n                        \"threat\": float(element.get(\"threat\", 0)),\n                        \"creativity\": float(element.get(\"creativity\", 0)),\n                        \"influence\": float(element.get(\"influence\", 0)),\n                        \"form\": float(element.get(\"form\", 0)),\n                        \"points_per_game\": float(element.get(\"points_per_game\", 0)),\n                        \"value_season\": float(element.get(\"value_season\", 0)),\n                        \"value_form\": float(element.get(\"value_form\", 0)),\n                        \"ict_index\": float(element.get(\"ict_index\", 0)),\n                        \"defensive_contribution\": float(element.get(\"defensive_contribution\", 0)),\n                    }\n                except KeyError as e:\n                    self.logger.warning(f\"Missing required field for player: {str(e)}\")\n                    return None\n                except ValueError as e:\n                    self.logger.warning(f\"Invalid numeric value for player {element.get('id')}: {str(e)}\")\n                    return None\n\n            # Process all players with error handling\n            for element in static_data[\"elements\"]:\n                result = process_player_data(element)\n                if result:\n                    player_id, player_data = result\n                    self.players_data[player_id] = player_data\n\n            # Apply Player Exclusions\n            def apply_player_exclusions() -&gt; Dict[int, Dict]:\n                \"\"\"Apply configured player exclusions and return filtered player data\"\"\"\n                initial_count = len(self.players_data)\n                players_to_keep = {}\n\n                for player_id, player_info in self.players_data.items():\n                    # Track exclusion reason if player is excluded\n                    exclusion_reason = None\n\n                    # Check ID exclusions\n                    if player_id in EXCLUDED_PLAYERS_BY_ID:\n                        exclusion_reason = f\"ID exclusion: {player_id}\"\n\n                    # Check name exclusions\n                    elif player_info[\"name\"] in EXCLUDED_PLAYERS_BY_NAME:\n                        exclusion_reason = f\"Name exclusion: {player_info['name']}\"\n\n                    # Check team/position exclusions\n                    else:\n                        team_name = self.teams_data.get(player_info[\"team_id\"], {}).get(\"name\")\n                        for rule in EXCLUDED_PLAYERS_BY_TEAM_AND_POSITION:\n                            if (team_name == rule.get(\"team\") and \n                                player_info[\"position\"] == rule.get(\"position\")):\n                                exclusion_reason = f\"Team/Position exclusion: {team_name}/{player_info['position']}\"\n                                break\n\n                    # Log exclusion or keep player\n                    if exclusion_reason:\n                        self.logger.info(\n                            f\"Excluding player {player_info['name']} - {exclusion_reason}\"\n                        )\n                    else:\n                        players_to_keep[player_id] = player_info\n\n                filtered_count = len(players_to_keep)\n                self.logger.info(\n                    f\"Player filtering complete. {initial_count - filtered_count} \"\n                    f\"players excluded. {filtered_count} players remaining.\"\n                )\n                return players_to_keep\n\n            self.players_data = apply_player_exclusions()\n\n            # Process teams data\n            if \"teams\" not in static_data:\n                raise ValueError(\"No team data found in API response\")\n\n            self.logger.info(f\"Processing {len(static_data['teams'])} teams...\")\n\n            def process_team_data(team: Dict) -&gt; Tuple[int, Dict]:\n                \"\"\"Helper function to process individual team data\"\"\"\n                try:\n                    return team[\"id\"], {\n                        \"name\": team[\"name\"],\n                        \"short_name\": team[\"short_name\"],\n                        \"strength\": team[\"strength\"],\n                        \"strength_overall_home\": team[\"strength_overall_home\"],\n                        \"strength_overall_away\": team[\"strength_overall_away\"],\n                        \"strength_attack_home\": team[\"strength_attack_home\"],\n                        \"strength_attack_away\": team[\"strength_attack_away\"],\n                        \"strength_defence_home\": team[\"strength_defence_home\"],\n                        \"strength_defence_away\": team[\"strength_defence_away\"],\n                    }\n                except KeyError as e:\n                    self.logger.warning(f\"Missing required field for team: {str(e)}\")\n                    return None\n\n            # Process all teams with error handling\n            for team in static_data[\"teams\"]:\n                result = process_team_data(team)\n                if result:\n                    team_id, team_data = result\n                    self.teams_data[team_id] = team_data\n\n            # Process fixtures data\n            self.logger.info(f\"Processing {len(fixtures_data)} fixtures...\")\n\n            def process_fixture_data(fixture: Dict) -&gt; Tuple[int, Dict]:\n                \"\"\"Helper function to process individual fixture data\"\"\"\n                try:\n                    fixture_id = fixture[\"id\"]\n                    # Validate required fields\n                    required_fields = [\"team_h\", \"team_a\", \"event\", \"finished\"]\n                    if not all(field in fixture for field in required_fields):\n                        missing = [f for f in required_fields if f not in fixture]\n                        raise KeyError(f\"Missing required fields: {', '.join(missing)}\")\n                    return fixture_id, fixture\n                except KeyError as e:\n                    self.logger.warning(f\"Invalid fixture data: {str(e)}\")\n                    return None\n\n            # Process all fixtures with error handling\n            for fixture in fixtures_data:\n                result = process_fixture_data(fixture)\n                if result:\n                    fixture_id, fixture_data = result\n                    self.fixtures_data[fixture_id] = fixture_data\n\n            self.logger.info(\"FPL data fetched and processed successfully.\")\n\n        except requests.exceptions.RequestException as e:\n            self.logger.error(f\"Failed to fetch FPL data: {str(e)}\")\n            self._reset_data_structures()\n            raise\n        except ValueError as e:\n            self.logger.error(f\"Invalid data received from FPL API: {str(e)}\")\n            self._reset_data_structures()\n            raise\n        except Exception as e:\n            self.logger.error(f\"Unexpected error during data processing: {str(e)}\")\n            self._reset_data_structures()\n            raise\n\n    def _reset_data_structures(self) -&gt; None:\n        \"\"\"Reset all data structures to empty state\"\"\"\n        self.players_data = {}\n        self.teams_data = {}\n        self.fixtures_data = {}\n\n    def _get_team_strength(self, team_id, is_home):\n        \"\"\"Get team strength based on home/away status.\"\"\"\n        team = self.teams_data.get(team_id, {})\n        if is_home:\n            return team.get(\"strength_overall_home\", 1000)  # Default if not found\n        return team.get(\"strength_overall_away\", 1000)  # Default if not found\n\n    def _predict_minutes(self, player_id):\n        \"\"\"\n        Predicts expected minutes for a player based on historical data.\n        More sophisticated logic for handling very low minute players.\n        \"\"\"\n        player = self.players_data.get(player_id)\n        if not player:\n            return 0.0\n\n        status = player[\"status\"]\n        news = player[\"news\"].lower()\n        minutes_played = player[\"minutes\"]\n\n        # 1. Unavailable players (injured, suspended, doubtful)\n        if status != \"a\" or any(\n            x in news\n            for x in [\n                \"injured\",\n                \"doubtful\",\n                \"suspension\",\n                \"red card\",\n                \"expected back\",\n            ]\n        ):\n            return 0.0\n\n        # 2. Players with significant minutes (starters/key rotation)\n        if minutes_played &gt;= MIN_MINUTES_THRESHOLD:\n            # Average minutes per game started (assuming most minutes come from starts)\n            # This is a heuristic; real FPL API doesn't give starts directly.\n            # We assume a player with &gt; MIN_MINUTES_THRESHOLD plays ~80-90 minutes when on pitch.\n            # So, (minutes_played / number_of_appearances) is a rough proxy.\n            # For simplicity, let's use a cap of 90 minutes.\n            if player[\"total_points\"] &gt; 0:  # Player has played at least one game\n                avg_minutes_per_appearance = minutes_played / (\n                    player[\"total_points\"] / player[\"points_per_game\"]\n                )\n                return min(avg_minutes_per_appearance, 90.0)\n            return 70.0  # Reasonable default for established player with points but no clear avg\n\n        # 3. Players with very low minutes (rarely play, new, youth)\n        if minutes_played &lt; VERY_LOW_MINUTES_THRESHOLD:\n            # If news suggests they might get a chance, assign default sub minutes.\n            # Otherwise, very low expected minutes or zero.\n            if any(x in news for x in [\"return imminent\", \"close to return\"]):\n                return DEFAULT_SUB_MINUTES  # Might get some minutes\n            return DEFAULT_UNKNOWN_PLAYER_MINUTES  # Very unlikely to play significant minutes\n\n        # 4. Players with some minutes but below significant threshold (regular subs)\n        return DEFAULT_SUB_MINUTES\n\n    def _calculate_expected_goals(self, team_attack_strength, opp_defence_strength):\n        \"\"\"\n        Calculates expected goals for a team based on its attack strength and\n        opponent's defensive strength. This is a simplified heuristic.\n        \"\"\"\n        # A simple ratio model: Higher attack strength and lower opponent defense means more goals\n        # Normalization factor can be adjusted based on average league goals\n        expected_goals = (\n            team_attack_strength / opp_defence_strength\n        ) * 1.5  # 1.5 is an arbitrary scaling factor\n        return max(0.0, expected_goals)\n\n    def _calculate_expected_conceded_goals(\n        self, team_defence_strength, opp_attack_strength\n    ):\n        \"\"\"\n        Calculates expected goals conceded by a team based on its defense strength\n        and opponent's attacking strength.\n        \"\"\"\n        # A simple ratio model: Higher opponent attack and lower team defense means more conceded goals\n        expected_conceded_goals = (\n            opp_attack_strength / team_defence_strength\n        ) * 1.5  # 1.5 is an arbitrary scaling factor\n        return max(0.0, expected_conceded_goals)\n\n    def calculate_xp_for_player(self, player_id, fixture_id):\n        \"\"\"\n        Calculates Expected Points (xP) for a single player in a given fixture.\n        Considers various factors: minutes, goals, assists, clean sheets, saves,\n        bonus points, and negative events, adjusted for fixture difficulty.\n        \"\"\"\n        player = self.players_data.get(player_id)\n        fixture = self.fixtures_data.get(fixture_id)\n\n        if not player or not fixture:\n            return {\"xp\": 0.0, \"reason\": \"Player or fixture data missing.\"}\n\n        # Handle unavailable players\n        if (\n            player[\"status\"] != \"a\"\n        ):  # 'd' for doubtful, 'i' for injured, 's' for suspended\n            return {\"xp\": 0.0, \"reason\": f\"Player status: {player['status']}\"}\n        if any(\n            x in player[\"news\"].lower()\n            for x in [\"injured\", \"doubtful\", \"suspension\", \"red card\"]\n        ):\n            return {\"xp\": 0.0, \"reason\": f\"Player news: {player['news']}\"}\n\n        # Predict minutes\n        expected_minutes = self._predict_minutes(player_id)\n        if expected_minutes &lt; 1.0:  # If expected to play very little or none\n            return {\"xp\": 0.0, \"reason\": \"Expected minutes too low.\"}\n\n        xp = 0.0\n        position = player[\"position\"]\n        # Use 'team_h' for home team ID\n        is_home_fixture = player[\"team_id\"] == fixture[\"team_h\"]\n\n        # Determine attacking and defensive strengths for the fixture\n        player_team_strength_attack = (\n            self.teams_data.get(fixture[\"team_h\"], {}).get(\n                \"strength_attack_home\"\n            )  # Use 'team_h'\n            if is_home_fixture\n            else self.teams_data.get(fixture[\"team_a\"], {}).get(\n                \"strength_attack_away\"\n            )  # Use 'team_a'\n        )\n        player_team_strength_defence = (\n            self.teams_data.get(fixture[\"team_h\"], {}).get(\n                \"strength_defence_home\"\n            )  # Use 'team_h'\n            if is_home_fixture\n            else self.teams_data.get(fixture[\"team_a\"], {}).get(\n                \"strength_defence_away\"\n            )  # Use 'team_a'\n        )\n        opponent_team_strength_attack = (\n            self.teams_data.get(fixture[\"team_a\"], {}).get(\n                \"strength_attack_away\"\n            )  # Use 'team_a'\n            if is_home_fixture\n            else self.teams_data.get(fixture[\"team_h\"], {}).get(\n                \"strength_attack_home\"\n            )  # Use 'team_h'\n        )\n        opponent_team_strength_defence = (\n            self.teams_data.get(fixture[\"team_a\"], {}).get(\n                \"strength_defence_away\"\n            )  # Use 'team_a'\n            if is_home_fixture\n            else self.teams_data.get(fixture[\"team_h\"], {}).get(\n                \"strength_defence_home\"\n            )  # Use 'team_h'\n        )\n\n        if None in [\n            player_team_strength_attack,\n            player_team_strength_defence,\n            opponent_team_strength_attack,\n            opponent_team_strength_defence,\n        ]:\n            # Fallback if strength data is missing (shouldn't happen with robust data fetch)\n            return {\"xp\": 0.0, \"reason\": \"Team strength data missing for fixture.\"}\n\n        # Apply confidence factor based on historical minutes\n        minutes_played = player.get(\"minutes\", 0)\n        confidence_factor = XP_CONFIDENCE_FACTORS[\"proven\"]  # Default to proven player\n        if minutes_played &lt; VERY_LOW_MINUTES_THRESHOLD:\n            confidence_factor = XP_CONFIDENCE_FACTORS[\"very_low_minutes\"]\n        elif minutes_played &lt; MIN_MINUTES_THRESHOLD:\n            confidence_factor = XP_CONFIDENCE_FACTORS[\"low_minutes\"]\n\n        # 1. Appearance points\n        if expected_minutes &gt;= 60:\n            xp += self.fpl_points[\"appearance_points_gte_60\"]\n        elif expected_minutes &gt; 0:\n            xp += self.fpl_points[\"appearance_points_lt_60\"]\n\n        # 2. Expected Goals (scaled by historical goals per 90 and opponent difficulty)\n        # Use player's form and total goals as a basis\n        goals_per_90_hist = (\n            (player[\"goals_scored\"] / player[\"minutes\"] * 90)\n            if player[\"minutes\"] &gt; 0\n            else 0.0\n        )\n        expected_team_goals = self._calculate_expected_goals(\n            player_team_strength_attack, opponent_team_strength_defence\n        )\n\n        expected_goals_player_contribution = (\n            (goals_per_90_hist / 90.0) * expected_minutes * (expected_team_goals / 1.5)\n        )  # Scale player's goal contribution by team's expected goals\n\n        if position == \"GK\":\n            xp += expected_goals_player_contribution * self.fpl_points[\"goal_gk\"]\n        elif position == \"DEF\":\n            xp += expected_goals_player_contribution * self.fpl_points[\"goal_def\"]\n        elif position == \"MID\":\n            xp += expected_goals_player_contribution * self.fpl_points[\"goal_mid\"]\n        elif position == \"FWD\":\n            xp += expected_goals_player_contribution * self.fpl_points[\"goal_fwd\"]\n\n        # 3. Expected Assists (scaled by historical assists per 90 and opponent difficulty)\n        assists_per_90_hist = (\n            (player[\"assists\"] / player[\"minutes\"] * 90)\n            if player[\"minutes\"] &gt; 0\n            else 0.0\n        )\n        # Assuming team's attacking strength correlates with assist opportunities\n        expected_assists_player_contribution = (\n            (assists_per_90_hist / 90.0)\n            * expected_minutes\n            * (expected_team_goals / 1.5)\n        )  # Similarly scale by team's expected goals\n        xp += expected_assists_player_contribution * self.fpl_points[\"assist_points\"]\n\n        # 4. Expected Clean Sheets (for GKs/DEFs/MIDs) and Conceded Goals deduction\n        expected_conceded = self._calculate_expected_conceded_goals(\n            player_team_strength_defence, opponent_team_strength_attack\n        )\n\n        # Probability of clean sheet\n        # Simplified: higher team defense / lower opponent attack -&gt; higher CS prob\n        # Use logistic or sigmoid for probability\n        cs_prob = 1.0 / (\n            1.0 + math.exp(expected_conceded - 1.0)\n        )  # Sigmoid centered at 1 goal\n\n        if position in [\"GK\", \"DEF\"]:\n            xp += cs_prob * self.fpl_points[\"clean_sheet_gk_def\"]\n\n            # Conceded goals deduction: Apply penalty for every 2 goals conceded *probability*\n            # For simplicity, calculate expected deduction: (expected_conceded / 2) * deduction\n            xp += (expected_conceded / 2.0) * self.fpl_points[\n                \"conceded_2_goals_deduction\"\n            ]\n        elif position == \"MID\":\n            xp += cs_prob * self.fpl_points[\"clean_sheet_mid\"]\n\n        # 5. Expected Saves (for GKs)\n        if position == \"GK\":\n            saves_per_90_hist = (\n                (player[\"saves\"] / player[\"minutes\"] * 90)\n                if player[\"minutes\"] &gt; 0\n                else 0.0\n            )\n            # Expected saves scaled by opponent's attacking strength (more attacking -&gt; more shots -&gt; more saves)\n            expected_saves_player_contribution = (\n                (saves_per_90_hist / 90.0)\n                * expected_minutes\n                * (opponent_team_strength_attack / player_team_strength_defence)\n            )\n            xp += (expected_saves_player_contribution / 3.0) * self.fpl_points[\n                \"saves_3_points\"\n            ]  # Using the new config point value\n\n            # Penalty saves (low probability, use historical rate)\n            penalty_saves_hist_per_game = (\n                player[\"penalties_saved\"] / (player[\"minutes\"] / 90.0)\n                if player[\"minutes\"] &gt; 0\n                else 0.0\n            )\n            xp += (\n                penalty_saves_hist_per_game\n                * (expected_minutes / 90.0)\n                * self.fpl_points[\"penalty_save_points\"]\n            )\n\n        # 6. Expected Bonus Points\n        # Use BPS (Bonus Points System) as a proxy. Scale player's average BPS by form and expected minutes.\n        bps_per_90_hist = (\n            (player[\"bps\"] / player[\"minutes\"] * 90) if player[\"minutes\"] &gt; 0 else 0.0\n        )\n        expected_bps = (bps_per_90_hist / 90.0) * expected_minutes * player[\"form\"]\n        xp += expected_bps * self.fpl_points[\"bonus_points_scaling_factor\"]\n\n        # 7. Minor Negative Events (Probabilistic)\n        # These are rare, so a simple probability based on expected minutes.\n        xp += (expected_minutes / 90.0) * (\n            self.fpl_points[\"yellow_card_deduction\"] * YELLOW_CARD_PROB\n            + self.fpl_points[\"red_card_deduction\"] * RED_CARD_PROB\n            + self.fpl_points[\"own_goal_deduction\"] * OWN_GOAL_PROB\n            + self.fpl_points[\"penalty_miss_deduction\"] * PENALTY_MISS_PROB\n        )\n\n        # 8. Defensive Contribution Points (for 2025/26 season)\n        # Use actual defensive_contribution data from API\n        defensive_contribution_per_90 = (\n            (player[\"defensive_contribution\"] / player[\"minutes\"] * 90)\n            if player[\"minutes\"] &gt; 0\n            else 0.0\n        )\n        expected_defensive_contribution = (defensive_contribution_per_90 / 90.0) * expected_minutes\n\n        # Award defensive contribution points based on position thresholds\n        if position in [\"DEF\", \"MID\", \"FWD\"]:  # Goalkeepers do not earn defensive contribution points\n            xp += expected_defensive_contribution * self.fpl_points[\"defensive_contribution_points\"]\n\n        # Apply confidence factor to final xP\n        xp = xp * confidence_factor\n\n        return {\"xp\": round(xp, 2), \"reason\": \"Success\", \"confidence\": confidence_factor}\n\n    def _calculate_all_players_xp(self):\n        \"\"\"\n        Calculates the Expected Points (xP) for all players over multiple upcoming gameweeks\n        and populates self.all_players_xp_calculated_data with xP per gameweek.\n        \"\"\"\n        print(\n            f\"Calculating xP for all players over {self.gameweeks_to_predict} gameweek(s)...\"\n        )\n\n        # Get all upcoming fixtures and sort them by gameweek\n        all_upcoming_fixtures_items = sorted(\n            [\n                (fid, fdict)\n                for fid, fdict in self.fixtures_data.items()\n                if not fdict[\"finished\"]\n            ],\n            key=lambda item: item[1][\"event\"],\n        )\n\n        if not all_upcoming_fixtures_items:\n            print(\"No upcoming fixtures found. Cannot calculate xP.\")\n            return\n\n        # Determine the current gameweek (the gameweek of the earliest upcoming fixture)\n        current_gameweek = all_upcoming_fixtures_items[0][1][\"event\"]\n        target_gameweeks = range(\n            current_gameweek, current_gameweek + self.gameweeks_to_predict\n        )\n\n        # Create a mapping of team_id_code to a list of their fixtures within the target gameweeks\n        team_fixtures_in_range = {team_code: [] for team_code in self.teams_data.keys()}\n        for fixture_id, fixture_data in all_upcoming_fixtures_items:\n            if fixture_data[\"event\"] in target_gameweeks:\n                home_team_code = fixture_data[\"team_h\"]\n                away_team_code = fixture_data[\"team_a\"]\n\n                team_fixtures_in_range[home_team_code].append(fixture_id)\n                team_fixtures_in_range[away_team_code].append(fixture_id)\n\n        # Calculate total xP for each player across the specified gameweeks\n        for player_id, player_data in self.players_data.items():\n            player_team_code = player_data[\"team_id\"]\n            player_position = player_data[\"position\"]\n\n            # Calculate xP for each relevant fixture and store by gameweek\n            expected_points_by_gw = {}\n            for fixture_id in team_fixtures_in_range.get(player_team_code, []):\n                fixture_gameweek = self.fixtures_data[fixture_id][\"event\"]\n                xp_result_single_gw = self.calculate_xp_for_player(\n                    player_id, fixture_id\n                )\n                if xp_result_single_gw and xp_result_single_gw[\"xp\"] is not None:\n                    if fixture_gameweek not in expected_points_by_gw:\n                        expected_points_by_gw[fixture_gameweek] = 0.0\n                    expected_points_by_gw[fixture_gameweek] += xp_result_single_gw[\"xp\"]\n\n            # Ensure all target gameweeks are present, even if xP is 0 for a given GW\n            for gw in target_gameweeks:\n                if gw not in expected_points_by_gw:\n                    expected_points_by_gw[gw] = 0.0\n\n            # Sort the dictionary by gameweek for consistent output\n            expected_points_by_gw = dict(sorted(expected_points_by_gw.items()))\n\n            # Prepare data for the optimizer\n            player_cost_m = player_data[\"cost_pence\"] / 10.0\n            team_name_full = self.teams_data.get(player_team_code, {}).get(\n                \"name\", \"Unknown Team\"\n            )\n\n            self.all_players_xp_calculated_data.append(\n                {\n                    \"name\": player_data[\"name\"],\n                    \"web_name\": player_data[\"web_name\"],\n                    \"team\": team_name_full,\n                    \"position\": player_position,\n                    \"cost\": player_cost_m,\n                    \"expected_points_by_gw\": expected_points_by_gw,  # Changed key and format\n                }\n            )\n        print(\"xP calculation for all players complete.\")\n\n    def get_upcoming_fixtures(self, limit=None):\n        \"\"\"\n        Returns a list of upcoming fixtures, sorted by gameweek and kickoff time.\n        Optionally limits the number of fixtures returned.\n        \"\"\"\n        upcoming = []\n        now = datetime.now()\n\n        # Sort all fixtures by gameweek and then by kickoff time\n        sorted_fixtures = sorted(\n            self.fixtures_data.values(),\n            key=lambda x: (\n                x.get(\"event\", 0),\n                x.get(\"kickoff_time\", \"9999-12-31T00:00:00Z\"),\n            ),\n        )\n\n        current_gameweek = None\n        for fixture_data in sorted_fixtures:\n            # Determine current gameweek from the earliest upcoming fixture\n            if not fixture_data[\"finished\"] and current_gameweek is None:\n                current_gameweek = fixture_data.get(\"event\", 0)\n\n            # Filter for upcoming fixtures within the prediction horizon\n            if (\n                fixture_data.get(\"event\", 0) &lt; current_gameweek  # Skip past gameweeks\n                or fixture_data.get(\"event\", 0)\n                &gt;= current_gameweek + self.gameweeks_to_predict\n            ):\n                continue  # Skip fixtures outside the prediction horizon\n\n            home_team_name = self.teams_data.get(\n                fixture_data[\"team_h\"], {}\n            ).get(  # Use 'team_h'\n                \"name\", \"Unknown\"\n            )\n            away_team_name = self.teams_data.get(\n                fixture_data[\"team_a\"], {}\n            ).get(  # Use 'team_a'\n                \"name\", \"Unknown\"\n            )\n\n            # Only add fixtures that are not finished\n            if not fixture_data[\"finished\"]:\n                upcoming.append(\n                    {\n                        \"fixture_id\": fixture_data[\"id\"],\n                        \"gameweek\": fixture_data.get(\"event\"),\n                        \"home_team_id\": fixture_data[\"team_h\"],  # Use 'team_h'\n                        \"away_team_id\": fixture_data[\"team_a\"],  # Use 'team_a'\n                        \"match\": f\"{home_team_name} vs {away_team_name}\",\n                        \"kickoff_time\": fixture_data.get(\"kickoff_time\"),\n                        \"home_team_difficulty\": fixture_data[\"team_h_difficulty\"],\n                        \"away_team_difficulty\": fixture_data[\"team_a_difficulty\"],\n                    }\n                )\n            if limit is not None and len(upcoming) &gt;= limit:\n                break\n        return upcoming\n\n    def get_players_for_optimizer(self):\n        \"\"\"\n        Returns the list of player data with calculated xP per gameweek,\n        formatted for the FPLOptimizer.\n        \"\"\"\n        return self.all_players_xp_calculated_data\n\n    def clear_cache(self):\n        \"\"\"\n        Clear all cached API responses. Use this when you want to force fresh data\n        from the FPL API.\n        \"\"\"\n        self.cache_manager.clear_cache()\n        self.logger.info(\"Cleared API response cache\")\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/xp_predictor/#build.lib.build.lib.fpl_solver.xp_predictor.FPLPredictor.__init__","title":"<code>__init__(gameweeks_to_predict=1)</code>","text":"<p>Initialize the FPLPredictor with data structures and fetch initial data.</p> <p>Parameters:</p> Name Type Description Default <code>gameweeks_to_predict</code> <code>int</code> <p>Number of upcoming gameweeks to calculate                 expected points for. Default is 1 (next gameweek).</p> <code>1</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If gameweeks_to_predict is not a positive integer</p> Source code in <code>build/lib/build/lib/fpl_solver/xp_predictor.py</code> <pre><code>def __init__(self, gameweeks_to_predict: int = 1):\n    \"\"\"\n    Initialize the FPLPredictor with data structures and fetch initial data.\n\n    Args:\n        gameweeks_to_predict: Number of upcoming gameweeks to calculate\n                            expected points for. Default is 1 (next gameweek).\n\n    Raises:\n        ValueError: If gameweeks_to_predict is not a positive integer\n    \"\"\"\n    self.logger = setup_logger(__name__)\n    if not isinstance(gameweeks_to_predict, int) or gameweeks_to_predict &lt; 1:\n        msg = f\"gameweeks_to_predict must be a positive integer, got {gameweeks_to_predict}\"\n        self.logger.error(msg)\n        raise ValueError(msg)\n\n    self.gameweeks_to_predict = gameweeks_to_predict\n    self.logger.info(f\"Initializing FPL Predictor for {gameweeks_to_predict} gameweek(s)\")\n\n    # Initialize cache manager\n    cache_dir = os.path.join(os.path.dirname(__file__), 'cache')\n    self.cache_manager = CacheManager(cache_dir)\n\n    # Configuration and static data\n    self.fpl_points: Dict[str, float] = FPL_POINTS\n    self.position_definitions: Dict[int, str] = {\n        1: \"GK\",\n        2: \"DEF\",\n        3: \"MID\",\n        4: \"FWD\",\n    }\n\n    # Data structures for FPL information\n    self.players_data: Dict[int, Dict] = {}\n    self.teams_data: Dict[int, Dict] = {}\n    self.fixtures_data: Dict[int, Dict] = {}\n    self.all_players_xp_calculated_data: List[Dict] = []\n\n    # Initialize data\n    try:\n        self._fetch_fpl_data()\n        self._calculate_all_players_xp()\n    except Exception as e:\n        self.logger.error(f\"Failed to initialize FPL Predictor: {str(e)}\")\n        raise\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/xp_predictor/#build.lib.build.lib.fpl_solver.xp_predictor.FPLPredictor.calculate_xp_for_player","title":"<code>calculate_xp_for_player(player_id, fixture_id)</code>","text":"<p>Calculates Expected Points (xP) for a single player in a given fixture. Considers various factors: minutes, goals, assists, clean sheets, saves, bonus points, and negative events, adjusted for fixture difficulty.</p> Source code in <code>build/lib/build/lib/fpl_solver/xp_predictor.py</code> <pre><code>def calculate_xp_for_player(self, player_id, fixture_id):\n    \"\"\"\n    Calculates Expected Points (xP) for a single player in a given fixture.\n    Considers various factors: minutes, goals, assists, clean sheets, saves,\n    bonus points, and negative events, adjusted for fixture difficulty.\n    \"\"\"\n    player = self.players_data.get(player_id)\n    fixture = self.fixtures_data.get(fixture_id)\n\n    if not player or not fixture:\n        return {\"xp\": 0.0, \"reason\": \"Player or fixture data missing.\"}\n\n    # Handle unavailable players\n    if (\n        player[\"status\"] != \"a\"\n    ):  # 'd' for doubtful, 'i' for injured, 's' for suspended\n        return {\"xp\": 0.0, \"reason\": f\"Player status: {player['status']}\"}\n    if any(\n        x in player[\"news\"].lower()\n        for x in [\"injured\", \"doubtful\", \"suspension\", \"red card\"]\n    ):\n        return {\"xp\": 0.0, \"reason\": f\"Player news: {player['news']}\"}\n\n    # Predict minutes\n    expected_minutes = self._predict_minutes(player_id)\n    if expected_minutes &lt; 1.0:  # If expected to play very little or none\n        return {\"xp\": 0.0, \"reason\": \"Expected minutes too low.\"}\n\n    xp = 0.0\n    position = player[\"position\"]\n    # Use 'team_h' for home team ID\n    is_home_fixture = player[\"team_id\"] == fixture[\"team_h\"]\n\n    # Determine attacking and defensive strengths for the fixture\n    player_team_strength_attack = (\n        self.teams_data.get(fixture[\"team_h\"], {}).get(\n            \"strength_attack_home\"\n        )  # Use 'team_h'\n        if is_home_fixture\n        else self.teams_data.get(fixture[\"team_a\"], {}).get(\n            \"strength_attack_away\"\n        )  # Use 'team_a'\n    )\n    player_team_strength_defence = (\n        self.teams_data.get(fixture[\"team_h\"], {}).get(\n            \"strength_defence_home\"\n        )  # Use 'team_h'\n        if is_home_fixture\n        else self.teams_data.get(fixture[\"team_a\"], {}).get(\n            \"strength_defence_away\"\n        )  # Use 'team_a'\n    )\n    opponent_team_strength_attack = (\n        self.teams_data.get(fixture[\"team_a\"], {}).get(\n            \"strength_attack_away\"\n        )  # Use 'team_a'\n        if is_home_fixture\n        else self.teams_data.get(fixture[\"team_h\"], {}).get(\n            \"strength_attack_home\"\n        )  # Use 'team_h'\n    )\n    opponent_team_strength_defence = (\n        self.teams_data.get(fixture[\"team_a\"], {}).get(\n            \"strength_defence_away\"\n        )  # Use 'team_a'\n        if is_home_fixture\n        else self.teams_data.get(fixture[\"team_h\"], {}).get(\n            \"strength_defence_home\"\n        )  # Use 'team_h'\n    )\n\n    if None in [\n        player_team_strength_attack,\n        player_team_strength_defence,\n        opponent_team_strength_attack,\n        opponent_team_strength_defence,\n    ]:\n        # Fallback if strength data is missing (shouldn't happen with robust data fetch)\n        return {\"xp\": 0.0, \"reason\": \"Team strength data missing for fixture.\"}\n\n    # Apply confidence factor based on historical minutes\n    minutes_played = player.get(\"minutes\", 0)\n    confidence_factor = XP_CONFIDENCE_FACTORS[\"proven\"]  # Default to proven player\n    if minutes_played &lt; VERY_LOW_MINUTES_THRESHOLD:\n        confidence_factor = XP_CONFIDENCE_FACTORS[\"very_low_minutes\"]\n    elif minutes_played &lt; MIN_MINUTES_THRESHOLD:\n        confidence_factor = XP_CONFIDENCE_FACTORS[\"low_minutes\"]\n\n    # 1. Appearance points\n    if expected_minutes &gt;= 60:\n        xp += self.fpl_points[\"appearance_points_gte_60\"]\n    elif expected_minutes &gt; 0:\n        xp += self.fpl_points[\"appearance_points_lt_60\"]\n\n    # 2. Expected Goals (scaled by historical goals per 90 and opponent difficulty)\n    # Use player's form and total goals as a basis\n    goals_per_90_hist = (\n        (player[\"goals_scored\"] / player[\"minutes\"] * 90)\n        if player[\"minutes\"] &gt; 0\n        else 0.0\n    )\n    expected_team_goals = self._calculate_expected_goals(\n        player_team_strength_attack, opponent_team_strength_defence\n    )\n\n    expected_goals_player_contribution = (\n        (goals_per_90_hist / 90.0) * expected_minutes * (expected_team_goals / 1.5)\n    )  # Scale player's goal contribution by team's expected goals\n\n    if position == \"GK\":\n        xp += expected_goals_player_contribution * self.fpl_points[\"goal_gk\"]\n    elif position == \"DEF\":\n        xp += expected_goals_player_contribution * self.fpl_points[\"goal_def\"]\n    elif position == \"MID\":\n        xp += expected_goals_player_contribution * self.fpl_points[\"goal_mid\"]\n    elif position == \"FWD\":\n        xp += expected_goals_player_contribution * self.fpl_points[\"goal_fwd\"]\n\n    # 3. Expected Assists (scaled by historical assists per 90 and opponent difficulty)\n    assists_per_90_hist = (\n        (player[\"assists\"] / player[\"minutes\"] * 90)\n        if player[\"minutes\"] &gt; 0\n        else 0.0\n    )\n    # Assuming team's attacking strength correlates with assist opportunities\n    expected_assists_player_contribution = (\n        (assists_per_90_hist / 90.0)\n        * expected_minutes\n        * (expected_team_goals / 1.5)\n    )  # Similarly scale by team's expected goals\n    xp += expected_assists_player_contribution * self.fpl_points[\"assist_points\"]\n\n    # 4. Expected Clean Sheets (for GKs/DEFs/MIDs) and Conceded Goals deduction\n    expected_conceded = self._calculate_expected_conceded_goals(\n        player_team_strength_defence, opponent_team_strength_attack\n    )\n\n    # Probability of clean sheet\n    # Simplified: higher team defense / lower opponent attack -&gt; higher CS prob\n    # Use logistic or sigmoid for probability\n    cs_prob = 1.0 / (\n        1.0 + math.exp(expected_conceded - 1.0)\n    )  # Sigmoid centered at 1 goal\n\n    if position in [\"GK\", \"DEF\"]:\n        xp += cs_prob * self.fpl_points[\"clean_sheet_gk_def\"]\n\n        # Conceded goals deduction: Apply penalty for every 2 goals conceded *probability*\n        # For simplicity, calculate expected deduction: (expected_conceded / 2) * deduction\n        xp += (expected_conceded / 2.0) * self.fpl_points[\n            \"conceded_2_goals_deduction\"\n        ]\n    elif position == \"MID\":\n        xp += cs_prob * self.fpl_points[\"clean_sheet_mid\"]\n\n    # 5. Expected Saves (for GKs)\n    if position == \"GK\":\n        saves_per_90_hist = (\n            (player[\"saves\"] / player[\"minutes\"] * 90)\n            if player[\"minutes\"] &gt; 0\n            else 0.0\n        )\n        # Expected saves scaled by opponent's attacking strength (more attacking -&gt; more shots -&gt; more saves)\n        expected_saves_player_contribution = (\n            (saves_per_90_hist / 90.0)\n            * expected_minutes\n            * (opponent_team_strength_attack / player_team_strength_defence)\n        )\n        xp += (expected_saves_player_contribution / 3.0) * self.fpl_points[\n            \"saves_3_points\"\n        ]  # Using the new config point value\n\n        # Penalty saves (low probability, use historical rate)\n        penalty_saves_hist_per_game = (\n            player[\"penalties_saved\"] / (player[\"minutes\"] / 90.0)\n            if player[\"minutes\"] &gt; 0\n            else 0.0\n        )\n        xp += (\n            penalty_saves_hist_per_game\n            * (expected_minutes / 90.0)\n            * self.fpl_points[\"penalty_save_points\"]\n        )\n\n    # 6. Expected Bonus Points\n    # Use BPS (Bonus Points System) as a proxy. Scale player's average BPS by form and expected minutes.\n    bps_per_90_hist = (\n        (player[\"bps\"] / player[\"minutes\"] * 90) if player[\"minutes\"] &gt; 0 else 0.0\n    )\n    expected_bps = (bps_per_90_hist / 90.0) * expected_minutes * player[\"form\"]\n    xp += expected_bps * self.fpl_points[\"bonus_points_scaling_factor\"]\n\n    # 7. Minor Negative Events (Probabilistic)\n    # These are rare, so a simple probability based on expected minutes.\n    xp += (expected_minutes / 90.0) * (\n        self.fpl_points[\"yellow_card_deduction\"] * YELLOW_CARD_PROB\n        + self.fpl_points[\"red_card_deduction\"] * RED_CARD_PROB\n        + self.fpl_points[\"own_goal_deduction\"] * OWN_GOAL_PROB\n        + self.fpl_points[\"penalty_miss_deduction\"] * PENALTY_MISS_PROB\n    )\n\n    # 8. Defensive Contribution Points (for 2025/26 season)\n    # Use actual defensive_contribution data from API\n    defensive_contribution_per_90 = (\n        (player[\"defensive_contribution\"] / player[\"minutes\"] * 90)\n        if player[\"minutes\"] &gt; 0\n        else 0.0\n    )\n    expected_defensive_contribution = (defensive_contribution_per_90 / 90.0) * expected_minutes\n\n    # Award defensive contribution points based on position thresholds\n    if position in [\"DEF\", \"MID\", \"FWD\"]:  # Goalkeepers do not earn defensive contribution points\n        xp += expected_defensive_contribution * self.fpl_points[\"defensive_contribution_points\"]\n\n    # Apply confidence factor to final xP\n    xp = xp * confidence_factor\n\n    return {\"xp\": round(xp, 2), \"reason\": \"Success\", \"confidence\": confidence_factor}\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/xp_predictor/#build.lib.build.lib.fpl_solver.xp_predictor.FPLPredictor.clear_cache","title":"<code>clear_cache()</code>","text":"<p>Clear all cached API responses. Use this when you want to force fresh data from the FPL API.</p> Source code in <code>build/lib/build/lib/fpl_solver/xp_predictor.py</code> <pre><code>def clear_cache(self):\n    \"\"\"\n    Clear all cached API responses. Use this when you want to force fresh data\n    from the FPL API.\n    \"\"\"\n    self.cache_manager.clear_cache()\n    self.logger.info(\"Cleared API response cache\")\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/xp_predictor/#build.lib.build.lib.fpl_solver.xp_predictor.FPLPredictor.get_players_for_optimizer","title":"<code>get_players_for_optimizer()</code>","text":"<p>Returns the list of player data with calculated xP per gameweek, formatted for the FPLOptimizer.</p> Source code in <code>build/lib/build/lib/fpl_solver/xp_predictor.py</code> <pre><code>def get_players_for_optimizer(self):\n    \"\"\"\n    Returns the list of player data with calculated xP per gameweek,\n    formatted for the FPLOptimizer.\n    \"\"\"\n    return self.all_players_xp_calculated_data\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/xp_predictor/#build.lib.build.lib.fpl_solver.xp_predictor.FPLPredictor.get_upcoming_fixtures","title":"<code>get_upcoming_fixtures(limit=None)</code>","text":"<p>Returns a list of upcoming fixtures, sorted by gameweek and kickoff time. Optionally limits the number of fixtures returned.</p> Source code in <code>build/lib/build/lib/fpl_solver/xp_predictor.py</code> <pre><code>def get_upcoming_fixtures(self, limit=None):\n    \"\"\"\n    Returns a list of upcoming fixtures, sorted by gameweek and kickoff time.\n    Optionally limits the number of fixtures returned.\n    \"\"\"\n    upcoming = []\n    now = datetime.now()\n\n    # Sort all fixtures by gameweek and then by kickoff time\n    sorted_fixtures = sorted(\n        self.fixtures_data.values(),\n        key=lambda x: (\n            x.get(\"event\", 0),\n            x.get(\"kickoff_time\", \"9999-12-31T00:00:00Z\"),\n        ),\n    )\n\n    current_gameweek = None\n    for fixture_data in sorted_fixtures:\n        # Determine current gameweek from the earliest upcoming fixture\n        if not fixture_data[\"finished\"] and current_gameweek is None:\n            current_gameweek = fixture_data.get(\"event\", 0)\n\n        # Filter for upcoming fixtures within the prediction horizon\n        if (\n            fixture_data.get(\"event\", 0) &lt; current_gameweek  # Skip past gameweeks\n            or fixture_data.get(\"event\", 0)\n            &gt;= current_gameweek + self.gameweeks_to_predict\n        ):\n            continue  # Skip fixtures outside the prediction horizon\n\n        home_team_name = self.teams_data.get(\n            fixture_data[\"team_h\"], {}\n        ).get(  # Use 'team_h'\n            \"name\", \"Unknown\"\n        )\n        away_team_name = self.teams_data.get(\n            fixture_data[\"team_a\"], {}\n        ).get(  # Use 'team_a'\n            \"name\", \"Unknown\"\n        )\n\n        # Only add fixtures that are not finished\n        if not fixture_data[\"finished\"]:\n            upcoming.append(\n                {\n                    \"fixture_id\": fixture_data[\"id\"],\n                    \"gameweek\": fixture_data.get(\"event\"),\n                    \"home_team_id\": fixture_data[\"team_h\"],  # Use 'team_h'\n                    \"away_team_id\": fixture_data[\"team_a\"],  # Use 'team_a'\n                    \"match\": f\"{home_team_name} vs {away_team_name}\",\n                    \"kickoff_time\": fixture_data.get(\"kickoff_time\"),\n                    \"home_team_difficulty\": fixture_data[\"team_h_difficulty\"],\n                    \"away_team_difficulty\": fixture_data[\"team_a_difficulty\"],\n                }\n            )\n        if limit is not None and len(upcoming) &gt;= limit:\n            break\n    return upcoming\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/","title":"fpl_solver","text":"<p>FPL Solver package initialization. This package provides tools for Fantasy Premier League optimization.</p>"},{"location":"autoapi/build/lib/fpl_solver/#build.lib.fpl_solver.cache_manager","title":"<code>cache_manager</code>","text":"<p>Cache manager for FPL API responses.</p> <p>This module provides functionality to cache API responses locally and manage their expiry.</p>"},{"location":"autoapi/build/lib/fpl_solver/#build.lib.fpl_solver.cache_manager.CacheManager","title":"<code>CacheManager</code>","text":"Source code in <code>build/lib/fpl_solver/cache_manager.py</code> <pre><code>class CacheManager:\n    def __init__(self, cache_dir: str, cache_expiry_hours: int = 3):\n        \"\"\"\n        Initialize the cache manager.\n\n        Args:\n            cache_dir: Directory to store cache files\n            cache_expiry_hours: Number of hours after which cache should be considered stale\n        \"\"\"\n        self.cache_dir = cache_dir\n        self.cache_expiry = timedelta(hours=cache_expiry_hours)\n\n        # Create cache directory if it doesn't exist\n        if not os.path.exists(cache_dir):\n            os.makedirs(cache_dir)\n\n    def _get_cache_path(self, endpoint: str) -&gt; str:\n        \"\"\"Get the full path for a cache file.\"\"\"\n        return os.path.join(self.cache_dir, f\"{endpoint}.json\")\n\n    def get_cached_response(self, endpoint: str) -&gt; Optional[Dict[str, Any]]:\n        \"\"\"\n        Retrieve cached response if it exists and is not expired.\n\n        Args:\n            endpoint: API endpoint identifier (e.g., 'static' or 'fixtures')\n\n        Returns:\n            Cached data if valid, None otherwise\n        \"\"\"\n        cache_path = self._get_cache_path(endpoint)\n\n        if not os.path.exists(cache_path):\n            return None\n\n        try:\n            with open(cache_path, 'r') as f:\n                cached_data = json.load(f)\n\n            # Check if cache has expired\n            cached_time = datetime.fromtimestamp(cached_data['cached_at'])\n            if datetime.now() - cached_time &gt; self.cache_expiry:\n                return None\n\n            return cached_data['data']\n\n        except (json.JSONDecodeError, KeyError, ValueError) as e:\n            # If there's any issue with the cache file, ignore it\n            return None\n\n    def save_response(self, endpoint: str, data: Dict[str, Any]) -&gt; None:\n        \"\"\"\n        Save API response to cache.\n\n        Args:\n            endpoint: API endpoint identifier\n            data: Response data to cache\n        \"\"\"\n        cache_path = self._get_cache_path(endpoint)\n\n        cache_data = {\n            'cached_at': time.time(),\n            'data': data\n        }\n\n        with open(cache_path, 'w') as f:\n            json.dump(cache_data, f)\n\n    def clear_cache(self) -&gt; None:\n        \"\"\"Clear all cached data.\"\"\"\n        for filename in os.listdir(self.cache_dir):\n            if filename.endswith('.json'):\n                os.remove(os.path.join(self.cache_dir, filename))\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/#build.lib.fpl_solver.cache_manager.CacheManager.__init__","title":"<code>__init__(cache_dir, cache_expiry_hours=3)</code>","text":"<p>Initialize the cache manager.</p> <p>Parameters:</p> Name Type Description Default <code>cache_dir</code> <code>str</code> <p>Directory to store cache files</p> required <code>cache_expiry_hours</code> <code>int</code> <p>Number of hours after which cache should be considered stale</p> <code>3</code> Source code in <code>build/lib/fpl_solver/cache_manager.py</code> <pre><code>def __init__(self, cache_dir: str, cache_expiry_hours: int = 3):\n    \"\"\"\n    Initialize the cache manager.\n\n    Args:\n        cache_dir: Directory to store cache files\n        cache_expiry_hours: Number of hours after which cache should be considered stale\n    \"\"\"\n    self.cache_dir = cache_dir\n    self.cache_expiry = timedelta(hours=cache_expiry_hours)\n\n    # Create cache directory if it doesn't exist\n    if not os.path.exists(cache_dir):\n        os.makedirs(cache_dir)\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/#build.lib.fpl_solver.cache_manager.CacheManager.clear_cache","title":"<code>clear_cache()</code>","text":"<p>Clear all cached data.</p> Source code in <code>build/lib/fpl_solver/cache_manager.py</code> <pre><code>def clear_cache(self) -&gt; None:\n    \"\"\"Clear all cached data.\"\"\"\n    for filename in os.listdir(self.cache_dir):\n        if filename.endswith('.json'):\n            os.remove(os.path.join(self.cache_dir, filename))\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/#build.lib.fpl_solver.cache_manager.CacheManager.get_cached_response","title":"<code>get_cached_response(endpoint)</code>","text":"<p>Retrieve cached response if it exists and is not expired.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>API endpoint identifier (e.g., 'static' or 'fixtures')</p> required <p>Returns:</p> Type Description <code>Optional[Dict[str, Any]]</code> <p>Cached data if valid, None otherwise</p> Source code in <code>build/lib/fpl_solver/cache_manager.py</code> <pre><code>def get_cached_response(self, endpoint: str) -&gt; Optional[Dict[str, Any]]:\n    \"\"\"\n    Retrieve cached response if it exists and is not expired.\n\n    Args:\n        endpoint: API endpoint identifier (e.g., 'static' or 'fixtures')\n\n    Returns:\n        Cached data if valid, None otherwise\n    \"\"\"\n    cache_path = self._get_cache_path(endpoint)\n\n    if not os.path.exists(cache_path):\n        return None\n\n    try:\n        with open(cache_path, 'r') as f:\n            cached_data = json.load(f)\n\n        # Check if cache has expired\n        cached_time = datetime.fromtimestamp(cached_data['cached_at'])\n        if datetime.now() - cached_time &gt; self.cache_expiry:\n            return None\n\n        return cached_data['data']\n\n    except (json.JSONDecodeError, KeyError, ValueError) as e:\n        # If there's any issue with the cache file, ignore it\n        return None\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/#build.lib.fpl_solver.cache_manager.CacheManager.save_response","title":"<code>save_response(endpoint, data)</code>","text":"<p>Save API response to cache.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>API endpoint identifier</p> required <code>data</code> <code>Dict[str, Any]</code> <p>Response data to cache</p> required Source code in <code>build/lib/fpl_solver/cache_manager.py</code> <pre><code>def save_response(self, endpoint: str, data: Dict[str, Any]) -&gt; None:\n    \"\"\"\n    Save API response to cache.\n\n    Args:\n        endpoint: API endpoint identifier\n        data: Response data to cache\n    \"\"\"\n    cache_path = self._get_cache_path(endpoint)\n\n    cache_data = {\n        'cached_at': time.time(),\n        'data': data\n    }\n\n    with open(cache_path, 'w') as f:\n        json.dump(cache_data, f)\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/#build.lib.fpl_solver.config","title":"<code>config</code>","text":"<p>fpl_config.py</p> <p>Configuration settings for the FPL Expected Points Predictor and Solver. This file centralizes all constants related to FPL scoring, thresholds, and optimization parameters.</p>"},{"location":"autoapi/build/lib/fpl_solver/#build.lib.fpl_solver.logger","title":"<code>logger</code>","text":"<p>Logging configuration for the FPL Solver package.</p>"},{"location":"autoapi/build/lib/fpl_solver/#build.lib.fpl_solver.logger.setup_logger","title":"<code>setup_logger(name, level=None)</code>","text":"<p>Set up a logger with consistent formatting and optional level override.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the logger</p> required <code>level</code> <code>Optional[int]</code> <p>Optional logging level override. If None, uses INFO</p> <code>None</code> <p>Returns:</p> Type Description <code>Logger</code> <p>logging.Logger: Configured logger instance</p> Source code in <code>build/lib/fpl_solver/logger.py</code> <pre><code>def setup_logger(name: str, level: Optional[int] = None) -&gt; logging.Logger:\n    \"\"\"\n    Set up a logger with consistent formatting and optional level override.\n\n    Args:\n        name: The name of the logger\n        level: Optional logging level override. If None, uses INFO\n\n    Returns:\n        logging.Logger: Configured logger instance\n    \"\"\"\n    logger = logging.getLogger(name)\n\n    if not logger.handlers:  # Only add handler if logger doesn't have one\n        handler = logging.StreamHandler(sys.stdout)\n        formatter = logging.Formatter(\n            '%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n            datefmt='%Y-%m-%d %H:%M:%S'\n        )\n        handler.setFormatter(formatter)\n        logger.addHandler(handler)\n\n    logger.setLevel(level or logging.INFO)\n    return logger\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/#build.lib.fpl_solver.solver","title":"<code>solver</code>","text":"<p>FPL Squad Optimizer using PuLP for Integer Linear Programming (ILP).</p> <p>This module provides optimization functionality to select the best possible FPL squad over multiple gameweeks, considering transfer constraints and chips.</p>"},{"location":"autoapi/build/lib/fpl_solver/#build.lib.fpl_solver.solver.FPLOptimizer","title":"<code>FPLOptimizer</code>","text":"<p>A class to optimize Fantasy Premier League (FPL) squad selection using Integer Linear Programming (ILP).</p> <p>The optimizer aims to select a 15-player squad (2 GKs, 5 DEFs, 5 MIDs, 3 FWDs) within a budget, with a maximum number of players from any single team, to maximize the total expected points.</p> Source code in <code>build/lib/fpl_solver/solver.py</code> <pre><code>class FPLOptimizer:\n    \"\"\"\n    A class to optimize Fantasy Premier League (FPL) squad selection\n    using Integer Linear Programming (ILP).\n\n    The optimizer aims to select a 15-player squad (2 GKs, 5 DEFs, 5 MIDs, 3 FWDs)\n    within a budget, with a maximum number of players from any single team,\n    to maximize the total expected points.\n    \"\"\"\n\n    def __init__(self, player_data: pd.DataFrame):\n        \"\"\"\n        Initializes the FPLOptimizer with player data.\n\n        Args:\n            player_data (pd.DataFrame): A DataFrame containing player information\n                                        with columns: 'name', 'team', 'position',\n                                        'cost', 'expected_points_by_gw' (a dict of xP per GW).\n        \"\"\"\n        required_columns = [\"name\", \"team\", \"position\", \"cost\", \"expected_points_by_gw\"]\n        if not all(col in player_data.columns for col in required_columns):\n            missing_cols = [\n                col for col in required_columns if col not in player_data.columns\n            ]\n            raise ValueError(\n                f\"player_data DataFrame must contain {required_columns} columns. Missing: {missing_cols}\"\n            )\n\n        self.player_data = player_data\n        self.problem = None\n        self.selected_squad_history = {}  # To store squad for each gameweek\n        self.total_cost = 0\n        self.total_expected_points = 0\n        self.total_transfer_hits = 0\n\n        # --- Process Enforced Players ---\n        self.enforced_player_indices = set()\n        self.enforced_team_pos_requirements = []\n\n        print(\"\\n--- Processing Enforced Players ---\")\n\n        # Enforce by Player ID\n        for player_id in ENFORCED_PLAYERS_BY_ID:\n            found_player = self.player_data[self.player_data[\"id\"] == player_id]\n            if not found_player.empty:\n                player_idx = found_player.index[0]\n                self.enforced_player_indices.add(player_idx)\n                print(\n                    f\"Enforcing player by ID: {found_player.loc[player_idx, 'name']} (ID: {player_id})\"\n                )\n            else:\n                print(\n                    f\"Warning: Enforced player with ID {player_id} not found in data.\"\n                )\n\n        # Enforce by Player Name\n        for player_name in ENFORCED_PLAYERS_BY_NAME:\n            found_player = self.player_data[self.player_data[\"name\"] == player_name]\n            if not found_player.empty:\n                player_idx = found_player.index[0]\n                self.enforced_player_indices.add(player_idx)\n                print(f\"Enforcing player by name: {player_name}\")\n            else:\n                print(f\"Warning: Enforced player '{player_name}' not found in data.\")\n\n        # Enforce by Team and Position\n        for requirement in ENFORCED_PLAYERS_BY_TEAM_AND_POSITION:\n            team = requirement.get(\"team\")\n            position = requirement.get(\"position\")\n            if team and position:\n                # Validate team and position exist in data\n                if team not in self.player_data[\"team\"].unique():\n                    print(\n                        f\"Warning: Enforced team '{team}' for position '{position}' not found in data.\"\n                    )\n                    continue\n                if position not in self.player_data[\"position\"].unique():\n                    print(\n                        f\"Warning: Enforced position '{position}' for team '{team}' not found in data.\"\n                    )\n                    continue\n\n                self.enforced_team_pos_requirements.append((team, position))\n                print(f\"Enforcing at least one {position} from {team}.\")\n            else:\n                print(\n                    f\"Warning: Invalid enforced team/position requirement: {requirement}\"\n                )\n\n        if not (\n            self.enforced_player_indices\n            or self.enforced_team_pos_requirements\n            or ENFORCED_PLAYERS_BY_ID\n            or ENFORCED_PLAYERS_BY_NAME\n            or ENFORCED_PLAYERS_BY_TEAM_AND_POSITION\n        ):\n            print(\"No players or team/position combinations are enforced.\")\n        print(\"-----------------------------------\\n\")\n\n    def solve(\n        self,\n        budget: float,\n        max_players_per_team: int,\n        chip_allowances: dict,\n        num_gameweeks: int,\n    ) -&gt; bool:\n        \"\"\"\n        Solves the FPL optimization problem using PuLP.\n\n        Args:\n            budget (float): The maximum budget in millions of pounds.\n            max_players_per_team (int): The maximum number of players allowed from\n                                        any single Premier League team.\n            chip_allowances (dict): A dictionary specifying the maximum usage for each chip.\n            num_gameweeks (int): The number of gameweeks to optimize over.\n\n        Returns:\n            bool: True if a solution was found, False otherwise.\n        \"\"\"\n        self.problem = LpProblem(\"FPL Squad Multi-Week Optimization\", LpMaximize)\n\n        # Decision variables for player selection, indexed by player and gameweek\n        player_vars = LpVariable.dicts(\n            \"Player\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n        )\n        starting_xi_vars = LpVariable.dicts(\n            \"StartingXI\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n        )\n        captain_var = LpVariable.dicts(\n            \"Captain\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n        )\n\n        # Binary variables for chip usage, indexed by gameweek\n        use_bench_boost = LpVariable.dicts(\n            \"Use_Bench_Boost\", range(num_gameweeks), 0, 1, LpBinary\n        )\n        use_triple_captain = LpVariable.dicts(\n            \"Use_Triple_Captain\", range(num_gameweeks), 0, 1, LpBinary\n        )\n\n        # Transfer variables\n        transfer_in_vars = LpVariable.dicts(\n            \"Transfer_In\",\n            (self.player_data.index, range(1, num_gameweeks)),\n            0,\n            1,\n            LpBinary,\n        )\n        transfer_out_vars = LpVariable.dicts(\n            \"Transfer_Out\",\n            (self.player_data.index, range(1, num_gameweeks)),\n            0,\n            1,\n            LpBinary,\n        )\n\n        # Total transfers made in a gameweek (absolute count)\n        transfers_made = LpVariable.dicts(\n            \"Transfers_Made\", range(1, num_gameweeks), 0, None, LpInteger\n        )\n        # Free transfers available at the start of a gameweek\n        free_transfers_available = LpVariable.dicts(\n            \"Free_Transfers_Available\",\n            range(num_gameweeks),\n            0,\n            MAX_FREE_TRANSFERS_SAVED + 1,\n            LpInteger,\n        )\n        # Number of transfer hits taken in a gameweek\n        transfer_hits = LpVariable.dicts(\n            \"Transfer_Hits\", range(1, num_gameweeks), 0, None, LpInteger\n        )\n\n        # Auxiliary variables for linearizing chip effects\n        is_bench_player = LpVariable.dicts(\n            \"Is_Bench_Player\",\n            (self.player_data.index, range(num_gameweeks)),\n            0,\n            1,\n            LpBinary,\n        )\n        actual_bench_boost_points = LpVariable.dicts(\n            \"Actual_Bench_Boost_Points\",\n            (self.player_data.index, range(num_gameweeks)),\n            0,\n            None,\n            LpContinuous,\n        )\n        actual_triple_captain_bonus = LpVariable.dicts(\n            \"Actual_Triple_Captain_Bonus\",\n            (self.player_data.index, range(num_gameweeks)),\n            0,\n            None,\n            LpContinuous,\n        )\n\n        # --- Objective Function ---\n        total_objective_points = []\n\n        # Get the first gameweek number from the player data to correctly index expected_points_by_gw\n        first_gw_key = next(\n            iter(\n                self.player_data.loc[\n                    self.player_data.index[0], \"expected_points_by_gw\"\n                ].keys()\n            )\n        )\n        current_gameweek_number_start = int(first_gw_key)\n\n        for w in range(num_gameweeks):\n            # The actual gameweek number (1-indexed)\n            gw_actual = current_gameweek_number_start + w\n\n            # Base expected points from the selected starting 11 for this gameweek\n            base_points_expression_gw = lpSum(\n                self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n                * starting_xi_vars[i][w]\n                for i in self.player_data.index\n            )\n            total_objective_points.append(base_points_expression_gw)\n\n            # Regular Captaincy points (additional 1x for captain)\n            captain_points_bonus_gw = lpSum(\n                self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n                * captain_var[i][w]\n                for i in self.player_data.index\n            )\n            total_objective_points.append(captain_points_bonus_gw)\n\n            # Define auxiliary variables and constraints for chips for each gameweek\n            for i in self.player_data.index:\n                # Use gameweek-specific player xP for chip calculations\n                player_xp = self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n\n                # Bench Boost auxiliary variables and constraints\n                self.problem += (\n                    is_bench_player[i][w] &lt;= player_vars[i][w],\n                    f\"IsBench_Squad_{i}_{w}\",\n                )\n                self.problem += (\n                    is_bench_player[i][w] &lt;= 1 - starting_xi_vars[i][w],\n                    f\"IsBench_NotStarter_{i}_{w}\",\n                )\n                self.problem += (\n                    is_bench_player[i][w]\n                    &gt;= player_vars[i][w] + (1 - starting_xi_vars[i][w]) - 1,\n                    f\"IsBench_Logical_{i}_{w}\",\n                )\n\n                self.problem += (\n                    actual_bench_boost_points[i][w]\n                    &lt;= player_xp * is_bench_player[i][w],\n                    f\"BenchBoost_Contr_1_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_bench_boost_points[i][w] &lt;= player_xp * use_bench_boost[w],\n                    f\"BenchBoost_Contr_2_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_bench_boost_points[i][w]\n                    &gt;= player_xp * (is_bench_player[i][w] + use_bench_boost[w] - 1),\n                    f\"BenchBoost_Contr_3_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_bench_boost_points[i][w] &gt;= 0,\n                    f\"BenchBoost_Contr_4_{i}_{w}\",\n                )\n\n                # Triple Captain auxiliary variables and constraints\n                # Changed player_xp * 2 to player_xp to reflect additional 1x bonus\n                self.problem += (\n                    actual_triple_captain_bonus[i][w] &lt;= player_xp * captain_var[i][w],\n                    f\"TripleCaptain_Contr_1_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_triple_captain_bonus[i][w]\n                    &lt;= player_xp * use_triple_captain[w],\n                    f\"TripleCaptain_Contr_2_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_triple_captain_bonus[i][w]\n                    &gt;= player_xp * (captain_var[i][w] + use_triple_captain[w] - 1),\n                    f\"TripleCaptain_Contr_3_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_triple_captain_bonus[i][w] &gt;= 0,\n                    f\"TripleCaptain_Contr_4_{i}_{w}\",\n                )\n\n            # Add points from bench boost and triple captain bonus for this gameweek\n            total_bench_boost_points_gw = lpSum(\n                actual_bench_boost_points[i][w] for i in self.player_data.index\n            )\n            total_triple_captain_bonus_points_gw = lpSum(\n                actual_triple_captain_bonus[i][w] for i in self.player_data.index\n            )\n\n            total_objective_points.append(total_bench_boost_points_gw)\n            total_objective_points.append(total_triple_captain_bonus_points_gw)\n\n        # Subtract transfer hits from the total objective\n        total_objective_points.append(\n            -POINTS_PER_HIT * lpSum(transfer_hits[w] for w in range(1, num_gameweeks))\n        )\n\n        self.problem += (\n            lpSum(total_objective_points),\n            \"Total Expected Points Over Gameweeks\",\n        )\n\n        # --- Constraints ---\n\n        # Apply constraints for each gameweek\n        for w in range(num_gameweeks):\n            # 1. Select exactly 15 players for the squad\n            self.problem += (\n                lpSum(player_vars[i][w] for i in self.player_data.index) == 15,\n                f\"Total_Players_GW{w}\",\n            )\n\n            # 2. Squad position constraints (2 GKs, 5 DEFs, 5 MIDs, 3 FWDs)\n            gks = self.player_data[self.player_data[\"position\"] == \"GK\"].index\n            defs = self.player_data[self.player_data[\"position\"] == \"DEF\"].index\n            mids = self.player_data[self.player_data[\"position\"] == \"MID\"].index\n            fwds = self.player_data[self.player_data[\"position\"] == \"FWD\"].index\n\n            self.problem += (\n                lpSum(player_vars[i][w] for i in gks) == 2,\n                f\"Goalkeepers_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(player_vars[i][w] for i in defs) == 5,\n                f\"Defenders_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(player_vars[i][w] for i in mids) == 5,\n                f\"Midfielders_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(player_vars[i][w] for i in fwds) == 3,\n                f\"Forwards_Count_GW{w}\",\n            )\n\n            # 3. Budget constraint\n            # This applies to the cost of the squad for the current gameweek.\n            self.problem += (\n                lpSum(\n                    self.player_data.loc[i, \"cost\"] * player_vars[i][w]\n                    for i in self.player_data.index\n                )\n                &lt;= budget,\n                f\"Total_Budget_GW{w}\",\n            )\n\n            # 4. Maximum players per team constraint\n            for team in self.player_data[\"team\"].unique():\n                team_players = self.player_data[self.player_data[\"team\"] == team].index\n                self.problem += (\n                    lpSum(player_vars[i][w] for i in team_players)\n                    &lt;= max_players_per_team,\n                    f\"Max_Players_from_{team}_GW{w}\",\n                )\n\n            # 5. Starting XI constraints\n            # 5.1 Select exactly 11 players for the starting XI\n            self.problem += (\n                lpSum(starting_xi_vars[i][w] for i in self.player_data.index) == 11,\n                f\"Total_Starting_XI_Players_GW{w}\",\n            )\n\n            # 5.2 A player can only be in the starting XI if they are in the squad\n            for i in self.player_data.index:\n                self.problem += (\n                    starting_xi_vars[i][w] &lt;= player_vars[i][w],\n                    f\"StartingXI_in_Squad_{i}_{w}\",\n                )\n\n            # 5.3 Starting XI position constraints (FPL allows flexible formations, so use minimums)\n            self.problem += (\n                lpSum(starting_xi_vars[i][w] for i in gks) == 1,\n                f\"Starting_Goalkeepers_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(starting_xi_vars[i][w] for i in defs) &gt;= 3,\n                f\"Min_Starting_Defenders_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(starting_xi_vars[i][w] for i in mids) &gt;= 2,\n                f\"Min_Starting_Midfielders_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(starting_xi_vars[i][w] for i in fwds) &gt;= 1,\n                f\"Min_Starting_Forwards_Count_GW{w}\",\n            )\n\n            # 6. Captain Constraints\n            # 6.1 Select exactly one captain from the starting XI\n            self.problem += (\n                lpSum(captain_var[i][w] for i in self.player_data.index) == 1,\n                f\"One_Captain_GW{w}\",\n            )\n\n            # 6.2 A player can only be captain if they are in the starting XI\n            for i in self.player_data.index:\n                self.problem += (\n                    captain_var[i][w] &lt;= starting_xi_vars[i][w],\n                    f\"Captain_in_StartingXI_{i}_{w}\",\n                )\n\n            # --- Enforced Player Constraints---\n            for player_idx in self.enforced_player_indices:\n                self.problem += (\n                    player_vars[player_idx][w] == 1,\n                    f\"Enforce_Player_{self.player_data.loc[player_idx, 'name']}_GW{w}\",\n                )\n\n            for team, position in self.enforced_team_pos_requirements:\n                # Filter players for the current team and position\n                team_pos_players = self.player_data[\n                    (self.player_data[\"team\"] == team)\n                    &amp; (self.player_data[\"position\"] == position)\n                ].index\n                if not team_pos_players.empty:\n                    self.problem += (\n                        lpSum(player_vars[i][w] for i in team_pos_players) &gt;= 1,\n                        f\"Enforce_One_{position}_from_{team}_GW{w}\",\n                    )\n                else:\n                    print(\n                        f\"Warning: No players found for enforced requirement: at least one {position} from {team} for GW{gw_actual}.\"\n                    )\n\n        # --- Chip Usage Constraints (TOTAL usage over all gameweeks) ---\n        # These constraints should be outside the per-gameweek loop to avoid duplicates.\n        self.problem += (\n            lpSum(use_bench_boost[j] for j in range(num_gameweeks))\n            &lt;= chip_allowances.get(\"bench_boost\", 0),\n            f\"Max_Bench_Boost_Usage_Total\",\n        )\n        self.problem += (\n            lpSum(use_triple_captain[j] for j in range(num_gameweeks))\n            &lt;= chip_allowances.get(\"triple_captain\", 0),\n            f\"Max_Triple_Captain_Usage_Total\",\n        )\n\n        # --- Inter-Gameweek Constraints (Transfers and Transfer Rules) ---\n        # Initialize free transfers for GW0 (first gameweek of optimization horizon)\n        # This assumes the optimization starts at GW0, and it has INITIAL_FREE_TRANSFERS.\n        # If the model starts at an arbitrary GW, this would need to be an input.\n        self.problem += (\n            free_transfers_available[0] == INITIAL_FREE_TRANSFERS,\n            f\"Initial_Free_Transfers_GW0\",\n        )\n\n        for w in range(1, num_gameweeks):\n            # Calculate total transfers made in this gameweek\n            self.problem += (\n                transfers_made[w]\n                == lpSum(transfer_in_vars[i][w] for i in self.player_data.index),\n                f\"Transfers_Made_GW{w}\",\n            )\n            # Total transfers in must equal total transfers out for each gameweek after the first\n            self.problem += (\n                lpSum(transfer_in_vars[i][w] for i in self.player_data.index)\n                == lpSum(transfer_out_vars[i][w] for i in self.player_data.index),\n                f\"Transfers_In_Equals_Out_GW{w}\",\n            )\n\n            # Calculate free transfers available for the current gameweek (w)\n            # Free transfers for GW_w = min(free transfers from GW_w-1 - transfers made in GW_w + 1, MAX_FREE_TRANSFERS_SAVED + 1)\n            # The + 1 in MAX_FREE_TRANSFERS_SAVED + 1 is because MAX_FREE_TRANSFERS_SAVED implies how many can be *saved*,\n            # so if you save 1, you have 1 (current) + 1 (saved) = 2.\n            self.problem += (\n                free_transfers_available[w]\n                &lt;= free_transfers_available[w - 1] - transfers_made[w] + 1,\n                f\"Free_Transfers_Calc_1_GW{w}\",\n            )\n            self.problem += (\n                free_transfers_available[w] &lt;= MAX_FREE_TRANSFERS_SAVED + 1,\n                f\"Free_Transfers_Calc_2_GW{w}\",\n            )\n            self.problem += (\n                free_transfers_available[w] &gt;= 0,  # Cannot have negative free transfers\n                f\"Free_Transfers_Non_Negative_GW{w}\",\n            )\n\n            # Calculate transfer hits\n            # transfer_hits[w] = max(0, transfers_made[w] - free_transfers_available_at_start_of_gw_w)\n            # This needs to be linearized. If transfers_made[w] &gt; free_transfers_available[w-1], then hit.\n            # free_transfers_available[w-1] represents transfers available *before* making transfers for GW_w\n            self.problem += (\n                transfer_hits[w] &gt;= transfers_made[w] - free_transfers_available[w - 1],\n                f\"Transfer_Hits_Calc_1_GW{w}\",\n            )\n            self.problem += (\n                transfer_hits[w] &gt;= 0,\n                f\"Transfer_Hits_Calc_2_GW{w}\",\n            )\n\n            for i in self.player_data.index:\n                # Squad continuity: player_vars[i][w] (in squad at start of GW w)\n                #                 = player_vars[i][w-1] (in squad at start of GW w-1)\n                #                 - transfer_out_vars[i][w] (transferred out for GW w)\n                #                 + transfer_in_vars[i][w] (transferred in for GW w)\n                self.problem += (\n                    player_vars[i][w]\n                    == player_vars[i][w - 1]\n                    - transfer_out_vars[i][w]\n                    + transfer_in_vars[i][w],\n                    f\"Squad_Continuity_{i}_GW{w}\",\n                )\n                # A player cannot be transferred in and out in the same gameweek\n                self.problem += (\n                    transfer_in_vars[i][w] + transfer_out_vars[i][w] &lt;= 1,\n                    f\"No_Simultaneous_Transfer_{i}_{w}\",\n                )\n\n        try:\n            # The solver is called with the GLPK_CMD solver\n            self.problem.solve(PULP_CBC_CMD(msg=0))  # msg=0 suppresses verbose output\n        except Exception as e:\n            print(f\"Error solving the problem: {e}\")\n            return False\n\n        if LpStatus[self.problem.status] == \"Optimal\":\n            print(\"Optimization successful! Optimal solution found.\")\n\n            self.selected_squad_history = {}\n            self.total_transfer_hits = 0\n            for w in range(num_gameweeks):\n                # The actual gameweek number (1-indexed)\n                gw_actual = current_gameweek_number_start + w\n\n                # Get selected players for the current gameweek\n                selected_squad_gw = self.player_data[\n                    [player_vars[i][w].varValue == 1 for i in self.player_data.index]\n                ].copy()\n\n                # Get starter and captain info for this gameweek\n                is_starter_series_gw = pd.Series(\n                    [\n                        starting_xi_vars[i][w].varValue == 1\n                        for i in self.player_data.index\n                    ],\n                    index=self.player_data.index,\n                )\n                is_captain_series_gw = pd.Series(\n                    [captain_var[i][w].varValue == 1 for i in self.player_data.index],\n                    index=self.player_data.index,\n                )\n\n                selected_squad_gw[\"is_starter\"] = is_starter_series_gw.loc[\n                    selected_squad_gw.index\n                ]\n                selected_squad_gw[\"is_captain\"] = is_captain_series_gw.loc[\n                    selected_squad_gw.index\n                ]\n\n                transfers_in_gw = 0\n                transfers_out_gw = 0\n                hits_gw = 0\n\n                # Store transfer details for gameweeks &gt; 0\n                if (\n                    w &gt; 0\n                ):  # Check for transfers only from GW1 onwards (index 1 in 0-indexed loop)\n                    transfer_in_flags = pd.Series(\n                        [\n                            transfer_in_vars[i][w].varValue == 1\n                            for i in self.player_data.index\n                        ],\n                        index=self.player_data.index,\n                    )\n                    transfer_out_flags = pd.Series(\n                        [\n                            transfer_out_vars[i][w].varValue == 1\n                            for i in self.player_data.index\n                        ],\n                        index=self.player_data.index,\n                    )\n\n                    selected_squad_gw[\"transfer_in\"] = transfer_in_flags.loc[\n                        selected_squad_gw.index\n                    ]\n                    selected_squad_gw[\"transfer_out\"] = transfer_out_flags.loc[\n                        selected_squad_gw.index\n                    ]\n\n                    transfers_in_gw = int(round(transfer_in_flags.sum()))\n                    transfers_out_gw = int(round(transfer_out_flags.sum()))\n                    hits_gw = int(round(transfer_hits[w].varValue))\n                    self.total_transfer_hits += hits_gw\n                else:\n                    selected_squad_gw[\"transfer_in\"] = False  # No transfers in for GW0\n                    selected_squad_gw[\"transfer_out\"] = (\n                        False  # No transfers out for GW0\n                    )\n\n                self.selected_squad_history[f\"GW{gw_actual}\"] = {\n                    \"squad\": selected_squad_gw,\n                    \"total_cost\": selected_squad_gw[\"cost\"].sum(),\n                    \"expected_points_from_xi\": sum(\n                        self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n                        * starting_xi_vars[i][w].varValue\n                        for i in self.player_data.index\n                    ),\n                    \"bench_boost_used\": bool(use_bench_boost[w].varValue),\n                    \"triple_captain_used\": bool(use_triple_captain[w].varValue),\n                    \"total_bench_boost_points\": value(\n                        lpSum(\n                            actual_bench_boost_points[i][w]\n                            for i in self.player_data.index\n                        )\n                    ),\n                    \"total_triple_captain_bonus\": value(\n                        lpSum(\n                            actual_triple_captain_bonus[i][w]\n                            for i in self.player_data.index\n                        )\n                    ),\n                    \"transfers_in_count\": transfers_in_gw,\n                    \"transfers_out_count\": transfers_out_gw,\n                    \"transfer_hits\": hits_gw,  # New\n                    \"free_transfers_available_next_gw\": (\n                        int(round(free_transfers_available[w].varValue))\n                        if w &lt; num_gameweeks - 1\n                        else 0\n                    ),  # Free transfers available *after* this GW's transfers are made\n                }\n\n            # Overall totals\n            self.total_cost = self.selected_squad_history[\n                f\"GW{current_gameweek_number_start + num_gameweeks - 1}\"\n            ][\n                \"total_cost\"\n            ]  # Cost of final squad\n            self.total_expected_points = value(\n                self.problem.objective\n            )  # Total objective value from solver\n            self.used_chips = {\n                f\"GW{current_gameweek_number_start + w}\": {\n                    \"bench_boost\": bool(use_bench_boost[w].varValue),\n                    \"triple_captain\": bool(use_triple_captain[w].varValue),\n                }\n                for w in range(num_gameweeks)\n            }\n\n            return True\n        else:\n            print(f\"No optimal solution found. Status: {LpStatus[self.problem.status]}\")\n            self.selected_squad_history = {}\n            self.total_cost = 0\n            self.total_expected_points = 0\n            self.used_chips = {}\n            self.total_transfer_hits = 0\n            return False\n\n    def get_selected_squad(self, gameweek: int = None) -&gt; pd.DataFrame | None:\n        \"\"\"\n        Returns the selected squad for a specific gameweek (1-indexed).\n        If no gameweek is specified, returns the squad for the last optimized gameweek.\n        \"\"\"\n        if not self.selected_squad_history:\n            return None\n\n        # Get the first GW key to determine the range of available GWs\n        first_gw_in_history = min(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n        last_gw_in_history = max(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n\n        if gameweek is None:\n            return self.selected_squad_history[f\"GW{last_gw_in_history}\"][\"squad\"]\n\n        if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n            print(\n                f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n            )\n            return None\n\n        return self.selected_squad_history.get(f\"GW{gameweek}\", {}).get(\"squad\")\n\n    def get_total_cost(self, gameweek: int = None) -&gt; float:\n        \"\"\"\n        Returns the total cost for a specific gameweek (1-indexed).\n        If no gameweek is specified, returns the cost of the squad in the last optimized gameweek.\n        \"\"\"\n        if not self.selected_squad_history:\n            return 0\n        first_gw_in_history = min(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n        last_gw_in_history = max(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n\n        if gameweek is None:\n            return self.selected_squad_history[f\"GW{last_gw_in_history}\"][\"total_cost\"]\n\n        if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n            print(\n                f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n            )\n            return 0  # Or raise an error\n\n        return self.selected_squad_history.get(f\"GW{gameweek}\", {}).get(\"total_cost\", 0)\n\n    def get_total_expected_points(self) -&gt; float:\n        \"\"\"\n        Returns the overall total expected points across all optimized gameweeks.\n        \"\"\"\n        return self.total_expected_points\n\n    def get_gameweek_summary(self, gameweek: int):\n        \"\"\"\n        Returns a dictionary summary for a specific gameweek.\n        \"\"\"\n        if not self.selected_squad_history:\n            return None\n        first_gw_in_history = min(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n        last_gw_in_history = max(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n\n        if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n            print(\n                f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n            )\n            return None\n\n        return self.selected_squad_history.get(f\"GW{gameweek}\")\n\n    def print_squad_summary(self, gameweek: int):\n        \"\"\"\n        Prints a formatted summary of the selected squad for a specific gameweek.\n        \"\"\"\n        if not self.selected_squad_history:\n            print(\"No squad has been selected yet. Run the 'solve' method first.\")\n            return\n\n        gw_data = self.get_gameweek_summary(gameweek)\n        if not gw_data:\n            return  # get_gameweek_summary already prints error message\n\n        selected_squad = gw_data[\"squad\"]\n        total_cost = gw_data[\"total_cost\"]\n        expected_points_from_xi = gw_data[\"expected_points_from_xi\"]\n        bench_boost_used = gw_data[\"bench_boost_used\"]\n        triple_captain_used = gw_data[\"triple_captain_used\"]\n        total_bench_boost_points = gw_data[\"total_bench_boost_points\"]\n        total_triple_captain_bonus = gw_data[\"total_triple_captain_bonus\"]\n        transfers_in_count = gw_data[\"transfers_in_count\"]  # New\n        transfers_out_count = gw_data[\"transfers_out_count\"]  # New\n        transfer_hits_taken = gw_data[\"transfer_hits\"]  # New\n        free_transfers_available_next_gw = gw_data[\n            \"free_transfers_available_next_gw\"\n        ]  # New\n\n        print(f\"\\n--- FPL Optimized Squad for Gameweek {gameweek} ---\")\n        print(f\"Squad Cost: \u00a3{total_cost:.1f}m\")\n        print(f\"Expected Points (Starting XI): {expected_points_from_xi:.2f}\")\n        print(\n            f\"Total Expected Points for GW{gameweek} (including chips): {expected_points_from_xi + total_bench_boost_points + total_triple_captain_bonus:.2f}\"\n        )\n        print(\"\\n--- Chips Used This Gameweek ---\")\n        if bench_boost_used:\n            print(f\"- Bench Boost (Added {total_bench_boost_points:.2f} points)\")\n        if triple_captain_used:\n            print(\n                f\"- Triple Captain (Added {total_triple_captain_bonus:.2f} bonus points)\"\n            )\n        if not (bench_boost_used or triple_captain_used):\n            print(\"No chips used this gameweek.\")\n\n        print(\"\\n--- Goalkeepers (Starting XI marked with *) ---\")\n        for index, row in selected_squad[selected_squad[\"position\"] == \"GK\"].iterrows():\n            starter_str = \"*\" if row[\"is_starter\"] else \"\"\n            captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n            transfer_status = \"\"\n            if row[\"transfer_in\"]:\n                transfer_status = \"(IN)\"\n            elif row[\"transfer_out\"]:\n                transfer_status = \"(OUT)\"\n\n            # Access gameweek-specific xP correctly\n            player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n            print(\n                f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n            )\n        print(\"\\n--- Defenders (Starting XI marked with *) ---\")\n        for index, row in selected_squad[\n            selected_squad[\"position\"] == \"DEF\"\n        ].iterrows():\n            starter_str = \"*\" if row[\"is_starter\"] else \"\"\n            captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n            transfer_status = \"\"\n            if row[\"transfer_in\"]:\n                transfer_status = \"(IN)\"\n            elif row[\"transfer_out\"]:\n                transfer_status = \"(OUT)\"\n\n            player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n            print(\n                f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n            )\n        print(\"\\n--- Midfielders (Starting XI marked with *) ---\")\n        for index, row in selected_squad[\n            selected_squad[\"position\"] == \"MID\"\n        ].iterrows():\n            starter_str = \"*\" if row[\"is_starter\"] else \"\"\n            captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n            transfer_status = \"\"\n            if row[\"transfer_in\"]:\n                transfer_status = \"(IN)\"\n            elif row[\"transfer_out\"]:\n                transfer_status = \"(OUT)\"\n\n            player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n            print(\n                f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n            )\n        print(\"\\n--- Forwards (Starting XI marked with *) ---\")\n        for index, row in selected_squad[\n            selected_squad[\"position\"] == \"FWD\"\n        ].iterrows():\n            starter_str = \"*\" if row[\"is_starter\"] else \"\"\n            captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n            transfer_status = \"\"\n            if row[\"transfer_in\"]:\n                transfer_status = \"(IN)\"\n            elif row[\"transfer_out\"]:\n                transfer_status = \"(OUT)\"\n\n            player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n            print(\n                f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n            )\n\n        print(f\"\\n--- Team Breakdown for GW{gameweek} ---\")\n        print(selected_squad[\"team\"].value_counts())\n\n        # Transfers are relevant from Gameweek 2 (index 1) onwards in the optimization horizon\n        # For display, if the current GW is the initial one (GW1 in the current context), no transfers are made\n        # If it's a subsequent GW, check if transfers occurred.\n        first_gw_in_history = min(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n        if (\n            gameweek &gt;= first_gw_in_history\n        ):  # Changed from &gt; to &gt;=, to show initial free transfers\n            # Display transfer info for this gameweek\n            print(\n                f\"  Transfers In: {transfers_in_count}, Transfers Out: {transfers_out_count}\"\n            )\n            print(\n                f\"  Transfer Hits: {transfer_hits_taken} (-{transfer_hits_taken * POINTS_PER_HIT} points)\"\n            )\n            # Only show free transfers for the *next* gameweek if it's not the last gameweek in the horizon\n            if gameweek &lt; max(\n                int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n            ):\n                print(\n                    f\"  Free Transfers Available for Next GW: {free_transfers_available_next_gw}\"\n                )\n        print(\"---------------------------\\n\")\n\n    def print_overall_summary(self):\n        \"\"\"\n        Prints an overall summary of the multi-week optimization results.\n        \"\"\"\n        if not self.selected_squad_history:\n            print(\"No optimization results to summarize.\")\n            return\n\n        print(\"\\n=== Overall Multi-Week FPL Optimization Summary ===\")\n        print(\n            f\"Total Expected Points Across All Gameweeks: {self.total_expected_points:.2f}\"\n        )\n\n        # Get the latest gameweek's cost\n        last_gw_key = max(\n            self.selected_squad_history.keys(), key=lambda k: int(k.replace(\"GW\", \"\"))\n        )\n        print(\n            f\"Squad Cost ({last_gw_key}): \u00a3{self.selected_squad_history[last_gw_key]['total_cost']:.1f}m\"\n        )\n        print(\n            f\"Total Transfer Hits Taken: {self.total_transfer_hits} (-{self.total_transfer_hits * POINTS_PER_HIT} points)\"\n        )\n\n        print(\"\\n--- Chip Usage Across Gameweeks ---\")\n        # Ensure consistent order by sorting gameweek keys\n        sorted_gw_keys = sorted(\n            self.used_chips.keys(), key=lambda k: int(k.replace(\"GW\", \"\"))\n        )\n        for gw_str in sorted_gw_keys:\n            chips = self.used_chips[gw_str]\n            chip_summary = []\n            if chips[\"bench_boost\"]:\n                chip_summary.append(\"Bench Boost\")\n            if chips[\"triple_captain\"]:\n                chip_summary.append(\"Triple Captain\")\n\n            if chip_summary:\n                print(f\"{gw_str}: {', '.join(chip_summary)}\")\n            else:\n                print(f\"{gw_str}: No chips used\")\n\n        print(\"\\n--- Gameweek-by-Gameweek Summary ---\")\n        # Iterate and print basic summary for each gameweek\n        for gw_str in sorted_gw_keys:\n            gw_data = self.selected_squad_history[gw_str]\n            print(f\"\\n--- {gw_str} ---\")\n            print(f\"  Squad Cost: \u00a3{gw_data['total_cost']:.1f}m\")\n            print(\n                f\"  Expected Points (Starting XI): {gw_data['expected_points_from_xi']:.2f}\"\n            )\n            print(\n                f\"  Total GW Points (incl. chips): {gw_data['expected_points_from_xi'] + gw_data['total_bench_boost_points'] + gw_data['total_triple_captain_bonus']:.2f}\"\n            )\n\n            # Display transfer info for this gameweek\n            transfers_in_count = gw_data[\"transfers_in_count\"]\n            transfers_out_count = gw_data[\"transfers_out_count\"]\n            transfer_hits_taken = gw_data[\"transfer_hits\"]\n            free_transfers_available_next_gw = gw_data[\n                \"free_transfers_available_next_gw\"\n            ]\n\n            print(\n                f\"  Transfers In: {transfers_in_count}, Transfers Out: {transfers_out_count}\"\n            )\n            print(\n                f\"  Transfer Hits: {transfer_hits_taken} (-{transfer_hits_taken * POINTS_PER_HIT} points)\"\n            )\n            # Only show free transfers for the *next* gameweek if it's not the last gameweek in the horizon\n            if int(gw_str.replace(\"GW\", \"\")) &lt; max(\n                int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n            ):\n                print(\n                    f\"  Free Transfers Available for Next GW: {free_transfers_available_next_gw}\"\n                )\n            print(\"-----------------------------------\")\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/#build.lib.fpl_solver.solver.FPLOptimizer.__init__","title":"<code>__init__(player_data)</code>","text":"<p>Initializes the FPLOptimizer with player data.</p> <p>Parameters:</p> Name Type Description Default <code>player_data</code> <code>DataFrame</code> <p>A DataFrame containing player information                         with columns: 'name', 'team', 'position',                         'cost', 'expected_points_by_gw' (a dict of xP per GW).</p> required Source code in <code>build/lib/fpl_solver/solver.py</code> <pre><code>def __init__(self, player_data: pd.DataFrame):\n    \"\"\"\n    Initializes the FPLOptimizer with player data.\n\n    Args:\n        player_data (pd.DataFrame): A DataFrame containing player information\n                                    with columns: 'name', 'team', 'position',\n                                    'cost', 'expected_points_by_gw' (a dict of xP per GW).\n    \"\"\"\n    required_columns = [\"name\", \"team\", \"position\", \"cost\", \"expected_points_by_gw\"]\n    if not all(col in player_data.columns for col in required_columns):\n        missing_cols = [\n            col for col in required_columns if col not in player_data.columns\n        ]\n        raise ValueError(\n            f\"player_data DataFrame must contain {required_columns} columns. Missing: {missing_cols}\"\n        )\n\n    self.player_data = player_data\n    self.problem = None\n    self.selected_squad_history = {}  # To store squad for each gameweek\n    self.total_cost = 0\n    self.total_expected_points = 0\n    self.total_transfer_hits = 0\n\n    # --- Process Enforced Players ---\n    self.enforced_player_indices = set()\n    self.enforced_team_pos_requirements = []\n\n    print(\"\\n--- Processing Enforced Players ---\")\n\n    # Enforce by Player ID\n    for player_id in ENFORCED_PLAYERS_BY_ID:\n        found_player = self.player_data[self.player_data[\"id\"] == player_id]\n        if not found_player.empty:\n            player_idx = found_player.index[0]\n            self.enforced_player_indices.add(player_idx)\n            print(\n                f\"Enforcing player by ID: {found_player.loc[player_idx, 'name']} (ID: {player_id})\"\n            )\n        else:\n            print(\n                f\"Warning: Enforced player with ID {player_id} not found in data.\"\n            )\n\n    # Enforce by Player Name\n    for player_name in ENFORCED_PLAYERS_BY_NAME:\n        found_player = self.player_data[self.player_data[\"name\"] == player_name]\n        if not found_player.empty:\n            player_idx = found_player.index[0]\n            self.enforced_player_indices.add(player_idx)\n            print(f\"Enforcing player by name: {player_name}\")\n        else:\n            print(f\"Warning: Enforced player '{player_name}' not found in data.\")\n\n    # Enforce by Team and Position\n    for requirement in ENFORCED_PLAYERS_BY_TEAM_AND_POSITION:\n        team = requirement.get(\"team\")\n        position = requirement.get(\"position\")\n        if team and position:\n            # Validate team and position exist in data\n            if team not in self.player_data[\"team\"].unique():\n                print(\n                    f\"Warning: Enforced team '{team}' for position '{position}' not found in data.\"\n                )\n                continue\n            if position not in self.player_data[\"position\"].unique():\n                print(\n                    f\"Warning: Enforced position '{position}' for team '{team}' not found in data.\"\n                )\n                continue\n\n            self.enforced_team_pos_requirements.append((team, position))\n            print(f\"Enforcing at least one {position} from {team}.\")\n        else:\n            print(\n                f\"Warning: Invalid enforced team/position requirement: {requirement}\"\n            )\n\n    if not (\n        self.enforced_player_indices\n        or self.enforced_team_pos_requirements\n        or ENFORCED_PLAYERS_BY_ID\n        or ENFORCED_PLAYERS_BY_NAME\n        or ENFORCED_PLAYERS_BY_TEAM_AND_POSITION\n    ):\n        print(\"No players or team/position combinations are enforced.\")\n    print(\"-----------------------------------\\n\")\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/#build.lib.fpl_solver.solver.FPLOptimizer.get_gameweek_summary","title":"<code>get_gameweek_summary(gameweek)</code>","text":"<p>Returns a dictionary summary for a specific gameweek.</p> Source code in <code>build/lib/fpl_solver/solver.py</code> <pre><code>def get_gameweek_summary(self, gameweek: int):\n    \"\"\"\n    Returns a dictionary summary for a specific gameweek.\n    \"\"\"\n    if not self.selected_squad_history:\n        return None\n    first_gw_in_history = min(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n    last_gw_in_history = max(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n\n    if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n        print(\n            f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n        )\n        return None\n\n    return self.selected_squad_history.get(f\"GW{gameweek}\")\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/#build.lib.fpl_solver.solver.FPLOptimizer.get_selected_squad","title":"<code>get_selected_squad(gameweek=None)</code>","text":"<p>Returns the selected squad for a specific gameweek (1-indexed). If no gameweek is specified, returns the squad for the last optimized gameweek.</p> Source code in <code>build/lib/fpl_solver/solver.py</code> <pre><code>def get_selected_squad(self, gameweek: int = None) -&gt; pd.DataFrame | None:\n    \"\"\"\n    Returns the selected squad for a specific gameweek (1-indexed).\n    If no gameweek is specified, returns the squad for the last optimized gameweek.\n    \"\"\"\n    if not self.selected_squad_history:\n        return None\n\n    # Get the first GW key to determine the range of available GWs\n    first_gw_in_history = min(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n    last_gw_in_history = max(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n\n    if gameweek is None:\n        return self.selected_squad_history[f\"GW{last_gw_in_history}\"][\"squad\"]\n\n    if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n        print(\n            f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n        )\n        return None\n\n    return self.selected_squad_history.get(f\"GW{gameweek}\", {}).get(\"squad\")\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/#build.lib.fpl_solver.solver.FPLOptimizer.get_total_cost","title":"<code>get_total_cost(gameweek=None)</code>","text":"<p>Returns the total cost for a specific gameweek (1-indexed). If no gameweek is specified, returns the cost of the squad in the last optimized gameweek.</p> Source code in <code>build/lib/fpl_solver/solver.py</code> <pre><code>def get_total_cost(self, gameweek: int = None) -&gt; float:\n    \"\"\"\n    Returns the total cost for a specific gameweek (1-indexed).\n    If no gameweek is specified, returns the cost of the squad in the last optimized gameweek.\n    \"\"\"\n    if not self.selected_squad_history:\n        return 0\n    first_gw_in_history = min(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n    last_gw_in_history = max(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n\n    if gameweek is None:\n        return self.selected_squad_history[f\"GW{last_gw_in_history}\"][\"total_cost\"]\n\n    if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n        print(\n            f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n        )\n        return 0  # Or raise an error\n\n    return self.selected_squad_history.get(f\"GW{gameweek}\", {}).get(\"total_cost\", 0)\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/#build.lib.fpl_solver.solver.FPLOptimizer.get_total_expected_points","title":"<code>get_total_expected_points()</code>","text":"<p>Returns the overall total expected points across all optimized gameweeks.</p> Source code in <code>build/lib/fpl_solver/solver.py</code> <pre><code>def get_total_expected_points(self) -&gt; float:\n    \"\"\"\n    Returns the overall total expected points across all optimized gameweeks.\n    \"\"\"\n    return self.total_expected_points\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/#build.lib.fpl_solver.solver.FPLOptimizer.print_overall_summary","title":"<code>print_overall_summary()</code>","text":"<p>Prints an overall summary of the multi-week optimization results.</p> Source code in <code>build/lib/fpl_solver/solver.py</code> <pre><code>def print_overall_summary(self):\n    \"\"\"\n    Prints an overall summary of the multi-week optimization results.\n    \"\"\"\n    if not self.selected_squad_history:\n        print(\"No optimization results to summarize.\")\n        return\n\n    print(\"\\n=== Overall Multi-Week FPL Optimization Summary ===\")\n    print(\n        f\"Total Expected Points Across All Gameweeks: {self.total_expected_points:.2f}\"\n    )\n\n    # Get the latest gameweek's cost\n    last_gw_key = max(\n        self.selected_squad_history.keys(), key=lambda k: int(k.replace(\"GW\", \"\"))\n    )\n    print(\n        f\"Squad Cost ({last_gw_key}): \u00a3{self.selected_squad_history[last_gw_key]['total_cost']:.1f}m\"\n    )\n    print(\n        f\"Total Transfer Hits Taken: {self.total_transfer_hits} (-{self.total_transfer_hits * POINTS_PER_HIT} points)\"\n    )\n\n    print(\"\\n--- Chip Usage Across Gameweeks ---\")\n    # Ensure consistent order by sorting gameweek keys\n    sorted_gw_keys = sorted(\n        self.used_chips.keys(), key=lambda k: int(k.replace(\"GW\", \"\"))\n    )\n    for gw_str in sorted_gw_keys:\n        chips = self.used_chips[gw_str]\n        chip_summary = []\n        if chips[\"bench_boost\"]:\n            chip_summary.append(\"Bench Boost\")\n        if chips[\"triple_captain\"]:\n            chip_summary.append(\"Triple Captain\")\n\n        if chip_summary:\n            print(f\"{gw_str}: {', '.join(chip_summary)}\")\n        else:\n            print(f\"{gw_str}: No chips used\")\n\n    print(\"\\n--- Gameweek-by-Gameweek Summary ---\")\n    # Iterate and print basic summary for each gameweek\n    for gw_str in sorted_gw_keys:\n        gw_data = self.selected_squad_history[gw_str]\n        print(f\"\\n--- {gw_str} ---\")\n        print(f\"  Squad Cost: \u00a3{gw_data['total_cost']:.1f}m\")\n        print(\n            f\"  Expected Points (Starting XI): {gw_data['expected_points_from_xi']:.2f}\"\n        )\n        print(\n            f\"  Total GW Points (incl. chips): {gw_data['expected_points_from_xi'] + gw_data['total_bench_boost_points'] + gw_data['total_triple_captain_bonus']:.2f}\"\n        )\n\n        # Display transfer info for this gameweek\n        transfers_in_count = gw_data[\"transfers_in_count\"]\n        transfers_out_count = gw_data[\"transfers_out_count\"]\n        transfer_hits_taken = gw_data[\"transfer_hits\"]\n        free_transfers_available_next_gw = gw_data[\n            \"free_transfers_available_next_gw\"\n        ]\n\n        print(\n            f\"  Transfers In: {transfers_in_count}, Transfers Out: {transfers_out_count}\"\n        )\n        print(\n            f\"  Transfer Hits: {transfer_hits_taken} (-{transfer_hits_taken * POINTS_PER_HIT} points)\"\n        )\n        # Only show free transfers for the *next* gameweek if it's not the last gameweek in the horizon\n        if int(gw_str.replace(\"GW\", \"\")) &lt; max(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        ):\n            print(\n                f\"  Free Transfers Available for Next GW: {free_transfers_available_next_gw}\"\n            )\n        print(\"-----------------------------------\")\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/#build.lib.fpl_solver.solver.FPLOptimizer.print_squad_summary","title":"<code>print_squad_summary(gameweek)</code>","text":"<p>Prints a formatted summary of the selected squad for a specific gameweek.</p> Source code in <code>build/lib/fpl_solver/solver.py</code> <pre><code>def print_squad_summary(self, gameweek: int):\n    \"\"\"\n    Prints a formatted summary of the selected squad for a specific gameweek.\n    \"\"\"\n    if not self.selected_squad_history:\n        print(\"No squad has been selected yet. Run the 'solve' method first.\")\n        return\n\n    gw_data = self.get_gameweek_summary(gameweek)\n    if not gw_data:\n        return  # get_gameweek_summary already prints error message\n\n    selected_squad = gw_data[\"squad\"]\n    total_cost = gw_data[\"total_cost\"]\n    expected_points_from_xi = gw_data[\"expected_points_from_xi\"]\n    bench_boost_used = gw_data[\"bench_boost_used\"]\n    triple_captain_used = gw_data[\"triple_captain_used\"]\n    total_bench_boost_points = gw_data[\"total_bench_boost_points\"]\n    total_triple_captain_bonus = gw_data[\"total_triple_captain_bonus\"]\n    transfers_in_count = gw_data[\"transfers_in_count\"]  # New\n    transfers_out_count = gw_data[\"transfers_out_count\"]  # New\n    transfer_hits_taken = gw_data[\"transfer_hits\"]  # New\n    free_transfers_available_next_gw = gw_data[\n        \"free_transfers_available_next_gw\"\n    ]  # New\n\n    print(f\"\\n--- FPL Optimized Squad for Gameweek {gameweek} ---\")\n    print(f\"Squad Cost: \u00a3{total_cost:.1f}m\")\n    print(f\"Expected Points (Starting XI): {expected_points_from_xi:.2f}\")\n    print(\n        f\"Total Expected Points for GW{gameweek} (including chips): {expected_points_from_xi + total_bench_boost_points + total_triple_captain_bonus:.2f}\"\n    )\n    print(\"\\n--- Chips Used This Gameweek ---\")\n    if bench_boost_used:\n        print(f\"- Bench Boost (Added {total_bench_boost_points:.2f} points)\")\n    if triple_captain_used:\n        print(\n            f\"- Triple Captain (Added {total_triple_captain_bonus:.2f} bonus points)\"\n        )\n    if not (bench_boost_used or triple_captain_used):\n        print(\"No chips used this gameweek.\")\n\n    print(\"\\n--- Goalkeepers (Starting XI marked with *) ---\")\n    for index, row in selected_squad[selected_squad[\"position\"] == \"GK\"].iterrows():\n        starter_str = \"*\" if row[\"is_starter\"] else \"\"\n        captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n        transfer_status = \"\"\n        if row[\"transfer_in\"]:\n            transfer_status = \"(IN)\"\n        elif row[\"transfer_out\"]:\n            transfer_status = \"(OUT)\"\n\n        # Access gameweek-specific xP correctly\n        player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n        print(\n            f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n        )\n    print(\"\\n--- Defenders (Starting XI marked with *) ---\")\n    for index, row in selected_squad[\n        selected_squad[\"position\"] == \"DEF\"\n    ].iterrows():\n        starter_str = \"*\" if row[\"is_starter\"] else \"\"\n        captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n        transfer_status = \"\"\n        if row[\"transfer_in\"]:\n            transfer_status = \"(IN)\"\n        elif row[\"transfer_out\"]:\n            transfer_status = \"(OUT)\"\n\n        player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n        print(\n            f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n        )\n    print(\"\\n--- Midfielders (Starting XI marked with *) ---\")\n    for index, row in selected_squad[\n        selected_squad[\"position\"] == \"MID\"\n    ].iterrows():\n        starter_str = \"*\" if row[\"is_starter\"] else \"\"\n        captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n        transfer_status = \"\"\n        if row[\"transfer_in\"]:\n            transfer_status = \"(IN)\"\n        elif row[\"transfer_out\"]:\n            transfer_status = \"(OUT)\"\n\n        player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n        print(\n            f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n        )\n    print(\"\\n--- Forwards (Starting XI marked with *) ---\")\n    for index, row in selected_squad[\n        selected_squad[\"position\"] == \"FWD\"\n    ].iterrows():\n        starter_str = \"*\" if row[\"is_starter\"] else \"\"\n        captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n        transfer_status = \"\"\n        if row[\"transfer_in\"]:\n            transfer_status = \"(IN)\"\n        elif row[\"transfer_out\"]:\n            transfer_status = \"(OUT)\"\n\n        player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n        print(\n            f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n        )\n\n    print(f\"\\n--- Team Breakdown for GW{gameweek} ---\")\n    print(selected_squad[\"team\"].value_counts())\n\n    # Transfers are relevant from Gameweek 2 (index 1) onwards in the optimization horizon\n    # For display, if the current GW is the initial one (GW1 in the current context), no transfers are made\n    # If it's a subsequent GW, check if transfers occurred.\n    first_gw_in_history = min(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n    if (\n        gameweek &gt;= first_gw_in_history\n    ):  # Changed from &gt; to &gt;=, to show initial free transfers\n        # Display transfer info for this gameweek\n        print(\n            f\"  Transfers In: {transfers_in_count}, Transfers Out: {transfers_out_count}\"\n        )\n        print(\n            f\"  Transfer Hits: {transfer_hits_taken} (-{transfer_hits_taken * POINTS_PER_HIT} points)\"\n        )\n        # Only show free transfers for the *next* gameweek if it's not the last gameweek in the horizon\n        if gameweek &lt; max(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        ):\n            print(\n                f\"  Free Transfers Available for Next GW: {free_transfers_available_next_gw}\"\n            )\n    print(\"---------------------------\\n\")\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/#build.lib.fpl_solver.solver.FPLOptimizer.solve","title":"<code>solve(budget, max_players_per_team, chip_allowances, num_gameweeks)</code>","text":"<p>Solves the FPL optimization problem using PuLP.</p> <p>Parameters:</p> Name Type Description Default <code>budget</code> <code>float</code> <p>The maximum budget in millions of pounds.</p> required <code>max_players_per_team</code> <code>int</code> <p>The maximum number of players allowed from                         any single Premier League team.</p> required <code>chip_allowances</code> <code>dict</code> <p>A dictionary specifying the maximum usage for each chip.</p> required <code>num_gameweeks</code> <code>int</code> <p>The number of gameweeks to optimize over.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if a solution was found, False otherwise.</p> Source code in <code>build/lib/fpl_solver/solver.py</code> <pre><code>def solve(\n    self,\n    budget: float,\n    max_players_per_team: int,\n    chip_allowances: dict,\n    num_gameweeks: int,\n) -&gt; bool:\n    \"\"\"\n    Solves the FPL optimization problem using PuLP.\n\n    Args:\n        budget (float): The maximum budget in millions of pounds.\n        max_players_per_team (int): The maximum number of players allowed from\n                                    any single Premier League team.\n        chip_allowances (dict): A dictionary specifying the maximum usage for each chip.\n        num_gameweeks (int): The number of gameweeks to optimize over.\n\n    Returns:\n        bool: True if a solution was found, False otherwise.\n    \"\"\"\n    self.problem = LpProblem(\"FPL Squad Multi-Week Optimization\", LpMaximize)\n\n    # Decision variables for player selection, indexed by player and gameweek\n    player_vars = LpVariable.dicts(\n        \"Player\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n    )\n    starting_xi_vars = LpVariable.dicts(\n        \"StartingXI\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n    )\n    captain_var = LpVariable.dicts(\n        \"Captain\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n    )\n\n    # Binary variables for chip usage, indexed by gameweek\n    use_bench_boost = LpVariable.dicts(\n        \"Use_Bench_Boost\", range(num_gameweeks), 0, 1, LpBinary\n    )\n    use_triple_captain = LpVariable.dicts(\n        \"Use_Triple_Captain\", range(num_gameweeks), 0, 1, LpBinary\n    )\n\n    # Transfer variables\n    transfer_in_vars = LpVariable.dicts(\n        \"Transfer_In\",\n        (self.player_data.index, range(1, num_gameweeks)),\n        0,\n        1,\n        LpBinary,\n    )\n    transfer_out_vars = LpVariable.dicts(\n        \"Transfer_Out\",\n        (self.player_data.index, range(1, num_gameweeks)),\n        0,\n        1,\n        LpBinary,\n    )\n\n    # Total transfers made in a gameweek (absolute count)\n    transfers_made = LpVariable.dicts(\n        \"Transfers_Made\", range(1, num_gameweeks), 0, None, LpInteger\n    )\n    # Free transfers available at the start of a gameweek\n    free_transfers_available = LpVariable.dicts(\n        \"Free_Transfers_Available\",\n        range(num_gameweeks),\n        0,\n        MAX_FREE_TRANSFERS_SAVED + 1,\n        LpInteger,\n    )\n    # Number of transfer hits taken in a gameweek\n    transfer_hits = LpVariable.dicts(\n        \"Transfer_Hits\", range(1, num_gameweeks), 0, None, LpInteger\n    )\n\n    # Auxiliary variables for linearizing chip effects\n    is_bench_player = LpVariable.dicts(\n        \"Is_Bench_Player\",\n        (self.player_data.index, range(num_gameweeks)),\n        0,\n        1,\n        LpBinary,\n    )\n    actual_bench_boost_points = LpVariable.dicts(\n        \"Actual_Bench_Boost_Points\",\n        (self.player_data.index, range(num_gameweeks)),\n        0,\n        None,\n        LpContinuous,\n    )\n    actual_triple_captain_bonus = LpVariable.dicts(\n        \"Actual_Triple_Captain_Bonus\",\n        (self.player_data.index, range(num_gameweeks)),\n        0,\n        None,\n        LpContinuous,\n    )\n\n    # --- Objective Function ---\n    total_objective_points = []\n\n    # Get the first gameweek number from the player data to correctly index expected_points_by_gw\n    first_gw_key = next(\n        iter(\n            self.player_data.loc[\n                self.player_data.index[0], \"expected_points_by_gw\"\n            ].keys()\n        )\n    )\n    current_gameweek_number_start = int(first_gw_key)\n\n    for w in range(num_gameweeks):\n        # The actual gameweek number (1-indexed)\n        gw_actual = current_gameweek_number_start + w\n\n        # Base expected points from the selected starting 11 for this gameweek\n        base_points_expression_gw = lpSum(\n            self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n            * starting_xi_vars[i][w]\n            for i in self.player_data.index\n        )\n        total_objective_points.append(base_points_expression_gw)\n\n        # Regular Captaincy points (additional 1x for captain)\n        captain_points_bonus_gw = lpSum(\n            self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n            * captain_var[i][w]\n            for i in self.player_data.index\n        )\n        total_objective_points.append(captain_points_bonus_gw)\n\n        # Define auxiliary variables and constraints for chips for each gameweek\n        for i in self.player_data.index:\n            # Use gameweek-specific player xP for chip calculations\n            player_xp = self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n\n            # Bench Boost auxiliary variables and constraints\n            self.problem += (\n                is_bench_player[i][w] &lt;= player_vars[i][w],\n                f\"IsBench_Squad_{i}_{w}\",\n            )\n            self.problem += (\n                is_bench_player[i][w] &lt;= 1 - starting_xi_vars[i][w],\n                f\"IsBench_NotStarter_{i}_{w}\",\n            )\n            self.problem += (\n                is_bench_player[i][w]\n                &gt;= player_vars[i][w] + (1 - starting_xi_vars[i][w]) - 1,\n                f\"IsBench_Logical_{i}_{w}\",\n            )\n\n            self.problem += (\n                actual_bench_boost_points[i][w]\n                &lt;= player_xp * is_bench_player[i][w],\n                f\"BenchBoost_Contr_1_{i}_{w}\",\n            )\n            self.problem += (\n                actual_bench_boost_points[i][w] &lt;= player_xp * use_bench_boost[w],\n                f\"BenchBoost_Contr_2_{i}_{w}\",\n            )\n            self.problem += (\n                actual_bench_boost_points[i][w]\n                &gt;= player_xp * (is_bench_player[i][w] + use_bench_boost[w] - 1),\n                f\"BenchBoost_Contr_3_{i}_{w}\",\n            )\n            self.problem += (\n                actual_bench_boost_points[i][w] &gt;= 0,\n                f\"BenchBoost_Contr_4_{i}_{w}\",\n            )\n\n            # Triple Captain auxiliary variables and constraints\n            # Changed player_xp * 2 to player_xp to reflect additional 1x bonus\n            self.problem += (\n                actual_triple_captain_bonus[i][w] &lt;= player_xp * captain_var[i][w],\n                f\"TripleCaptain_Contr_1_{i}_{w}\",\n            )\n            self.problem += (\n                actual_triple_captain_bonus[i][w]\n                &lt;= player_xp * use_triple_captain[w],\n                f\"TripleCaptain_Contr_2_{i}_{w}\",\n            )\n            self.problem += (\n                actual_triple_captain_bonus[i][w]\n                &gt;= player_xp * (captain_var[i][w] + use_triple_captain[w] - 1),\n                f\"TripleCaptain_Contr_3_{i}_{w}\",\n            )\n            self.problem += (\n                actual_triple_captain_bonus[i][w] &gt;= 0,\n                f\"TripleCaptain_Contr_4_{i}_{w}\",\n            )\n\n        # Add points from bench boost and triple captain bonus for this gameweek\n        total_bench_boost_points_gw = lpSum(\n            actual_bench_boost_points[i][w] for i in self.player_data.index\n        )\n        total_triple_captain_bonus_points_gw = lpSum(\n            actual_triple_captain_bonus[i][w] for i in self.player_data.index\n        )\n\n        total_objective_points.append(total_bench_boost_points_gw)\n        total_objective_points.append(total_triple_captain_bonus_points_gw)\n\n    # Subtract transfer hits from the total objective\n    total_objective_points.append(\n        -POINTS_PER_HIT * lpSum(transfer_hits[w] for w in range(1, num_gameweeks))\n    )\n\n    self.problem += (\n        lpSum(total_objective_points),\n        \"Total Expected Points Over Gameweeks\",\n    )\n\n    # --- Constraints ---\n\n    # Apply constraints for each gameweek\n    for w in range(num_gameweeks):\n        # 1. Select exactly 15 players for the squad\n        self.problem += (\n            lpSum(player_vars[i][w] for i in self.player_data.index) == 15,\n            f\"Total_Players_GW{w}\",\n        )\n\n        # 2. Squad position constraints (2 GKs, 5 DEFs, 5 MIDs, 3 FWDs)\n        gks = self.player_data[self.player_data[\"position\"] == \"GK\"].index\n        defs = self.player_data[self.player_data[\"position\"] == \"DEF\"].index\n        mids = self.player_data[self.player_data[\"position\"] == \"MID\"].index\n        fwds = self.player_data[self.player_data[\"position\"] == \"FWD\"].index\n\n        self.problem += (\n            lpSum(player_vars[i][w] for i in gks) == 2,\n            f\"Goalkeepers_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(player_vars[i][w] for i in defs) == 5,\n            f\"Defenders_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(player_vars[i][w] for i in mids) == 5,\n            f\"Midfielders_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(player_vars[i][w] for i in fwds) == 3,\n            f\"Forwards_Count_GW{w}\",\n        )\n\n        # 3. Budget constraint\n        # This applies to the cost of the squad for the current gameweek.\n        self.problem += (\n            lpSum(\n                self.player_data.loc[i, \"cost\"] * player_vars[i][w]\n                for i in self.player_data.index\n            )\n            &lt;= budget,\n            f\"Total_Budget_GW{w}\",\n        )\n\n        # 4. Maximum players per team constraint\n        for team in self.player_data[\"team\"].unique():\n            team_players = self.player_data[self.player_data[\"team\"] == team].index\n            self.problem += (\n                lpSum(player_vars[i][w] for i in team_players)\n                &lt;= max_players_per_team,\n                f\"Max_Players_from_{team}_GW{w}\",\n            )\n\n        # 5. Starting XI constraints\n        # 5.1 Select exactly 11 players for the starting XI\n        self.problem += (\n            lpSum(starting_xi_vars[i][w] for i in self.player_data.index) == 11,\n            f\"Total_Starting_XI_Players_GW{w}\",\n        )\n\n        # 5.2 A player can only be in the starting XI if they are in the squad\n        for i in self.player_data.index:\n            self.problem += (\n                starting_xi_vars[i][w] &lt;= player_vars[i][w],\n                f\"StartingXI_in_Squad_{i}_{w}\",\n            )\n\n        # 5.3 Starting XI position constraints (FPL allows flexible formations, so use minimums)\n        self.problem += (\n            lpSum(starting_xi_vars[i][w] for i in gks) == 1,\n            f\"Starting_Goalkeepers_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(starting_xi_vars[i][w] for i in defs) &gt;= 3,\n            f\"Min_Starting_Defenders_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(starting_xi_vars[i][w] for i in mids) &gt;= 2,\n            f\"Min_Starting_Midfielders_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(starting_xi_vars[i][w] for i in fwds) &gt;= 1,\n            f\"Min_Starting_Forwards_Count_GW{w}\",\n        )\n\n        # 6. Captain Constraints\n        # 6.1 Select exactly one captain from the starting XI\n        self.problem += (\n            lpSum(captain_var[i][w] for i in self.player_data.index) == 1,\n            f\"One_Captain_GW{w}\",\n        )\n\n        # 6.2 A player can only be captain if they are in the starting XI\n        for i in self.player_data.index:\n            self.problem += (\n                captain_var[i][w] &lt;= starting_xi_vars[i][w],\n                f\"Captain_in_StartingXI_{i}_{w}\",\n            )\n\n        # --- Enforced Player Constraints---\n        for player_idx in self.enforced_player_indices:\n            self.problem += (\n                player_vars[player_idx][w] == 1,\n                f\"Enforce_Player_{self.player_data.loc[player_idx, 'name']}_GW{w}\",\n            )\n\n        for team, position in self.enforced_team_pos_requirements:\n            # Filter players for the current team and position\n            team_pos_players = self.player_data[\n                (self.player_data[\"team\"] == team)\n                &amp; (self.player_data[\"position\"] == position)\n            ].index\n            if not team_pos_players.empty:\n                self.problem += (\n                    lpSum(player_vars[i][w] for i in team_pos_players) &gt;= 1,\n                    f\"Enforce_One_{position}_from_{team}_GW{w}\",\n                )\n            else:\n                print(\n                    f\"Warning: No players found for enforced requirement: at least one {position} from {team} for GW{gw_actual}.\"\n                )\n\n    # --- Chip Usage Constraints (TOTAL usage over all gameweeks) ---\n    # These constraints should be outside the per-gameweek loop to avoid duplicates.\n    self.problem += (\n        lpSum(use_bench_boost[j] for j in range(num_gameweeks))\n        &lt;= chip_allowances.get(\"bench_boost\", 0),\n        f\"Max_Bench_Boost_Usage_Total\",\n    )\n    self.problem += (\n        lpSum(use_triple_captain[j] for j in range(num_gameweeks))\n        &lt;= chip_allowances.get(\"triple_captain\", 0),\n        f\"Max_Triple_Captain_Usage_Total\",\n    )\n\n    # --- Inter-Gameweek Constraints (Transfers and Transfer Rules) ---\n    # Initialize free transfers for GW0 (first gameweek of optimization horizon)\n    # This assumes the optimization starts at GW0, and it has INITIAL_FREE_TRANSFERS.\n    # If the model starts at an arbitrary GW, this would need to be an input.\n    self.problem += (\n        free_transfers_available[0] == INITIAL_FREE_TRANSFERS,\n        f\"Initial_Free_Transfers_GW0\",\n    )\n\n    for w in range(1, num_gameweeks):\n        # Calculate total transfers made in this gameweek\n        self.problem += (\n            transfers_made[w]\n            == lpSum(transfer_in_vars[i][w] for i in self.player_data.index),\n            f\"Transfers_Made_GW{w}\",\n        )\n        # Total transfers in must equal total transfers out for each gameweek after the first\n        self.problem += (\n            lpSum(transfer_in_vars[i][w] for i in self.player_data.index)\n            == lpSum(transfer_out_vars[i][w] for i in self.player_data.index),\n            f\"Transfers_In_Equals_Out_GW{w}\",\n        )\n\n        # Calculate free transfers available for the current gameweek (w)\n        # Free transfers for GW_w = min(free transfers from GW_w-1 - transfers made in GW_w + 1, MAX_FREE_TRANSFERS_SAVED + 1)\n        # The + 1 in MAX_FREE_TRANSFERS_SAVED + 1 is because MAX_FREE_TRANSFERS_SAVED implies how many can be *saved*,\n        # so if you save 1, you have 1 (current) + 1 (saved) = 2.\n        self.problem += (\n            free_transfers_available[w]\n            &lt;= free_transfers_available[w - 1] - transfers_made[w] + 1,\n            f\"Free_Transfers_Calc_1_GW{w}\",\n        )\n        self.problem += (\n            free_transfers_available[w] &lt;= MAX_FREE_TRANSFERS_SAVED + 1,\n            f\"Free_Transfers_Calc_2_GW{w}\",\n        )\n        self.problem += (\n            free_transfers_available[w] &gt;= 0,  # Cannot have negative free transfers\n            f\"Free_Transfers_Non_Negative_GW{w}\",\n        )\n\n        # Calculate transfer hits\n        # transfer_hits[w] = max(0, transfers_made[w] - free_transfers_available_at_start_of_gw_w)\n        # This needs to be linearized. If transfers_made[w] &gt; free_transfers_available[w-1], then hit.\n        # free_transfers_available[w-1] represents transfers available *before* making transfers for GW_w\n        self.problem += (\n            transfer_hits[w] &gt;= transfers_made[w] - free_transfers_available[w - 1],\n            f\"Transfer_Hits_Calc_1_GW{w}\",\n        )\n        self.problem += (\n            transfer_hits[w] &gt;= 0,\n            f\"Transfer_Hits_Calc_2_GW{w}\",\n        )\n\n        for i in self.player_data.index:\n            # Squad continuity: player_vars[i][w] (in squad at start of GW w)\n            #                 = player_vars[i][w-1] (in squad at start of GW w-1)\n            #                 - transfer_out_vars[i][w] (transferred out for GW w)\n            #                 + transfer_in_vars[i][w] (transferred in for GW w)\n            self.problem += (\n                player_vars[i][w]\n                == player_vars[i][w - 1]\n                - transfer_out_vars[i][w]\n                + transfer_in_vars[i][w],\n                f\"Squad_Continuity_{i}_GW{w}\",\n            )\n            # A player cannot be transferred in and out in the same gameweek\n            self.problem += (\n                transfer_in_vars[i][w] + transfer_out_vars[i][w] &lt;= 1,\n                f\"No_Simultaneous_Transfer_{i}_{w}\",\n            )\n\n    try:\n        # The solver is called with the GLPK_CMD solver\n        self.problem.solve(PULP_CBC_CMD(msg=0))  # msg=0 suppresses verbose output\n    except Exception as e:\n        print(f\"Error solving the problem: {e}\")\n        return False\n\n    if LpStatus[self.problem.status] == \"Optimal\":\n        print(\"Optimization successful! Optimal solution found.\")\n\n        self.selected_squad_history = {}\n        self.total_transfer_hits = 0\n        for w in range(num_gameweeks):\n            # The actual gameweek number (1-indexed)\n            gw_actual = current_gameweek_number_start + w\n\n            # Get selected players for the current gameweek\n            selected_squad_gw = self.player_data[\n                [player_vars[i][w].varValue == 1 for i in self.player_data.index]\n            ].copy()\n\n            # Get starter and captain info for this gameweek\n            is_starter_series_gw = pd.Series(\n                [\n                    starting_xi_vars[i][w].varValue == 1\n                    for i in self.player_data.index\n                ],\n                index=self.player_data.index,\n            )\n            is_captain_series_gw = pd.Series(\n                [captain_var[i][w].varValue == 1 for i in self.player_data.index],\n                index=self.player_data.index,\n            )\n\n            selected_squad_gw[\"is_starter\"] = is_starter_series_gw.loc[\n                selected_squad_gw.index\n            ]\n            selected_squad_gw[\"is_captain\"] = is_captain_series_gw.loc[\n                selected_squad_gw.index\n            ]\n\n            transfers_in_gw = 0\n            transfers_out_gw = 0\n            hits_gw = 0\n\n            # Store transfer details for gameweeks &gt; 0\n            if (\n                w &gt; 0\n            ):  # Check for transfers only from GW1 onwards (index 1 in 0-indexed loop)\n                transfer_in_flags = pd.Series(\n                    [\n                        transfer_in_vars[i][w].varValue == 1\n                        for i in self.player_data.index\n                    ],\n                    index=self.player_data.index,\n                )\n                transfer_out_flags = pd.Series(\n                    [\n                        transfer_out_vars[i][w].varValue == 1\n                        for i in self.player_data.index\n                    ],\n                    index=self.player_data.index,\n                )\n\n                selected_squad_gw[\"transfer_in\"] = transfer_in_flags.loc[\n                    selected_squad_gw.index\n                ]\n                selected_squad_gw[\"transfer_out\"] = transfer_out_flags.loc[\n                    selected_squad_gw.index\n                ]\n\n                transfers_in_gw = int(round(transfer_in_flags.sum()))\n                transfers_out_gw = int(round(transfer_out_flags.sum()))\n                hits_gw = int(round(transfer_hits[w].varValue))\n                self.total_transfer_hits += hits_gw\n            else:\n                selected_squad_gw[\"transfer_in\"] = False  # No transfers in for GW0\n                selected_squad_gw[\"transfer_out\"] = (\n                    False  # No transfers out for GW0\n                )\n\n            self.selected_squad_history[f\"GW{gw_actual}\"] = {\n                \"squad\": selected_squad_gw,\n                \"total_cost\": selected_squad_gw[\"cost\"].sum(),\n                \"expected_points_from_xi\": sum(\n                    self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n                    * starting_xi_vars[i][w].varValue\n                    for i in self.player_data.index\n                ),\n                \"bench_boost_used\": bool(use_bench_boost[w].varValue),\n                \"triple_captain_used\": bool(use_triple_captain[w].varValue),\n                \"total_bench_boost_points\": value(\n                    lpSum(\n                        actual_bench_boost_points[i][w]\n                        for i in self.player_data.index\n                    )\n                ),\n                \"total_triple_captain_bonus\": value(\n                    lpSum(\n                        actual_triple_captain_bonus[i][w]\n                        for i in self.player_data.index\n                    )\n                ),\n                \"transfers_in_count\": transfers_in_gw,\n                \"transfers_out_count\": transfers_out_gw,\n                \"transfer_hits\": hits_gw,  # New\n                \"free_transfers_available_next_gw\": (\n                    int(round(free_transfers_available[w].varValue))\n                    if w &lt; num_gameweeks - 1\n                    else 0\n                ),  # Free transfers available *after* this GW's transfers are made\n            }\n\n        # Overall totals\n        self.total_cost = self.selected_squad_history[\n            f\"GW{current_gameweek_number_start + num_gameweeks - 1}\"\n        ][\n            \"total_cost\"\n        ]  # Cost of final squad\n        self.total_expected_points = value(\n            self.problem.objective\n        )  # Total objective value from solver\n        self.used_chips = {\n            f\"GW{current_gameweek_number_start + w}\": {\n                \"bench_boost\": bool(use_bench_boost[w].varValue),\n                \"triple_captain\": bool(use_triple_captain[w].varValue),\n            }\n            for w in range(num_gameweeks)\n        }\n\n        return True\n    else:\n        print(f\"No optimal solution found. Status: {LpStatus[self.problem.status]}\")\n        self.selected_squad_history = {}\n        self.total_cost = 0\n        self.total_expected_points = 0\n        self.used_chips = {}\n        self.total_transfer_hits = 0\n        return False\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/#build.lib.fpl_solver.xp_predictor","title":"<code>xp_predictor</code>","text":"<p>FPL Expected Points (xP) Predictor Module.</p> <p>This module provides functionality to predict Fantasy Premier League (FPL) points for players based on historical data, team strengths, and fixture difficulty.</p>"},{"location":"autoapi/build/lib/fpl_solver/#build.lib.fpl_solver.xp_predictor.FPLPredictor","title":"<code>FPLPredictor</code>","text":"<p>Predictive algorithm for Expected Points (xP) in Fantasy Premier League, using real data from the FPL API.</p> <p>This class handles: - Fetching and processing FPL API data - Calculating expected points based on multiple factors - Managing player exclusions and filtering - Providing fixture and player data for optimization</p> <p>Attributes:</p> Name Type Description <code>gameweeks_to_predict</code> <code>int</code> <p>Number of future gameweeks to analyze</p> <code>players_data</code> <code>Dict</code> <p>Player statistics and information</p> <code>teams_data</code> <code>Dict</code> <p>Team statistics and attributes</p> <code>fixtures_data</code> <code>Dict</code> <p>Upcoming and historical match data</p> <code>all_players_xp_calculated_data</code> <code>List</code> <p>Processed xP calculations</p> Source code in <code>build/lib/fpl_solver/xp_predictor.py</code> <pre><code>class FPLPredictor:\n    \"\"\"\n    Predictive algorithm for Expected Points (xP) in Fantasy Premier League,\n    using real data from the FPL API.\n\n    This class handles:\n    - Fetching and processing FPL API data\n    - Calculating expected points based on multiple factors\n    - Managing player exclusions and filtering\n    - Providing fixture and player data for optimization\n\n    Attributes:\n        gameweeks_to_predict (int): Number of future gameweeks to analyze\n        players_data (Dict): Player statistics and information\n        teams_data (Dict): Team statistics and attributes\n        fixtures_data (Dict): Upcoming and historical match data\n        all_players_xp_calculated_data (List): Processed xP calculations\n    \"\"\"\n\n    def __init__(self, gameweeks_to_predict: int = 1):\n        \"\"\"\n        Initialize the FPLPredictor with data structures and fetch initial data.\n\n        Args:\n            gameweeks_to_predict: Number of upcoming gameweeks to calculate\n                                expected points for. Default is 1 (next gameweek).\n\n        Raises:\n            ValueError: If gameweeks_to_predict is not a positive integer\n        \"\"\"\n        self.logger = setup_logger(__name__)\n        if not isinstance(gameweeks_to_predict, int) or gameweeks_to_predict &lt; 1:\n            msg = f\"gameweeks_to_predict must be a positive integer, got {gameweeks_to_predict}\"\n            self.logger.error(msg)\n            raise ValueError(msg)\n\n        self.gameweeks_to_predict = gameweeks_to_predict\n        self.logger.info(f\"Initializing FPL Predictor for {gameweeks_to_predict} gameweek(s)\")\n\n        # Initialize cache manager\n        cache_dir = os.path.join(os.path.dirname(__file__), 'cache')\n        self.cache_manager = CacheManager(cache_dir)\n\n        # Configuration and static data\n        self.fpl_points: Dict[str, float] = FPL_POINTS\n        self.position_definitions: Dict[int, str] = {\n            1: \"GK\",\n            2: \"DEF\",\n            3: \"MID\",\n            4: \"FWD\",\n        }\n\n        # Data structures for FPL information\n        self.players_data: Dict[int, Dict] = {}\n        self.teams_data: Dict[int, Dict] = {}\n        self.fixtures_data: Dict[int, Dict] = {}\n        self.all_players_xp_calculated_data: List[Dict] = []\n\n        # Initialize data\n        try:\n            self._fetch_fpl_data()\n            self._calculate_all_players_xp()\n        except Exception as e:\n            self.logger.error(f\"Failed to initialize FPL Predictor: {str(e)}\")\n            raise\n\n    def _fetch_fpl_data(self) -&gt; None:\n        \"\"\"\n        Fetch and process data from the FPL API.\n\n        This method retrieves player, team, and fixture data from the FPL API,\n        processes it, and stores it in the appropriate data structures. It also\n        applies any configured player exclusions.\n\n        Raises:\n            requests.RequestException: If API requests fail\n            ValueError: If required data is missing from API response\n            Exception: For other unexpected errors\n        \"\"\"\n        self.logger.info(\"Fetching FPL data from API...\")\n\n        try:\n            # Helper function to fetch from API with caching\n            def fetch_api_data(url: str, endpoint: str) -&gt; dict:\n                # Try to get from cache first\n                cached_data = self.cache_manager.get_cached_response(endpoint)\n                if cached_data is not None:\n                    self.logger.info(f\"Using cached {endpoint} data\")\n                    return cached_data\n\n                # If not in cache or expired, fetch from API\n                try:\n                    self.logger.info(f\"Fetching {endpoint} data from API\")\n                    response = requests.get(url, timeout=10)\n                    response.raise_for_status()\n                    data = response.json()\n\n                    # Cache the response\n                    self.cache_manager.save_response(endpoint, data)\n                    return data\n\n                except requests.RequestException as e:\n                    self.logger.error(f\"Failed to fetch {endpoint} data: {str(e)}\")\n                    raise\n\n            # Fetch both endpoints\n            static_data = fetch_api_data(\n                \"https://fantasy.premierleague.com/api/bootstrap-static/\",\n                \"static\"\n            )\n            fixtures_data = fetch_api_data(\n                \"https://fantasy.premierleague.com/api/fixtures/\",\n                \"fixtures\"\n            )\n\n            # Process players data\n            if \"elements\" not in static_data:\n                raise ValueError(\"No player elements found in API response\")\n\n            self.logger.info(f\"Processing {len(static_data['elements'])} players...\")\n\n            def process_player_data(element: Dict) -&gt; Tuple[int, Dict]:\n                \"\"\"Helper function to process individual player data\"\"\"\n                try:\n                    player_id = element[\"id\"]\n                    return player_id, {\n                        \"name\": f\"{element['first_name']} {element['second_name']}\",\n                        \"web_name\": element[\"web_name\"],\n                        \"team_id\": element[\"team\"],\n                        \"element_type\": element[\"element_type\"],\n                        \"position\": self.position_definitions.get(\n                            element[\"element_type\"], \"Unknown\"\n                        ),\n                        \"cost_pence\": element[\"now_cost\"],\n                        \"status\": element[\"status\"],\n                        \"news\": element[\"news\"],\n                        \"total_points\": element[\"total_points\"],\n                        \"minutes\": element[\"minutes\"],\n                        \"goals_scored\": element[\"goals_scored\"],\n                        \"assists\": element[\"assists\"],\n                        \"clean_sheets\": element[\"clean_sheets\"],\n                        \"goals_conceded\": element[\"goals_conceded\"],\n                        \"penalties_saved\": element[\"penalties_saved\"],\n                        \"penalties_missed\": element[\"penalties_missed\"],\n                        \"yellow_cards\": element[\"yellow_cards\"],\n                        \"red_cards\": element[\"red_cards\"],\n                        \"own_goals\": element[\"own_goals\"],\n                        \"saves\": element[\"saves\"],\n                        \"bonus\": element[\"bonus\"],\n                        \"bps\": element[\"bps\"],\n                        \"threat\": float(element.get(\"threat\", 0)),\n                        \"creativity\": float(element.get(\"creativity\", 0)),\n                        \"influence\": float(element.get(\"influence\", 0)),\n                        \"form\": float(element.get(\"form\", 0)),\n                        \"points_per_game\": float(element.get(\"points_per_game\", 0)),\n                        \"value_season\": float(element.get(\"value_season\", 0)),\n                        \"value_form\": float(element.get(\"value_form\", 0)),\n                        \"ict_index\": float(element.get(\"ict_index\", 0)),\n                        \"defensive_contribution\": float(element.get(\"defensive_contribution\", 0)),\n                    }\n                except KeyError as e:\n                    self.logger.warning(f\"Missing required field for player: {str(e)}\")\n                    return None\n                except ValueError as e:\n                    self.logger.warning(f\"Invalid numeric value for player {element.get('id')}: {str(e)}\")\n                    return None\n\n            # Process all players with error handling\n            for element in static_data[\"elements\"]:\n                result = process_player_data(element)\n                if result:\n                    player_id, player_data = result\n                    self.players_data[player_id] = player_data\n\n            # Apply Player Exclusions\n            def apply_player_exclusions() -&gt; Dict[int, Dict]:\n                \"\"\"Apply configured player exclusions and return filtered player data\"\"\"\n                initial_count = len(self.players_data)\n                players_to_keep = {}\n\n                for player_id, player_info in self.players_data.items():\n                    # Track exclusion reason if player is excluded\n                    exclusion_reason = None\n\n                    # Check ID exclusions\n                    if player_id in EXCLUDED_PLAYERS_BY_ID:\n                        exclusion_reason = f\"ID exclusion: {player_id}\"\n\n                    # Check name exclusions\n                    elif player_info[\"name\"] in EXCLUDED_PLAYERS_BY_NAME:\n                        exclusion_reason = f\"Name exclusion: {player_info['name']}\"\n\n                    # Check team/position exclusions\n                    else:\n                        team_name = self.teams_data.get(player_info[\"team_id\"], {}).get(\"name\")\n                        for rule in EXCLUDED_PLAYERS_BY_TEAM_AND_POSITION:\n                            if (team_name == rule.get(\"team\") and \n                                player_info[\"position\"] == rule.get(\"position\")):\n                                exclusion_reason = f\"Team/Position exclusion: {team_name}/{player_info['position']}\"\n                                break\n\n                    # Log exclusion or keep player\n                    if exclusion_reason:\n                        self.logger.info(\n                            f\"Excluding player {player_info['name']} - {exclusion_reason}\"\n                        )\n                    else:\n                        players_to_keep[player_id] = player_info\n\n                filtered_count = len(players_to_keep)\n                self.logger.info(\n                    f\"Player filtering complete. {initial_count - filtered_count} \"\n                    f\"players excluded. {filtered_count} players remaining.\"\n                )\n                return players_to_keep\n\n            self.players_data = apply_player_exclusions()\n\n            # Process teams data\n            if \"teams\" not in static_data:\n                raise ValueError(\"No team data found in API response\")\n\n            self.logger.info(f\"Processing {len(static_data['teams'])} teams...\")\n\n            def process_team_data(team: Dict) -&gt; Tuple[int, Dict]:\n                \"\"\"Helper function to process individual team data\"\"\"\n                try:\n                    return team[\"id\"], {\n                        \"name\": team[\"name\"],\n                        \"short_name\": team[\"short_name\"],\n                        \"strength\": team[\"strength\"],\n                        \"strength_overall_home\": team[\"strength_overall_home\"],\n                        \"strength_overall_away\": team[\"strength_overall_away\"],\n                        \"strength_attack_home\": team[\"strength_attack_home\"],\n                        \"strength_attack_away\": team[\"strength_attack_away\"],\n                        \"strength_defence_home\": team[\"strength_defence_home\"],\n                        \"strength_defence_away\": team[\"strength_defence_away\"],\n                    }\n                except KeyError as e:\n                    self.logger.warning(f\"Missing required field for team: {str(e)}\")\n                    return None\n\n            # Process all teams with error handling\n            for team in static_data[\"teams\"]:\n                result = process_team_data(team)\n                if result:\n                    team_id, team_data = result\n                    self.teams_data[team_id] = team_data\n\n            # Process fixtures data\n            self.logger.info(f\"Processing {len(fixtures_data)} fixtures...\")\n\n            def process_fixture_data(fixture: Dict) -&gt; Tuple[int, Dict]:\n                \"\"\"Helper function to process individual fixture data\"\"\"\n                try:\n                    fixture_id = fixture[\"id\"]\n                    # Validate required fields\n                    required_fields = [\"team_h\", \"team_a\", \"event\", \"finished\"]\n                    if not all(field in fixture for field in required_fields):\n                        missing = [f for f in required_fields if f not in fixture]\n                        raise KeyError(f\"Missing required fields: {', '.join(missing)}\")\n                    return fixture_id, fixture\n                except KeyError as e:\n                    self.logger.warning(f\"Invalid fixture data: {str(e)}\")\n                    return None\n\n            # Process all fixtures with error handling\n            for fixture in fixtures_data:\n                result = process_fixture_data(fixture)\n                if result:\n                    fixture_id, fixture_data = result\n                    self.fixtures_data[fixture_id] = fixture_data\n\n            self.logger.info(\"FPL data fetched and processed successfully.\")\n\n        except requests.exceptions.RequestException as e:\n            self.logger.error(f\"Failed to fetch FPL data: {str(e)}\")\n            self._reset_data_structures()\n            raise\n        except ValueError as e:\n            self.logger.error(f\"Invalid data received from FPL API: {str(e)}\")\n            self._reset_data_structures()\n            raise\n        except Exception as e:\n            self.logger.error(f\"Unexpected error during data processing: {str(e)}\")\n            self._reset_data_structures()\n            raise\n\n    def _reset_data_structures(self) -&gt; None:\n        \"\"\"Reset all data structures to empty state\"\"\"\n        self.players_data = {}\n        self.teams_data = {}\n        self.fixtures_data = {}\n\n    def _get_team_strength(self, team_id, is_home):\n        \"\"\"Get team strength based on home/away status.\"\"\"\n        team = self.teams_data.get(team_id, {})\n        if is_home:\n            return team.get(\"strength_overall_home\", 1000)  # Default if not found\n        return team.get(\"strength_overall_away\", 1000)  # Default if not found\n\n    def _predict_minutes(self, player_id):\n        \"\"\"\n        Predicts expected minutes for a player based on historical data.\n        More sophisticated logic for handling very low minute players.\n        \"\"\"\n        player = self.players_data.get(player_id)\n        if not player:\n            return 0.0\n\n        status = player[\"status\"]\n        news = player[\"news\"].lower()\n        minutes_played = player[\"minutes\"]\n\n        # 1. Unavailable players (injured, suspended, doubtful)\n        if status != \"a\" or any(\n            x in news\n            for x in [\n                \"injured\",\n                \"doubtful\",\n                \"suspension\",\n                \"red card\",\n                \"expected back\",\n            ]\n        ):\n            return 0.0\n\n        # 2. Players with significant minutes (starters/key rotation)\n        if minutes_played &gt;= MIN_MINUTES_THRESHOLD:\n            # Average minutes per game started (assuming most minutes come from starts)\n            # This is a heuristic; real FPL API doesn't give starts directly.\n            # We assume a player with &gt; MIN_MINUTES_THRESHOLD plays ~80-90 minutes when on pitch.\n            # So, (minutes_played / number_of_appearances) is a rough proxy.\n            # For simplicity, let's use a cap of 90 minutes.\n            if player[\"total_points\"] &gt; 0:  # Player has played at least one game\n                avg_minutes_per_appearance = minutes_played / (\n                    player[\"total_points\"] / player[\"points_per_game\"]\n                )\n                return min(avg_minutes_per_appearance, 90.0)\n            return 70.0  # Reasonable default for established player with points but no clear avg\n\n        # 3. Players with very low minutes (rarely play, new, youth)\n        if minutes_played &lt; VERY_LOW_MINUTES_THRESHOLD:\n            # If news suggests they might get a chance, assign default sub minutes.\n            # Otherwise, very low expected minutes or zero.\n            if any(x in news for x in [\"return imminent\", \"close to return\"]):\n                return DEFAULT_SUB_MINUTES  # Might get some minutes\n            return DEFAULT_UNKNOWN_PLAYER_MINUTES  # Very unlikely to play significant minutes\n\n        # 4. Players with some minutes but below significant threshold (regular subs)\n        return DEFAULT_SUB_MINUTES\n\n    def _calculate_expected_goals(self, team_attack_strength, opp_defence_strength):\n        \"\"\"\n        Calculates expected goals for a team based on its attack strength and\n        opponent's defensive strength. This is a simplified heuristic.\n        \"\"\"\n        # A simple ratio model: Higher attack strength and lower opponent defense means more goals\n        # Normalization factor can be adjusted based on average league goals\n        expected_goals = (\n            team_attack_strength / opp_defence_strength\n        ) * 1.5  # 1.5 is an arbitrary scaling factor\n        return max(0.0, expected_goals)\n\n    def _calculate_expected_conceded_goals(\n        self, team_defence_strength, opp_attack_strength\n    ):\n        \"\"\"\n        Calculates expected goals conceded by a team based on its defense strength\n        and opponent's attacking strength.\n        \"\"\"\n        # A simple ratio model: Higher opponent attack and lower team defense means more conceded goals\n        expected_conceded_goals = (\n            opp_attack_strength / team_defence_strength\n        ) * 1.5  # 1.5 is an arbitrary scaling factor\n        return max(0.0, expected_conceded_goals)\n\n    def calculate_xp_for_player(self, player_id, fixture_id):\n        \"\"\"\n        Calculates Expected Points (xP) for a single player in a given fixture.\n        Considers various factors: minutes, goals, assists, clean sheets, saves,\n        bonus points, and negative events, adjusted for fixture difficulty.\n        \"\"\"\n        player = self.players_data.get(player_id)\n        fixture = self.fixtures_data.get(fixture_id)\n\n        if not player or not fixture:\n            return {\"xp\": 0.0, \"reason\": \"Player or fixture data missing.\"}\n\n        # Handle unavailable players\n        if (\n            player[\"status\"] != \"a\"\n        ):  # 'd' for doubtful, 'i' for injured, 's' for suspended\n            return {\"xp\": 0.0, \"reason\": f\"Player status: {player['status']}\"}\n        if any(\n            x in player[\"news\"].lower()\n            for x in [\"injured\", \"doubtful\", \"suspension\", \"red card\"]\n        ):\n            return {\"xp\": 0.0, \"reason\": f\"Player news: {player['news']}\"}\n\n        # Predict minutes\n        expected_minutes = self._predict_minutes(player_id)\n        if expected_minutes &lt; 1.0:  # If expected to play very little or none\n            return {\"xp\": 0.0, \"reason\": \"Expected minutes too low.\"}\n\n        xp = 0.0\n        position = player[\"position\"]\n        # Use 'team_h' for home team ID\n        is_home_fixture = player[\"team_id\"] == fixture[\"team_h\"]\n\n        # Determine attacking and defensive strengths for the fixture\n        player_team_strength_attack = (\n            self.teams_data.get(fixture[\"team_h\"], {}).get(\n                \"strength_attack_home\"\n            )  # Use 'team_h'\n            if is_home_fixture\n            else self.teams_data.get(fixture[\"team_a\"], {}).get(\n                \"strength_attack_away\"\n            )  # Use 'team_a'\n        )\n        player_team_strength_defence = (\n            self.teams_data.get(fixture[\"team_h\"], {}).get(\n                \"strength_defence_home\"\n            )  # Use 'team_h'\n            if is_home_fixture\n            else self.teams_data.get(fixture[\"team_a\"], {}).get(\n                \"strength_defence_away\"\n            )  # Use 'team_a'\n        )\n        opponent_team_strength_attack = (\n            self.teams_data.get(fixture[\"team_a\"], {}).get(\n                \"strength_attack_away\"\n            )  # Use 'team_a'\n            if is_home_fixture\n            else self.teams_data.get(fixture[\"team_h\"], {}).get(\n                \"strength_attack_home\"\n            )  # Use 'team_h'\n        )\n        opponent_team_strength_defence = (\n            self.teams_data.get(fixture[\"team_a\"], {}).get(\n                \"strength_defence_away\"\n            )  # Use 'team_a'\n            if is_home_fixture\n            else self.teams_data.get(fixture[\"team_h\"], {}).get(\n                \"strength_defence_home\"\n            )  # Use 'team_h'\n        )\n\n        if None in [\n            player_team_strength_attack,\n            player_team_strength_defence,\n            opponent_team_strength_attack,\n            opponent_team_strength_defence,\n        ]:\n            # Fallback if strength data is missing (shouldn't happen with robust data fetch)\n            return {\"xp\": 0.0, \"reason\": \"Team strength data missing for fixture.\"}\n\n        # Apply confidence factor based on historical minutes\n        minutes_played = player.get(\"minutes\", 0)\n        confidence_factor = XP_CONFIDENCE_FACTORS[\"proven\"]  # Default to proven player\n        if minutes_played &lt; VERY_LOW_MINUTES_THRESHOLD:\n            confidence_factor = XP_CONFIDENCE_FACTORS[\"very_low_minutes\"]\n        elif minutes_played &lt; MIN_MINUTES_THRESHOLD:\n            confidence_factor = XP_CONFIDENCE_FACTORS[\"low_minutes\"]\n\n        # 1. Appearance points\n        if expected_minutes &gt;= 60:\n            xp += self.fpl_points[\"appearance_points_gte_60\"]\n        elif expected_minutes &gt; 0:\n            xp += self.fpl_points[\"appearance_points_lt_60\"]\n\n        # 2. Expected Goals (scaled by historical goals per 90 and opponent difficulty)\n        # Use player's form and total goals as a basis\n        goals_per_90_hist = (\n            (player[\"goals_scored\"] / player[\"minutes\"] * 90)\n            if player[\"minutes\"] &gt; 0\n            else 0.0\n        )\n        expected_team_goals = self._calculate_expected_goals(\n            player_team_strength_attack, opponent_team_strength_defence\n        )\n\n        expected_goals_player_contribution = (\n            (goals_per_90_hist / 90.0) * expected_minutes * (expected_team_goals / 1.5)\n        )  # Scale player's goal contribution by team's expected goals\n\n        if position == \"GK\":\n            xp += expected_goals_player_contribution * self.fpl_points[\"goal_gk\"]\n        elif position == \"DEF\":\n            xp += expected_goals_player_contribution * self.fpl_points[\"goal_def\"]\n        elif position == \"MID\":\n            xp += expected_goals_player_contribution * self.fpl_points[\"goal_mid\"]\n        elif position == \"FWD\":\n            xp += expected_goals_player_contribution * self.fpl_points[\"goal_fwd\"]\n\n        # 3. Expected Assists (scaled by historical assists per 90 and opponent difficulty)\n        assists_per_90_hist = (\n            (player[\"assists\"] / player[\"minutes\"] * 90)\n            if player[\"minutes\"] &gt; 0\n            else 0.0\n        )\n        # Assuming team's attacking strength correlates with assist opportunities\n        expected_assists_player_contribution = (\n            (assists_per_90_hist / 90.0)\n            * expected_minutes\n            * (expected_team_goals / 1.5)\n        )  # Similarly scale by team's expected goals\n        xp += expected_assists_player_contribution * self.fpl_points[\"assist_points\"]\n\n        # 4. Expected Clean Sheets (for GKs/DEFs/MIDs) and Conceded Goals deduction\n        expected_conceded = self._calculate_expected_conceded_goals(\n            player_team_strength_defence, opponent_team_strength_attack\n        )\n\n        # Probability of clean sheet\n        # Simplified: higher team defense / lower opponent attack -&gt; higher CS prob\n        # Use logistic or sigmoid for probability\n        cs_prob = 1.0 / (\n            1.0 + math.exp(expected_conceded - 1.0)\n        )  # Sigmoid centered at 1 goal\n\n        if position in [\"GK\", \"DEF\"]:\n            xp += cs_prob * self.fpl_points[\"clean_sheet_gk_def\"]\n\n            # Conceded goals deduction: Apply penalty for every 2 goals conceded *probability*\n            # For simplicity, calculate expected deduction: (expected_conceded / 2) * deduction\n            xp += (expected_conceded / 2.0) * self.fpl_points[\n                \"conceded_2_goals_deduction\"\n            ]\n        elif position == \"MID\":\n            xp += cs_prob * self.fpl_points[\"clean_sheet_mid\"]\n\n        # 5. Expected Saves (for GKs)\n        if position == \"GK\":\n            saves_per_90_hist = (\n                (player[\"saves\"] / player[\"minutes\"] * 90)\n                if player[\"minutes\"] &gt; 0\n                else 0.0\n            )\n            # Expected saves scaled by opponent's attacking strength (more attacking -&gt; more shots -&gt; more saves)\n            expected_saves_player_contribution = (\n                (saves_per_90_hist / 90.0)\n                * expected_minutes\n                * (opponent_team_strength_attack / player_team_strength_defence)\n            )\n            xp += (expected_saves_player_contribution / 3.0) * self.fpl_points[\n                \"saves_3_points\"\n            ]  # Using the new config point value\n\n            # Penalty saves (low probability, use historical rate)\n            penalty_saves_hist_per_game = (\n                player[\"penalties_saved\"] / (player[\"minutes\"] / 90.0)\n                if player[\"minutes\"] &gt; 0\n                else 0.0\n            )\n            xp += (\n                penalty_saves_hist_per_game\n                * (expected_minutes / 90.0)\n                * self.fpl_points[\"penalty_save_points\"]\n            )\n\n        # 6. Expected Bonus Points\n        # Use BPS (Bonus Points System) as a proxy. Scale player's average BPS by form and expected minutes.\n        bps_per_90_hist = (\n            (player[\"bps\"] / player[\"minutes\"] * 90) if player[\"minutes\"] &gt; 0 else 0.0\n        )\n        expected_bps = (bps_per_90_hist / 90.0) * expected_minutes * player[\"form\"]\n        xp += expected_bps * self.fpl_points[\"bonus_points_scaling_factor\"]\n\n        # 7. Minor Negative Events (Probabilistic)\n        # These are rare, so a simple probability based on expected minutes.\n        xp += (expected_minutes / 90.0) * (\n            self.fpl_points[\"yellow_card_deduction\"] * YELLOW_CARD_PROB\n            + self.fpl_points[\"red_card_deduction\"] * RED_CARD_PROB\n            + self.fpl_points[\"own_goal_deduction\"] * OWN_GOAL_PROB\n            + self.fpl_points[\"penalty_miss_deduction\"] * PENALTY_MISS_PROB\n        )\n\n        # 8. Defensive Contribution Points (for 2025/26 season)\n        # Use actual defensive_contribution data from API\n        defensive_contribution_per_90 = (\n            (player[\"defensive_contribution\"] / player[\"minutes\"] * 90)\n            if player[\"minutes\"] &gt; 0\n            else 0.0\n        )\n        expected_defensive_contribution = (defensive_contribution_per_90 / 90.0) * expected_minutes\n\n        # Award defensive contribution points based on position thresholds\n        if position in [\"DEF\", \"MID\", \"FWD\"]:  # Goalkeepers do not earn defensive contribution points\n            xp += expected_defensive_contribution * self.fpl_points[\"defensive_contribution_points\"]\n\n        # Apply confidence factor to final xP\n        xp = xp * confidence_factor\n\n        return {\"xp\": round(xp, 2), \"reason\": \"Success\", \"confidence\": confidence_factor}\n\n    def _calculate_all_players_xp(self):\n        \"\"\"\n        Calculates the Expected Points (xP) for all players over multiple upcoming gameweeks\n        and populates self.all_players_xp_calculated_data with xP per gameweek.\n        \"\"\"\n        print(\n            f\"Calculating xP for all players over {self.gameweeks_to_predict} gameweek(s)...\"\n        )\n\n        # Get all upcoming fixtures and sort them by gameweek\n        all_upcoming_fixtures_items = sorted(\n            [\n                (fid, fdict)\n                for fid, fdict in self.fixtures_data.items()\n                if not fdict[\"finished\"]\n            ],\n            key=lambda item: item[1][\"event\"],\n        )\n\n        if not all_upcoming_fixtures_items:\n            print(\"No upcoming fixtures found. Cannot calculate xP.\")\n            return\n\n        # Determine the current gameweek (the gameweek of the earliest upcoming fixture)\n        current_gameweek = all_upcoming_fixtures_items[0][1][\"event\"]\n        target_gameweeks = range(\n            current_gameweek, current_gameweek + self.gameweeks_to_predict\n        )\n\n        # Create a mapping of team_id_code to a list of their fixtures within the target gameweeks\n        team_fixtures_in_range = {team_code: [] for team_code in self.teams_data.keys()}\n        for fixture_id, fixture_data in all_upcoming_fixtures_items:\n            if fixture_data[\"event\"] in target_gameweeks:\n                home_team_code = fixture_data[\"team_h\"]\n                away_team_code = fixture_data[\"team_a\"]\n\n                team_fixtures_in_range[home_team_code].append(fixture_id)\n                team_fixtures_in_range[away_team_code].append(fixture_id)\n\n        # Calculate total xP for each player across the specified gameweeks\n        for player_id, player_data in self.players_data.items():\n            player_team_code = player_data[\"team_id\"]\n            player_position = player_data[\"position\"]\n\n            # Calculate xP for each relevant fixture and store by gameweek\n            expected_points_by_gw = {}\n            for fixture_id in team_fixtures_in_range.get(player_team_code, []):\n                fixture_gameweek = self.fixtures_data[fixture_id][\"event\"]\n                xp_result_single_gw = self.calculate_xp_for_player(\n                    player_id, fixture_id\n                )\n                if xp_result_single_gw and xp_result_single_gw[\"xp\"] is not None:\n                    if fixture_gameweek not in expected_points_by_gw:\n                        expected_points_by_gw[fixture_gameweek] = 0.0\n                    expected_points_by_gw[fixture_gameweek] += xp_result_single_gw[\"xp\"]\n\n            # Ensure all target gameweeks are present, even if xP is 0 for a given GW\n            for gw in target_gameweeks:\n                if gw not in expected_points_by_gw:\n                    expected_points_by_gw[gw] = 0.0\n\n            # Sort the dictionary by gameweek for consistent output\n            expected_points_by_gw = dict(sorted(expected_points_by_gw.items()))\n\n            # Prepare data for the optimizer\n            player_cost_m = player_data[\"cost_pence\"] / 10.0\n            team_name_full = self.teams_data.get(player_team_code, {}).get(\n                \"name\", \"Unknown Team\"\n            )\n\n            self.all_players_xp_calculated_data.append(\n                {\n                    \"name\": player_data[\"name\"],\n                    \"web_name\": player_data[\"web_name\"],\n                    \"team\": team_name_full,\n                    \"position\": player_position,\n                    \"cost\": player_cost_m,\n                    \"expected_points_by_gw\": expected_points_by_gw,  # Changed key and format\n                }\n            )\n        print(\"xP calculation for all players complete.\")\n\n    def get_upcoming_fixtures(self, limit=None):\n        \"\"\"\n        Returns a list of upcoming fixtures, sorted by gameweek and kickoff time.\n        Optionally limits the number of fixtures returned.\n        \"\"\"\n        upcoming = []\n        now = datetime.now()\n\n        # Sort all fixtures by gameweek and then by kickoff time\n        sorted_fixtures = sorted(\n            self.fixtures_data.values(),\n            key=lambda x: (\n                x.get(\"event\", 0),\n                x.get(\"kickoff_time\", \"9999-12-31T00:00:00Z\"),\n            ),\n        )\n\n        current_gameweek = None\n        for fixture_data in sorted_fixtures:\n            # Determine current gameweek from the earliest upcoming fixture\n            if not fixture_data[\"finished\"] and current_gameweek is None:\n                current_gameweek = fixture_data.get(\"event\", 0)\n\n            # Filter for upcoming fixtures within the prediction horizon\n            if (\n                fixture_data.get(\"event\", 0) &lt; current_gameweek  # Skip past gameweeks\n                or fixture_data.get(\"event\", 0)\n                &gt;= current_gameweek + self.gameweeks_to_predict\n            ):\n                continue  # Skip fixtures outside the prediction horizon\n\n            home_team_name = self.teams_data.get(\n                fixture_data[\"team_h\"], {}\n            ).get(  # Use 'team_h'\n                \"name\", \"Unknown\"\n            )\n            away_team_name = self.teams_data.get(\n                fixture_data[\"team_a\"], {}\n            ).get(  # Use 'team_a'\n                \"name\", \"Unknown\"\n            )\n\n            # Only add fixtures that are not finished\n            if not fixture_data[\"finished\"]:\n                upcoming.append(\n                    {\n                        \"fixture_id\": fixture_data[\"id\"],\n                        \"gameweek\": fixture_data.get(\"event\"),\n                        \"home_team_id\": fixture_data[\"team_h\"],  # Use 'team_h'\n                        \"away_team_id\": fixture_data[\"team_a\"],  # Use 'team_a'\n                        \"match\": f\"{home_team_name} vs {away_team_name}\",\n                        \"kickoff_time\": fixture_data.get(\"kickoff_time\"),\n                        \"home_team_difficulty\": fixture_data[\"team_h_difficulty\"],\n                        \"away_team_difficulty\": fixture_data[\"team_a_difficulty\"],\n                    }\n                )\n            if limit is not None and len(upcoming) &gt;= limit:\n                break\n        return upcoming\n\n    def get_players_for_optimizer(self):\n        \"\"\"\n        Returns the list of player data with calculated xP per gameweek,\n        formatted for the FPLOptimizer.\n        \"\"\"\n        return self.all_players_xp_calculated_data\n\n    def clear_cache(self):\n        \"\"\"\n        Clear all cached API responses. Use this when you want to force fresh data\n        from the FPL API.\n        \"\"\"\n        self.cache_manager.clear_cache()\n        self.logger.info(\"Cleared API response cache\")\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/#build.lib.fpl_solver.xp_predictor.FPLPredictor.__init__","title":"<code>__init__(gameweeks_to_predict=1)</code>","text":"<p>Initialize the FPLPredictor with data structures and fetch initial data.</p> <p>Parameters:</p> Name Type Description Default <code>gameweeks_to_predict</code> <code>int</code> <p>Number of upcoming gameweeks to calculate                 expected points for. Default is 1 (next gameweek).</p> <code>1</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If gameweeks_to_predict is not a positive integer</p> Source code in <code>build/lib/fpl_solver/xp_predictor.py</code> <pre><code>def __init__(self, gameweeks_to_predict: int = 1):\n    \"\"\"\n    Initialize the FPLPredictor with data structures and fetch initial data.\n\n    Args:\n        gameweeks_to_predict: Number of upcoming gameweeks to calculate\n                            expected points for. Default is 1 (next gameweek).\n\n    Raises:\n        ValueError: If gameweeks_to_predict is not a positive integer\n    \"\"\"\n    self.logger = setup_logger(__name__)\n    if not isinstance(gameweeks_to_predict, int) or gameweeks_to_predict &lt; 1:\n        msg = f\"gameweeks_to_predict must be a positive integer, got {gameweeks_to_predict}\"\n        self.logger.error(msg)\n        raise ValueError(msg)\n\n    self.gameweeks_to_predict = gameweeks_to_predict\n    self.logger.info(f\"Initializing FPL Predictor for {gameweeks_to_predict} gameweek(s)\")\n\n    # Initialize cache manager\n    cache_dir = os.path.join(os.path.dirname(__file__), 'cache')\n    self.cache_manager = CacheManager(cache_dir)\n\n    # Configuration and static data\n    self.fpl_points: Dict[str, float] = FPL_POINTS\n    self.position_definitions: Dict[int, str] = {\n        1: \"GK\",\n        2: \"DEF\",\n        3: \"MID\",\n        4: \"FWD\",\n    }\n\n    # Data structures for FPL information\n    self.players_data: Dict[int, Dict] = {}\n    self.teams_data: Dict[int, Dict] = {}\n    self.fixtures_data: Dict[int, Dict] = {}\n    self.all_players_xp_calculated_data: List[Dict] = []\n\n    # Initialize data\n    try:\n        self._fetch_fpl_data()\n        self._calculate_all_players_xp()\n    except Exception as e:\n        self.logger.error(f\"Failed to initialize FPL Predictor: {str(e)}\")\n        raise\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/#build.lib.fpl_solver.xp_predictor.FPLPredictor.calculate_xp_for_player","title":"<code>calculate_xp_for_player(player_id, fixture_id)</code>","text":"<p>Calculates Expected Points (xP) for a single player in a given fixture. Considers various factors: minutes, goals, assists, clean sheets, saves, bonus points, and negative events, adjusted for fixture difficulty.</p> Source code in <code>build/lib/fpl_solver/xp_predictor.py</code> <pre><code>def calculate_xp_for_player(self, player_id, fixture_id):\n    \"\"\"\n    Calculates Expected Points (xP) for a single player in a given fixture.\n    Considers various factors: minutes, goals, assists, clean sheets, saves,\n    bonus points, and negative events, adjusted for fixture difficulty.\n    \"\"\"\n    player = self.players_data.get(player_id)\n    fixture = self.fixtures_data.get(fixture_id)\n\n    if not player or not fixture:\n        return {\"xp\": 0.0, \"reason\": \"Player or fixture data missing.\"}\n\n    # Handle unavailable players\n    if (\n        player[\"status\"] != \"a\"\n    ):  # 'd' for doubtful, 'i' for injured, 's' for suspended\n        return {\"xp\": 0.0, \"reason\": f\"Player status: {player['status']}\"}\n    if any(\n        x in player[\"news\"].lower()\n        for x in [\"injured\", \"doubtful\", \"suspension\", \"red card\"]\n    ):\n        return {\"xp\": 0.0, \"reason\": f\"Player news: {player['news']}\"}\n\n    # Predict minutes\n    expected_minutes = self._predict_minutes(player_id)\n    if expected_minutes &lt; 1.0:  # If expected to play very little or none\n        return {\"xp\": 0.0, \"reason\": \"Expected minutes too low.\"}\n\n    xp = 0.0\n    position = player[\"position\"]\n    # Use 'team_h' for home team ID\n    is_home_fixture = player[\"team_id\"] == fixture[\"team_h\"]\n\n    # Determine attacking and defensive strengths for the fixture\n    player_team_strength_attack = (\n        self.teams_data.get(fixture[\"team_h\"], {}).get(\n            \"strength_attack_home\"\n        )  # Use 'team_h'\n        if is_home_fixture\n        else self.teams_data.get(fixture[\"team_a\"], {}).get(\n            \"strength_attack_away\"\n        )  # Use 'team_a'\n    )\n    player_team_strength_defence = (\n        self.teams_data.get(fixture[\"team_h\"], {}).get(\n            \"strength_defence_home\"\n        )  # Use 'team_h'\n        if is_home_fixture\n        else self.teams_data.get(fixture[\"team_a\"], {}).get(\n            \"strength_defence_away\"\n        )  # Use 'team_a'\n    )\n    opponent_team_strength_attack = (\n        self.teams_data.get(fixture[\"team_a\"], {}).get(\n            \"strength_attack_away\"\n        )  # Use 'team_a'\n        if is_home_fixture\n        else self.teams_data.get(fixture[\"team_h\"], {}).get(\n            \"strength_attack_home\"\n        )  # Use 'team_h'\n    )\n    opponent_team_strength_defence = (\n        self.teams_data.get(fixture[\"team_a\"], {}).get(\n            \"strength_defence_away\"\n        )  # Use 'team_a'\n        if is_home_fixture\n        else self.teams_data.get(fixture[\"team_h\"], {}).get(\n            \"strength_defence_home\"\n        )  # Use 'team_h'\n    )\n\n    if None in [\n        player_team_strength_attack,\n        player_team_strength_defence,\n        opponent_team_strength_attack,\n        opponent_team_strength_defence,\n    ]:\n        # Fallback if strength data is missing (shouldn't happen with robust data fetch)\n        return {\"xp\": 0.0, \"reason\": \"Team strength data missing for fixture.\"}\n\n    # Apply confidence factor based on historical minutes\n    minutes_played = player.get(\"minutes\", 0)\n    confidence_factor = XP_CONFIDENCE_FACTORS[\"proven\"]  # Default to proven player\n    if minutes_played &lt; VERY_LOW_MINUTES_THRESHOLD:\n        confidence_factor = XP_CONFIDENCE_FACTORS[\"very_low_minutes\"]\n    elif minutes_played &lt; MIN_MINUTES_THRESHOLD:\n        confidence_factor = XP_CONFIDENCE_FACTORS[\"low_minutes\"]\n\n    # 1. Appearance points\n    if expected_minutes &gt;= 60:\n        xp += self.fpl_points[\"appearance_points_gte_60\"]\n    elif expected_minutes &gt; 0:\n        xp += self.fpl_points[\"appearance_points_lt_60\"]\n\n    # 2. Expected Goals (scaled by historical goals per 90 and opponent difficulty)\n    # Use player's form and total goals as a basis\n    goals_per_90_hist = (\n        (player[\"goals_scored\"] / player[\"minutes\"] * 90)\n        if player[\"minutes\"] &gt; 0\n        else 0.0\n    )\n    expected_team_goals = self._calculate_expected_goals(\n        player_team_strength_attack, opponent_team_strength_defence\n    )\n\n    expected_goals_player_contribution = (\n        (goals_per_90_hist / 90.0) * expected_minutes * (expected_team_goals / 1.5)\n    )  # Scale player's goal contribution by team's expected goals\n\n    if position == \"GK\":\n        xp += expected_goals_player_contribution * self.fpl_points[\"goal_gk\"]\n    elif position == \"DEF\":\n        xp += expected_goals_player_contribution * self.fpl_points[\"goal_def\"]\n    elif position == \"MID\":\n        xp += expected_goals_player_contribution * self.fpl_points[\"goal_mid\"]\n    elif position == \"FWD\":\n        xp += expected_goals_player_contribution * self.fpl_points[\"goal_fwd\"]\n\n    # 3. Expected Assists (scaled by historical assists per 90 and opponent difficulty)\n    assists_per_90_hist = (\n        (player[\"assists\"] / player[\"minutes\"] * 90)\n        if player[\"minutes\"] &gt; 0\n        else 0.0\n    )\n    # Assuming team's attacking strength correlates with assist opportunities\n    expected_assists_player_contribution = (\n        (assists_per_90_hist / 90.0)\n        * expected_minutes\n        * (expected_team_goals / 1.5)\n    )  # Similarly scale by team's expected goals\n    xp += expected_assists_player_contribution * self.fpl_points[\"assist_points\"]\n\n    # 4. Expected Clean Sheets (for GKs/DEFs/MIDs) and Conceded Goals deduction\n    expected_conceded = self._calculate_expected_conceded_goals(\n        player_team_strength_defence, opponent_team_strength_attack\n    )\n\n    # Probability of clean sheet\n    # Simplified: higher team defense / lower opponent attack -&gt; higher CS prob\n    # Use logistic or sigmoid for probability\n    cs_prob = 1.0 / (\n        1.0 + math.exp(expected_conceded - 1.0)\n    )  # Sigmoid centered at 1 goal\n\n    if position in [\"GK\", \"DEF\"]:\n        xp += cs_prob * self.fpl_points[\"clean_sheet_gk_def\"]\n\n        # Conceded goals deduction: Apply penalty for every 2 goals conceded *probability*\n        # For simplicity, calculate expected deduction: (expected_conceded / 2) * deduction\n        xp += (expected_conceded / 2.0) * self.fpl_points[\n            \"conceded_2_goals_deduction\"\n        ]\n    elif position == \"MID\":\n        xp += cs_prob * self.fpl_points[\"clean_sheet_mid\"]\n\n    # 5. Expected Saves (for GKs)\n    if position == \"GK\":\n        saves_per_90_hist = (\n            (player[\"saves\"] / player[\"minutes\"] * 90)\n            if player[\"minutes\"] &gt; 0\n            else 0.0\n        )\n        # Expected saves scaled by opponent's attacking strength (more attacking -&gt; more shots -&gt; more saves)\n        expected_saves_player_contribution = (\n            (saves_per_90_hist / 90.0)\n            * expected_minutes\n            * (opponent_team_strength_attack / player_team_strength_defence)\n        )\n        xp += (expected_saves_player_contribution / 3.0) * self.fpl_points[\n            \"saves_3_points\"\n        ]  # Using the new config point value\n\n        # Penalty saves (low probability, use historical rate)\n        penalty_saves_hist_per_game = (\n            player[\"penalties_saved\"] / (player[\"minutes\"] / 90.0)\n            if player[\"minutes\"] &gt; 0\n            else 0.0\n        )\n        xp += (\n            penalty_saves_hist_per_game\n            * (expected_minutes / 90.0)\n            * self.fpl_points[\"penalty_save_points\"]\n        )\n\n    # 6. Expected Bonus Points\n    # Use BPS (Bonus Points System) as a proxy. Scale player's average BPS by form and expected minutes.\n    bps_per_90_hist = (\n        (player[\"bps\"] / player[\"minutes\"] * 90) if player[\"minutes\"] &gt; 0 else 0.0\n    )\n    expected_bps = (bps_per_90_hist / 90.0) * expected_minutes * player[\"form\"]\n    xp += expected_bps * self.fpl_points[\"bonus_points_scaling_factor\"]\n\n    # 7. Minor Negative Events (Probabilistic)\n    # These are rare, so a simple probability based on expected minutes.\n    xp += (expected_minutes / 90.0) * (\n        self.fpl_points[\"yellow_card_deduction\"] * YELLOW_CARD_PROB\n        + self.fpl_points[\"red_card_deduction\"] * RED_CARD_PROB\n        + self.fpl_points[\"own_goal_deduction\"] * OWN_GOAL_PROB\n        + self.fpl_points[\"penalty_miss_deduction\"] * PENALTY_MISS_PROB\n    )\n\n    # 8. Defensive Contribution Points (for 2025/26 season)\n    # Use actual defensive_contribution data from API\n    defensive_contribution_per_90 = (\n        (player[\"defensive_contribution\"] / player[\"minutes\"] * 90)\n        if player[\"minutes\"] &gt; 0\n        else 0.0\n    )\n    expected_defensive_contribution = (defensive_contribution_per_90 / 90.0) * expected_minutes\n\n    # Award defensive contribution points based on position thresholds\n    if position in [\"DEF\", \"MID\", \"FWD\"]:  # Goalkeepers do not earn defensive contribution points\n        xp += expected_defensive_contribution * self.fpl_points[\"defensive_contribution_points\"]\n\n    # Apply confidence factor to final xP\n    xp = xp * confidence_factor\n\n    return {\"xp\": round(xp, 2), \"reason\": \"Success\", \"confidence\": confidence_factor}\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/#build.lib.fpl_solver.xp_predictor.FPLPredictor.clear_cache","title":"<code>clear_cache()</code>","text":"<p>Clear all cached API responses. Use this when you want to force fresh data from the FPL API.</p> Source code in <code>build/lib/fpl_solver/xp_predictor.py</code> <pre><code>def clear_cache(self):\n    \"\"\"\n    Clear all cached API responses. Use this when you want to force fresh data\n    from the FPL API.\n    \"\"\"\n    self.cache_manager.clear_cache()\n    self.logger.info(\"Cleared API response cache\")\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/#build.lib.fpl_solver.xp_predictor.FPLPredictor.get_players_for_optimizer","title":"<code>get_players_for_optimizer()</code>","text":"<p>Returns the list of player data with calculated xP per gameweek, formatted for the FPLOptimizer.</p> Source code in <code>build/lib/fpl_solver/xp_predictor.py</code> <pre><code>def get_players_for_optimizer(self):\n    \"\"\"\n    Returns the list of player data with calculated xP per gameweek,\n    formatted for the FPLOptimizer.\n    \"\"\"\n    return self.all_players_xp_calculated_data\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/#build.lib.fpl_solver.xp_predictor.FPLPredictor.get_upcoming_fixtures","title":"<code>get_upcoming_fixtures(limit=None)</code>","text":"<p>Returns a list of upcoming fixtures, sorted by gameweek and kickoff time. Optionally limits the number of fixtures returned.</p> Source code in <code>build/lib/fpl_solver/xp_predictor.py</code> <pre><code>def get_upcoming_fixtures(self, limit=None):\n    \"\"\"\n    Returns a list of upcoming fixtures, sorted by gameweek and kickoff time.\n    Optionally limits the number of fixtures returned.\n    \"\"\"\n    upcoming = []\n    now = datetime.now()\n\n    # Sort all fixtures by gameweek and then by kickoff time\n    sorted_fixtures = sorted(\n        self.fixtures_data.values(),\n        key=lambda x: (\n            x.get(\"event\", 0),\n            x.get(\"kickoff_time\", \"9999-12-31T00:00:00Z\"),\n        ),\n    )\n\n    current_gameweek = None\n    for fixture_data in sorted_fixtures:\n        # Determine current gameweek from the earliest upcoming fixture\n        if not fixture_data[\"finished\"] and current_gameweek is None:\n            current_gameweek = fixture_data.get(\"event\", 0)\n\n        # Filter for upcoming fixtures within the prediction horizon\n        if (\n            fixture_data.get(\"event\", 0) &lt; current_gameweek  # Skip past gameweeks\n            or fixture_data.get(\"event\", 0)\n            &gt;= current_gameweek + self.gameweeks_to_predict\n        ):\n            continue  # Skip fixtures outside the prediction horizon\n\n        home_team_name = self.teams_data.get(\n            fixture_data[\"team_h\"], {}\n        ).get(  # Use 'team_h'\n            \"name\", \"Unknown\"\n        )\n        away_team_name = self.teams_data.get(\n            fixture_data[\"team_a\"], {}\n        ).get(  # Use 'team_a'\n            \"name\", \"Unknown\"\n        )\n\n        # Only add fixtures that are not finished\n        if not fixture_data[\"finished\"]:\n            upcoming.append(\n                {\n                    \"fixture_id\": fixture_data[\"id\"],\n                    \"gameweek\": fixture_data.get(\"event\"),\n                    \"home_team_id\": fixture_data[\"team_h\"],  # Use 'team_h'\n                    \"away_team_id\": fixture_data[\"team_a\"],  # Use 'team_a'\n                    \"match\": f\"{home_team_name} vs {away_team_name}\",\n                    \"kickoff_time\": fixture_data.get(\"kickoff_time\"),\n                    \"home_team_difficulty\": fixture_data[\"team_h_difficulty\"],\n                    \"away_team_difficulty\": fixture_data[\"team_a_difficulty\"],\n                }\n            )\n        if limit is not None and len(upcoming) &gt;= limit:\n            break\n    return upcoming\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/cache_manager/","title":"cache_manager","text":"<p>Cache manager for FPL API responses.</p> <p>This module provides functionality to cache API responses locally and manage their expiry.</p>"},{"location":"autoapi/build/lib/fpl_solver/cache_manager/#build.lib.fpl_solver.cache_manager.CacheManager","title":"<code>CacheManager</code>","text":"Source code in <code>build/lib/fpl_solver/cache_manager.py</code> <pre><code>class CacheManager:\n    def __init__(self, cache_dir: str, cache_expiry_hours: int = 3):\n        \"\"\"\n        Initialize the cache manager.\n\n        Args:\n            cache_dir: Directory to store cache files\n            cache_expiry_hours: Number of hours after which cache should be considered stale\n        \"\"\"\n        self.cache_dir = cache_dir\n        self.cache_expiry = timedelta(hours=cache_expiry_hours)\n\n        # Create cache directory if it doesn't exist\n        if not os.path.exists(cache_dir):\n            os.makedirs(cache_dir)\n\n    def _get_cache_path(self, endpoint: str) -&gt; str:\n        \"\"\"Get the full path for a cache file.\"\"\"\n        return os.path.join(self.cache_dir, f\"{endpoint}.json\")\n\n    def get_cached_response(self, endpoint: str) -&gt; Optional[Dict[str, Any]]:\n        \"\"\"\n        Retrieve cached response if it exists and is not expired.\n\n        Args:\n            endpoint: API endpoint identifier (e.g., 'static' or 'fixtures')\n\n        Returns:\n            Cached data if valid, None otherwise\n        \"\"\"\n        cache_path = self._get_cache_path(endpoint)\n\n        if not os.path.exists(cache_path):\n            return None\n\n        try:\n            with open(cache_path, 'r') as f:\n                cached_data = json.load(f)\n\n            # Check if cache has expired\n            cached_time = datetime.fromtimestamp(cached_data['cached_at'])\n            if datetime.now() - cached_time &gt; self.cache_expiry:\n                return None\n\n            return cached_data['data']\n\n        except (json.JSONDecodeError, KeyError, ValueError) as e:\n            # If there's any issue with the cache file, ignore it\n            return None\n\n    def save_response(self, endpoint: str, data: Dict[str, Any]) -&gt; None:\n        \"\"\"\n        Save API response to cache.\n\n        Args:\n            endpoint: API endpoint identifier\n            data: Response data to cache\n        \"\"\"\n        cache_path = self._get_cache_path(endpoint)\n\n        cache_data = {\n            'cached_at': time.time(),\n            'data': data\n        }\n\n        with open(cache_path, 'w') as f:\n            json.dump(cache_data, f)\n\n    def clear_cache(self) -&gt; None:\n        \"\"\"Clear all cached data.\"\"\"\n        for filename in os.listdir(self.cache_dir):\n            if filename.endswith('.json'):\n                os.remove(os.path.join(self.cache_dir, filename))\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/cache_manager/#build.lib.fpl_solver.cache_manager.CacheManager.__init__","title":"<code>__init__(cache_dir, cache_expiry_hours=3)</code>","text":"<p>Initialize the cache manager.</p> <p>Parameters:</p> Name Type Description Default <code>cache_dir</code> <code>str</code> <p>Directory to store cache files</p> required <code>cache_expiry_hours</code> <code>int</code> <p>Number of hours after which cache should be considered stale</p> <code>3</code> Source code in <code>build/lib/fpl_solver/cache_manager.py</code> <pre><code>def __init__(self, cache_dir: str, cache_expiry_hours: int = 3):\n    \"\"\"\n    Initialize the cache manager.\n\n    Args:\n        cache_dir: Directory to store cache files\n        cache_expiry_hours: Number of hours after which cache should be considered stale\n    \"\"\"\n    self.cache_dir = cache_dir\n    self.cache_expiry = timedelta(hours=cache_expiry_hours)\n\n    # Create cache directory if it doesn't exist\n    if not os.path.exists(cache_dir):\n        os.makedirs(cache_dir)\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/cache_manager/#build.lib.fpl_solver.cache_manager.CacheManager.clear_cache","title":"<code>clear_cache()</code>","text":"<p>Clear all cached data.</p> Source code in <code>build/lib/fpl_solver/cache_manager.py</code> <pre><code>def clear_cache(self) -&gt; None:\n    \"\"\"Clear all cached data.\"\"\"\n    for filename in os.listdir(self.cache_dir):\n        if filename.endswith('.json'):\n            os.remove(os.path.join(self.cache_dir, filename))\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/cache_manager/#build.lib.fpl_solver.cache_manager.CacheManager.get_cached_response","title":"<code>get_cached_response(endpoint)</code>","text":"<p>Retrieve cached response if it exists and is not expired.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>API endpoint identifier (e.g., 'static' or 'fixtures')</p> required <p>Returns:</p> Type Description <code>Optional[Dict[str, Any]]</code> <p>Cached data if valid, None otherwise</p> Source code in <code>build/lib/fpl_solver/cache_manager.py</code> <pre><code>def get_cached_response(self, endpoint: str) -&gt; Optional[Dict[str, Any]]:\n    \"\"\"\n    Retrieve cached response if it exists and is not expired.\n\n    Args:\n        endpoint: API endpoint identifier (e.g., 'static' or 'fixtures')\n\n    Returns:\n        Cached data if valid, None otherwise\n    \"\"\"\n    cache_path = self._get_cache_path(endpoint)\n\n    if not os.path.exists(cache_path):\n        return None\n\n    try:\n        with open(cache_path, 'r') as f:\n            cached_data = json.load(f)\n\n        # Check if cache has expired\n        cached_time = datetime.fromtimestamp(cached_data['cached_at'])\n        if datetime.now() - cached_time &gt; self.cache_expiry:\n            return None\n\n        return cached_data['data']\n\n    except (json.JSONDecodeError, KeyError, ValueError) as e:\n        # If there's any issue with the cache file, ignore it\n        return None\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/cache_manager/#build.lib.fpl_solver.cache_manager.CacheManager.save_response","title":"<code>save_response(endpoint, data)</code>","text":"<p>Save API response to cache.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>API endpoint identifier</p> required <code>data</code> <code>Dict[str, Any]</code> <p>Response data to cache</p> required Source code in <code>build/lib/fpl_solver/cache_manager.py</code> <pre><code>def save_response(self, endpoint: str, data: Dict[str, Any]) -&gt; None:\n    \"\"\"\n    Save API response to cache.\n\n    Args:\n        endpoint: API endpoint identifier\n        data: Response data to cache\n    \"\"\"\n    cache_path = self._get_cache_path(endpoint)\n\n    cache_data = {\n        'cached_at': time.time(),\n        'data': data\n    }\n\n    with open(cache_path, 'w') as f:\n        json.dump(cache_data, f)\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/config/","title":"config","text":"<p>fpl_config.py</p> <p>Configuration settings for the FPL Expected Points Predictor and Solver. This file centralizes all constants related to FPL scoring, thresholds, and optimization parameters.</p>"},{"location":"autoapi/build/lib/fpl_solver/logger/","title":"logger","text":"<p>Logging configuration for the FPL Solver package.</p>"},{"location":"autoapi/build/lib/fpl_solver/logger/#build.lib.fpl_solver.logger.setup_logger","title":"<code>setup_logger(name, level=None)</code>","text":"<p>Set up a logger with consistent formatting and optional level override.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the logger</p> required <code>level</code> <code>Optional[int]</code> <p>Optional logging level override. If None, uses INFO</p> <code>None</code> <p>Returns:</p> Type Description <code>Logger</code> <p>logging.Logger: Configured logger instance</p> Source code in <code>build/lib/fpl_solver/logger.py</code> <pre><code>def setup_logger(name: str, level: Optional[int] = None) -&gt; logging.Logger:\n    \"\"\"\n    Set up a logger with consistent formatting and optional level override.\n\n    Args:\n        name: The name of the logger\n        level: Optional logging level override. If None, uses INFO\n\n    Returns:\n        logging.Logger: Configured logger instance\n    \"\"\"\n    logger = logging.getLogger(name)\n\n    if not logger.handlers:  # Only add handler if logger doesn't have one\n        handler = logging.StreamHandler(sys.stdout)\n        formatter = logging.Formatter(\n            '%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n            datefmt='%Y-%m-%d %H:%M:%S'\n        )\n        handler.setFormatter(formatter)\n        logger.addHandler(handler)\n\n    logger.setLevel(level or logging.INFO)\n    return logger\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/solver/","title":"solver","text":"<p>FPL Squad Optimizer using PuLP for Integer Linear Programming (ILP).</p> <p>This module provides optimization functionality to select the best possible FPL squad over multiple gameweeks, considering transfer constraints and chips.</p>"},{"location":"autoapi/build/lib/fpl_solver/solver/#build.lib.fpl_solver.solver.FPLOptimizer","title":"<code>FPLOptimizer</code>","text":"<p>A class to optimize Fantasy Premier League (FPL) squad selection using Integer Linear Programming (ILP).</p> <p>The optimizer aims to select a 15-player squad (2 GKs, 5 DEFs, 5 MIDs, 3 FWDs) within a budget, with a maximum number of players from any single team, to maximize the total expected points.</p> Source code in <code>build/lib/fpl_solver/solver.py</code> <pre><code>class FPLOptimizer:\n    \"\"\"\n    A class to optimize Fantasy Premier League (FPL) squad selection\n    using Integer Linear Programming (ILP).\n\n    The optimizer aims to select a 15-player squad (2 GKs, 5 DEFs, 5 MIDs, 3 FWDs)\n    within a budget, with a maximum number of players from any single team,\n    to maximize the total expected points.\n    \"\"\"\n\n    def __init__(self, player_data: pd.DataFrame):\n        \"\"\"\n        Initializes the FPLOptimizer with player data.\n\n        Args:\n            player_data (pd.DataFrame): A DataFrame containing player information\n                                        with columns: 'name', 'team', 'position',\n                                        'cost', 'expected_points_by_gw' (a dict of xP per GW).\n        \"\"\"\n        required_columns = [\"name\", \"team\", \"position\", \"cost\", \"expected_points_by_gw\"]\n        if not all(col in player_data.columns for col in required_columns):\n            missing_cols = [\n                col for col in required_columns if col not in player_data.columns\n            ]\n            raise ValueError(\n                f\"player_data DataFrame must contain {required_columns} columns. Missing: {missing_cols}\"\n            )\n\n        self.player_data = player_data\n        self.problem = None\n        self.selected_squad_history = {}  # To store squad for each gameweek\n        self.total_cost = 0\n        self.total_expected_points = 0\n        self.total_transfer_hits = 0\n\n        # --- Process Enforced Players ---\n        self.enforced_player_indices = set()\n        self.enforced_team_pos_requirements = []\n\n        print(\"\\n--- Processing Enforced Players ---\")\n\n        # Enforce by Player ID\n        for player_id in ENFORCED_PLAYERS_BY_ID:\n            found_player = self.player_data[self.player_data[\"id\"] == player_id]\n            if not found_player.empty:\n                player_idx = found_player.index[0]\n                self.enforced_player_indices.add(player_idx)\n                print(\n                    f\"Enforcing player by ID: {found_player.loc[player_idx, 'name']} (ID: {player_id})\"\n                )\n            else:\n                print(\n                    f\"Warning: Enforced player with ID {player_id} not found in data.\"\n                )\n\n        # Enforce by Player Name\n        for player_name in ENFORCED_PLAYERS_BY_NAME:\n            found_player = self.player_data[self.player_data[\"name\"] == player_name]\n            if not found_player.empty:\n                player_idx = found_player.index[0]\n                self.enforced_player_indices.add(player_idx)\n                print(f\"Enforcing player by name: {player_name}\")\n            else:\n                print(f\"Warning: Enforced player '{player_name}' not found in data.\")\n\n        # Enforce by Team and Position\n        for requirement in ENFORCED_PLAYERS_BY_TEAM_AND_POSITION:\n            team = requirement.get(\"team\")\n            position = requirement.get(\"position\")\n            if team and position:\n                # Validate team and position exist in data\n                if team not in self.player_data[\"team\"].unique():\n                    print(\n                        f\"Warning: Enforced team '{team}' for position '{position}' not found in data.\"\n                    )\n                    continue\n                if position not in self.player_data[\"position\"].unique():\n                    print(\n                        f\"Warning: Enforced position '{position}' for team '{team}' not found in data.\"\n                    )\n                    continue\n\n                self.enforced_team_pos_requirements.append((team, position))\n                print(f\"Enforcing at least one {position} from {team}.\")\n            else:\n                print(\n                    f\"Warning: Invalid enforced team/position requirement: {requirement}\"\n                )\n\n        if not (\n            self.enforced_player_indices\n            or self.enforced_team_pos_requirements\n            or ENFORCED_PLAYERS_BY_ID\n            or ENFORCED_PLAYERS_BY_NAME\n            or ENFORCED_PLAYERS_BY_TEAM_AND_POSITION\n        ):\n            print(\"No players or team/position combinations are enforced.\")\n        print(\"-----------------------------------\\n\")\n\n    def solve(\n        self,\n        budget: float,\n        max_players_per_team: int,\n        chip_allowances: dict,\n        num_gameweeks: int,\n    ) -&gt; bool:\n        \"\"\"\n        Solves the FPL optimization problem using PuLP.\n\n        Args:\n            budget (float): The maximum budget in millions of pounds.\n            max_players_per_team (int): The maximum number of players allowed from\n                                        any single Premier League team.\n            chip_allowances (dict): A dictionary specifying the maximum usage for each chip.\n            num_gameweeks (int): The number of gameweeks to optimize over.\n\n        Returns:\n            bool: True if a solution was found, False otherwise.\n        \"\"\"\n        self.problem = LpProblem(\"FPL Squad Multi-Week Optimization\", LpMaximize)\n\n        # Decision variables for player selection, indexed by player and gameweek\n        player_vars = LpVariable.dicts(\n            \"Player\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n        )\n        starting_xi_vars = LpVariable.dicts(\n            \"StartingXI\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n        )\n        captain_var = LpVariable.dicts(\n            \"Captain\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n        )\n\n        # Binary variables for chip usage, indexed by gameweek\n        use_bench_boost = LpVariable.dicts(\n            \"Use_Bench_Boost\", range(num_gameweeks), 0, 1, LpBinary\n        )\n        use_triple_captain = LpVariable.dicts(\n            \"Use_Triple_Captain\", range(num_gameweeks), 0, 1, LpBinary\n        )\n\n        # Transfer variables\n        transfer_in_vars = LpVariable.dicts(\n            \"Transfer_In\",\n            (self.player_data.index, range(1, num_gameweeks)),\n            0,\n            1,\n            LpBinary,\n        )\n        transfer_out_vars = LpVariable.dicts(\n            \"Transfer_Out\",\n            (self.player_data.index, range(1, num_gameweeks)),\n            0,\n            1,\n            LpBinary,\n        )\n\n        # Total transfers made in a gameweek (absolute count)\n        transfers_made = LpVariable.dicts(\n            \"Transfers_Made\", range(1, num_gameweeks), 0, None, LpInteger\n        )\n        # Free transfers available at the start of a gameweek\n        free_transfers_available = LpVariable.dicts(\n            \"Free_Transfers_Available\",\n            range(num_gameweeks),\n            0,\n            MAX_FREE_TRANSFERS_SAVED + 1,\n            LpInteger,\n        )\n        # Number of transfer hits taken in a gameweek\n        transfer_hits = LpVariable.dicts(\n            \"Transfer_Hits\", range(1, num_gameweeks), 0, None, LpInteger\n        )\n\n        # Auxiliary variables for linearizing chip effects\n        is_bench_player = LpVariable.dicts(\n            \"Is_Bench_Player\",\n            (self.player_data.index, range(num_gameweeks)),\n            0,\n            1,\n            LpBinary,\n        )\n        actual_bench_boost_points = LpVariable.dicts(\n            \"Actual_Bench_Boost_Points\",\n            (self.player_data.index, range(num_gameweeks)),\n            0,\n            None,\n            LpContinuous,\n        )\n        actual_triple_captain_bonus = LpVariable.dicts(\n            \"Actual_Triple_Captain_Bonus\",\n            (self.player_data.index, range(num_gameweeks)),\n            0,\n            None,\n            LpContinuous,\n        )\n\n        # --- Objective Function ---\n        total_objective_points = []\n\n        # Get the first gameweek number from the player data to correctly index expected_points_by_gw\n        first_gw_key = next(\n            iter(\n                self.player_data.loc[\n                    self.player_data.index[0], \"expected_points_by_gw\"\n                ].keys()\n            )\n        )\n        current_gameweek_number_start = int(first_gw_key)\n\n        for w in range(num_gameweeks):\n            # The actual gameweek number (1-indexed)\n            gw_actual = current_gameweek_number_start + w\n\n            # Base expected points from the selected starting 11 for this gameweek\n            base_points_expression_gw = lpSum(\n                self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n                * starting_xi_vars[i][w]\n                for i in self.player_data.index\n            )\n            total_objective_points.append(base_points_expression_gw)\n\n            # Regular Captaincy points (additional 1x for captain)\n            captain_points_bonus_gw = lpSum(\n                self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n                * captain_var[i][w]\n                for i in self.player_data.index\n            )\n            total_objective_points.append(captain_points_bonus_gw)\n\n            # Define auxiliary variables and constraints for chips for each gameweek\n            for i in self.player_data.index:\n                # Use gameweek-specific player xP for chip calculations\n                player_xp = self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n\n                # Bench Boost auxiliary variables and constraints\n                self.problem += (\n                    is_bench_player[i][w] &lt;= player_vars[i][w],\n                    f\"IsBench_Squad_{i}_{w}\",\n                )\n                self.problem += (\n                    is_bench_player[i][w] &lt;= 1 - starting_xi_vars[i][w],\n                    f\"IsBench_NotStarter_{i}_{w}\",\n                )\n                self.problem += (\n                    is_bench_player[i][w]\n                    &gt;= player_vars[i][w] + (1 - starting_xi_vars[i][w]) - 1,\n                    f\"IsBench_Logical_{i}_{w}\",\n                )\n\n                self.problem += (\n                    actual_bench_boost_points[i][w]\n                    &lt;= player_xp * is_bench_player[i][w],\n                    f\"BenchBoost_Contr_1_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_bench_boost_points[i][w] &lt;= player_xp * use_bench_boost[w],\n                    f\"BenchBoost_Contr_2_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_bench_boost_points[i][w]\n                    &gt;= player_xp * (is_bench_player[i][w] + use_bench_boost[w] - 1),\n                    f\"BenchBoost_Contr_3_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_bench_boost_points[i][w] &gt;= 0,\n                    f\"BenchBoost_Contr_4_{i}_{w}\",\n                )\n\n                # Triple Captain auxiliary variables and constraints\n                # Changed player_xp * 2 to player_xp to reflect additional 1x bonus\n                self.problem += (\n                    actual_triple_captain_bonus[i][w] &lt;= player_xp * captain_var[i][w],\n                    f\"TripleCaptain_Contr_1_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_triple_captain_bonus[i][w]\n                    &lt;= player_xp * use_triple_captain[w],\n                    f\"TripleCaptain_Contr_2_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_triple_captain_bonus[i][w]\n                    &gt;= player_xp * (captain_var[i][w] + use_triple_captain[w] - 1),\n                    f\"TripleCaptain_Contr_3_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_triple_captain_bonus[i][w] &gt;= 0,\n                    f\"TripleCaptain_Contr_4_{i}_{w}\",\n                )\n\n            # Add points from bench boost and triple captain bonus for this gameweek\n            total_bench_boost_points_gw = lpSum(\n                actual_bench_boost_points[i][w] for i in self.player_data.index\n            )\n            total_triple_captain_bonus_points_gw = lpSum(\n                actual_triple_captain_bonus[i][w] for i in self.player_data.index\n            )\n\n            total_objective_points.append(total_bench_boost_points_gw)\n            total_objective_points.append(total_triple_captain_bonus_points_gw)\n\n        # Subtract transfer hits from the total objective\n        total_objective_points.append(\n            -POINTS_PER_HIT * lpSum(transfer_hits[w] for w in range(1, num_gameweeks))\n        )\n\n        self.problem += (\n            lpSum(total_objective_points),\n            \"Total Expected Points Over Gameweeks\",\n        )\n\n        # --- Constraints ---\n\n        # Apply constraints for each gameweek\n        for w in range(num_gameweeks):\n            # 1. Select exactly 15 players for the squad\n            self.problem += (\n                lpSum(player_vars[i][w] for i in self.player_data.index) == 15,\n                f\"Total_Players_GW{w}\",\n            )\n\n            # 2. Squad position constraints (2 GKs, 5 DEFs, 5 MIDs, 3 FWDs)\n            gks = self.player_data[self.player_data[\"position\"] == \"GK\"].index\n            defs = self.player_data[self.player_data[\"position\"] == \"DEF\"].index\n            mids = self.player_data[self.player_data[\"position\"] == \"MID\"].index\n            fwds = self.player_data[self.player_data[\"position\"] == \"FWD\"].index\n\n            self.problem += (\n                lpSum(player_vars[i][w] for i in gks) == 2,\n                f\"Goalkeepers_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(player_vars[i][w] for i in defs) == 5,\n                f\"Defenders_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(player_vars[i][w] for i in mids) == 5,\n                f\"Midfielders_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(player_vars[i][w] for i in fwds) == 3,\n                f\"Forwards_Count_GW{w}\",\n            )\n\n            # 3. Budget constraint\n            # This applies to the cost of the squad for the current gameweek.\n            self.problem += (\n                lpSum(\n                    self.player_data.loc[i, \"cost\"] * player_vars[i][w]\n                    for i in self.player_data.index\n                )\n                &lt;= budget,\n                f\"Total_Budget_GW{w}\",\n            )\n\n            # 4. Maximum players per team constraint\n            for team in self.player_data[\"team\"].unique():\n                team_players = self.player_data[self.player_data[\"team\"] == team].index\n                self.problem += (\n                    lpSum(player_vars[i][w] for i in team_players)\n                    &lt;= max_players_per_team,\n                    f\"Max_Players_from_{team}_GW{w}\",\n                )\n\n            # 5. Starting XI constraints\n            # 5.1 Select exactly 11 players for the starting XI\n            self.problem += (\n                lpSum(starting_xi_vars[i][w] for i in self.player_data.index) == 11,\n                f\"Total_Starting_XI_Players_GW{w}\",\n            )\n\n            # 5.2 A player can only be in the starting XI if they are in the squad\n            for i in self.player_data.index:\n                self.problem += (\n                    starting_xi_vars[i][w] &lt;= player_vars[i][w],\n                    f\"StartingXI_in_Squad_{i}_{w}\",\n                )\n\n            # 5.3 Starting XI position constraints (FPL allows flexible formations, so use minimums)\n            self.problem += (\n                lpSum(starting_xi_vars[i][w] for i in gks) == 1,\n                f\"Starting_Goalkeepers_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(starting_xi_vars[i][w] for i in defs) &gt;= 3,\n                f\"Min_Starting_Defenders_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(starting_xi_vars[i][w] for i in mids) &gt;= 2,\n                f\"Min_Starting_Midfielders_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(starting_xi_vars[i][w] for i in fwds) &gt;= 1,\n                f\"Min_Starting_Forwards_Count_GW{w}\",\n            )\n\n            # 6. Captain Constraints\n            # 6.1 Select exactly one captain from the starting XI\n            self.problem += (\n                lpSum(captain_var[i][w] for i in self.player_data.index) == 1,\n                f\"One_Captain_GW{w}\",\n            )\n\n            # 6.2 A player can only be captain if they are in the starting XI\n            for i in self.player_data.index:\n                self.problem += (\n                    captain_var[i][w] &lt;= starting_xi_vars[i][w],\n                    f\"Captain_in_StartingXI_{i}_{w}\",\n                )\n\n            # --- Enforced Player Constraints---\n            for player_idx in self.enforced_player_indices:\n                self.problem += (\n                    player_vars[player_idx][w] == 1,\n                    f\"Enforce_Player_{self.player_data.loc[player_idx, 'name']}_GW{w}\",\n                )\n\n            for team, position in self.enforced_team_pos_requirements:\n                # Filter players for the current team and position\n                team_pos_players = self.player_data[\n                    (self.player_data[\"team\"] == team)\n                    &amp; (self.player_data[\"position\"] == position)\n                ].index\n                if not team_pos_players.empty:\n                    self.problem += (\n                        lpSum(player_vars[i][w] for i in team_pos_players) &gt;= 1,\n                        f\"Enforce_One_{position}_from_{team}_GW{w}\",\n                    )\n                else:\n                    print(\n                        f\"Warning: No players found for enforced requirement: at least one {position} from {team} for GW{gw_actual}.\"\n                    )\n\n        # --- Chip Usage Constraints (TOTAL usage over all gameweeks) ---\n        # These constraints should be outside the per-gameweek loop to avoid duplicates.\n        self.problem += (\n            lpSum(use_bench_boost[j] for j in range(num_gameweeks))\n            &lt;= chip_allowances.get(\"bench_boost\", 0),\n            f\"Max_Bench_Boost_Usage_Total\",\n        )\n        self.problem += (\n            lpSum(use_triple_captain[j] for j in range(num_gameweeks))\n            &lt;= chip_allowances.get(\"triple_captain\", 0),\n            f\"Max_Triple_Captain_Usage_Total\",\n        )\n\n        # --- Inter-Gameweek Constraints (Transfers and Transfer Rules) ---\n        # Initialize free transfers for GW0 (first gameweek of optimization horizon)\n        # This assumes the optimization starts at GW0, and it has INITIAL_FREE_TRANSFERS.\n        # If the model starts at an arbitrary GW, this would need to be an input.\n        self.problem += (\n            free_transfers_available[0] == INITIAL_FREE_TRANSFERS,\n            f\"Initial_Free_Transfers_GW0\",\n        )\n\n        for w in range(1, num_gameweeks):\n            # Calculate total transfers made in this gameweek\n            self.problem += (\n                transfers_made[w]\n                == lpSum(transfer_in_vars[i][w] for i in self.player_data.index),\n                f\"Transfers_Made_GW{w}\",\n            )\n            # Total transfers in must equal total transfers out for each gameweek after the first\n            self.problem += (\n                lpSum(transfer_in_vars[i][w] for i in self.player_data.index)\n                == lpSum(transfer_out_vars[i][w] for i in self.player_data.index),\n                f\"Transfers_In_Equals_Out_GW{w}\",\n            )\n\n            # Calculate free transfers available for the current gameweek (w)\n            # Free transfers for GW_w = min(free transfers from GW_w-1 - transfers made in GW_w + 1, MAX_FREE_TRANSFERS_SAVED + 1)\n            # The + 1 in MAX_FREE_TRANSFERS_SAVED + 1 is because MAX_FREE_TRANSFERS_SAVED implies how many can be *saved*,\n            # so if you save 1, you have 1 (current) + 1 (saved) = 2.\n            self.problem += (\n                free_transfers_available[w]\n                &lt;= free_transfers_available[w - 1] - transfers_made[w] + 1,\n                f\"Free_Transfers_Calc_1_GW{w}\",\n            )\n            self.problem += (\n                free_transfers_available[w] &lt;= MAX_FREE_TRANSFERS_SAVED + 1,\n                f\"Free_Transfers_Calc_2_GW{w}\",\n            )\n            self.problem += (\n                free_transfers_available[w] &gt;= 0,  # Cannot have negative free transfers\n                f\"Free_Transfers_Non_Negative_GW{w}\",\n            )\n\n            # Calculate transfer hits\n            # transfer_hits[w] = max(0, transfers_made[w] - free_transfers_available_at_start_of_gw_w)\n            # This needs to be linearized. If transfers_made[w] &gt; free_transfers_available[w-1], then hit.\n            # free_transfers_available[w-1] represents transfers available *before* making transfers for GW_w\n            self.problem += (\n                transfer_hits[w] &gt;= transfers_made[w] - free_transfers_available[w - 1],\n                f\"Transfer_Hits_Calc_1_GW{w}\",\n            )\n            self.problem += (\n                transfer_hits[w] &gt;= 0,\n                f\"Transfer_Hits_Calc_2_GW{w}\",\n            )\n\n            for i in self.player_data.index:\n                # Squad continuity: player_vars[i][w] (in squad at start of GW w)\n                #                 = player_vars[i][w-1] (in squad at start of GW w-1)\n                #                 - transfer_out_vars[i][w] (transferred out for GW w)\n                #                 + transfer_in_vars[i][w] (transferred in for GW w)\n                self.problem += (\n                    player_vars[i][w]\n                    == player_vars[i][w - 1]\n                    - transfer_out_vars[i][w]\n                    + transfer_in_vars[i][w],\n                    f\"Squad_Continuity_{i}_GW{w}\",\n                )\n                # A player cannot be transferred in and out in the same gameweek\n                self.problem += (\n                    transfer_in_vars[i][w] + transfer_out_vars[i][w] &lt;= 1,\n                    f\"No_Simultaneous_Transfer_{i}_{w}\",\n                )\n\n        try:\n            # The solver is called with the GLPK_CMD solver\n            self.problem.solve(PULP_CBC_CMD(msg=0))  # msg=0 suppresses verbose output\n        except Exception as e:\n            print(f\"Error solving the problem: {e}\")\n            return False\n\n        if LpStatus[self.problem.status] == \"Optimal\":\n            print(\"Optimization successful! Optimal solution found.\")\n\n            self.selected_squad_history = {}\n            self.total_transfer_hits = 0\n            for w in range(num_gameweeks):\n                # The actual gameweek number (1-indexed)\n                gw_actual = current_gameweek_number_start + w\n\n                # Get selected players for the current gameweek\n                selected_squad_gw = self.player_data[\n                    [player_vars[i][w].varValue == 1 for i in self.player_data.index]\n                ].copy()\n\n                # Get starter and captain info for this gameweek\n                is_starter_series_gw = pd.Series(\n                    [\n                        starting_xi_vars[i][w].varValue == 1\n                        for i in self.player_data.index\n                    ],\n                    index=self.player_data.index,\n                )\n                is_captain_series_gw = pd.Series(\n                    [captain_var[i][w].varValue == 1 for i in self.player_data.index],\n                    index=self.player_data.index,\n                )\n\n                selected_squad_gw[\"is_starter\"] = is_starter_series_gw.loc[\n                    selected_squad_gw.index\n                ]\n                selected_squad_gw[\"is_captain\"] = is_captain_series_gw.loc[\n                    selected_squad_gw.index\n                ]\n\n                transfers_in_gw = 0\n                transfers_out_gw = 0\n                hits_gw = 0\n\n                # Store transfer details for gameweeks &gt; 0\n                if (\n                    w &gt; 0\n                ):  # Check for transfers only from GW1 onwards (index 1 in 0-indexed loop)\n                    transfer_in_flags = pd.Series(\n                        [\n                            transfer_in_vars[i][w].varValue == 1\n                            for i in self.player_data.index\n                        ],\n                        index=self.player_data.index,\n                    )\n                    transfer_out_flags = pd.Series(\n                        [\n                            transfer_out_vars[i][w].varValue == 1\n                            for i in self.player_data.index\n                        ],\n                        index=self.player_data.index,\n                    )\n\n                    selected_squad_gw[\"transfer_in\"] = transfer_in_flags.loc[\n                        selected_squad_gw.index\n                    ]\n                    selected_squad_gw[\"transfer_out\"] = transfer_out_flags.loc[\n                        selected_squad_gw.index\n                    ]\n\n                    transfers_in_gw = int(round(transfer_in_flags.sum()))\n                    transfers_out_gw = int(round(transfer_out_flags.sum()))\n                    hits_gw = int(round(transfer_hits[w].varValue))\n                    self.total_transfer_hits += hits_gw\n                else:\n                    selected_squad_gw[\"transfer_in\"] = False  # No transfers in for GW0\n                    selected_squad_gw[\"transfer_out\"] = (\n                        False  # No transfers out for GW0\n                    )\n\n                self.selected_squad_history[f\"GW{gw_actual}\"] = {\n                    \"squad\": selected_squad_gw,\n                    \"total_cost\": selected_squad_gw[\"cost\"].sum(),\n                    \"expected_points_from_xi\": sum(\n                        self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n                        * starting_xi_vars[i][w].varValue\n                        for i in self.player_data.index\n                    ),\n                    \"bench_boost_used\": bool(use_bench_boost[w].varValue),\n                    \"triple_captain_used\": bool(use_triple_captain[w].varValue),\n                    \"total_bench_boost_points\": value(\n                        lpSum(\n                            actual_bench_boost_points[i][w]\n                            for i in self.player_data.index\n                        )\n                    ),\n                    \"total_triple_captain_bonus\": value(\n                        lpSum(\n                            actual_triple_captain_bonus[i][w]\n                            for i in self.player_data.index\n                        )\n                    ),\n                    \"transfers_in_count\": transfers_in_gw,\n                    \"transfers_out_count\": transfers_out_gw,\n                    \"transfer_hits\": hits_gw,  # New\n                    \"free_transfers_available_next_gw\": (\n                        int(round(free_transfers_available[w].varValue))\n                        if w &lt; num_gameweeks - 1\n                        else 0\n                    ),  # Free transfers available *after* this GW's transfers are made\n                }\n\n            # Overall totals\n            self.total_cost = self.selected_squad_history[\n                f\"GW{current_gameweek_number_start + num_gameweeks - 1}\"\n            ][\n                \"total_cost\"\n            ]  # Cost of final squad\n            self.total_expected_points = value(\n                self.problem.objective\n            )  # Total objective value from solver\n            self.used_chips = {\n                f\"GW{current_gameweek_number_start + w}\": {\n                    \"bench_boost\": bool(use_bench_boost[w].varValue),\n                    \"triple_captain\": bool(use_triple_captain[w].varValue),\n                }\n                for w in range(num_gameweeks)\n            }\n\n            return True\n        else:\n            print(f\"No optimal solution found. Status: {LpStatus[self.problem.status]}\")\n            self.selected_squad_history = {}\n            self.total_cost = 0\n            self.total_expected_points = 0\n            self.used_chips = {}\n            self.total_transfer_hits = 0\n            return False\n\n    def get_selected_squad(self, gameweek: int = None) -&gt; pd.DataFrame | None:\n        \"\"\"\n        Returns the selected squad for a specific gameweek (1-indexed).\n        If no gameweek is specified, returns the squad for the last optimized gameweek.\n        \"\"\"\n        if not self.selected_squad_history:\n            return None\n\n        # Get the first GW key to determine the range of available GWs\n        first_gw_in_history = min(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n        last_gw_in_history = max(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n\n        if gameweek is None:\n            return self.selected_squad_history[f\"GW{last_gw_in_history}\"][\"squad\"]\n\n        if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n            print(\n                f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n            )\n            return None\n\n        return self.selected_squad_history.get(f\"GW{gameweek}\", {}).get(\"squad\")\n\n    def get_total_cost(self, gameweek: int = None) -&gt; float:\n        \"\"\"\n        Returns the total cost for a specific gameweek (1-indexed).\n        If no gameweek is specified, returns the cost of the squad in the last optimized gameweek.\n        \"\"\"\n        if not self.selected_squad_history:\n            return 0\n        first_gw_in_history = min(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n        last_gw_in_history = max(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n\n        if gameweek is None:\n            return self.selected_squad_history[f\"GW{last_gw_in_history}\"][\"total_cost\"]\n\n        if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n            print(\n                f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n            )\n            return 0  # Or raise an error\n\n        return self.selected_squad_history.get(f\"GW{gameweek}\", {}).get(\"total_cost\", 0)\n\n    def get_total_expected_points(self) -&gt; float:\n        \"\"\"\n        Returns the overall total expected points across all optimized gameweeks.\n        \"\"\"\n        return self.total_expected_points\n\n    def get_gameweek_summary(self, gameweek: int):\n        \"\"\"\n        Returns a dictionary summary for a specific gameweek.\n        \"\"\"\n        if not self.selected_squad_history:\n            return None\n        first_gw_in_history = min(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n        last_gw_in_history = max(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n\n        if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n            print(\n                f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n            )\n            return None\n\n        return self.selected_squad_history.get(f\"GW{gameweek}\")\n\n    def print_squad_summary(self, gameweek: int):\n        \"\"\"\n        Prints a formatted summary of the selected squad for a specific gameweek.\n        \"\"\"\n        if not self.selected_squad_history:\n            print(\"No squad has been selected yet. Run the 'solve' method first.\")\n            return\n\n        gw_data = self.get_gameweek_summary(gameweek)\n        if not gw_data:\n            return  # get_gameweek_summary already prints error message\n\n        selected_squad = gw_data[\"squad\"]\n        total_cost = gw_data[\"total_cost\"]\n        expected_points_from_xi = gw_data[\"expected_points_from_xi\"]\n        bench_boost_used = gw_data[\"bench_boost_used\"]\n        triple_captain_used = gw_data[\"triple_captain_used\"]\n        total_bench_boost_points = gw_data[\"total_bench_boost_points\"]\n        total_triple_captain_bonus = gw_data[\"total_triple_captain_bonus\"]\n        transfers_in_count = gw_data[\"transfers_in_count\"]  # New\n        transfers_out_count = gw_data[\"transfers_out_count\"]  # New\n        transfer_hits_taken = gw_data[\"transfer_hits\"]  # New\n        free_transfers_available_next_gw = gw_data[\n            \"free_transfers_available_next_gw\"\n        ]  # New\n\n        print(f\"\\n--- FPL Optimized Squad for Gameweek {gameweek} ---\")\n        print(f\"Squad Cost: \u00a3{total_cost:.1f}m\")\n        print(f\"Expected Points (Starting XI): {expected_points_from_xi:.2f}\")\n        print(\n            f\"Total Expected Points for GW{gameweek} (including chips): {expected_points_from_xi + total_bench_boost_points + total_triple_captain_bonus:.2f}\"\n        )\n        print(\"\\n--- Chips Used This Gameweek ---\")\n        if bench_boost_used:\n            print(f\"- Bench Boost (Added {total_bench_boost_points:.2f} points)\")\n        if triple_captain_used:\n            print(\n                f\"- Triple Captain (Added {total_triple_captain_bonus:.2f} bonus points)\"\n            )\n        if not (bench_boost_used or triple_captain_used):\n            print(\"No chips used this gameweek.\")\n\n        print(\"\\n--- Goalkeepers (Starting XI marked with *) ---\")\n        for index, row in selected_squad[selected_squad[\"position\"] == \"GK\"].iterrows():\n            starter_str = \"*\" if row[\"is_starter\"] else \"\"\n            captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n            transfer_status = \"\"\n            if row[\"transfer_in\"]:\n                transfer_status = \"(IN)\"\n            elif row[\"transfer_out\"]:\n                transfer_status = \"(OUT)\"\n\n            # Access gameweek-specific xP correctly\n            player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n            print(\n                f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n            )\n        print(\"\\n--- Defenders (Starting XI marked with *) ---\")\n        for index, row in selected_squad[\n            selected_squad[\"position\"] == \"DEF\"\n        ].iterrows():\n            starter_str = \"*\" if row[\"is_starter\"] else \"\"\n            captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n            transfer_status = \"\"\n            if row[\"transfer_in\"]:\n                transfer_status = \"(IN)\"\n            elif row[\"transfer_out\"]:\n                transfer_status = \"(OUT)\"\n\n            player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n            print(\n                f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n            )\n        print(\"\\n--- Midfielders (Starting XI marked with *) ---\")\n        for index, row in selected_squad[\n            selected_squad[\"position\"] == \"MID\"\n        ].iterrows():\n            starter_str = \"*\" if row[\"is_starter\"] else \"\"\n            captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n            transfer_status = \"\"\n            if row[\"transfer_in\"]:\n                transfer_status = \"(IN)\"\n            elif row[\"transfer_out\"]:\n                transfer_status = \"(OUT)\"\n\n            player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n            print(\n                f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n            )\n        print(\"\\n--- Forwards (Starting XI marked with *) ---\")\n        for index, row in selected_squad[\n            selected_squad[\"position\"] == \"FWD\"\n        ].iterrows():\n            starter_str = \"*\" if row[\"is_starter\"] else \"\"\n            captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n            transfer_status = \"\"\n            if row[\"transfer_in\"]:\n                transfer_status = \"(IN)\"\n            elif row[\"transfer_out\"]:\n                transfer_status = \"(OUT)\"\n\n            player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n            print(\n                f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n            )\n\n        print(f\"\\n--- Team Breakdown for GW{gameweek} ---\")\n        print(selected_squad[\"team\"].value_counts())\n\n        # Transfers are relevant from Gameweek 2 (index 1) onwards in the optimization horizon\n        # For display, if the current GW is the initial one (GW1 in the current context), no transfers are made\n        # If it's a subsequent GW, check if transfers occurred.\n        first_gw_in_history = min(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n        if (\n            gameweek &gt;= first_gw_in_history\n        ):  # Changed from &gt; to &gt;=, to show initial free transfers\n            # Display transfer info for this gameweek\n            print(\n                f\"  Transfers In: {transfers_in_count}, Transfers Out: {transfers_out_count}\"\n            )\n            print(\n                f\"  Transfer Hits: {transfer_hits_taken} (-{transfer_hits_taken * POINTS_PER_HIT} points)\"\n            )\n            # Only show free transfers for the *next* gameweek if it's not the last gameweek in the horizon\n            if gameweek &lt; max(\n                int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n            ):\n                print(\n                    f\"  Free Transfers Available for Next GW: {free_transfers_available_next_gw}\"\n                )\n        print(\"---------------------------\\n\")\n\n    def print_overall_summary(self):\n        \"\"\"\n        Prints an overall summary of the multi-week optimization results.\n        \"\"\"\n        if not self.selected_squad_history:\n            print(\"No optimization results to summarize.\")\n            return\n\n        print(\"\\n=== Overall Multi-Week FPL Optimization Summary ===\")\n        print(\n            f\"Total Expected Points Across All Gameweeks: {self.total_expected_points:.2f}\"\n        )\n\n        # Get the latest gameweek's cost\n        last_gw_key = max(\n            self.selected_squad_history.keys(), key=lambda k: int(k.replace(\"GW\", \"\"))\n        )\n        print(\n            f\"Squad Cost ({last_gw_key}): \u00a3{self.selected_squad_history[last_gw_key]['total_cost']:.1f}m\"\n        )\n        print(\n            f\"Total Transfer Hits Taken: {self.total_transfer_hits} (-{self.total_transfer_hits * POINTS_PER_HIT} points)\"\n        )\n\n        print(\"\\n--- Chip Usage Across Gameweeks ---\")\n        # Ensure consistent order by sorting gameweek keys\n        sorted_gw_keys = sorted(\n            self.used_chips.keys(), key=lambda k: int(k.replace(\"GW\", \"\"))\n        )\n        for gw_str in sorted_gw_keys:\n            chips = self.used_chips[gw_str]\n            chip_summary = []\n            if chips[\"bench_boost\"]:\n                chip_summary.append(\"Bench Boost\")\n            if chips[\"triple_captain\"]:\n                chip_summary.append(\"Triple Captain\")\n\n            if chip_summary:\n                print(f\"{gw_str}: {', '.join(chip_summary)}\")\n            else:\n                print(f\"{gw_str}: No chips used\")\n\n        print(\"\\n--- Gameweek-by-Gameweek Summary ---\")\n        # Iterate and print basic summary for each gameweek\n        for gw_str in sorted_gw_keys:\n            gw_data = self.selected_squad_history[gw_str]\n            print(f\"\\n--- {gw_str} ---\")\n            print(f\"  Squad Cost: \u00a3{gw_data['total_cost']:.1f}m\")\n            print(\n                f\"  Expected Points (Starting XI): {gw_data['expected_points_from_xi']:.2f}\"\n            )\n            print(\n                f\"  Total GW Points (incl. chips): {gw_data['expected_points_from_xi'] + gw_data['total_bench_boost_points'] + gw_data['total_triple_captain_bonus']:.2f}\"\n            )\n\n            # Display transfer info for this gameweek\n            transfers_in_count = gw_data[\"transfers_in_count\"]\n            transfers_out_count = gw_data[\"transfers_out_count\"]\n            transfer_hits_taken = gw_data[\"transfer_hits\"]\n            free_transfers_available_next_gw = gw_data[\n                \"free_transfers_available_next_gw\"\n            ]\n\n            print(\n                f\"  Transfers In: {transfers_in_count}, Transfers Out: {transfers_out_count}\"\n            )\n            print(\n                f\"  Transfer Hits: {transfer_hits_taken} (-{transfer_hits_taken * POINTS_PER_HIT} points)\"\n            )\n            # Only show free transfers for the *next* gameweek if it's not the last gameweek in the horizon\n            if int(gw_str.replace(\"GW\", \"\")) &lt; max(\n                int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n            ):\n                print(\n                    f\"  Free Transfers Available for Next GW: {free_transfers_available_next_gw}\"\n                )\n            print(\"-----------------------------------\")\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/solver/#build.lib.fpl_solver.solver.FPLOptimizer.__init__","title":"<code>__init__(player_data)</code>","text":"<p>Initializes the FPLOptimizer with player data.</p> <p>Parameters:</p> Name Type Description Default <code>player_data</code> <code>DataFrame</code> <p>A DataFrame containing player information                         with columns: 'name', 'team', 'position',                         'cost', 'expected_points_by_gw' (a dict of xP per GW).</p> required Source code in <code>build/lib/fpl_solver/solver.py</code> <pre><code>def __init__(self, player_data: pd.DataFrame):\n    \"\"\"\n    Initializes the FPLOptimizer with player data.\n\n    Args:\n        player_data (pd.DataFrame): A DataFrame containing player information\n                                    with columns: 'name', 'team', 'position',\n                                    'cost', 'expected_points_by_gw' (a dict of xP per GW).\n    \"\"\"\n    required_columns = [\"name\", \"team\", \"position\", \"cost\", \"expected_points_by_gw\"]\n    if not all(col in player_data.columns for col in required_columns):\n        missing_cols = [\n            col for col in required_columns if col not in player_data.columns\n        ]\n        raise ValueError(\n            f\"player_data DataFrame must contain {required_columns} columns. Missing: {missing_cols}\"\n        )\n\n    self.player_data = player_data\n    self.problem = None\n    self.selected_squad_history = {}  # To store squad for each gameweek\n    self.total_cost = 0\n    self.total_expected_points = 0\n    self.total_transfer_hits = 0\n\n    # --- Process Enforced Players ---\n    self.enforced_player_indices = set()\n    self.enforced_team_pos_requirements = []\n\n    print(\"\\n--- Processing Enforced Players ---\")\n\n    # Enforce by Player ID\n    for player_id in ENFORCED_PLAYERS_BY_ID:\n        found_player = self.player_data[self.player_data[\"id\"] == player_id]\n        if not found_player.empty:\n            player_idx = found_player.index[0]\n            self.enforced_player_indices.add(player_idx)\n            print(\n                f\"Enforcing player by ID: {found_player.loc[player_idx, 'name']} (ID: {player_id})\"\n            )\n        else:\n            print(\n                f\"Warning: Enforced player with ID {player_id} not found in data.\"\n            )\n\n    # Enforce by Player Name\n    for player_name in ENFORCED_PLAYERS_BY_NAME:\n        found_player = self.player_data[self.player_data[\"name\"] == player_name]\n        if not found_player.empty:\n            player_idx = found_player.index[0]\n            self.enforced_player_indices.add(player_idx)\n            print(f\"Enforcing player by name: {player_name}\")\n        else:\n            print(f\"Warning: Enforced player '{player_name}' not found in data.\")\n\n    # Enforce by Team and Position\n    for requirement in ENFORCED_PLAYERS_BY_TEAM_AND_POSITION:\n        team = requirement.get(\"team\")\n        position = requirement.get(\"position\")\n        if team and position:\n            # Validate team and position exist in data\n            if team not in self.player_data[\"team\"].unique():\n                print(\n                    f\"Warning: Enforced team '{team}' for position '{position}' not found in data.\"\n                )\n                continue\n            if position not in self.player_data[\"position\"].unique():\n                print(\n                    f\"Warning: Enforced position '{position}' for team '{team}' not found in data.\"\n                )\n                continue\n\n            self.enforced_team_pos_requirements.append((team, position))\n            print(f\"Enforcing at least one {position} from {team}.\")\n        else:\n            print(\n                f\"Warning: Invalid enforced team/position requirement: {requirement}\"\n            )\n\n    if not (\n        self.enforced_player_indices\n        or self.enforced_team_pos_requirements\n        or ENFORCED_PLAYERS_BY_ID\n        or ENFORCED_PLAYERS_BY_NAME\n        or ENFORCED_PLAYERS_BY_TEAM_AND_POSITION\n    ):\n        print(\"No players or team/position combinations are enforced.\")\n    print(\"-----------------------------------\\n\")\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/solver/#build.lib.fpl_solver.solver.FPLOptimizer.get_gameweek_summary","title":"<code>get_gameweek_summary(gameweek)</code>","text":"<p>Returns a dictionary summary for a specific gameweek.</p> Source code in <code>build/lib/fpl_solver/solver.py</code> <pre><code>def get_gameweek_summary(self, gameweek: int):\n    \"\"\"\n    Returns a dictionary summary for a specific gameweek.\n    \"\"\"\n    if not self.selected_squad_history:\n        return None\n    first_gw_in_history = min(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n    last_gw_in_history = max(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n\n    if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n        print(\n            f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n        )\n        return None\n\n    return self.selected_squad_history.get(f\"GW{gameweek}\")\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/solver/#build.lib.fpl_solver.solver.FPLOptimizer.get_selected_squad","title":"<code>get_selected_squad(gameweek=None)</code>","text":"<p>Returns the selected squad for a specific gameweek (1-indexed). If no gameweek is specified, returns the squad for the last optimized gameweek.</p> Source code in <code>build/lib/fpl_solver/solver.py</code> <pre><code>def get_selected_squad(self, gameweek: int = None) -&gt; pd.DataFrame | None:\n    \"\"\"\n    Returns the selected squad for a specific gameweek (1-indexed).\n    If no gameweek is specified, returns the squad for the last optimized gameweek.\n    \"\"\"\n    if not self.selected_squad_history:\n        return None\n\n    # Get the first GW key to determine the range of available GWs\n    first_gw_in_history = min(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n    last_gw_in_history = max(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n\n    if gameweek is None:\n        return self.selected_squad_history[f\"GW{last_gw_in_history}\"][\"squad\"]\n\n    if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n        print(\n            f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n        )\n        return None\n\n    return self.selected_squad_history.get(f\"GW{gameweek}\", {}).get(\"squad\")\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/solver/#build.lib.fpl_solver.solver.FPLOptimizer.get_total_cost","title":"<code>get_total_cost(gameweek=None)</code>","text":"<p>Returns the total cost for a specific gameweek (1-indexed). If no gameweek is specified, returns the cost of the squad in the last optimized gameweek.</p> Source code in <code>build/lib/fpl_solver/solver.py</code> <pre><code>def get_total_cost(self, gameweek: int = None) -&gt; float:\n    \"\"\"\n    Returns the total cost for a specific gameweek (1-indexed).\n    If no gameweek is specified, returns the cost of the squad in the last optimized gameweek.\n    \"\"\"\n    if not self.selected_squad_history:\n        return 0\n    first_gw_in_history = min(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n    last_gw_in_history = max(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n\n    if gameweek is None:\n        return self.selected_squad_history[f\"GW{last_gw_in_history}\"][\"total_cost\"]\n\n    if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n        print(\n            f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n        )\n        return 0  # Or raise an error\n\n    return self.selected_squad_history.get(f\"GW{gameweek}\", {}).get(\"total_cost\", 0)\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/solver/#build.lib.fpl_solver.solver.FPLOptimizer.get_total_expected_points","title":"<code>get_total_expected_points()</code>","text":"<p>Returns the overall total expected points across all optimized gameweeks.</p> Source code in <code>build/lib/fpl_solver/solver.py</code> <pre><code>def get_total_expected_points(self) -&gt; float:\n    \"\"\"\n    Returns the overall total expected points across all optimized gameweeks.\n    \"\"\"\n    return self.total_expected_points\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/solver/#build.lib.fpl_solver.solver.FPLOptimizer.print_overall_summary","title":"<code>print_overall_summary()</code>","text":"<p>Prints an overall summary of the multi-week optimization results.</p> Source code in <code>build/lib/fpl_solver/solver.py</code> <pre><code>def print_overall_summary(self):\n    \"\"\"\n    Prints an overall summary of the multi-week optimization results.\n    \"\"\"\n    if not self.selected_squad_history:\n        print(\"No optimization results to summarize.\")\n        return\n\n    print(\"\\n=== Overall Multi-Week FPL Optimization Summary ===\")\n    print(\n        f\"Total Expected Points Across All Gameweeks: {self.total_expected_points:.2f}\"\n    )\n\n    # Get the latest gameweek's cost\n    last_gw_key = max(\n        self.selected_squad_history.keys(), key=lambda k: int(k.replace(\"GW\", \"\"))\n    )\n    print(\n        f\"Squad Cost ({last_gw_key}): \u00a3{self.selected_squad_history[last_gw_key]['total_cost']:.1f}m\"\n    )\n    print(\n        f\"Total Transfer Hits Taken: {self.total_transfer_hits} (-{self.total_transfer_hits * POINTS_PER_HIT} points)\"\n    )\n\n    print(\"\\n--- Chip Usage Across Gameweeks ---\")\n    # Ensure consistent order by sorting gameweek keys\n    sorted_gw_keys = sorted(\n        self.used_chips.keys(), key=lambda k: int(k.replace(\"GW\", \"\"))\n    )\n    for gw_str in sorted_gw_keys:\n        chips = self.used_chips[gw_str]\n        chip_summary = []\n        if chips[\"bench_boost\"]:\n            chip_summary.append(\"Bench Boost\")\n        if chips[\"triple_captain\"]:\n            chip_summary.append(\"Triple Captain\")\n\n        if chip_summary:\n            print(f\"{gw_str}: {', '.join(chip_summary)}\")\n        else:\n            print(f\"{gw_str}: No chips used\")\n\n    print(\"\\n--- Gameweek-by-Gameweek Summary ---\")\n    # Iterate and print basic summary for each gameweek\n    for gw_str in sorted_gw_keys:\n        gw_data = self.selected_squad_history[gw_str]\n        print(f\"\\n--- {gw_str} ---\")\n        print(f\"  Squad Cost: \u00a3{gw_data['total_cost']:.1f}m\")\n        print(\n            f\"  Expected Points (Starting XI): {gw_data['expected_points_from_xi']:.2f}\"\n        )\n        print(\n            f\"  Total GW Points (incl. chips): {gw_data['expected_points_from_xi'] + gw_data['total_bench_boost_points'] + gw_data['total_triple_captain_bonus']:.2f}\"\n        )\n\n        # Display transfer info for this gameweek\n        transfers_in_count = gw_data[\"transfers_in_count\"]\n        transfers_out_count = gw_data[\"transfers_out_count\"]\n        transfer_hits_taken = gw_data[\"transfer_hits\"]\n        free_transfers_available_next_gw = gw_data[\n            \"free_transfers_available_next_gw\"\n        ]\n\n        print(\n            f\"  Transfers In: {transfers_in_count}, Transfers Out: {transfers_out_count}\"\n        )\n        print(\n            f\"  Transfer Hits: {transfer_hits_taken} (-{transfer_hits_taken * POINTS_PER_HIT} points)\"\n        )\n        # Only show free transfers for the *next* gameweek if it's not the last gameweek in the horizon\n        if int(gw_str.replace(\"GW\", \"\")) &lt; max(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        ):\n            print(\n                f\"  Free Transfers Available for Next GW: {free_transfers_available_next_gw}\"\n            )\n        print(\"-----------------------------------\")\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/solver/#build.lib.fpl_solver.solver.FPLOptimizer.print_squad_summary","title":"<code>print_squad_summary(gameweek)</code>","text":"<p>Prints a formatted summary of the selected squad for a specific gameweek.</p> Source code in <code>build/lib/fpl_solver/solver.py</code> <pre><code>def print_squad_summary(self, gameweek: int):\n    \"\"\"\n    Prints a formatted summary of the selected squad for a specific gameweek.\n    \"\"\"\n    if not self.selected_squad_history:\n        print(\"No squad has been selected yet. Run the 'solve' method first.\")\n        return\n\n    gw_data = self.get_gameweek_summary(gameweek)\n    if not gw_data:\n        return  # get_gameweek_summary already prints error message\n\n    selected_squad = gw_data[\"squad\"]\n    total_cost = gw_data[\"total_cost\"]\n    expected_points_from_xi = gw_data[\"expected_points_from_xi\"]\n    bench_boost_used = gw_data[\"bench_boost_used\"]\n    triple_captain_used = gw_data[\"triple_captain_used\"]\n    total_bench_boost_points = gw_data[\"total_bench_boost_points\"]\n    total_triple_captain_bonus = gw_data[\"total_triple_captain_bonus\"]\n    transfers_in_count = gw_data[\"transfers_in_count\"]  # New\n    transfers_out_count = gw_data[\"transfers_out_count\"]  # New\n    transfer_hits_taken = gw_data[\"transfer_hits\"]  # New\n    free_transfers_available_next_gw = gw_data[\n        \"free_transfers_available_next_gw\"\n    ]  # New\n\n    print(f\"\\n--- FPL Optimized Squad for Gameweek {gameweek} ---\")\n    print(f\"Squad Cost: \u00a3{total_cost:.1f}m\")\n    print(f\"Expected Points (Starting XI): {expected_points_from_xi:.2f}\")\n    print(\n        f\"Total Expected Points for GW{gameweek} (including chips): {expected_points_from_xi + total_bench_boost_points + total_triple_captain_bonus:.2f}\"\n    )\n    print(\"\\n--- Chips Used This Gameweek ---\")\n    if bench_boost_used:\n        print(f\"- Bench Boost (Added {total_bench_boost_points:.2f} points)\")\n    if triple_captain_used:\n        print(\n            f\"- Triple Captain (Added {total_triple_captain_bonus:.2f} bonus points)\"\n        )\n    if not (bench_boost_used or triple_captain_used):\n        print(\"No chips used this gameweek.\")\n\n    print(\"\\n--- Goalkeepers (Starting XI marked with *) ---\")\n    for index, row in selected_squad[selected_squad[\"position\"] == \"GK\"].iterrows():\n        starter_str = \"*\" if row[\"is_starter\"] else \"\"\n        captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n        transfer_status = \"\"\n        if row[\"transfer_in\"]:\n            transfer_status = \"(IN)\"\n        elif row[\"transfer_out\"]:\n            transfer_status = \"(OUT)\"\n\n        # Access gameweek-specific xP correctly\n        player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n        print(\n            f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n        )\n    print(\"\\n--- Defenders (Starting XI marked with *) ---\")\n    for index, row in selected_squad[\n        selected_squad[\"position\"] == \"DEF\"\n    ].iterrows():\n        starter_str = \"*\" if row[\"is_starter\"] else \"\"\n        captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n        transfer_status = \"\"\n        if row[\"transfer_in\"]:\n            transfer_status = \"(IN)\"\n        elif row[\"transfer_out\"]:\n            transfer_status = \"(OUT)\"\n\n        player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n        print(\n            f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n        )\n    print(\"\\n--- Midfielders (Starting XI marked with *) ---\")\n    for index, row in selected_squad[\n        selected_squad[\"position\"] == \"MID\"\n    ].iterrows():\n        starter_str = \"*\" if row[\"is_starter\"] else \"\"\n        captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n        transfer_status = \"\"\n        if row[\"transfer_in\"]:\n            transfer_status = \"(IN)\"\n        elif row[\"transfer_out\"]:\n            transfer_status = \"(OUT)\"\n\n        player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n        print(\n            f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n        )\n    print(\"\\n--- Forwards (Starting XI marked with *) ---\")\n    for index, row in selected_squad[\n        selected_squad[\"position\"] == \"FWD\"\n    ].iterrows():\n        starter_str = \"*\" if row[\"is_starter\"] else \"\"\n        captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n        transfer_status = \"\"\n        if row[\"transfer_in\"]:\n            transfer_status = \"(IN)\"\n        elif row[\"transfer_out\"]:\n            transfer_status = \"(OUT)\"\n\n        player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n        print(\n            f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n        )\n\n    print(f\"\\n--- Team Breakdown for GW{gameweek} ---\")\n    print(selected_squad[\"team\"].value_counts())\n\n    # Transfers are relevant from Gameweek 2 (index 1) onwards in the optimization horizon\n    # For display, if the current GW is the initial one (GW1 in the current context), no transfers are made\n    # If it's a subsequent GW, check if transfers occurred.\n    first_gw_in_history = min(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n    if (\n        gameweek &gt;= first_gw_in_history\n    ):  # Changed from &gt; to &gt;=, to show initial free transfers\n        # Display transfer info for this gameweek\n        print(\n            f\"  Transfers In: {transfers_in_count}, Transfers Out: {transfers_out_count}\"\n        )\n        print(\n            f\"  Transfer Hits: {transfer_hits_taken} (-{transfer_hits_taken * POINTS_PER_HIT} points)\"\n        )\n        # Only show free transfers for the *next* gameweek if it's not the last gameweek in the horizon\n        if gameweek &lt; max(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        ):\n            print(\n                f\"  Free Transfers Available for Next GW: {free_transfers_available_next_gw}\"\n            )\n    print(\"---------------------------\\n\")\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/solver/#build.lib.fpl_solver.solver.FPLOptimizer.solve","title":"<code>solve(budget, max_players_per_team, chip_allowances, num_gameweeks)</code>","text":"<p>Solves the FPL optimization problem using PuLP.</p> <p>Parameters:</p> Name Type Description Default <code>budget</code> <code>float</code> <p>The maximum budget in millions of pounds.</p> required <code>max_players_per_team</code> <code>int</code> <p>The maximum number of players allowed from                         any single Premier League team.</p> required <code>chip_allowances</code> <code>dict</code> <p>A dictionary specifying the maximum usage for each chip.</p> required <code>num_gameweeks</code> <code>int</code> <p>The number of gameweeks to optimize over.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if a solution was found, False otherwise.</p> Source code in <code>build/lib/fpl_solver/solver.py</code> <pre><code>def solve(\n    self,\n    budget: float,\n    max_players_per_team: int,\n    chip_allowances: dict,\n    num_gameweeks: int,\n) -&gt; bool:\n    \"\"\"\n    Solves the FPL optimization problem using PuLP.\n\n    Args:\n        budget (float): The maximum budget in millions of pounds.\n        max_players_per_team (int): The maximum number of players allowed from\n                                    any single Premier League team.\n        chip_allowances (dict): A dictionary specifying the maximum usage for each chip.\n        num_gameweeks (int): The number of gameweeks to optimize over.\n\n    Returns:\n        bool: True if a solution was found, False otherwise.\n    \"\"\"\n    self.problem = LpProblem(\"FPL Squad Multi-Week Optimization\", LpMaximize)\n\n    # Decision variables for player selection, indexed by player and gameweek\n    player_vars = LpVariable.dicts(\n        \"Player\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n    )\n    starting_xi_vars = LpVariable.dicts(\n        \"StartingXI\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n    )\n    captain_var = LpVariable.dicts(\n        \"Captain\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n    )\n\n    # Binary variables for chip usage, indexed by gameweek\n    use_bench_boost = LpVariable.dicts(\n        \"Use_Bench_Boost\", range(num_gameweeks), 0, 1, LpBinary\n    )\n    use_triple_captain = LpVariable.dicts(\n        \"Use_Triple_Captain\", range(num_gameweeks), 0, 1, LpBinary\n    )\n\n    # Transfer variables\n    transfer_in_vars = LpVariable.dicts(\n        \"Transfer_In\",\n        (self.player_data.index, range(1, num_gameweeks)),\n        0,\n        1,\n        LpBinary,\n    )\n    transfer_out_vars = LpVariable.dicts(\n        \"Transfer_Out\",\n        (self.player_data.index, range(1, num_gameweeks)),\n        0,\n        1,\n        LpBinary,\n    )\n\n    # Total transfers made in a gameweek (absolute count)\n    transfers_made = LpVariable.dicts(\n        \"Transfers_Made\", range(1, num_gameweeks), 0, None, LpInteger\n    )\n    # Free transfers available at the start of a gameweek\n    free_transfers_available = LpVariable.dicts(\n        \"Free_Transfers_Available\",\n        range(num_gameweeks),\n        0,\n        MAX_FREE_TRANSFERS_SAVED + 1,\n        LpInteger,\n    )\n    # Number of transfer hits taken in a gameweek\n    transfer_hits = LpVariable.dicts(\n        \"Transfer_Hits\", range(1, num_gameweeks), 0, None, LpInteger\n    )\n\n    # Auxiliary variables for linearizing chip effects\n    is_bench_player = LpVariable.dicts(\n        \"Is_Bench_Player\",\n        (self.player_data.index, range(num_gameweeks)),\n        0,\n        1,\n        LpBinary,\n    )\n    actual_bench_boost_points = LpVariable.dicts(\n        \"Actual_Bench_Boost_Points\",\n        (self.player_data.index, range(num_gameweeks)),\n        0,\n        None,\n        LpContinuous,\n    )\n    actual_triple_captain_bonus = LpVariable.dicts(\n        \"Actual_Triple_Captain_Bonus\",\n        (self.player_data.index, range(num_gameweeks)),\n        0,\n        None,\n        LpContinuous,\n    )\n\n    # --- Objective Function ---\n    total_objective_points = []\n\n    # Get the first gameweek number from the player data to correctly index expected_points_by_gw\n    first_gw_key = next(\n        iter(\n            self.player_data.loc[\n                self.player_data.index[0], \"expected_points_by_gw\"\n            ].keys()\n        )\n    )\n    current_gameweek_number_start = int(first_gw_key)\n\n    for w in range(num_gameweeks):\n        # The actual gameweek number (1-indexed)\n        gw_actual = current_gameweek_number_start + w\n\n        # Base expected points from the selected starting 11 for this gameweek\n        base_points_expression_gw = lpSum(\n            self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n            * starting_xi_vars[i][w]\n            for i in self.player_data.index\n        )\n        total_objective_points.append(base_points_expression_gw)\n\n        # Regular Captaincy points (additional 1x for captain)\n        captain_points_bonus_gw = lpSum(\n            self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n            * captain_var[i][w]\n            for i in self.player_data.index\n        )\n        total_objective_points.append(captain_points_bonus_gw)\n\n        # Define auxiliary variables and constraints for chips for each gameweek\n        for i in self.player_data.index:\n            # Use gameweek-specific player xP for chip calculations\n            player_xp = self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n\n            # Bench Boost auxiliary variables and constraints\n            self.problem += (\n                is_bench_player[i][w] &lt;= player_vars[i][w],\n                f\"IsBench_Squad_{i}_{w}\",\n            )\n            self.problem += (\n                is_bench_player[i][w] &lt;= 1 - starting_xi_vars[i][w],\n                f\"IsBench_NotStarter_{i}_{w}\",\n            )\n            self.problem += (\n                is_bench_player[i][w]\n                &gt;= player_vars[i][w] + (1 - starting_xi_vars[i][w]) - 1,\n                f\"IsBench_Logical_{i}_{w}\",\n            )\n\n            self.problem += (\n                actual_bench_boost_points[i][w]\n                &lt;= player_xp * is_bench_player[i][w],\n                f\"BenchBoost_Contr_1_{i}_{w}\",\n            )\n            self.problem += (\n                actual_bench_boost_points[i][w] &lt;= player_xp * use_bench_boost[w],\n                f\"BenchBoost_Contr_2_{i}_{w}\",\n            )\n            self.problem += (\n                actual_bench_boost_points[i][w]\n                &gt;= player_xp * (is_bench_player[i][w] + use_bench_boost[w] - 1),\n                f\"BenchBoost_Contr_3_{i}_{w}\",\n            )\n            self.problem += (\n                actual_bench_boost_points[i][w] &gt;= 0,\n                f\"BenchBoost_Contr_4_{i}_{w}\",\n            )\n\n            # Triple Captain auxiliary variables and constraints\n            # Changed player_xp * 2 to player_xp to reflect additional 1x bonus\n            self.problem += (\n                actual_triple_captain_bonus[i][w] &lt;= player_xp * captain_var[i][w],\n                f\"TripleCaptain_Contr_1_{i}_{w}\",\n            )\n            self.problem += (\n                actual_triple_captain_bonus[i][w]\n                &lt;= player_xp * use_triple_captain[w],\n                f\"TripleCaptain_Contr_2_{i}_{w}\",\n            )\n            self.problem += (\n                actual_triple_captain_bonus[i][w]\n                &gt;= player_xp * (captain_var[i][w] + use_triple_captain[w] - 1),\n                f\"TripleCaptain_Contr_3_{i}_{w}\",\n            )\n            self.problem += (\n                actual_triple_captain_bonus[i][w] &gt;= 0,\n                f\"TripleCaptain_Contr_4_{i}_{w}\",\n            )\n\n        # Add points from bench boost and triple captain bonus for this gameweek\n        total_bench_boost_points_gw = lpSum(\n            actual_bench_boost_points[i][w] for i in self.player_data.index\n        )\n        total_triple_captain_bonus_points_gw = lpSum(\n            actual_triple_captain_bonus[i][w] for i in self.player_data.index\n        )\n\n        total_objective_points.append(total_bench_boost_points_gw)\n        total_objective_points.append(total_triple_captain_bonus_points_gw)\n\n    # Subtract transfer hits from the total objective\n    total_objective_points.append(\n        -POINTS_PER_HIT * lpSum(transfer_hits[w] for w in range(1, num_gameweeks))\n    )\n\n    self.problem += (\n        lpSum(total_objective_points),\n        \"Total Expected Points Over Gameweeks\",\n    )\n\n    # --- Constraints ---\n\n    # Apply constraints for each gameweek\n    for w in range(num_gameweeks):\n        # 1. Select exactly 15 players for the squad\n        self.problem += (\n            lpSum(player_vars[i][w] for i in self.player_data.index) == 15,\n            f\"Total_Players_GW{w}\",\n        )\n\n        # 2. Squad position constraints (2 GKs, 5 DEFs, 5 MIDs, 3 FWDs)\n        gks = self.player_data[self.player_data[\"position\"] == \"GK\"].index\n        defs = self.player_data[self.player_data[\"position\"] == \"DEF\"].index\n        mids = self.player_data[self.player_data[\"position\"] == \"MID\"].index\n        fwds = self.player_data[self.player_data[\"position\"] == \"FWD\"].index\n\n        self.problem += (\n            lpSum(player_vars[i][w] for i in gks) == 2,\n            f\"Goalkeepers_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(player_vars[i][w] for i in defs) == 5,\n            f\"Defenders_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(player_vars[i][w] for i in mids) == 5,\n            f\"Midfielders_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(player_vars[i][w] for i in fwds) == 3,\n            f\"Forwards_Count_GW{w}\",\n        )\n\n        # 3. Budget constraint\n        # This applies to the cost of the squad for the current gameweek.\n        self.problem += (\n            lpSum(\n                self.player_data.loc[i, \"cost\"] * player_vars[i][w]\n                for i in self.player_data.index\n            )\n            &lt;= budget,\n            f\"Total_Budget_GW{w}\",\n        )\n\n        # 4. Maximum players per team constraint\n        for team in self.player_data[\"team\"].unique():\n            team_players = self.player_data[self.player_data[\"team\"] == team].index\n            self.problem += (\n                lpSum(player_vars[i][w] for i in team_players)\n                &lt;= max_players_per_team,\n                f\"Max_Players_from_{team}_GW{w}\",\n            )\n\n        # 5. Starting XI constraints\n        # 5.1 Select exactly 11 players for the starting XI\n        self.problem += (\n            lpSum(starting_xi_vars[i][w] for i in self.player_data.index) == 11,\n            f\"Total_Starting_XI_Players_GW{w}\",\n        )\n\n        # 5.2 A player can only be in the starting XI if they are in the squad\n        for i in self.player_data.index:\n            self.problem += (\n                starting_xi_vars[i][w] &lt;= player_vars[i][w],\n                f\"StartingXI_in_Squad_{i}_{w}\",\n            )\n\n        # 5.3 Starting XI position constraints (FPL allows flexible formations, so use minimums)\n        self.problem += (\n            lpSum(starting_xi_vars[i][w] for i in gks) == 1,\n            f\"Starting_Goalkeepers_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(starting_xi_vars[i][w] for i in defs) &gt;= 3,\n            f\"Min_Starting_Defenders_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(starting_xi_vars[i][w] for i in mids) &gt;= 2,\n            f\"Min_Starting_Midfielders_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(starting_xi_vars[i][w] for i in fwds) &gt;= 1,\n            f\"Min_Starting_Forwards_Count_GW{w}\",\n        )\n\n        # 6. Captain Constraints\n        # 6.1 Select exactly one captain from the starting XI\n        self.problem += (\n            lpSum(captain_var[i][w] for i in self.player_data.index) == 1,\n            f\"One_Captain_GW{w}\",\n        )\n\n        # 6.2 A player can only be captain if they are in the starting XI\n        for i in self.player_data.index:\n            self.problem += (\n                captain_var[i][w] &lt;= starting_xi_vars[i][w],\n                f\"Captain_in_StartingXI_{i}_{w}\",\n            )\n\n        # --- Enforced Player Constraints---\n        for player_idx in self.enforced_player_indices:\n            self.problem += (\n                player_vars[player_idx][w] == 1,\n                f\"Enforce_Player_{self.player_data.loc[player_idx, 'name']}_GW{w}\",\n            )\n\n        for team, position in self.enforced_team_pos_requirements:\n            # Filter players for the current team and position\n            team_pos_players = self.player_data[\n                (self.player_data[\"team\"] == team)\n                &amp; (self.player_data[\"position\"] == position)\n            ].index\n            if not team_pos_players.empty:\n                self.problem += (\n                    lpSum(player_vars[i][w] for i in team_pos_players) &gt;= 1,\n                    f\"Enforce_One_{position}_from_{team}_GW{w}\",\n                )\n            else:\n                print(\n                    f\"Warning: No players found for enforced requirement: at least one {position} from {team} for GW{gw_actual}.\"\n                )\n\n    # --- Chip Usage Constraints (TOTAL usage over all gameweeks) ---\n    # These constraints should be outside the per-gameweek loop to avoid duplicates.\n    self.problem += (\n        lpSum(use_bench_boost[j] for j in range(num_gameweeks))\n        &lt;= chip_allowances.get(\"bench_boost\", 0),\n        f\"Max_Bench_Boost_Usage_Total\",\n    )\n    self.problem += (\n        lpSum(use_triple_captain[j] for j in range(num_gameweeks))\n        &lt;= chip_allowances.get(\"triple_captain\", 0),\n        f\"Max_Triple_Captain_Usage_Total\",\n    )\n\n    # --- Inter-Gameweek Constraints (Transfers and Transfer Rules) ---\n    # Initialize free transfers for GW0 (first gameweek of optimization horizon)\n    # This assumes the optimization starts at GW0, and it has INITIAL_FREE_TRANSFERS.\n    # If the model starts at an arbitrary GW, this would need to be an input.\n    self.problem += (\n        free_transfers_available[0] == INITIAL_FREE_TRANSFERS,\n        f\"Initial_Free_Transfers_GW0\",\n    )\n\n    for w in range(1, num_gameweeks):\n        # Calculate total transfers made in this gameweek\n        self.problem += (\n            transfers_made[w]\n            == lpSum(transfer_in_vars[i][w] for i in self.player_data.index),\n            f\"Transfers_Made_GW{w}\",\n        )\n        # Total transfers in must equal total transfers out for each gameweek after the first\n        self.problem += (\n            lpSum(transfer_in_vars[i][w] for i in self.player_data.index)\n            == lpSum(transfer_out_vars[i][w] for i in self.player_data.index),\n            f\"Transfers_In_Equals_Out_GW{w}\",\n        )\n\n        # Calculate free transfers available for the current gameweek (w)\n        # Free transfers for GW_w = min(free transfers from GW_w-1 - transfers made in GW_w + 1, MAX_FREE_TRANSFERS_SAVED + 1)\n        # The + 1 in MAX_FREE_TRANSFERS_SAVED + 1 is because MAX_FREE_TRANSFERS_SAVED implies how many can be *saved*,\n        # so if you save 1, you have 1 (current) + 1 (saved) = 2.\n        self.problem += (\n            free_transfers_available[w]\n            &lt;= free_transfers_available[w - 1] - transfers_made[w] + 1,\n            f\"Free_Transfers_Calc_1_GW{w}\",\n        )\n        self.problem += (\n            free_transfers_available[w] &lt;= MAX_FREE_TRANSFERS_SAVED + 1,\n            f\"Free_Transfers_Calc_2_GW{w}\",\n        )\n        self.problem += (\n            free_transfers_available[w] &gt;= 0,  # Cannot have negative free transfers\n            f\"Free_Transfers_Non_Negative_GW{w}\",\n        )\n\n        # Calculate transfer hits\n        # transfer_hits[w] = max(0, transfers_made[w] - free_transfers_available_at_start_of_gw_w)\n        # This needs to be linearized. If transfers_made[w] &gt; free_transfers_available[w-1], then hit.\n        # free_transfers_available[w-1] represents transfers available *before* making transfers for GW_w\n        self.problem += (\n            transfer_hits[w] &gt;= transfers_made[w] - free_transfers_available[w - 1],\n            f\"Transfer_Hits_Calc_1_GW{w}\",\n        )\n        self.problem += (\n            transfer_hits[w] &gt;= 0,\n            f\"Transfer_Hits_Calc_2_GW{w}\",\n        )\n\n        for i in self.player_data.index:\n            # Squad continuity: player_vars[i][w] (in squad at start of GW w)\n            #                 = player_vars[i][w-1] (in squad at start of GW w-1)\n            #                 - transfer_out_vars[i][w] (transferred out for GW w)\n            #                 + transfer_in_vars[i][w] (transferred in for GW w)\n            self.problem += (\n                player_vars[i][w]\n                == player_vars[i][w - 1]\n                - transfer_out_vars[i][w]\n                + transfer_in_vars[i][w],\n                f\"Squad_Continuity_{i}_GW{w}\",\n            )\n            # A player cannot be transferred in and out in the same gameweek\n            self.problem += (\n                transfer_in_vars[i][w] + transfer_out_vars[i][w] &lt;= 1,\n                f\"No_Simultaneous_Transfer_{i}_{w}\",\n            )\n\n    try:\n        # The solver is called with the GLPK_CMD solver\n        self.problem.solve(PULP_CBC_CMD(msg=0))  # msg=0 suppresses verbose output\n    except Exception as e:\n        print(f\"Error solving the problem: {e}\")\n        return False\n\n    if LpStatus[self.problem.status] == \"Optimal\":\n        print(\"Optimization successful! Optimal solution found.\")\n\n        self.selected_squad_history = {}\n        self.total_transfer_hits = 0\n        for w in range(num_gameweeks):\n            # The actual gameweek number (1-indexed)\n            gw_actual = current_gameweek_number_start + w\n\n            # Get selected players for the current gameweek\n            selected_squad_gw = self.player_data[\n                [player_vars[i][w].varValue == 1 for i in self.player_data.index]\n            ].copy()\n\n            # Get starter and captain info for this gameweek\n            is_starter_series_gw = pd.Series(\n                [\n                    starting_xi_vars[i][w].varValue == 1\n                    for i in self.player_data.index\n                ],\n                index=self.player_data.index,\n            )\n            is_captain_series_gw = pd.Series(\n                [captain_var[i][w].varValue == 1 for i in self.player_data.index],\n                index=self.player_data.index,\n            )\n\n            selected_squad_gw[\"is_starter\"] = is_starter_series_gw.loc[\n                selected_squad_gw.index\n            ]\n            selected_squad_gw[\"is_captain\"] = is_captain_series_gw.loc[\n                selected_squad_gw.index\n            ]\n\n            transfers_in_gw = 0\n            transfers_out_gw = 0\n            hits_gw = 0\n\n            # Store transfer details for gameweeks &gt; 0\n            if (\n                w &gt; 0\n            ):  # Check for transfers only from GW1 onwards (index 1 in 0-indexed loop)\n                transfer_in_flags = pd.Series(\n                    [\n                        transfer_in_vars[i][w].varValue == 1\n                        for i in self.player_data.index\n                    ],\n                    index=self.player_data.index,\n                )\n                transfer_out_flags = pd.Series(\n                    [\n                        transfer_out_vars[i][w].varValue == 1\n                        for i in self.player_data.index\n                    ],\n                    index=self.player_data.index,\n                )\n\n                selected_squad_gw[\"transfer_in\"] = transfer_in_flags.loc[\n                    selected_squad_gw.index\n                ]\n                selected_squad_gw[\"transfer_out\"] = transfer_out_flags.loc[\n                    selected_squad_gw.index\n                ]\n\n                transfers_in_gw = int(round(transfer_in_flags.sum()))\n                transfers_out_gw = int(round(transfer_out_flags.sum()))\n                hits_gw = int(round(transfer_hits[w].varValue))\n                self.total_transfer_hits += hits_gw\n            else:\n                selected_squad_gw[\"transfer_in\"] = False  # No transfers in for GW0\n                selected_squad_gw[\"transfer_out\"] = (\n                    False  # No transfers out for GW0\n                )\n\n            self.selected_squad_history[f\"GW{gw_actual}\"] = {\n                \"squad\": selected_squad_gw,\n                \"total_cost\": selected_squad_gw[\"cost\"].sum(),\n                \"expected_points_from_xi\": sum(\n                    self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n                    * starting_xi_vars[i][w].varValue\n                    for i in self.player_data.index\n                ),\n                \"bench_boost_used\": bool(use_bench_boost[w].varValue),\n                \"triple_captain_used\": bool(use_triple_captain[w].varValue),\n                \"total_bench_boost_points\": value(\n                    lpSum(\n                        actual_bench_boost_points[i][w]\n                        for i in self.player_data.index\n                    )\n                ),\n                \"total_triple_captain_bonus\": value(\n                    lpSum(\n                        actual_triple_captain_bonus[i][w]\n                        for i in self.player_data.index\n                    )\n                ),\n                \"transfers_in_count\": transfers_in_gw,\n                \"transfers_out_count\": transfers_out_gw,\n                \"transfer_hits\": hits_gw,  # New\n                \"free_transfers_available_next_gw\": (\n                    int(round(free_transfers_available[w].varValue))\n                    if w &lt; num_gameweeks - 1\n                    else 0\n                ),  # Free transfers available *after* this GW's transfers are made\n            }\n\n        # Overall totals\n        self.total_cost = self.selected_squad_history[\n            f\"GW{current_gameweek_number_start + num_gameweeks - 1}\"\n        ][\n            \"total_cost\"\n        ]  # Cost of final squad\n        self.total_expected_points = value(\n            self.problem.objective\n        )  # Total objective value from solver\n        self.used_chips = {\n            f\"GW{current_gameweek_number_start + w}\": {\n                \"bench_boost\": bool(use_bench_boost[w].varValue),\n                \"triple_captain\": bool(use_triple_captain[w].varValue),\n            }\n            for w in range(num_gameweeks)\n        }\n\n        return True\n    else:\n        print(f\"No optimal solution found. Status: {LpStatus[self.problem.status]}\")\n        self.selected_squad_history = {}\n        self.total_cost = 0\n        self.total_expected_points = 0\n        self.used_chips = {}\n        self.total_transfer_hits = 0\n        return False\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/xp_predictor/","title":"xp_predictor","text":"<p>FPL Expected Points (xP) Predictor Module.</p> <p>This module provides functionality to predict Fantasy Premier League (FPL) points for players based on historical data, team strengths, and fixture difficulty.</p>"},{"location":"autoapi/build/lib/fpl_solver/xp_predictor/#build.lib.fpl_solver.xp_predictor.FPLPredictor","title":"<code>FPLPredictor</code>","text":"<p>Predictive algorithm for Expected Points (xP) in Fantasy Premier League, using real data from the FPL API.</p> <p>This class handles: - Fetching and processing FPL API data - Calculating expected points based on multiple factors - Managing player exclusions and filtering - Providing fixture and player data for optimization</p> <p>Attributes:</p> Name Type Description <code>gameweeks_to_predict</code> <code>int</code> <p>Number of future gameweeks to analyze</p> <code>players_data</code> <code>Dict</code> <p>Player statistics and information</p> <code>teams_data</code> <code>Dict</code> <p>Team statistics and attributes</p> <code>fixtures_data</code> <code>Dict</code> <p>Upcoming and historical match data</p> <code>all_players_xp_calculated_data</code> <code>List</code> <p>Processed xP calculations</p> Source code in <code>build/lib/fpl_solver/xp_predictor.py</code> <pre><code>class FPLPredictor:\n    \"\"\"\n    Predictive algorithm for Expected Points (xP) in Fantasy Premier League,\n    using real data from the FPL API.\n\n    This class handles:\n    - Fetching and processing FPL API data\n    - Calculating expected points based on multiple factors\n    - Managing player exclusions and filtering\n    - Providing fixture and player data for optimization\n\n    Attributes:\n        gameweeks_to_predict (int): Number of future gameweeks to analyze\n        players_data (Dict): Player statistics and information\n        teams_data (Dict): Team statistics and attributes\n        fixtures_data (Dict): Upcoming and historical match data\n        all_players_xp_calculated_data (List): Processed xP calculations\n    \"\"\"\n\n    def __init__(self, gameweeks_to_predict: int = 1):\n        \"\"\"\n        Initialize the FPLPredictor with data structures and fetch initial data.\n\n        Args:\n            gameweeks_to_predict: Number of upcoming gameweeks to calculate\n                                expected points for. Default is 1 (next gameweek).\n\n        Raises:\n            ValueError: If gameweeks_to_predict is not a positive integer\n        \"\"\"\n        self.logger = setup_logger(__name__)\n        if not isinstance(gameweeks_to_predict, int) or gameweeks_to_predict &lt; 1:\n            msg = f\"gameweeks_to_predict must be a positive integer, got {gameweeks_to_predict}\"\n            self.logger.error(msg)\n            raise ValueError(msg)\n\n        self.gameweeks_to_predict = gameweeks_to_predict\n        self.logger.info(f\"Initializing FPL Predictor for {gameweeks_to_predict} gameweek(s)\")\n\n        # Initialize cache manager\n        cache_dir = os.path.join(os.path.dirname(__file__), 'cache')\n        self.cache_manager = CacheManager(cache_dir)\n\n        # Configuration and static data\n        self.fpl_points: Dict[str, float] = FPL_POINTS\n        self.position_definitions: Dict[int, str] = {\n            1: \"GK\",\n            2: \"DEF\",\n            3: \"MID\",\n            4: \"FWD\",\n        }\n\n        # Data structures for FPL information\n        self.players_data: Dict[int, Dict] = {}\n        self.teams_data: Dict[int, Dict] = {}\n        self.fixtures_data: Dict[int, Dict] = {}\n        self.all_players_xp_calculated_data: List[Dict] = []\n\n        # Initialize data\n        try:\n            self._fetch_fpl_data()\n            self._calculate_all_players_xp()\n        except Exception as e:\n            self.logger.error(f\"Failed to initialize FPL Predictor: {str(e)}\")\n            raise\n\n    def _fetch_fpl_data(self) -&gt; None:\n        \"\"\"\n        Fetch and process data from the FPL API.\n\n        This method retrieves player, team, and fixture data from the FPL API,\n        processes it, and stores it in the appropriate data structures. It also\n        applies any configured player exclusions.\n\n        Raises:\n            requests.RequestException: If API requests fail\n            ValueError: If required data is missing from API response\n            Exception: For other unexpected errors\n        \"\"\"\n        self.logger.info(\"Fetching FPL data from API...\")\n\n        try:\n            # Helper function to fetch from API with caching\n            def fetch_api_data(url: str, endpoint: str) -&gt; dict:\n                # Try to get from cache first\n                cached_data = self.cache_manager.get_cached_response(endpoint)\n                if cached_data is not None:\n                    self.logger.info(f\"Using cached {endpoint} data\")\n                    return cached_data\n\n                # If not in cache or expired, fetch from API\n                try:\n                    self.logger.info(f\"Fetching {endpoint} data from API\")\n                    response = requests.get(url, timeout=10)\n                    response.raise_for_status()\n                    data = response.json()\n\n                    # Cache the response\n                    self.cache_manager.save_response(endpoint, data)\n                    return data\n\n                except requests.RequestException as e:\n                    self.logger.error(f\"Failed to fetch {endpoint} data: {str(e)}\")\n                    raise\n\n            # Fetch both endpoints\n            static_data = fetch_api_data(\n                \"https://fantasy.premierleague.com/api/bootstrap-static/\",\n                \"static\"\n            )\n            fixtures_data = fetch_api_data(\n                \"https://fantasy.premierleague.com/api/fixtures/\",\n                \"fixtures\"\n            )\n\n            # Process players data\n            if \"elements\" not in static_data:\n                raise ValueError(\"No player elements found in API response\")\n\n            self.logger.info(f\"Processing {len(static_data['elements'])} players...\")\n\n            def process_player_data(element: Dict) -&gt; Tuple[int, Dict]:\n                \"\"\"Helper function to process individual player data\"\"\"\n                try:\n                    player_id = element[\"id\"]\n                    return player_id, {\n                        \"name\": f\"{element['first_name']} {element['second_name']}\",\n                        \"web_name\": element[\"web_name\"],\n                        \"team_id\": element[\"team\"],\n                        \"element_type\": element[\"element_type\"],\n                        \"position\": self.position_definitions.get(\n                            element[\"element_type\"], \"Unknown\"\n                        ),\n                        \"cost_pence\": element[\"now_cost\"],\n                        \"status\": element[\"status\"],\n                        \"news\": element[\"news\"],\n                        \"total_points\": element[\"total_points\"],\n                        \"minutes\": element[\"minutes\"],\n                        \"goals_scored\": element[\"goals_scored\"],\n                        \"assists\": element[\"assists\"],\n                        \"clean_sheets\": element[\"clean_sheets\"],\n                        \"goals_conceded\": element[\"goals_conceded\"],\n                        \"penalties_saved\": element[\"penalties_saved\"],\n                        \"penalties_missed\": element[\"penalties_missed\"],\n                        \"yellow_cards\": element[\"yellow_cards\"],\n                        \"red_cards\": element[\"red_cards\"],\n                        \"own_goals\": element[\"own_goals\"],\n                        \"saves\": element[\"saves\"],\n                        \"bonus\": element[\"bonus\"],\n                        \"bps\": element[\"bps\"],\n                        \"threat\": float(element.get(\"threat\", 0)),\n                        \"creativity\": float(element.get(\"creativity\", 0)),\n                        \"influence\": float(element.get(\"influence\", 0)),\n                        \"form\": float(element.get(\"form\", 0)),\n                        \"points_per_game\": float(element.get(\"points_per_game\", 0)),\n                        \"value_season\": float(element.get(\"value_season\", 0)),\n                        \"value_form\": float(element.get(\"value_form\", 0)),\n                        \"ict_index\": float(element.get(\"ict_index\", 0)),\n                        \"defensive_contribution\": float(element.get(\"defensive_contribution\", 0)),\n                    }\n                except KeyError as e:\n                    self.logger.warning(f\"Missing required field for player: {str(e)}\")\n                    return None\n                except ValueError as e:\n                    self.logger.warning(f\"Invalid numeric value for player {element.get('id')}: {str(e)}\")\n                    return None\n\n            # Process all players with error handling\n            for element in static_data[\"elements\"]:\n                result = process_player_data(element)\n                if result:\n                    player_id, player_data = result\n                    self.players_data[player_id] = player_data\n\n            # Apply Player Exclusions\n            def apply_player_exclusions() -&gt; Dict[int, Dict]:\n                \"\"\"Apply configured player exclusions and return filtered player data\"\"\"\n                initial_count = len(self.players_data)\n                players_to_keep = {}\n\n                for player_id, player_info in self.players_data.items():\n                    # Track exclusion reason if player is excluded\n                    exclusion_reason = None\n\n                    # Check ID exclusions\n                    if player_id in EXCLUDED_PLAYERS_BY_ID:\n                        exclusion_reason = f\"ID exclusion: {player_id}\"\n\n                    # Check name exclusions\n                    elif player_info[\"name\"] in EXCLUDED_PLAYERS_BY_NAME:\n                        exclusion_reason = f\"Name exclusion: {player_info['name']}\"\n\n                    # Check team/position exclusions\n                    else:\n                        team_name = self.teams_data.get(player_info[\"team_id\"], {}).get(\"name\")\n                        for rule in EXCLUDED_PLAYERS_BY_TEAM_AND_POSITION:\n                            if (team_name == rule.get(\"team\") and \n                                player_info[\"position\"] == rule.get(\"position\")):\n                                exclusion_reason = f\"Team/Position exclusion: {team_name}/{player_info['position']}\"\n                                break\n\n                    # Log exclusion or keep player\n                    if exclusion_reason:\n                        self.logger.info(\n                            f\"Excluding player {player_info['name']} - {exclusion_reason}\"\n                        )\n                    else:\n                        players_to_keep[player_id] = player_info\n\n                filtered_count = len(players_to_keep)\n                self.logger.info(\n                    f\"Player filtering complete. {initial_count - filtered_count} \"\n                    f\"players excluded. {filtered_count} players remaining.\"\n                )\n                return players_to_keep\n\n            self.players_data = apply_player_exclusions()\n\n            # Process teams data\n            if \"teams\" not in static_data:\n                raise ValueError(\"No team data found in API response\")\n\n            self.logger.info(f\"Processing {len(static_data['teams'])} teams...\")\n\n            def process_team_data(team: Dict) -&gt; Tuple[int, Dict]:\n                \"\"\"Helper function to process individual team data\"\"\"\n                try:\n                    return team[\"id\"], {\n                        \"name\": team[\"name\"],\n                        \"short_name\": team[\"short_name\"],\n                        \"strength\": team[\"strength\"],\n                        \"strength_overall_home\": team[\"strength_overall_home\"],\n                        \"strength_overall_away\": team[\"strength_overall_away\"],\n                        \"strength_attack_home\": team[\"strength_attack_home\"],\n                        \"strength_attack_away\": team[\"strength_attack_away\"],\n                        \"strength_defence_home\": team[\"strength_defence_home\"],\n                        \"strength_defence_away\": team[\"strength_defence_away\"],\n                    }\n                except KeyError as e:\n                    self.logger.warning(f\"Missing required field for team: {str(e)}\")\n                    return None\n\n            # Process all teams with error handling\n            for team in static_data[\"teams\"]:\n                result = process_team_data(team)\n                if result:\n                    team_id, team_data = result\n                    self.teams_data[team_id] = team_data\n\n            # Process fixtures data\n            self.logger.info(f\"Processing {len(fixtures_data)} fixtures...\")\n\n            def process_fixture_data(fixture: Dict) -&gt; Tuple[int, Dict]:\n                \"\"\"Helper function to process individual fixture data\"\"\"\n                try:\n                    fixture_id = fixture[\"id\"]\n                    # Validate required fields\n                    required_fields = [\"team_h\", \"team_a\", \"event\", \"finished\"]\n                    if not all(field in fixture for field in required_fields):\n                        missing = [f for f in required_fields if f not in fixture]\n                        raise KeyError(f\"Missing required fields: {', '.join(missing)}\")\n                    return fixture_id, fixture\n                except KeyError as e:\n                    self.logger.warning(f\"Invalid fixture data: {str(e)}\")\n                    return None\n\n            # Process all fixtures with error handling\n            for fixture in fixtures_data:\n                result = process_fixture_data(fixture)\n                if result:\n                    fixture_id, fixture_data = result\n                    self.fixtures_data[fixture_id] = fixture_data\n\n            self.logger.info(\"FPL data fetched and processed successfully.\")\n\n        except requests.exceptions.RequestException as e:\n            self.logger.error(f\"Failed to fetch FPL data: {str(e)}\")\n            self._reset_data_structures()\n            raise\n        except ValueError as e:\n            self.logger.error(f\"Invalid data received from FPL API: {str(e)}\")\n            self._reset_data_structures()\n            raise\n        except Exception as e:\n            self.logger.error(f\"Unexpected error during data processing: {str(e)}\")\n            self._reset_data_structures()\n            raise\n\n    def _reset_data_structures(self) -&gt; None:\n        \"\"\"Reset all data structures to empty state\"\"\"\n        self.players_data = {}\n        self.teams_data = {}\n        self.fixtures_data = {}\n\n    def _get_team_strength(self, team_id, is_home):\n        \"\"\"Get team strength based on home/away status.\"\"\"\n        team = self.teams_data.get(team_id, {})\n        if is_home:\n            return team.get(\"strength_overall_home\", 1000)  # Default if not found\n        return team.get(\"strength_overall_away\", 1000)  # Default if not found\n\n    def _predict_minutes(self, player_id):\n        \"\"\"\n        Predicts expected minutes for a player based on historical data.\n        More sophisticated logic for handling very low minute players.\n        \"\"\"\n        player = self.players_data.get(player_id)\n        if not player:\n            return 0.0\n\n        status = player[\"status\"]\n        news = player[\"news\"].lower()\n        minutes_played = player[\"minutes\"]\n\n        # 1. Unavailable players (injured, suspended, doubtful)\n        if status != \"a\" or any(\n            x in news\n            for x in [\n                \"injured\",\n                \"doubtful\",\n                \"suspension\",\n                \"red card\",\n                \"expected back\",\n            ]\n        ):\n            return 0.0\n\n        # 2. Players with significant minutes (starters/key rotation)\n        if minutes_played &gt;= MIN_MINUTES_THRESHOLD:\n            # Average minutes per game started (assuming most minutes come from starts)\n            # This is a heuristic; real FPL API doesn't give starts directly.\n            # We assume a player with &gt; MIN_MINUTES_THRESHOLD plays ~80-90 minutes when on pitch.\n            # So, (minutes_played / number_of_appearances) is a rough proxy.\n            # For simplicity, let's use a cap of 90 minutes.\n            if player[\"total_points\"] &gt; 0:  # Player has played at least one game\n                avg_minutes_per_appearance = minutes_played / (\n                    player[\"total_points\"] / player[\"points_per_game\"]\n                )\n                return min(avg_minutes_per_appearance, 90.0)\n            return 70.0  # Reasonable default for established player with points but no clear avg\n\n        # 3. Players with very low minutes (rarely play, new, youth)\n        if minutes_played &lt; VERY_LOW_MINUTES_THRESHOLD:\n            # If news suggests they might get a chance, assign default sub minutes.\n            # Otherwise, very low expected minutes or zero.\n            if any(x in news for x in [\"return imminent\", \"close to return\"]):\n                return DEFAULT_SUB_MINUTES  # Might get some minutes\n            return DEFAULT_UNKNOWN_PLAYER_MINUTES  # Very unlikely to play significant minutes\n\n        # 4. Players with some minutes but below significant threshold (regular subs)\n        return DEFAULT_SUB_MINUTES\n\n    def _calculate_expected_goals(self, team_attack_strength, opp_defence_strength):\n        \"\"\"\n        Calculates expected goals for a team based on its attack strength and\n        opponent's defensive strength. This is a simplified heuristic.\n        \"\"\"\n        # A simple ratio model: Higher attack strength and lower opponent defense means more goals\n        # Normalization factor can be adjusted based on average league goals\n        expected_goals = (\n            team_attack_strength / opp_defence_strength\n        ) * 1.5  # 1.5 is an arbitrary scaling factor\n        return max(0.0, expected_goals)\n\n    def _calculate_expected_conceded_goals(\n        self, team_defence_strength, opp_attack_strength\n    ):\n        \"\"\"\n        Calculates expected goals conceded by a team based on its defense strength\n        and opponent's attacking strength.\n        \"\"\"\n        # A simple ratio model: Higher opponent attack and lower team defense means more conceded goals\n        expected_conceded_goals = (\n            opp_attack_strength / team_defence_strength\n        ) * 1.5  # 1.5 is an arbitrary scaling factor\n        return max(0.0, expected_conceded_goals)\n\n    def calculate_xp_for_player(self, player_id, fixture_id):\n        \"\"\"\n        Calculates Expected Points (xP) for a single player in a given fixture.\n        Considers various factors: minutes, goals, assists, clean sheets, saves,\n        bonus points, and negative events, adjusted for fixture difficulty.\n        \"\"\"\n        player = self.players_data.get(player_id)\n        fixture = self.fixtures_data.get(fixture_id)\n\n        if not player or not fixture:\n            return {\"xp\": 0.0, \"reason\": \"Player or fixture data missing.\"}\n\n        # Handle unavailable players\n        if (\n            player[\"status\"] != \"a\"\n        ):  # 'd' for doubtful, 'i' for injured, 's' for suspended\n            return {\"xp\": 0.0, \"reason\": f\"Player status: {player['status']}\"}\n        if any(\n            x in player[\"news\"].lower()\n            for x in [\"injured\", \"doubtful\", \"suspension\", \"red card\"]\n        ):\n            return {\"xp\": 0.0, \"reason\": f\"Player news: {player['news']}\"}\n\n        # Predict minutes\n        expected_minutes = self._predict_minutes(player_id)\n        if expected_minutes &lt; 1.0:  # If expected to play very little or none\n            return {\"xp\": 0.0, \"reason\": \"Expected minutes too low.\"}\n\n        xp = 0.0\n        position = player[\"position\"]\n        # Use 'team_h' for home team ID\n        is_home_fixture = player[\"team_id\"] == fixture[\"team_h\"]\n\n        # Determine attacking and defensive strengths for the fixture\n        player_team_strength_attack = (\n            self.teams_data.get(fixture[\"team_h\"], {}).get(\n                \"strength_attack_home\"\n            )  # Use 'team_h'\n            if is_home_fixture\n            else self.teams_data.get(fixture[\"team_a\"], {}).get(\n                \"strength_attack_away\"\n            )  # Use 'team_a'\n        )\n        player_team_strength_defence = (\n            self.teams_data.get(fixture[\"team_h\"], {}).get(\n                \"strength_defence_home\"\n            )  # Use 'team_h'\n            if is_home_fixture\n            else self.teams_data.get(fixture[\"team_a\"], {}).get(\n                \"strength_defence_away\"\n            )  # Use 'team_a'\n        )\n        opponent_team_strength_attack = (\n            self.teams_data.get(fixture[\"team_a\"], {}).get(\n                \"strength_attack_away\"\n            )  # Use 'team_a'\n            if is_home_fixture\n            else self.teams_data.get(fixture[\"team_h\"], {}).get(\n                \"strength_attack_home\"\n            )  # Use 'team_h'\n        )\n        opponent_team_strength_defence = (\n            self.teams_data.get(fixture[\"team_a\"], {}).get(\n                \"strength_defence_away\"\n            )  # Use 'team_a'\n            if is_home_fixture\n            else self.teams_data.get(fixture[\"team_h\"], {}).get(\n                \"strength_defence_home\"\n            )  # Use 'team_h'\n        )\n\n        if None in [\n            player_team_strength_attack,\n            player_team_strength_defence,\n            opponent_team_strength_attack,\n            opponent_team_strength_defence,\n        ]:\n            # Fallback if strength data is missing (shouldn't happen with robust data fetch)\n            return {\"xp\": 0.0, \"reason\": \"Team strength data missing for fixture.\"}\n\n        # Apply confidence factor based on historical minutes\n        minutes_played = player.get(\"minutes\", 0)\n        confidence_factor = XP_CONFIDENCE_FACTORS[\"proven\"]  # Default to proven player\n        if minutes_played &lt; VERY_LOW_MINUTES_THRESHOLD:\n            confidence_factor = XP_CONFIDENCE_FACTORS[\"very_low_minutes\"]\n        elif minutes_played &lt; MIN_MINUTES_THRESHOLD:\n            confidence_factor = XP_CONFIDENCE_FACTORS[\"low_minutes\"]\n\n        # 1. Appearance points\n        if expected_minutes &gt;= 60:\n            xp += self.fpl_points[\"appearance_points_gte_60\"]\n        elif expected_minutes &gt; 0:\n            xp += self.fpl_points[\"appearance_points_lt_60\"]\n\n        # 2. Expected Goals (scaled by historical goals per 90 and opponent difficulty)\n        # Use player's form and total goals as a basis\n        goals_per_90_hist = (\n            (player[\"goals_scored\"] / player[\"minutes\"] * 90)\n            if player[\"minutes\"] &gt; 0\n            else 0.0\n        )\n        expected_team_goals = self._calculate_expected_goals(\n            player_team_strength_attack, opponent_team_strength_defence\n        )\n\n        expected_goals_player_contribution = (\n            (goals_per_90_hist / 90.0) * expected_minutes * (expected_team_goals / 1.5)\n        )  # Scale player's goal contribution by team's expected goals\n\n        if position == \"GK\":\n            xp += expected_goals_player_contribution * self.fpl_points[\"goal_gk\"]\n        elif position == \"DEF\":\n            xp += expected_goals_player_contribution * self.fpl_points[\"goal_def\"]\n        elif position == \"MID\":\n            xp += expected_goals_player_contribution * self.fpl_points[\"goal_mid\"]\n        elif position == \"FWD\":\n            xp += expected_goals_player_contribution * self.fpl_points[\"goal_fwd\"]\n\n        # 3. Expected Assists (scaled by historical assists per 90 and opponent difficulty)\n        assists_per_90_hist = (\n            (player[\"assists\"] / player[\"minutes\"] * 90)\n            if player[\"minutes\"] &gt; 0\n            else 0.0\n        )\n        # Assuming team's attacking strength correlates with assist opportunities\n        expected_assists_player_contribution = (\n            (assists_per_90_hist / 90.0)\n            * expected_minutes\n            * (expected_team_goals / 1.5)\n        )  # Similarly scale by team's expected goals\n        xp += expected_assists_player_contribution * self.fpl_points[\"assist_points\"]\n\n        # 4. Expected Clean Sheets (for GKs/DEFs/MIDs) and Conceded Goals deduction\n        expected_conceded = self._calculate_expected_conceded_goals(\n            player_team_strength_defence, opponent_team_strength_attack\n        )\n\n        # Probability of clean sheet\n        # Simplified: higher team defense / lower opponent attack -&gt; higher CS prob\n        # Use logistic or sigmoid for probability\n        cs_prob = 1.0 / (\n            1.0 + math.exp(expected_conceded - 1.0)\n        )  # Sigmoid centered at 1 goal\n\n        if position in [\"GK\", \"DEF\"]:\n            xp += cs_prob * self.fpl_points[\"clean_sheet_gk_def\"]\n\n            # Conceded goals deduction: Apply penalty for every 2 goals conceded *probability*\n            # For simplicity, calculate expected deduction: (expected_conceded / 2) * deduction\n            xp += (expected_conceded / 2.0) * self.fpl_points[\n                \"conceded_2_goals_deduction\"\n            ]\n        elif position == \"MID\":\n            xp += cs_prob * self.fpl_points[\"clean_sheet_mid\"]\n\n        # 5. Expected Saves (for GKs)\n        if position == \"GK\":\n            saves_per_90_hist = (\n                (player[\"saves\"] / player[\"minutes\"] * 90)\n                if player[\"minutes\"] &gt; 0\n                else 0.0\n            )\n            # Expected saves scaled by opponent's attacking strength (more attacking -&gt; more shots -&gt; more saves)\n            expected_saves_player_contribution = (\n                (saves_per_90_hist / 90.0)\n                * expected_minutes\n                * (opponent_team_strength_attack / player_team_strength_defence)\n            )\n            xp += (expected_saves_player_contribution / 3.0) * self.fpl_points[\n                \"saves_3_points\"\n            ]  # Using the new config point value\n\n            # Penalty saves (low probability, use historical rate)\n            penalty_saves_hist_per_game = (\n                player[\"penalties_saved\"] / (player[\"minutes\"] / 90.0)\n                if player[\"minutes\"] &gt; 0\n                else 0.0\n            )\n            xp += (\n                penalty_saves_hist_per_game\n                * (expected_minutes / 90.0)\n                * self.fpl_points[\"penalty_save_points\"]\n            )\n\n        # 6. Expected Bonus Points\n        # Use BPS (Bonus Points System) as a proxy. Scale player's average BPS by form and expected minutes.\n        bps_per_90_hist = (\n            (player[\"bps\"] / player[\"minutes\"] * 90) if player[\"minutes\"] &gt; 0 else 0.0\n        )\n        expected_bps = (bps_per_90_hist / 90.0) * expected_minutes * player[\"form\"]\n        xp += expected_bps * self.fpl_points[\"bonus_points_scaling_factor\"]\n\n        # 7. Minor Negative Events (Probabilistic)\n        # These are rare, so a simple probability based on expected minutes.\n        xp += (expected_minutes / 90.0) * (\n            self.fpl_points[\"yellow_card_deduction\"] * YELLOW_CARD_PROB\n            + self.fpl_points[\"red_card_deduction\"] * RED_CARD_PROB\n            + self.fpl_points[\"own_goal_deduction\"] * OWN_GOAL_PROB\n            + self.fpl_points[\"penalty_miss_deduction\"] * PENALTY_MISS_PROB\n        )\n\n        # 8. Defensive Contribution Points (for 2025/26 season)\n        # Use actual defensive_contribution data from API\n        defensive_contribution_per_90 = (\n            (player[\"defensive_contribution\"] / player[\"minutes\"] * 90)\n            if player[\"minutes\"] &gt; 0\n            else 0.0\n        )\n        expected_defensive_contribution = (defensive_contribution_per_90 / 90.0) * expected_minutes\n\n        # Award defensive contribution points based on position thresholds\n        if position in [\"DEF\", \"MID\", \"FWD\"]:  # Goalkeepers do not earn defensive contribution points\n            xp += expected_defensive_contribution * self.fpl_points[\"defensive_contribution_points\"]\n\n        # Apply confidence factor to final xP\n        xp = xp * confidence_factor\n\n        return {\"xp\": round(xp, 2), \"reason\": \"Success\", \"confidence\": confidence_factor}\n\n    def _calculate_all_players_xp(self):\n        \"\"\"\n        Calculates the Expected Points (xP) for all players over multiple upcoming gameweeks\n        and populates self.all_players_xp_calculated_data with xP per gameweek.\n        \"\"\"\n        print(\n            f\"Calculating xP for all players over {self.gameweeks_to_predict} gameweek(s)...\"\n        )\n\n        # Get all upcoming fixtures and sort them by gameweek\n        all_upcoming_fixtures_items = sorted(\n            [\n                (fid, fdict)\n                for fid, fdict in self.fixtures_data.items()\n                if not fdict[\"finished\"]\n            ],\n            key=lambda item: item[1][\"event\"],\n        )\n\n        if not all_upcoming_fixtures_items:\n            print(\"No upcoming fixtures found. Cannot calculate xP.\")\n            return\n\n        # Determine the current gameweek (the gameweek of the earliest upcoming fixture)\n        current_gameweek = all_upcoming_fixtures_items[0][1][\"event\"]\n        target_gameweeks = range(\n            current_gameweek, current_gameweek + self.gameweeks_to_predict\n        )\n\n        # Create a mapping of team_id_code to a list of their fixtures within the target gameweeks\n        team_fixtures_in_range = {team_code: [] for team_code in self.teams_data.keys()}\n        for fixture_id, fixture_data in all_upcoming_fixtures_items:\n            if fixture_data[\"event\"] in target_gameweeks:\n                home_team_code = fixture_data[\"team_h\"]\n                away_team_code = fixture_data[\"team_a\"]\n\n                team_fixtures_in_range[home_team_code].append(fixture_id)\n                team_fixtures_in_range[away_team_code].append(fixture_id)\n\n        # Calculate total xP for each player across the specified gameweeks\n        for player_id, player_data in self.players_data.items():\n            player_team_code = player_data[\"team_id\"]\n            player_position = player_data[\"position\"]\n\n            # Calculate xP for each relevant fixture and store by gameweek\n            expected_points_by_gw = {}\n            for fixture_id in team_fixtures_in_range.get(player_team_code, []):\n                fixture_gameweek = self.fixtures_data[fixture_id][\"event\"]\n                xp_result_single_gw = self.calculate_xp_for_player(\n                    player_id, fixture_id\n                )\n                if xp_result_single_gw and xp_result_single_gw[\"xp\"] is not None:\n                    if fixture_gameweek not in expected_points_by_gw:\n                        expected_points_by_gw[fixture_gameweek] = 0.0\n                    expected_points_by_gw[fixture_gameweek] += xp_result_single_gw[\"xp\"]\n\n            # Ensure all target gameweeks are present, even if xP is 0 for a given GW\n            for gw in target_gameweeks:\n                if gw not in expected_points_by_gw:\n                    expected_points_by_gw[gw] = 0.0\n\n            # Sort the dictionary by gameweek for consistent output\n            expected_points_by_gw = dict(sorted(expected_points_by_gw.items()))\n\n            # Prepare data for the optimizer\n            player_cost_m = player_data[\"cost_pence\"] / 10.0\n            team_name_full = self.teams_data.get(player_team_code, {}).get(\n                \"name\", \"Unknown Team\"\n            )\n\n            self.all_players_xp_calculated_data.append(\n                {\n                    \"name\": player_data[\"name\"],\n                    \"web_name\": player_data[\"web_name\"],\n                    \"team\": team_name_full,\n                    \"position\": player_position,\n                    \"cost\": player_cost_m,\n                    \"expected_points_by_gw\": expected_points_by_gw,  # Changed key and format\n                }\n            )\n        print(\"xP calculation for all players complete.\")\n\n    def get_upcoming_fixtures(self, limit=None):\n        \"\"\"\n        Returns a list of upcoming fixtures, sorted by gameweek and kickoff time.\n        Optionally limits the number of fixtures returned.\n        \"\"\"\n        upcoming = []\n        now = datetime.now()\n\n        # Sort all fixtures by gameweek and then by kickoff time\n        sorted_fixtures = sorted(\n            self.fixtures_data.values(),\n            key=lambda x: (\n                x.get(\"event\", 0),\n                x.get(\"kickoff_time\", \"9999-12-31T00:00:00Z\"),\n            ),\n        )\n\n        current_gameweek = None\n        for fixture_data in sorted_fixtures:\n            # Determine current gameweek from the earliest upcoming fixture\n            if not fixture_data[\"finished\"] and current_gameweek is None:\n                current_gameweek = fixture_data.get(\"event\", 0)\n\n            # Filter for upcoming fixtures within the prediction horizon\n            if (\n                fixture_data.get(\"event\", 0) &lt; current_gameweek  # Skip past gameweeks\n                or fixture_data.get(\"event\", 0)\n                &gt;= current_gameweek + self.gameweeks_to_predict\n            ):\n                continue  # Skip fixtures outside the prediction horizon\n\n            home_team_name = self.teams_data.get(\n                fixture_data[\"team_h\"], {}\n            ).get(  # Use 'team_h'\n                \"name\", \"Unknown\"\n            )\n            away_team_name = self.teams_data.get(\n                fixture_data[\"team_a\"], {}\n            ).get(  # Use 'team_a'\n                \"name\", \"Unknown\"\n            )\n\n            # Only add fixtures that are not finished\n            if not fixture_data[\"finished\"]:\n                upcoming.append(\n                    {\n                        \"fixture_id\": fixture_data[\"id\"],\n                        \"gameweek\": fixture_data.get(\"event\"),\n                        \"home_team_id\": fixture_data[\"team_h\"],  # Use 'team_h'\n                        \"away_team_id\": fixture_data[\"team_a\"],  # Use 'team_a'\n                        \"match\": f\"{home_team_name} vs {away_team_name}\",\n                        \"kickoff_time\": fixture_data.get(\"kickoff_time\"),\n                        \"home_team_difficulty\": fixture_data[\"team_h_difficulty\"],\n                        \"away_team_difficulty\": fixture_data[\"team_a_difficulty\"],\n                    }\n                )\n            if limit is not None and len(upcoming) &gt;= limit:\n                break\n        return upcoming\n\n    def get_players_for_optimizer(self):\n        \"\"\"\n        Returns the list of player data with calculated xP per gameweek,\n        formatted for the FPLOptimizer.\n        \"\"\"\n        return self.all_players_xp_calculated_data\n\n    def clear_cache(self):\n        \"\"\"\n        Clear all cached API responses. Use this when you want to force fresh data\n        from the FPL API.\n        \"\"\"\n        self.cache_manager.clear_cache()\n        self.logger.info(\"Cleared API response cache\")\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/xp_predictor/#build.lib.fpl_solver.xp_predictor.FPLPredictor.__init__","title":"<code>__init__(gameweeks_to_predict=1)</code>","text":"<p>Initialize the FPLPredictor with data structures and fetch initial data.</p> <p>Parameters:</p> Name Type Description Default <code>gameweeks_to_predict</code> <code>int</code> <p>Number of upcoming gameweeks to calculate                 expected points for. Default is 1 (next gameweek).</p> <code>1</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If gameweeks_to_predict is not a positive integer</p> Source code in <code>build/lib/fpl_solver/xp_predictor.py</code> <pre><code>def __init__(self, gameweeks_to_predict: int = 1):\n    \"\"\"\n    Initialize the FPLPredictor with data structures and fetch initial data.\n\n    Args:\n        gameweeks_to_predict: Number of upcoming gameweeks to calculate\n                            expected points for. Default is 1 (next gameweek).\n\n    Raises:\n        ValueError: If gameweeks_to_predict is not a positive integer\n    \"\"\"\n    self.logger = setup_logger(__name__)\n    if not isinstance(gameweeks_to_predict, int) or gameweeks_to_predict &lt; 1:\n        msg = f\"gameweeks_to_predict must be a positive integer, got {gameweeks_to_predict}\"\n        self.logger.error(msg)\n        raise ValueError(msg)\n\n    self.gameweeks_to_predict = gameweeks_to_predict\n    self.logger.info(f\"Initializing FPL Predictor for {gameweeks_to_predict} gameweek(s)\")\n\n    # Initialize cache manager\n    cache_dir = os.path.join(os.path.dirname(__file__), 'cache')\n    self.cache_manager = CacheManager(cache_dir)\n\n    # Configuration and static data\n    self.fpl_points: Dict[str, float] = FPL_POINTS\n    self.position_definitions: Dict[int, str] = {\n        1: \"GK\",\n        2: \"DEF\",\n        3: \"MID\",\n        4: \"FWD\",\n    }\n\n    # Data structures for FPL information\n    self.players_data: Dict[int, Dict] = {}\n    self.teams_data: Dict[int, Dict] = {}\n    self.fixtures_data: Dict[int, Dict] = {}\n    self.all_players_xp_calculated_data: List[Dict] = []\n\n    # Initialize data\n    try:\n        self._fetch_fpl_data()\n        self._calculate_all_players_xp()\n    except Exception as e:\n        self.logger.error(f\"Failed to initialize FPL Predictor: {str(e)}\")\n        raise\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/xp_predictor/#build.lib.fpl_solver.xp_predictor.FPLPredictor.calculate_xp_for_player","title":"<code>calculate_xp_for_player(player_id, fixture_id)</code>","text":"<p>Calculates Expected Points (xP) for a single player in a given fixture. Considers various factors: minutes, goals, assists, clean sheets, saves, bonus points, and negative events, adjusted for fixture difficulty.</p> Source code in <code>build/lib/fpl_solver/xp_predictor.py</code> <pre><code>def calculate_xp_for_player(self, player_id, fixture_id):\n    \"\"\"\n    Calculates Expected Points (xP) for a single player in a given fixture.\n    Considers various factors: minutes, goals, assists, clean sheets, saves,\n    bonus points, and negative events, adjusted for fixture difficulty.\n    \"\"\"\n    player = self.players_data.get(player_id)\n    fixture = self.fixtures_data.get(fixture_id)\n\n    if not player or not fixture:\n        return {\"xp\": 0.0, \"reason\": \"Player or fixture data missing.\"}\n\n    # Handle unavailable players\n    if (\n        player[\"status\"] != \"a\"\n    ):  # 'd' for doubtful, 'i' for injured, 's' for suspended\n        return {\"xp\": 0.0, \"reason\": f\"Player status: {player['status']}\"}\n    if any(\n        x in player[\"news\"].lower()\n        for x in [\"injured\", \"doubtful\", \"suspension\", \"red card\"]\n    ):\n        return {\"xp\": 0.0, \"reason\": f\"Player news: {player['news']}\"}\n\n    # Predict minutes\n    expected_minutes = self._predict_minutes(player_id)\n    if expected_minutes &lt; 1.0:  # If expected to play very little or none\n        return {\"xp\": 0.0, \"reason\": \"Expected minutes too low.\"}\n\n    xp = 0.0\n    position = player[\"position\"]\n    # Use 'team_h' for home team ID\n    is_home_fixture = player[\"team_id\"] == fixture[\"team_h\"]\n\n    # Determine attacking and defensive strengths for the fixture\n    player_team_strength_attack = (\n        self.teams_data.get(fixture[\"team_h\"], {}).get(\n            \"strength_attack_home\"\n        )  # Use 'team_h'\n        if is_home_fixture\n        else self.teams_data.get(fixture[\"team_a\"], {}).get(\n            \"strength_attack_away\"\n        )  # Use 'team_a'\n    )\n    player_team_strength_defence = (\n        self.teams_data.get(fixture[\"team_h\"], {}).get(\n            \"strength_defence_home\"\n        )  # Use 'team_h'\n        if is_home_fixture\n        else self.teams_data.get(fixture[\"team_a\"], {}).get(\n            \"strength_defence_away\"\n        )  # Use 'team_a'\n    )\n    opponent_team_strength_attack = (\n        self.teams_data.get(fixture[\"team_a\"], {}).get(\n            \"strength_attack_away\"\n        )  # Use 'team_a'\n        if is_home_fixture\n        else self.teams_data.get(fixture[\"team_h\"], {}).get(\n            \"strength_attack_home\"\n        )  # Use 'team_h'\n    )\n    opponent_team_strength_defence = (\n        self.teams_data.get(fixture[\"team_a\"], {}).get(\n            \"strength_defence_away\"\n        )  # Use 'team_a'\n        if is_home_fixture\n        else self.teams_data.get(fixture[\"team_h\"], {}).get(\n            \"strength_defence_home\"\n        )  # Use 'team_h'\n    )\n\n    if None in [\n        player_team_strength_attack,\n        player_team_strength_defence,\n        opponent_team_strength_attack,\n        opponent_team_strength_defence,\n    ]:\n        # Fallback if strength data is missing (shouldn't happen with robust data fetch)\n        return {\"xp\": 0.0, \"reason\": \"Team strength data missing for fixture.\"}\n\n    # Apply confidence factor based on historical minutes\n    minutes_played = player.get(\"minutes\", 0)\n    confidence_factor = XP_CONFIDENCE_FACTORS[\"proven\"]  # Default to proven player\n    if minutes_played &lt; VERY_LOW_MINUTES_THRESHOLD:\n        confidence_factor = XP_CONFIDENCE_FACTORS[\"very_low_minutes\"]\n    elif minutes_played &lt; MIN_MINUTES_THRESHOLD:\n        confidence_factor = XP_CONFIDENCE_FACTORS[\"low_minutes\"]\n\n    # 1. Appearance points\n    if expected_minutes &gt;= 60:\n        xp += self.fpl_points[\"appearance_points_gte_60\"]\n    elif expected_minutes &gt; 0:\n        xp += self.fpl_points[\"appearance_points_lt_60\"]\n\n    # 2. Expected Goals (scaled by historical goals per 90 and opponent difficulty)\n    # Use player's form and total goals as a basis\n    goals_per_90_hist = (\n        (player[\"goals_scored\"] / player[\"minutes\"] * 90)\n        if player[\"minutes\"] &gt; 0\n        else 0.0\n    )\n    expected_team_goals = self._calculate_expected_goals(\n        player_team_strength_attack, opponent_team_strength_defence\n    )\n\n    expected_goals_player_contribution = (\n        (goals_per_90_hist / 90.0) * expected_minutes * (expected_team_goals / 1.5)\n    )  # Scale player's goal contribution by team's expected goals\n\n    if position == \"GK\":\n        xp += expected_goals_player_contribution * self.fpl_points[\"goal_gk\"]\n    elif position == \"DEF\":\n        xp += expected_goals_player_contribution * self.fpl_points[\"goal_def\"]\n    elif position == \"MID\":\n        xp += expected_goals_player_contribution * self.fpl_points[\"goal_mid\"]\n    elif position == \"FWD\":\n        xp += expected_goals_player_contribution * self.fpl_points[\"goal_fwd\"]\n\n    # 3. Expected Assists (scaled by historical assists per 90 and opponent difficulty)\n    assists_per_90_hist = (\n        (player[\"assists\"] / player[\"minutes\"] * 90)\n        if player[\"minutes\"] &gt; 0\n        else 0.0\n    )\n    # Assuming team's attacking strength correlates with assist opportunities\n    expected_assists_player_contribution = (\n        (assists_per_90_hist / 90.0)\n        * expected_minutes\n        * (expected_team_goals / 1.5)\n    )  # Similarly scale by team's expected goals\n    xp += expected_assists_player_contribution * self.fpl_points[\"assist_points\"]\n\n    # 4. Expected Clean Sheets (for GKs/DEFs/MIDs) and Conceded Goals deduction\n    expected_conceded = self._calculate_expected_conceded_goals(\n        player_team_strength_defence, opponent_team_strength_attack\n    )\n\n    # Probability of clean sheet\n    # Simplified: higher team defense / lower opponent attack -&gt; higher CS prob\n    # Use logistic or sigmoid for probability\n    cs_prob = 1.0 / (\n        1.0 + math.exp(expected_conceded - 1.0)\n    )  # Sigmoid centered at 1 goal\n\n    if position in [\"GK\", \"DEF\"]:\n        xp += cs_prob * self.fpl_points[\"clean_sheet_gk_def\"]\n\n        # Conceded goals deduction: Apply penalty for every 2 goals conceded *probability*\n        # For simplicity, calculate expected deduction: (expected_conceded / 2) * deduction\n        xp += (expected_conceded / 2.0) * self.fpl_points[\n            \"conceded_2_goals_deduction\"\n        ]\n    elif position == \"MID\":\n        xp += cs_prob * self.fpl_points[\"clean_sheet_mid\"]\n\n    # 5. Expected Saves (for GKs)\n    if position == \"GK\":\n        saves_per_90_hist = (\n            (player[\"saves\"] / player[\"minutes\"] * 90)\n            if player[\"minutes\"] &gt; 0\n            else 0.0\n        )\n        # Expected saves scaled by opponent's attacking strength (more attacking -&gt; more shots -&gt; more saves)\n        expected_saves_player_contribution = (\n            (saves_per_90_hist / 90.0)\n            * expected_minutes\n            * (opponent_team_strength_attack / player_team_strength_defence)\n        )\n        xp += (expected_saves_player_contribution / 3.0) * self.fpl_points[\n            \"saves_3_points\"\n        ]  # Using the new config point value\n\n        # Penalty saves (low probability, use historical rate)\n        penalty_saves_hist_per_game = (\n            player[\"penalties_saved\"] / (player[\"minutes\"] / 90.0)\n            if player[\"minutes\"] &gt; 0\n            else 0.0\n        )\n        xp += (\n            penalty_saves_hist_per_game\n            * (expected_minutes / 90.0)\n            * self.fpl_points[\"penalty_save_points\"]\n        )\n\n    # 6. Expected Bonus Points\n    # Use BPS (Bonus Points System) as a proxy. Scale player's average BPS by form and expected minutes.\n    bps_per_90_hist = (\n        (player[\"bps\"] / player[\"minutes\"] * 90) if player[\"minutes\"] &gt; 0 else 0.0\n    )\n    expected_bps = (bps_per_90_hist / 90.0) * expected_minutes * player[\"form\"]\n    xp += expected_bps * self.fpl_points[\"bonus_points_scaling_factor\"]\n\n    # 7. Minor Negative Events (Probabilistic)\n    # These are rare, so a simple probability based on expected minutes.\n    xp += (expected_minutes / 90.0) * (\n        self.fpl_points[\"yellow_card_deduction\"] * YELLOW_CARD_PROB\n        + self.fpl_points[\"red_card_deduction\"] * RED_CARD_PROB\n        + self.fpl_points[\"own_goal_deduction\"] * OWN_GOAL_PROB\n        + self.fpl_points[\"penalty_miss_deduction\"] * PENALTY_MISS_PROB\n    )\n\n    # 8. Defensive Contribution Points (for 2025/26 season)\n    # Use actual defensive_contribution data from API\n    defensive_contribution_per_90 = (\n        (player[\"defensive_contribution\"] / player[\"minutes\"] * 90)\n        if player[\"minutes\"] &gt; 0\n        else 0.0\n    )\n    expected_defensive_contribution = (defensive_contribution_per_90 / 90.0) * expected_minutes\n\n    # Award defensive contribution points based on position thresholds\n    if position in [\"DEF\", \"MID\", \"FWD\"]:  # Goalkeepers do not earn defensive contribution points\n        xp += expected_defensive_contribution * self.fpl_points[\"defensive_contribution_points\"]\n\n    # Apply confidence factor to final xP\n    xp = xp * confidence_factor\n\n    return {\"xp\": round(xp, 2), \"reason\": \"Success\", \"confidence\": confidence_factor}\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/xp_predictor/#build.lib.fpl_solver.xp_predictor.FPLPredictor.clear_cache","title":"<code>clear_cache()</code>","text":"<p>Clear all cached API responses. Use this when you want to force fresh data from the FPL API.</p> Source code in <code>build/lib/fpl_solver/xp_predictor.py</code> <pre><code>def clear_cache(self):\n    \"\"\"\n    Clear all cached API responses. Use this when you want to force fresh data\n    from the FPL API.\n    \"\"\"\n    self.cache_manager.clear_cache()\n    self.logger.info(\"Cleared API response cache\")\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/xp_predictor/#build.lib.fpl_solver.xp_predictor.FPLPredictor.get_players_for_optimizer","title":"<code>get_players_for_optimizer()</code>","text":"<p>Returns the list of player data with calculated xP per gameweek, formatted for the FPLOptimizer.</p> Source code in <code>build/lib/fpl_solver/xp_predictor.py</code> <pre><code>def get_players_for_optimizer(self):\n    \"\"\"\n    Returns the list of player data with calculated xP per gameweek,\n    formatted for the FPLOptimizer.\n    \"\"\"\n    return self.all_players_xp_calculated_data\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/xp_predictor/#build.lib.fpl_solver.xp_predictor.FPLPredictor.get_upcoming_fixtures","title":"<code>get_upcoming_fixtures(limit=None)</code>","text":"<p>Returns a list of upcoming fixtures, sorted by gameweek and kickoff time. Optionally limits the number of fixtures returned.</p> Source code in <code>build/lib/fpl_solver/xp_predictor.py</code> <pre><code>def get_upcoming_fixtures(self, limit=None):\n    \"\"\"\n    Returns a list of upcoming fixtures, sorted by gameweek and kickoff time.\n    Optionally limits the number of fixtures returned.\n    \"\"\"\n    upcoming = []\n    now = datetime.now()\n\n    # Sort all fixtures by gameweek and then by kickoff time\n    sorted_fixtures = sorted(\n        self.fixtures_data.values(),\n        key=lambda x: (\n            x.get(\"event\", 0),\n            x.get(\"kickoff_time\", \"9999-12-31T00:00:00Z\"),\n        ),\n    )\n\n    current_gameweek = None\n    for fixture_data in sorted_fixtures:\n        # Determine current gameweek from the earliest upcoming fixture\n        if not fixture_data[\"finished\"] and current_gameweek is None:\n            current_gameweek = fixture_data.get(\"event\", 0)\n\n        # Filter for upcoming fixtures within the prediction horizon\n        if (\n            fixture_data.get(\"event\", 0) &lt; current_gameweek  # Skip past gameweeks\n            or fixture_data.get(\"event\", 0)\n            &gt;= current_gameweek + self.gameweeks_to_predict\n        ):\n            continue  # Skip fixtures outside the prediction horizon\n\n        home_team_name = self.teams_data.get(\n            fixture_data[\"team_h\"], {}\n        ).get(  # Use 'team_h'\n            \"name\", \"Unknown\"\n        )\n        away_team_name = self.teams_data.get(\n            fixture_data[\"team_a\"], {}\n        ).get(  # Use 'team_a'\n            \"name\", \"Unknown\"\n        )\n\n        # Only add fixtures that are not finished\n        if not fixture_data[\"finished\"]:\n            upcoming.append(\n                {\n                    \"fixture_id\": fixture_data[\"id\"],\n                    \"gameweek\": fixture_data.get(\"event\"),\n                    \"home_team_id\": fixture_data[\"team_h\"],  # Use 'team_h'\n                    \"away_team_id\": fixture_data[\"team_a\"],  # Use 'team_a'\n                    \"match\": f\"{home_team_name} vs {away_team_name}\",\n                    \"kickoff_time\": fixture_data.get(\"kickoff_time\"),\n                    \"home_team_difficulty\": fixture_data[\"team_h_difficulty\"],\n                    \"away_team_difficulty\": fixture_data[\"team_a_difficulty\"],\n                }\n            )\n        if limit is not None and len(upcoming) &gt;= limit:\n            break\n    return upcoming\n</code></pre>"},{"location":"autoapi/fpl_solver/","title":"fpl_solver","text":"<p>FPL Solver package initialization. This package provides tools for Fantasy Premier League optimization.</p>"},{"location":"autoapi/fpl_solver/#fpl_solver.cache_manager","title":"<code>cache_manager</code>","text":"<p>Cache manager for FPL API responses.</p> <p>This module provides functionality to cache API responses locally and manage their expiry.</p>"},{"location":"autoapi/fpl_solver/#fpl_solver.cache_manager.CacheManager","title":"<code>CacheManager</code>","text":"Source code in <code>fpl_solver/cache_manager.py</code> <pre><code>class CacheManager:\n    def __init__(self, cache_dir: str, cache_expiry_hours: int = 3):\n        \"\"\"\n        Initialize the cache manager.\n\n        Args:\n            cache_dir: Directory to store cache files\n            cache_expiry_hours: Number of hours after which cache should be considered stale\n        \"\"\"\n        self.cache_dir = cache_dir\n        self.cache_expiry = timedelta(hours=cache_expiry_hours)\n\n        # Create cache directory if it doesn't exist\n        if not os.path.exists(cache_dir):\n            os.makedirs(cache_dir)\n\n    def _get_cache_path(self, endpoint: str) -&gt; str:\n        \"\"\"Get the full path for a cache file.\"\"\"\n        return os.path.join(self.cache_dir, f\"{endpoint}.json\")\n\n    def get_cached_response(self, endpoint: str) -&gt; Optional[Dict[str, Any]]:\n        \"\"\"\n        Retrieve cached response if it exists and is not expired.\n\n        Args:\n            endpoint: API endpoint identifier (e.g., 'static' or 'fixtures')\n\n        Returns:\n            Cached data if valid, None otherwise\n        \"\"\"\n        cache_path = self._get_cache_path(endpoint)\n\n        if not os.path.exists(cache_path):\n            return None\n\n        try:\n            with open(cache_path, 'r') as f:\n                cached_data = json.load(f)\n\n            # Check if cache has expired\n            cached_time = datetime.fromtimestamp(cached_data['cached_at'])\n            if datetime.now() - cached_time &gt; self.cache_expiry:\n                return None\n\n            return cached_data['data']\n\n        except (json.JSONDecodeError, KeyError, ValueError) as e:\n            # If there's any issue with the cache file, ignore it\n            return None\n\n    def save_response(self, endpoint: str, data: Dict[str, Any]) -&gt; None:\n        \"\"\"\n        Save API response to cache.\n\n        Args:\n            endpoint: API endpoint identifier\n            data: Response data to cache\n        \"\"\"\n        cache_path = self._get_cache_path(endpoint)\n\n        cache_data = {\n            'cached_at': time.time(),\n            'data': data\n        }\n\n        with open(cache_path, 'w') as f:\n            json.dump(cache_data, f)\n\n    def clear_cache(self) -&gt; None:\n        \"\"\"Clear all cached data.\"\"\"\n        for filename in os.listdir(self.cache_dir):\n            if filename.endswith('.json'):\n                os.remove(os.path.join(self.cache_dir, filename))\n</code></pre>"},{"location":"autoapi/fpl_solver/#fpl_solver.cache_manager.CacheManager.__init__","title":"<code>__init__(cache_dir, cache_expiry_hours=3)</code>","text":"<p>Initialize the cache manager.</p> <p>Parameters:</p> Name Type Description Default <code>cache_dir</code> <code>str</code> <p>Directory to store cache files</p> required <code>cache_expiry_hours</code> <code>int</code> <p>Number of hours after which cache should be considered stale</p> <code>3</code> Source code in <code>fpl_solver/cache_manager.py</code> <pre><code>def __init__(self, cache_dir: str, cache_expiry_hours: int = 3):\n    \"\"\"\n    Initialize the cache manager.\n\n    Args:\n        cache_dir: Directory to store cache files\n        cache_expiry_hours: Number of hours after which cache should be considered stale\n    \"\"\"\n    self.cache_dir = cache_dir\n    self.cache_expiry = timedelta(hours=cache_expiry_hours)\n\n    # Create cache directory if it doesn't exist\n    if not os.path.exists(cache_dir):\n        os.makedirs(cache_dir)\n</code></pre>"},{"location":"autoapi/fpl_solver/#fpl_solver.cache_manager.CacheManager.clear_cache","title":"<code>clear_cache()</code>","text":"<p>Clear all cached data.</p> Source code in <code>fpl_solver/cache_manager.py</code> <pre><code>def clear_cache(self) -&gt; None:\n    \"\"\"Clear all cached data.\"\"\"\n    for filename in os.listdir(self.cache_dir):\n        if filename.endswith('.json'):\n            os.remove(os.path.join(self.cache_dir, filename))\n</code></pre>"},{"location":"autoapi/fpl_solver/#fpl_solver.cache_manager.CacheManager.get_cached_response","title":"<code>get_cached_response(endpoint)</code>","text":"<p>Retrieve cached response if it exists and is not expired.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>API endpoint identifier (e.g., 'static' or 'fixtures')</p> required <p>Returns:</p> Type Description <code>Optional[Dict[str, Any]]</code> <p>Cached data if valid, None otherwise</p> Source code in <code>fpl_solver/cache_manager.py</code> <pre><code>def get_cached_response(self, endpoint: str) -&gt; Optional[Dict[str, Any]]:\n    \"\"\"\n    Retrieve cached response if it exists and is not expired.\n\n    Args:\n        endpoint: API endpoint identifier (e.g., 'static' or 'fixtures')\n\n    Returns:\n        Cached data if valid, None otherwise\n    \"\"\"\n    cache_path = self._get_cache_path(endpoint)\n\n    if not os.path.exists(cache_path):\n        return None\n\n    try:\n        with open(cache_path, 'r') as f:\n            cached_data = json.load(f)\n\n        # Check if cache has expired\n        cached_time = datetime.fromtimestamp(cached_data['cached_at'])\n        if datetime.now() - cached_time &gt; self.cache_expiry:\n            return None\n\n        return cached_data['data']\n\n    except (json.JSONDecodeError, KeyError, ValueError) as e:\n        # If there's any issue with the cache file, ignore it\n        return None\n</code></pre>"},{"location":"autoapi/fpl_solver/#fpl_solver.cache_manager.CacheManager.save_response","title":"<code>save_response(endpoint, data)</code>","text":"<p>Save API response to cache.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>API endpoint identifier</p> required <code>data</code> <code>Dict[str, Any]</code> <p>Response data to cache</p> required Source code in <code>fpl_solver/cache_manager.py</code> <pre><code>def save_response(self, endpoint: str, data: Dict[str, Any]) -&gt; None:\n    \"\"\"\n    Save API response to cache.\n\n    Args:\n        endpoint: API endpoint identifier\n        data: Response data to cache\n    \"\"\"\n    cache_path = self._get_cache_path(endpoint)\n\n    cache_data = {\n        'cached_at': time.time(),\n        'data': data\n    }\n\n    with open(cache_path, 'w') as f:\n        json.dump(cache_data, f)\n</code></pre>"},{"location":"autoapi/fpl_solver/#fpl_solver.config","title":"<code>config</code>","text":"<p>fpl_config.py</p> <p>Configuration settings for the FPL Expected Points Predictor and Solver. This file centralizes all constants related to FPL scoring, thresholds, and optimization parameters.</p>"},{"location":"autoapi/fpl_solver/#fpl_solver.logger","title":"<code>logger</code>","text":"<p>Logging configuration for the FPL Solver package.</p>"},{"location":"autoapi/fpl_solver/#fpl_solver.logger.setup_logger","title":"<code>setup_logger(name, level=None)</code>","text":"<p>Set up a logger with consistent formatting and optional level override.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the logger</p> required <code>level</code> <code>Optional[int]</code> <p>Optional logging level override. If None, uses INFO</p> <code>None</code> <p>Returns:</p> Type Description <code>Logger</code> <p>logging.Logger: Configured logger instance</p> Source code in <code>fpl_solver/logger.py</code> <pre><code>def setup_logger(name: str, level: Optional[int] = None) -&gt; logging.Logger:\n    \"\"\"\n    Set up a logger with consistent formatting and optional level override.\n\n    Args:\n        name: The name of the logger\n        level: Optional logging level override. If None, uses INFO\n\n    Returns:\n        logging.Logger: Configured logger instance\n    \"\"\"\n    logger = logging.getLogger(name)\n\n    if not logger.handlers:  # Only add handler if logger doesn't have one\n        handler = logging.StreamHandler(sys.stdout)\n        formatter = logging.Formatter(\n            '%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n            datefmt='%Y-%m-%d %H:%M:%S'\n        )\n        handler.setFormatter(formatter)\n        logger.addHandler(handler)\n\n    logger.setLevel(level or logging.INFO)\n    return logger\n</code></pre>"},{"location":"autoapi/fpl_solver/#fpl_solver.solver","title":"<code>solver</code>","text":"<p>FPL Squad Optimizer using PuLP for Integer Linear Programming (ILP).</p> <p>This module provides optimization functionality to select the best possible FPL squad over multiple gameweeks, considering transfer constraints and chips.</p>"},{"location":"autoapi/fpl_solver/#fpl_solver.solver.FPLOptimizer","title":"<code>FPLOptimizer</code>","text":"<p>A class to optimize Fantasy Premier League (FPL) squad selection using Integer Linear Programming (ILP).</p> <p>The optimizer aims to select a 15-player squad (2 GKs, 5 DEFs, 5 MIDs, 3 FWDs) within a budget, with a maximum number of players from any single team, to maximize the total expected points.</p> Source code in <code>fpl_solver/solver.py</code> <pre><code>class FPLOptimizer:\n    \"\"\"\n    A class to optimize Fantasy Premier League (FPL) squad selection\n    using Integer Linear Programming (ILP).\n\n    The optimizer aims to select a 15-player squad (2 GKs, 5 DEFs, 5 MIDs, 3 FWDs)\n    within a budget, with a maximum number of players from any single team,\n    to maximize the total expected points.\n    \"\"\"\n\n    def __init__(self, player_data: pd.DataFrame):\n        \"\"\"\n        Initializes the FPLOptimizer with player data.\n\n        Args:\n            player_data (pd.DataFrame): A DataFrame containing player information\n                                        with columns: 'name', 'team', 'position',\n                                        'cost', 'expected_points_by_gw' (a dict of xP per GW).\n        \"\"\"\n        required_columns = [\"name\", \"team\", \"position\", \"cost\", \"expected_points_by_gw\"]\n        if not all(col in player_data.columns for col in required_columns):\n            missing_cols = [\n                col for col in required_columns if col not in player_data.columns\n            ]\n            raise ValueError(\n                f\"player_data DataFrame must contain {required_columns} columns. Missing: {missing_cols}\"\n            )\n\n        self.player_data = player_data\n        self.problem = None\n        self.selected_squad_history = {}  # To store squad for each gameweek\n        self.total_cost = 0\n        self.total_expected_points = 0\n        self.total_transfer_hits = 0\n\n        # --- Process Enforced Players ---\n        self.enforced_player_indices = set()\n        self.enforced_team_pos_requirements = []\n\n        print(\"\\n--- Processing Enforced Players ---\")\n\n        # Enforce by Player ID\n        for player_id in ENFORCED_PLAYERS_BY_ID:\n            found_player = self.player_data[self.player_data[\"id\"] == player_id]\n            if not found_player.empty:\n                player_idx = found_player.index[0]\n                self.enforced_player_indices.add(player_idx)\n                print(\n                    f\"Enforcing player by ID: {found_player.loc[player_idx, 'name']} (ID: {player_id})\"\n                )\n            else:\n                print(\n                    f\"Warning: Enforced player with ID {player_id} not found in data.\"\n                )\n\n        # Enforce by Player Name\n        for player_name in ENFORCED_PLAYERS_BY_NAME:\n            found_player = self.player_data[self.player_data[\"name\"] == player_name]\n            if not found_player.empty:\n                player_idx = found_player.index[0]\n                self.enforced_player_indices.add(player_idx)\n                print(f\"Enforcing player by name: {player_name}\")\n            else:\n                print(f\"Warning: Enforced player '{player_name}' not found in data.\")\n\n        # Enforce by Team and Position\n        for requirement in ENFORCED_PLAYERS_BY_TEAM_AND_POSITION:\n            team = requirement.get(\"team\")\n            position = requirement.get(\"position\")\n            if team and position:\n                # Validate team and position exist in data\n                if team not in self.player_data[\"team\"].unique():\n                    print(\n                        f\"Warning: Enforced team '{team}' for position '{position}' not found in data.\"\n                    )\n                    continue\n                if position not in self.player_data[\"position\"].unique():\n                    print(\n                        f\"Warning: Enforced position '{position}' for team '{team}' not found in data.\"\n                    )\n                    continue\n\n                self.enforced_team_pos_requirements.append((team, position))\n                print(f\"Enforcing at least one {position} from {team}.\")\n            else:\n                print(\n                    f\"Warning: Invalid enforced team/position requirement: {requirement}\"\n                )\n\n        if not (\n            self.enforced_player_indices\n            or self.enforced_team_pos_requirements\n            or ENFORCED_PLAYERS_BY_ID\n            or ENFORCED_PLAYERS_BY_NAME\n            or ENFORCED_PLAYERS_BY_TEAM_AND_POSITION\n        ):\n            print(\"No players or team/position combinations are enforced.\")\n        print(\"-----------------------------------\\n\")\n\n    def solve(\n        self,\n        budget: float,\n        max_players_per_team: int,\n        chip_allowances: dict,\n        num_gameweeks: int,\n    ) -&gt; bool:\n        \"\"\"\n        Solves the FPL optimization problem using PuLP.\n\n        Args:\n            budget (float): The maximum budget in millions of pounds.\n            max_players_per_team (int): The maximum number of players allowed from\n                                        any single Premier League team.\n            chip_allowances (dict): A dictionary specifying the maximum usage for each chip.\n            num_gameweeks (int): The number of gameweeks to optimize over.\n\n        Returns:\n            bool: True if a solution was found, False otherwise.\n        \"\"\"\n        self.problem = LpProblem(\"FPL Squad Multi-Week Optimization\", LpMaximize)\n\n        # Decision variables for player selection, indexed by player and gameweek\n        player_vars = LpVariable.dicts(\n            \"Player\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n        )\n        starting_xi_vars = LpVariable.dicts(\n            \"StartingXI\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n        )\n        captain_var = LpVariable.dicts(\n            \"Captain\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n        )\n\n        # Binary variables for chip usage, indexed by gameweek\n        use_bench_boost = LpVariable.dicts(\n            \"Use_Bench_Boost\", range(num_gameweeks), 0, 1, LpBinary\n        )\n        use_triple_captain = LpVariable.dicts(\n            \"Use_Triple_Captain\", range(num_gameweeks), 0, 1, LpBinary\n        )\n\n        # Transfer variables\n        transfer_in_vars = LpVariable.dicts(\n            \"Transfer_In\",\n            (self.player_data.index, range(1, num_gameweeks)),\n            0,\n            1,\n            LpBinary,\n        )\n        transfer_out_vars = LpVariable.dicts(\n            \"Transfer_Out\",\n            (self.player_data.index, range(1, num_gameweeks)),\n            0,\n            1,\n            LpBinary,\n        )\n\n        # Total transfers made in a gameweek (absolute count)\n        transfers_made = LpVariable.dicts(\n            \"Transfers_Made\", range(1, num_gameweeks), 0, None, LpInteger\n        )\n        # Free transfers available at the start of a gameweek\n        free_transfers_available = LpVariable.dicts(\n            \"Free_Transfers_Available\",\n            range(num_gameweeks),\n            0,\n            MAX_FREE_TRANSFERS_SAVED + 1,\n            LpInteger,\n        )\n        # Number of transfer hits taken in a gameweek\n        transfer_hits = LpVariable.dicts(\n            \"Transfer_Hits\", range(1, num_gameweeks), 0, None, LpInteger\n        )\n\n        # Auxiliary variables for linearizing chip effects\n        is_bench_player = LpVariable.dicts(\n            \"Is_Bench_Player\",\n            (self.player_data.index, range(num_gameweeks)),\n            0,\n            1,\n            LpBinary,\n        )\n        actual_bench_boost_points = LpVariable.dicts(\n            \"Actual_Bench_Boost_Points\",\n            (self.player_data.index, range(num_gameweeks)),\n            0,\n            None,\n            LpContinuous,\n        )\n        actual_triple_captain_bonus = LpVariable.dicts(\n            \"Actual_Triple_Captain_Bonus\",\n            (self.player_data.index, range(num_gameweeks)),\n            0,\n            None,\n            LpContinuous,\n        )\n\n        # --- Objective Function ---\n        total_objective_points = []\n\n        # Get the first gameweek number from the player data to correctly index expected_points_by_gw\n        first_gw_key = next(\n            iter(\n                self.player_data.loc[\n                    self.player_data.index[0], \"expected_points_by_gw\"\n                ].keys()\n            )\n        )\n        current_gameweek_number_start = int(first_gw_key)\n\n        for w in range(num_gameweeks):\n            # The actual gameweek number (1-indexed)\n            gw_actual = current_gameweek_number_start + w\n\n            # Base expected points from the selected starting 11 for this gameweek\n            base_points_expression_gw = lpSum(\n                self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n                * starting_xi_vars[i][w]\n                for i in self.player_data.index\n            )\n            total_objective_points.append(base_points_expression_gw)\n\n            # Regular Captaincy points (additional 1x for captain)\n            captain_points_bonus_gw = lpSum(\n                self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n                * captain_var[i][w]\n                for i in self.player_data.index\n            )\n            total_objective_points.append(captain_points_bonus_gw)\n\n            # Define auxiliary variables and constraints for chips for each gameweek\n            for i in self.player_data.index:\n                # Use gameweek-specific player xP for chip calculations\n                player_xp = self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n\n                # Bench Boost auxiliary variables and constraints\n                self.problem += (\n                    is_bench_player[i][w] &lt;= player_vars[i][w],\n                    f\"IsBench_Squad_{i}_{w}\",\n                )\n                self.problem += (\n                    is_bench_player[i][w] &lt;= 1 - starting_xi_vars[i][w],\n                    f\"IsBench_NotStarter_{i}_{w}\",\n                )\n                self.problem += (\n                    is_bench_player[i][w]\n                    &gt;= player_vars[i][w] + (1 - starting_xi_vars[i][w]) - 1,\n                    f\"IsBench_Logical_{i}_{w}\",\n                )\n\n                self.problem += (\n                    actual_bench_boost_points[i][w]\n                    &lt;= player_xp * is_bench_player[i][w],\n                    f\"BenchBoost_Contr_1_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_bench_boost_points[i][w] &lt;= player_xp * use_bench_boost[w],\n                    f\"BenchBoost_Contr_2_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_bench_boost_points[i][w]\n                    &gt;= player_xp * (is_bench_player[i][w] + use_bench_boost[w] - 1),\n                    f\"BenchBoost_Contr_3_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_bench_boost_points[i][w] &gt;= 0,\n                    f\"BenchBoost_Contr_4_{i}_{w}\",\n                )\n\n                # Triple Captain auxiliary variables and constraints\n                # Changed player_xp * 2 to player_xp to reflect additional 1x bonus\n                self.problem += (\n                    actual_triple_captain_bonus[i][w] &lt;= player_xp * captain_var[i][w],\n                    f\"TripleCaptain_Contr_1_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_triple_captain_bonus[i][w]\n                    &lt;= player_xp * use_triple_captain[w],\n                    f\"TripleCaptain_Contr_2_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_triple_captain_bonus[i][w]\n                    &gt;= player_xp * (captain_var[i][w] + use_triple_captain[w] - 1),\n                    f\"TripleCaptain_Contr_3_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_triple_captain_bonus[i][w] &gt;= 0,\n                    f\"TripleCaptain_Contr_4_{i}_{w}\",\n                )\n\n            # Add points from bench boost and triple captain bonus for this gameweek\n            total_bench_boost_points_gw = lpSum(\n                actual_bench_boost_points[i][w] for i in self.player_data.index\n            )\n            total_triple_captain_bonus_points_gw = lpSum(\n                actual_triple_captain_bonus[i][w] for i in self.player_data.index\n            )\n\n            total_objective_points.append(total_bench_boost_points_gw)\n            total_objective_points.append(total_triple_captain_bonus_points_gw)\n\n        # Subtract transfer hits from the total objective\n        total_objective_points.append(\n            -POINTS_PER_HIT * lpSum(transfer_hits[w] for w in range(1, num_gameweeks))\n        )\n\n        self.problem += (\n            lpSum(total_objective_points),\n            \"Total Expected Points Over Gameweeks\",\n        )\n\n        # --- Constraints ---\n\n        # Apply constraints for each gameweek\n        for w in range(num_gameweeks):\n            # 1. Select exactly 15 players for the squad\n            self.problem += (\n                lpSum(player_vars[i][w] for i in self.player_data.index) == 15,\n                f\"Total_Players_GW{w}\",\n            )\n\n            # 2. Squad position constraints (2 GKs, 5 DEFs, 5 MIDs, 3 FWDs)\n            gks = self.player_data[self.player_data[\"position\"] == \"GK\"].index\n            defs = self.player_data[self.player_data[\"position\"] == \"DEF\"].index\n            mids = self.player_data[self.player_data[\"position\"] == \"MID\"].index\n            fwds = self.player_data[self.player_data[\"position\"] == \"FWD\"].index\n\n            self.problem += (\n                lpSum(player_vars[i][w] for i in gks) == 2,\n                f\"Goalkeepers_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(player_vars[i][w] for i in defs) == 5,\n                f\"Defenders_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(player_vars[i][w] for i in mids) == 5,\n                f\"Midfielders_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(player_vars[i][w] for i in fwds) == 3,\n                f\"Forwards_Count_GW{w}\",\n            )\n\n            # 3. Budget constraint\n            # This applies to the cost of the squad for the current gameweek.\n            self.problem += (\n                lpSum(\n                    self.player_data.loc[i, \"cost\"] * player_vars[i][w]\n                    for i in self.player_data.index\n                )\n                &lt;= budget,\n                f\"Total_Budget_GW{w}\",\n            )\n\n            # 4. Maximum players per team constraint\n            for team in self.player_data[\"team\"].unique():\n                team_players = self.player_data[self.player_data[\"team\"] == team].index\n                self.problem += (\n                    lpSum(player_vars[i][w] for i in team_players)\n                    &lt;= max_players_per_team,\n                    f\"Max_Players_from_{team}_GW{w}\",\n                )\n\n            # 5. Starting XI constraints\n            # 5.1 Select exactly 11 players for the starting XI\n            self.problem += (\n                lpSum(starting_xi_vars[i][w] for i in self.player_data.index) == 11,\n                f\"Total_Starting_XI_Players_GW{w}\",\n            )\n\n            # 5.2 A player can only be in the starting XI if they are in the squad\n            for i in self.player_data.index:\n                self.problem += (\n                    starting_xi_vars[i][w] &lt;= player_vars[i][w],\n                    f\"StartingXI_in_Squad_{i}_{w}\",\n                )\n\n            # 5.3 Starting XI position constraints (FPL allows flexible formations, so use minimums)\n            self.problem += (\n                lpSum(starting_xi_vars[i][w] for i in gks) == 1,\n                f\"Starting_Goalkeepers_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(starting_xi_vars[i][w] for i in defs) &gt;= 3,\n                f\"Min_Starting_Defenders_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(starting_xi_vars[i][w] for i in mids) &gt;= 2,\n                f\"Min_Starting_Midfielders_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(starting_xi_vars[i][w] for i in fwds) &gt;= 1,\n                f\"Min_Starting_Forwards_Count_GW{w}\",\n            )\n\n            # 6. Captain Constraints\n            # 6.1 Select exactly one captain from the starting XI\n            self.problem += (\n                lpSum(captain_var[i][w] for i in self.player_data.index) == 1,\n                f\"One_Captain_GW{w}\",\n            )\n\n            # 6.2 A player can only be captain if they are in the starting XI\n            for i in self.player_data.index:\n                self.problem += (\n                    captain_var[i][w] &lt;= starting_xi_vars[i][w],\n                    f\"Captain_in_StartingXI_{i}_{w}\",\n                )\n\n            # --- Enforced Player Constraints---\n            for player_idx in self.enforced_player_indices:\n                self.problem += (\n                    player_vars[player_idx][w] == 1,\n                    f\"Enforce_Player_{self.player_data.loc[player_idx, 'name']}_GW{w}\",\n                )\n\n            for team, position in self.enforced_team_pos_requirements:\n                # Filter players for the current team and position\n                team_pos_players = self.player_data[\n                    (self.player_data[\"team\"] == team)\n                    &amp; (self.player_data[\"position\"] == position)\n                ].index\n                if not team_pos_players.empty:\n                    self.problem += (\n                        lpSum(player_vars[i][w] for i in team_pos_players) &gt;= 1,\n                        f\"Enforce_One_{position}_from_{team}_GW{w}\",\n                    )\n                else:\n                    print(\n                        f\"Warning: No players found for enforced requirement: at least one {position} from {team} for GW{gw_actual}.\"\n                    )\n\n        # --- Chip Usage Constraints (TOTAL usage over all gameweeks) ---\n        # These constraints should be outside the per-gameweek loop to avoid duplicates.\n        self.problem += (\n            lpSum(use_bench_boost[j] for j in range(num_gameweeks))\n            &lt;= chip_allowances.get(\"bench_boost\", 0),\n            f\"Max_Bench_Boost_Usage_Total\",\n        )\n        self.problem += (\n            lpSum(use_triple_captain[j] for j in range(num_gameweeks))\n            &lt;= chip_allowances.get(\"triple_captain\", 0),\n            f\"Max_Triple_Captain_Usage_Total\",\n        )\n\n        # --- Inter-Gameweek Constraints (Transfers and Transfer Rules) ---\n        # Initialize free transfers for GW0 (first gameweek of optimization horizon)\n        # This assumes the optimization starts at GW0, and it has INITIAL_FREE_TRANSFERS.\n        # If the model starts at an arbitrary GW, this would need to be an input.\n        self.problem += (\n            free_transfers_available[0] == INITIAL_FREE_TRANSFERS,\n            f\"Initial_Free_Transfers_GW0\",\n        )\n\n        for w in range(1, num_gameweeks):\n            # Calculate total transfers made in this gameweek\n            self.problem += (\n                transfers_made[w]\n                == lpSum(transfer_in_vars[i][w] for i in self.player_data.index),\n                f\"Transfers_Made_GW{w}\",\n            )\n            # Total transfers in must equal total transfers out for each gameweek after the first\n            self.problem += (\n                lpSum(transfer_in_vars[i][w] for i in self.player_data.index)\n                == lpSum(transfer_out_vars[i][w] for i in self.player_data.index),\n                f\"Transfers_In_Equals_Out_GW{w}\",\n            )\n\n            # Calculate free transfers available for the current gameweek (w)\n            # Free transfers for GW_w = min(free transfers from GW_w-1 - transfers made in GW_w + 1, MAX_FREE_TRANSFERS_SAVED + 1)\n            # The + 1 in MAX_FREE_TRANSFERS_SAVED + 1 is because MAX_FREE_TRANSFERS_SAVED implies how many can be *saved*,\n            # so if you save 1, you have 1 (current) + 1 (saved) = 2.\n            self.problem += (\n                free_transfers_available[w]\n                &lt;= free_transfers_available[w - 1] - transfers_made[w] + 1,\n                f\"Free_Transfers_Calc_1_GW{w}\",\n            )\n            self.problem += (\n                free_transfers_available[w] &lt;= MAX_FREE_TRANSFERS_SAVED + 1,\n                f\"Free_Transfers_Calc_2_GW{w}\",\n            )\n            self.problem += (\n                free_transfers_available[w] &gt;= 0,  # Cannot have negative free transfers\n                f\"Free_Transfers_Non_Negative_GW{w}\",\n            )\n\n            # Calculate transfer hits\n            # transfer_hits[w] = max(0, transfers_made[w] - free_transfers_available_at_start_of_gw_w)\n            # This needs to be linearized. If transfers_made[w] &gt; free_transfers_available[w-1], then hit.\n            # free_transfers_available[w-1] represents transfers available *before* making transfers for GW_w\n            self.problem += (\n                transfer_hits[w] &gt;= transfers_made[w] - free_transfers_available[w - 1],\n                f\"Transfer_Hits_Calc_1_GW{w}\",\n            )\n            self.problem += (\n                transfer_hits[w] &gt;= 0,\n                f\"Transfer_Hits_Calc_2_GW{w}\",\n            )\n\n            for i in self.player_data.index:\n                # Squad continuity: player_vars[i][w] (in squad at start of GW w)\n                #                 = player_vars[i][w-1] (in squad at start of GW w-1)\n                #                 - transfer_out_vars[i][w] (transferred out for GW w)\n                #                 + transfer_in_vars[i][w] (transferred in for GW w)\n                self.problem += (\n                    player_vars[i][w]\n                    == player_vars[i][w - 1]\n                    - transfer_out_vars[i][w]\n                    + transfer_in_vars[i][w],\n                    f\"Squad_Continuity_{i}_GW{w}\",\n                )\n                # A player cannot be transferred in and out in the same gameweek\n                self.problem += (\n                    transfer_in_vars[i][w] + transfer_out_vars[i][w] &lt;= 1,\n                    f\"No_Simultaneous_Transfer_{i}_{w}\",\n                )\n\n        try:\n            # The solver is called with the GLPK_CMD solver\n            self.problem.solve(PULP_CBC_CMD(msg=0))  # msg=0 suppresses verbose output\n        except Exception as e:\n            print(f\"Error solving the problem: {e}\")\n            return False\n\n        if LpStatus[self.problem.status] == \"Optimal\":\n            print(\"Optimization successful! Optimal solution found.\")\n\n            self.selected_squad_history = {}\n            self.total_transfer_hits = 0\n            for w in range(num_gameweeks):\n                # The actual gameweek number (1-indexed)\n                gw_actual = current_gameweek_number_start + w\n\n                # Get selected players for the current gameweek\n                selected_squad_gw = self.player_data[\n                    [player_vars[i][w].varValue == 1 for i in self.player_data.index]\n                ].copy()\n\n                # Get starter and captain info for this gameweek\n                is_starter_series_gw = pd.Series(\n                    [\n                        starting_xi_vars[i][w].varValue == 1\n                        for i in self.player_data.index\n                    ],\n                    index=self.player_data.index,\n                )\n                is_captain_series_gw = pd.Series(\n                    [captain_var[i][w].varValue == 1 for i in self.player_data.index],\n                    index=self.player_data.index,\n                )\n\n                selected_squad_gw[\"is_starter\"] = is_starter_series_gw.loc[\n                    selected_squad_gw.index\n                ]\n                selected_squad_gw[\"is_captain\"] = is_captain_series_gw.loc[\n                    selected_squad_gw.index\n                ]\n\n                transfers_in_gw = 0\n                transfers_out_gw = 0\n                hits_gw = 0\n\n                # Store transfer details for gameweeks &gt; 0\n                if (\n                    w &gt; 0\n                ):  # Check for transfers only from GW1 onwards (index 1 in 0-indexed loop)\n                    transfer_in_flags = pd.Series(\n                        [\n                            transfer_in_vars[i][w].varValue == 1\n                            for i in self.player_data.index\n                        ],\n                        index=self.player_data.index,\n                    )\n                    transfer_out_flags = pd.Series(\n                        [\n                            transfer_out_vars[i][w].varValue == 1\n                            for i in self.player_data.index\n                        ],\n                        index=self.player_data.index,\n                    )\n\n                    selected_squad_gw[\"transfer_in\"] = transfer_in_flags.loc[\n                        selected_squad_gw.index\n                    ]\n                    selected_squad_gw[\"transfer_out\"] = transfer_out_flags.loc[\n                        selected_squad_gw.index\n                    ]\n\n                    transfers_in_gw = int(round(transfer_in_flags.sum()))\n                    transfers_out_gw = int(round(transfer_out_flags.sum()))\n                    hits_gw = int(round(transfer_hits[w].varValue))\n                    self.total_transfer_hits += hits_gw\n                else:\n                    selected_squad_gw[\"transfer_in\"] = False  # No transfers in for GW0\n                    selected_squad_gw[\"transfer_out\"] = (\n                        False  # No transfers out for GW0\n                    )\n\n                self.selected_squad_history[f\"GW{gw_actual}\"] = {\n                    \"squad\": selected_squad_gw,\n                    \"total_cost\": selected_squad_gw[\"cost\"].sum(),\n                    \"expected_points_from_xi\": sum(\n                        self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n                        * starting_xi_vars[i][w].varValue\n                        for i in self.player_data.index\n                    ),\n                    \"bench_boost_used\": bool(use_bench_boost[w].varValue),\n                    \"triple_captain_used\": bool(use_triple_captain[w].varValue),\n                    \"total_bench_boost_points\": value(\n                        lpSum(\n                            actual_bench_boost_points[i][w]\n                            for i in self.player_data.index\n                        )\n                    ),\n                    \"total_triple_captain_bonus\": value(\n                        lpSum(\n                            actual_triple_captain_bonus[i][w]\n                            for i in self.player_data.index\n                        )\n                    ),\n                    \"transfers_in_count\": transfers_in_gw,\n                    \"transfers_out_count\": transfers_out_gw,\n                    \"transfer_hits\": hits_gw,  # New\n                    \"free_transfers_available_next_gw\": (\n                        int(round(free_transfers_available[w].varValue))\n                        if w &lt; num_gameweeks - 1\n                        else 0\n                    ),  # Free transfers available *after* this GW's transfers are made\n                }\n\n            # Overall totals\n            self.total_cost = self.selected_squad_history[\n                f\"GW{current_gameweek_number_start + num_gameweeks - 1}\"\n            ][\n                \"total_cost\"\n            ]  # Cost of final squad\n            self.total_expected_points = value(\n                self.problem.objective\n            )  # Total objective value from solver\n            self.used_chips = {\n                f\"GW{current_gameweek_number_start + w}\": {\n                    \"bench_boost\": bool(use_bench_boost[w].varValue),\n                    \"triple_captain\": bool(use_triple_captain[w].varValue),\n                }\n                for w in range(num_gameweeks)\n            }\n\n            return True\n        else:\n            print(f\"No optimal solution found. Status: {LpStatus[self.problem.status]}\")\n            self.selected_squad_history = {}\n            self.total_cost = 0\n            self.total_expected_points = 0\n            self.used_chips = {}\n            self.total_transfer_hits = 0\n            return False\n\n    def get_selected_squad(self, gameweek: int = None) -&gt; pd.DataFrame | None:\n        \"\"\"\n        Returns the selected squad for a specific gameweek (1-indexed).\n        If no gameweek is specified, returns the squad for the last optimized gameweek.\n        \"\"\"\n        if not self.selected_squad_history:\n            return None\n\n        # Get the first GW key to determine the range of available GWs\n        first_gw_in_history = min(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n        last_gw_in_history = max(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n\n        if gameweek is None:\n            return self.selected_squad_history[f\"GW{last_gw_in_history}\"][\"squad\"]\n\n        if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n            print(\n                f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n            )\n            return None\n\n        return self.selected_squad_history.get(f\"GW{gameweek}\", {}).get(\"squad\")\n\n    def get_total_cost(self, gameweek: int = None) -&gt; float:\n        \"\"\"\n        Returns the total cost for a specific gameweek (1-indexed).\n        If no gameweek is specified, returns the cost of the squad in the last optimized gameweek.\n        \"\"\"\n        if not self.selected_squad_history:\n            return 0\n        first_gw_in_history = min(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n        last_gw_in_history = max(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n\n        if gameweek is None:\n            return self.selected_squad_history[f\"GW{last_gw_in_history}\"][\"total_cost\"]\n\n        if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n            print(\n                f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n            )\n            return 0  # Or raise an error\n\n        return self.selected_squad_history.get(f\"GW{gameweek}\", {}).get(\"total_cost\", 0)\n\n    def get_total_expected_points(self) -&gt; float:\n        \"\"\"\n        Returns the overall total expected points across all optimized gameweeks.\n        \"\"\"\n        return self.total_expected_points\n\n    def get_gameweek_summary(self, gameweek: int):\n        \"\"\"\n        Returns a dictionary summary for a specific gameweek.\n        \"\"\"\n        if not self.selected_squad_history:\n            return None\n        first_gw_in_history = min(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n        last_gw_in_history = max(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n\n        if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n            print(\n                f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n            )\n            return None\n\n        return self.selected_squad_history.get(f\"GW{gameweek}\")\n\n    def print_squad_summary(self, gameweek: int):\n        \"\"\"\n        Prints a formatted summary of the selected squad for a specific gameweek.\n        \"\"\"\n        if not self.selected_squad_history:\n            print(\"No squad has been selected yet. Run the 'solve' method first.\")\n            return\n\n        gw_data = self.get_gameweek_summary(gameweek)\n        if not gw_data:\n            return  # get_gameweek_summary already prints error message\n\n        selected_squad = gw_data[\"squad\"]\n        total_cost = gw_data[\"total_cost\"]\n        expected_points_from_xi = gw_data[\"expected_points_from_xi\"]\n        bench_boost_used = gw_data[\"bench_boost_used\"]\n        triple_captain_used = gw_data[\"triple_captain_used\"]\n        total_bench_boost_points = gw_data[\"total_bench_boost_points\"]\n        total_triple_captain_bonus = gw_data[\"total_triple_captain_bonus\"]\n        transfers_in_count = gw_data[\"transfers_in_count\"]  # New\n        transfers_out_count = gw_data[\"transfers_out_count\"]  # New\n        transfer_hits_taken = gw_data[\"transfer_hits\"]  # New\n        free_transfers_available_next_gw = gw_data[\n            \"free_transfers_available_next_gw\"\n        ]  # New\n\n        print(f\"\\n--- FPL Optimized Squad for Gameweek {gameweek} ---\")\n        print(f\"Squad Cost: \u00a3{total_cost:.1f}m\")\n        print(f\"Expected Points (Starting XI): {expected_points_from_xi:.2f}\")\n        print(\n            f\"Total Expected Points for GW{gameweek} (including chips): {expected_points_from_xi + total_bench_boost_points + total_triple_captain_bonus:.2f}\"\n        )\n        print(\"\\n--- Chips Used This Gameweek ---\")\n        if bench_boost_used:\n            print(f\"- Bench Boost (Added {total_bench_boost_points:.2f} points)\")\n        if triple_captain_used:\n            print(\n                f\"- Triple Captain (Added {total_triple_captain_bonus:.2f} bonus points)\"\n            )\n        if not (bench_boost_used or triple_captain_used):\n            print(\"No chips used this gameweek.\")\n\n        print(\"\\n--- Goalkeepers (Starting XI marked with *) ---\")\n        for index, row in selected_squad[selected_squad[\"position\"] == \"GK\"].iterrows():\n            starter_str = \"*\" if row[\"is_starter\"] else \"\"\n            captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n            transfer_status = \"\"\n            if row[\"transfer_in\"]:\n                transfer_status = \"(IN)\"\n            elif row[\"transfer_out\"]:\n                transfer_status = \"(OUT)\"\n\n            # Access gameweek-specific xP correctly\n            player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n            print(\n                f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n            )\n        print(\"\\n--- Defenders (Starting XI marked with *) ---\")\n        for index, row in selected_squad[\n            selected_squad[\"position\"] == \"DEF\"\n        ].iterrows():\n            starter_str = \"*\" if row[\"is_starter\"] else \"\"\n            captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n            transfer_status = \"\"\n            if row[\"transfer_in\"]:\n                transfer_status = \"(IN)\"\n            elif row[\"transfer_out\"]:\n                transfer_status = \"(OUT)\"\n\n            player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n            print(\n                f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n            )\n        print(\"\\n--- Midfielders (Starting XI marked with *) ---\")\n        for index, row in selected_squad[\n            selected_squad[\"position\"] == \"MID\"\n        ].iterrows():\n            starter_str = \"*\" if row[\"is_starter\"] else \"\"\n            captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n            transfer_status = \"\"\n            if row[\"transfer_in\"]:\n                transfer_status = \"(IN)\"\n            elif row[\"transfer_out\"]:\n                transfer_status = \"(OUT)\"\n\n            player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n            print(\n                f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n            )\n        print(\"\\n--- Forwards (Starting XI marked with *) ---\")\n        for index, row in selected_squad[\n            selected_squad[\"position\"] == \"FWD\"\n        ].iterrows():\n            starter_str = \"*\" if row[\"is_starter\"] else \"\"\n            captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n            transfer_status = \"\"\n            if row[\"transfer_in\"]:\n                transfer_status = \"(IN)\"\n            elif row[\"transfer_out\"]:\n                transfer_status = \"(OUT)\"\n\n            player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n            print(\n                f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n            )\n\n        print(f\"\\n--- Team Breakdown for GW{gameweek} ---\")\n        print(selected_squad[\"team\"].value_counts())\n\n        # Transfers are relevant from Gameweek 2 (index 1) onwards in the optimization horizon\n        # For display, if the current GW is the initial one (GW1 in the current context), no transfers are made\n        # If it's a subsequent GW, check if transfers occurred.\n        first_gw_in_history = min(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n        if (\n            gameweek &gt;= first_gw_in_history\n        ):  # Changed from &gt; to &gt;=, to show initial free transfers\n            # Display transfer info for this gameweek\n            print(\n                f\"  Transfers In: {transfers_in_count}, Transfers Out: {transfers_out_count}\"\n            )\n            print(\n                f\"  Transfer Hits: {transfer_hits_taken} (-{transfer_hits_taken * POINTS_PER_HIT} points)\"\n            )\n            # Only show free transfers for the *next* gameweek if it's not the last gameweek in the horizon\n            if gameweek &lt; max(\n                int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n            ):\n                print(\n                    f\"  Free Transfers Available for Next GW: {free_transfers_available_next_gw}\"\n                )\n        print(\"---------------------------\\n\")\n\n    def print_overall_summary(self):\n        \"\"\"\n        Prints an overall summary of the multi-week optimization results.\n        \"\"\"\n        if not self.selected_squad_history:\n            print(\"No optimization results to summarize.\")\n            return\n\n        print(\"\\n=== Overall Multi-Week FPL Optimization Summary ===\")\n        print(\n            f\"Total Expected Points Across All Gameweeks: {self.total_expected_points:.2f}\"\n        )\n\n        # Get the latest gameweek's cost\n        last_gw_key = max(\n            self.selected_squad_history.keys(), key=lambda k: int(k.replace(\"GW\", \"\"))\n        )\n        print(\n            f\"Squad Cost ({last_gw_key}): \u00a3{self.selected_squad_history[last_gw_key]['total_cost']:.1f}m\"\n        )\n        print(\n            f\"Total Transfer Hits Taken: {self.total_transfer_hits} (-{self.total_transfer_hits * POINTS_PER_HIT} points)\"\n        )\n\n        print(\"\\n--- Chip Usage Across Gameweeks ---\")\n        # Ensure consistent order by sorting gameweek keys\n        sorted_gw_keys = sorted(\n            self.used_chips.keys(), key=lambda k: int(k.replace(\"GW\", \"\"))\n        )\n        for gw_str in sorted_gw_keys:\n            chips = self.used_chips[gw_str]\n            chip_summary = []\n            if chips[\"bench_boost\"]:\n                chip_summary.append(\"Bench Boost\")\n            if chips[\"triple_captain\"]:\n                chip_summary.append(\"Triple Captain\")\n\n            if chip_summary:\n                print(f\"{gw_str}: {', '.join(chip_summary)}\")\n            else:\n                print(f\"{gw_str}: No chips used\")\n\n        print(\"\\n--- Gameweek-by-Gameweek Summary ---\")\n        # Iterate and print basic summary for each gameweek\n        for gw_str in sorted_gw_keys:\n            gw_data = self.selected_squad_history[gw_str]\n            print(f\"\\n--- {gw_str} ---\")\n            print(f\"  Squad Cost: \u00a3{gw_data['total_cost']:.1f}m\")\n            print(\n                f\"  Expected Points (Starting XI): {gw_data['expected_points_from_xi']:.2f}\"\n            )\n            print(\n                f\"  Total GW Points (incl. chips): {gw_data['expected_points_from_xi'] + gw_data['total_bench_boost_points'] + gw_data['total_triple_captain_bonus']:.2f}\"\n            )\n\n            # Display transfer info for this gameweek\n            transfers_in_count = gw_data[\"transfers_in_count\"]\n            transfers_out_count = gw_data[\"transfers_out_count\"]\n            transfer_hits_taken = gw_data[\"transfer_hits\"]\n            free_transfers_available_next_gw = gw_data[\n                \"free_transfers_available_next_gw\"\n            ]\n\n            print(\n                f\"  Transfers In: {transfers_in_count}, Transfers Out: {transfers_out_count}\"\n            )\n            print(\n                f\"  Transfer Hits: {transfer_hits_taken} (-{transfer_hits_taken * POINTS_PER_HIT} points)\"\n            )\n            # Only show free transfers for the *next* gameweek if it's not the last gameweek in the horizon\n            if int(gw_str.replace(\"GW\", \"\")) &lt; max(\n                int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n            ):\n                print(\n                    f\"  Free Transfers Available for Next GW: {free_transfers_available_next_gw}\"\n                )\n            print(\"-----------------------------------\")\n</code></pre>"},{"location":"autoapi/fpl_solver/#fpl_solver.solver.FPLOptimizer.__init__","title":"<code>__init__(player_data)</code>","text":"<p>Initializes the FPLOptimizer with player data.</p> <p>Parameters:</p> Name Type Description Default <code>player_data</code> <code>DataFrame</code> <p>A DataFrame containing player information                         with columns: 'name', 'team', 'position',                         'cost', 'expected_points_by_gw' (a dict of xP per GW).</p> required Source code in <code>fpl_solver/solver.py</code> <pre><code>def __init__(self, player_data: pd.DataFrame):\n    \"\"\"\n    Initializes the FPLOptimizer with player data.\n\n    Args:\n        player_data (pd.DataFrame): A DataFrame containing player information\n                                    with columns: 'name', 'team', 'position',\n                                    'cost', 'expected_points_by_gw' (a dict of xP per GW).\n    \"\"\"\n    required_columns = [\"name\", \"team\", \"position\", \"cost\", \"expected_points_by_gw\"]\n    if not all(col in player_data.columns for col in required_columns):\n        missing_cols = [\n            col for col in required_columns if col not in player_data.columns\n        ]\n        raise ValueError(\n            f\"player_data DataFrame must contain {required_columns} columns. Missing: {missing_cols}\"\n        )\n\n    self.player_data = player_data\n    self.problem = None\n    self.selected_squad_history = {}  # To store squad for each gameweek\n    self.total_cost = 0\n    self.total_expected_points = 0\n    self.total_transfer_hits = 0\n\n    # --- Process Enforced Players ---\n    self.enforced_player_indices = set()\n    self.enforced_team_pos_requirements = []\n\n    print(\"\\n--- Processing Enforced Players ---\")\n\n    # Enforce by Player ID\n    for player_id in ENFORCED_PLAYERS_BY_ID:\n        found_player = self.player_data[self.player_data[\"id\"] == player_id]\n        if not found_player.empty:\n            player_idx = found_player.index[0]\n            self.enforced_player_indices.add(player_idx)\n            print(\n                f\"Enforcing player by ID: {found_player.loc[player_idx, 'name']} (ID: {player_id})\"\n            )\n        else:\n            print(\n                f\"Warning: Enforced player with ID {player_id} not found in data.\"\n            )\n\n    # Enforce by Player Name\n    for player_name in ENFORCED_PLAYERS_BY_NAME:\n        found_player = self.player_data[self.player_data[\"name\"] == player_name]\n        if not found_player.empty:\n            player_idx = found_player.index[0]\n            self.enforced_player_indices.add(player_idx)\n            print(f\"Enforcing player by name: {player_name}\")\n        else:\n            print(f\"Warning: Enforced player '{player_name}' not found in data.\")\n\n    # Enforce by Team and Position\n    for requirement in ENFORCED_PLAYERS_BY_TEAM_AND_POSITION:\n        team = requirement.get(\"team\")\n        position = requirement.get(\"position\")\n        if team and position:\n            # Validate team and position exist in data\n            if team not in self.player_data[\"team\"].unique():\n                print(\n                    f\"Warning: Enforced team '{team}' for position '{position}' not found in data.\"\n                )\n                continue\n            if position not in self.player_data[\"position\"].unique():\n                print(\n                    f\"Warning: Enforced position '{position}' for team '{team}' not found in data.\"\n                )\n                continue\n\n            self.enforced_team_pos_requirements.append((team, position))\n            print(f\"Enforcing at least one {position} from {team}.\")\n        else:\n            print(\n                f\"Warning: Invalid enforced team/position requirement: {requirement}\"\n            )\n\n    if not (\n        self.enforced_player_indices\n        or self.enforced_team_pos_requirements\n        or ENFORCED_PLAYERS_BY_ID\n        or ENFORCED_PLAYERS_BY_NAME\n        or ENFORCED_PLAYERS_BY_TEAM_AND_POSITION\n    ):\n        print(\"No players or team/position combinations are enforced.\")\n    print(\"-----------------------------------\\n\")\n</code></pre>"},{"location":"autoapi/fpl_solver/#fpl_solver.solver.FPLOptimizer.get_gameweek_summary","title":"<code>get_gameweek_summary(gameweek)</code>","text":"<p>Returns a dictionary summary for a specific gameweek.</p> Source code in <code>fpl_solver/solver.py</code> <pre><code>def get_gameweek_summary(self, gameweek: int):\n    \"\"\"\n    Returns a dictionary summary for a specific gameweek.\n    \"\"\"\n    if not self.selected_squad_history:\n        return None\n    first_gw_in_history = min(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n    last_gw_in_history = max(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n\n    if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n        print(\n            f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n        )\n        return None\n\n    return self.selected_squad_history.get(f\"GW{gameweek}\")\n</code></pre>"},{"location":"autoapi/fpl_solver/#fpl_solver.solver.FPLOptimizer.get_selected_squad","title":"<code>get_selected_squad(gameweek=None)</code>","text":"<p>Returns the selected squad for a specific gameweek (1-indexed). If no gameweek is specified, returns the squad for the last optimized gameweek.</p> Source code in <code>fpl_solver/solver.py</code> <pre><code>def get_selected_squad(self, gameweek: int = None) -&gt; pd.DataFrame | None:\n    \"\"\"\n    Returns the selected squad for a specific gameweek (1-indexed).\n    If no gameweek is specified, returns the squad for the last optimized gameweek.\n    \"\"\"\n    if not self.selected_squad_history:\n        return None\n\n    # Get the first GW key to determine the range of available GWs\n    first_gw_in_history = min(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n    last_gw_in_history = max(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n\n    if gameweek is None:\n        return self.selected_squad_history[f\"GW{last_gw_in_history}\"][\"squad\"]\n\n    if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n        print(\n            f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n        )\n        return None\n\n    return self.selected_squad_history.get(f\"GW{gameweek}\", {}).get(\"squad\")\n</code></pre>"},{"location":"autoapi/fpl_solver/#fpl_solver.solver.FPLOptimizer.get_total_cost","title":"<code>get_total_cost(gameweek=None)</code>","text":"<p>Returns the total cost for a specific gameweek (1-indexed). If no gameweek is specified, returns the cost of the squad in the last optimized gameweek.</p> Source code in <code>fpl_solver/solver.py</code> <pre><code>def get_total_cost(self, gameweek: int = None) -&gt; float:\n    \"\"\"\n    Returns the total cost for a specific gameweek (1-indexed).\n    If no gameweek is specified, returns the cost of the squad in the last optimized gameweek.\n    \"\"\"\n    if not self.selected_squad_history:\n        return 0\n    first_gw_in_history = min(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n    last_gw_in_history = max(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n\n    if gameweek is None:\n        return self.selected_squad_history[f\"GW{last_gw_in_history}\"][\"total_cost\"]\n\n    if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n        print(\n            f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n        )\n        return 0  # Or raise an error\n\n    return self.selected_squad_history.get(f\"GW{gameweek}\", {}).get(\"total_cost\", 0)\n</code></pre>"},{"location":"autoapi/fpl_solver/#fpl_solver.solver.FPLOptimizer.get_total_expected_points","title":"<code>get_total_expected_points()</code>","text":"<p>Returns the overall total expected points across all optimized gameweeks.</p> Source code in <code>fpl_solver/solver.py</code> <pre><code>def get_total_expected_points(self) -&gt; float:\n    \"\"\"\n    Returns the overall total expected points across all optimized gameweeks.\n    \"\"\"\n    return self.total_expected_points\n</code></pre>"},{"location":"autoapi/fpl_solver/#fpl_solver.solver.FPLOptimizer.print_overall_summary","title":"<code>print_overall_summary()</code>","text":"<p>Prints an overall summary of the multi-week optimization results.</p> Source code in <code>fpl_solver/solver.py</code> <pre><code>def print_overall_summary(self):\n    \"\"\"\n    Prints an overall summary of the multi-week optimization results.\n    \"\"\"\n    if not self.selected_squad_history:\n        print(\"No optimization results to summarize.\")\n        return\n\n    print(\"\\n=== Overall Multi-Week FPL Optimization Summary ===\")\n    print(\n        f\"Total Expected Points Across All Gameweeks: {self.total_expected_points:.2f}\"\n    )\n\n    # Get the latest gameweek's cost\n    last_gw_key = max(\n        self.selected_squad_history.keys(), key=lambda k: int(k.replace(\"GW\", \"\"))\n    )\n    print(\n        f\"Squad Cost ({last_gw_key}): \u00a3{self.selected_squad_history[last_gw_key]['total_cost']:.1f}m\"\n    )\n    print(\n        f\"Total Transfer Hits Taken: {self.total_transfer_hits} (-{self.total_transfer_hits * POINTS_PER_HIT} points)\"\n    )\n\n    print(\"\\n--- Chip Usage Across Gameweeks ---\")\n    # Ensure consistent order by sorting gameweek keys\n    sorted_gw_keys = sorted(\n        self.used_chips.keys(), key=lambda k: int(k.replace(\"GW\", \"\"))\n    )\n    for gw_str in sorted_gw_keys:\n        chips = self.used_chips[gw_str]\n        chip_summary = []\n        if chips[\"bench_boost\"]:\n            chip_summary.append(\"Bench Boost\")\n        if chips[\"triple_captain\"]:\n            chip_summary.append(\"Triple Captain\")\n\n        if chip_summary:\n            print(f\"{gw_str}: {', '.join(chip_summary)}\")\n        else:\n            print(f\"{gw_str}: No chips used\")\n\n    print(\"\\n--- Gameweek-by-Gameweek Summary ---\")\n    # Iterate and print basic summary for each gameweek\n    for gw_str in sorted_gw_keys:\n        gw_data = self.selected_squad_history[gw_str]\n        print(f\"\\n--- {gw_str} ---\")\n        print(f\"  Squad Cost: \u00a3{gw_data['total_cost']:.1f}m\")\n        print(\n            f\"  Expected Points (Starting XI): {gw_data['expected_points_from_xi']:.2f}\"\n        )\n        print(\n            f\"  Total GW Points (incl. chips): {gw_data['expected_points_from_xi'] + gw_data['total_bench_boost_points'] + gw_data['total_triple_captain_bonus']:.2f}\"\n        )\n\n        # Display transfer info for this gameweek\n        transfers_in_count = gw_data[\"transfers_in_count\"]\n        transfers_out_count = gw_data[\"transfers_out_count\"]\n        transfer_hits_taken = gw_data[\"transfer_hits\"]\n        free_transfers_available_next_gw = gw_data[\n            \"free_transfers_available_next_gw\"\n        ]\n\n        print(\n            f\"  Transfers In: {transfers_in_count}, Transfers Out: {transfers_out_count}\"\n        )\n        print(\n            f\"  Transfer Hits: {transfer_hits_taken} (-{transfer_hits_taken * POINTS_PER_HIT} points)\"\n        )\n        # Only show free transfers for the *next* gameweek if it's not the last gameweek in the horizon\n        if int(gw_str.replace(\"GW\", \"\")) &lt; max(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        ):\n            print(\n                f\"  Free Transfers Available for Next GW: {free_transfers_available_next_gw}\"\n            )\n        print(\"-----------------------------------\")\n</code></pre>"},{"location":"autoapi/fpl_solver/#fpl_solver.solver.FPLOptimizer.print_squad_summary","title":"<code>print_squad_summary(gameweek)</code>","text":"<p>Prints a formatted summary of the selected squad for a specific gameweek.</p> Source code in <code>fpl_solver/solver.py</code> <pre><code>def print_squad_summary(self, gameweek: int):\n    \"\"\"\n    Prints a formatted summary of the selected squad for a specific gameweek.\n    \"\"\"\n    if not self.selected_squad_history:\n        print(\"No squad has been selected yet. Run the 'solve' method first.\")\n        return\n\n    gw_data = self.get_gameweek_summary(gameweek)\n    if not gw_data:\n        return  # get_gameweek_summary already prints error message\n\n    selected_squad = gw_data[\"squad\"]\n    total_cost = gw_data[\"total_cost\"]\n    expected_points_from_xi = gw_data[\"expected_points_from_xi\"]\n    bench_boost_used = gw_data[\"bench_boost_used\"]\n    triple_captain_used = gw_data[\"triple_captain_used\"]\n    total_bench_boost_points = gw_data[\"total_bench_boost_points\"]\n    total_triple_captain_bonus = gw_data[\"total_triple_captain_bonus\"]\n    transfers_in_count = gw_data[\"transfers_in_count\"]  # New\n    transfers_out_count = gw_data[\"transfers_out_count\"]  # New\n    transfer_hits_taken = gw_data[\"transfer_hits\"]  # New\n    free_transfers_available_next_gw = gw_data[\n        \"free_transfers_available_next_gw\"\n    ]  # New\n\n    print(f\"\\n--- FPL Optimized Squad for Gameweek {gameweek} ---\")\n    print(f\"Squad Cost: \u00a3{total_cost:.1f}m\")\n    print(f\"Expected Points (Starting XI): {expected_points_from_xi:.2f}\")\n    print(\n        f\"Total Expected Points for GW{gameweek} (including chips): {expected_points_from_xi + total_bench_boost_points + total_triple_captain_bonus:.2f}\"\n    )\n    print(\"\\n--- Chips Used This Gameweek ---\")\n    if bench_boost_used:\n        print(f\"- Bench Boost (Added {total_bench_boost_points:.2f} points)\")\n    if triple_captain_used:\n        print(\n            f\"- Triple Captain (Added {total_triple_captain_bonus:.2f} bonus points)\"\n        )\n    if not (bench_boost_used or triple_captain_used):\n        print(\"No chips used this gameweek.\")\n\n    print(\"\\n--- Goalkeepers (Starting XI marked with *) ---\")\n    for index, row in selected_squad[selected_squad[\"position\"] == \"GK\"].iterrows():\n        starter_str = \"*\" if row[\"is_starter\"] else \"\"\n        captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n        transfer_status = \"\"\n        if row[\"transfer_in\"]:\n            transfer_status = \"(IN)\"\n        elif row[\"transfer_out\"]:\n            transfer_status = \"(OUT)\"\n\n        # Access gameweek-specific xP correctly\n        player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n        print(\n            f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n        )\n    print(\"\\n--- Defenders (Starting XI marked with *) ---\")\n    for index, row in selected_squad[\n        selected_squad[\"position\"] == \"DEF\"\n    ].iterrows():\n        starter_str = \"*\" if row[\"is_starter\"] else \"\"\n        captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n        transfer_status = \"\"\n        if row[\"transfer_in\"]:\n            transfer_status = \"(IN)\"\n        elif row[\"transfer_out\"]:\n            transfer_status = \"(OUT)\"\n\n        player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n        print(\n            f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n        )\n    print(\"\\n--- Midfielders (Starting XI marked with *) ---\")\n    for index, row in selected_squad[\n        selected_squad[\"position\"] == \"MID\"\n    ].iterrows():\n        starter_str = \"*\" if row[\"is_starter\"] else \"\"\n        captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n        transfer_status = \"\"\n        if row[\"transfer_in\"]:\n            transfer_status = \"(IN)\"\n        elif row[\"transfer_out\"]:\n            transfer_status = \"(OUT)\"\n\n        player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n        print(\n            f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n        )\n    print(\"\\n--- Forwards (Starting XI marked with *) ---\")\n    for index, row in selected_squad[\n        selected_squad[\"position\"] == \"FWD\"\n    ].iterrows():\n        starter_str = \"*\" if row[\"is_starter\"] else \"\"\n        captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n        transfer_status = \"\"\n        if row[\"transfer_in\"]:\n            transfer_status = \"(IN)\"\n        elif row[\"transfer_out\"]:\n            transfer_status = \"(OUT)\"\n\n        player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n        print(\n            f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n        )\n\n    print(f\"\\n--- Team Breakdown for GW{gameweek} ---\")\n    print(selected_squad[\"team\"].value_counts())\n\n    # Transfers are relevant from Gameweek 2 (index 1) onwards in the optimization horizon\n    # For display, if the current GW is the initial one (GW1 in the current context), no transfers are made\n    # If it's a subsequent GW, check if transfers occurred.\n    first_gw_in_history = min(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n    if (\n        gameweek &gt;= first_gw_in_history\n    ):  # Changed from &gt; to &gt;=, to show initial free transfers\n        # Display transfer info for this gameweek\n        print(\n            f\"  Transfers In: {transfers_in_count}, Transfers Out: {transfers_out_count}\"\n        )\n        print(\n            f\"  Transfer Hits: {transfer_hits_taken} (-{transfer_hits_taken * POINTS_PER_HIT} points)\"\n        )\n        # Only show free transfers for the *next* gameweek if it's not the last gameweek in the horizon\n        if gameweek &lt; max(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        ):\n            print(\n                f\"  Free Transfers Available for Next GW: {free_transfers_available_next_gw}\"\n            )\n    print(\"---------------------------\\n\")\n</code></pre>"},{"location":"autoapi/fpl_solver/#fpl_solver.solver.FPLOptimizer.solve","title":"<code>solve(budget, max_players_per_team, chip_allowances, num_gameweeks)</code>","text":"<p>Solves the FPL optimization problem using PuLP.</p> <p>Parameters:</p> Name Type Description Default <code>budget</code> <code>float</code> <p>The maximum budget in millions of pounds.</p> required <code>max_players_per_team</code> <code>int</code> <p>The maximum number of players allowed from                         any single Premier League team.</p> required <code>chip_allowances</code> <code>dict</code> <p>A dictionary specifying the maximum usage for each chip.</p> required <code>num_gameweeks</code> <code>int</code> <p>The number of gameweeks to optimize over.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if a solution was found, False otherwise.</p> Source code in <code>fpl_solver/solver.py</code> <pre><code>def solve(\n    self,\n    budget: float,\n    max_players_per_team: int,\n    chip_allowances: dict,\n    num_gameweeks: int,\n) -&gt; bool:\n    \"\"\"\n    Solves the FPL optimization problem using PuLP.\n\n    Args:\n        budget (float): The maximum budget in millions of pounds.\n        max_players_per_team (int): The maximum number of players allowed from\n                                    any single Premier League team.\n        chip_allowances (dict): A dictionary specifying the maximum usage for each chip.\n        num_gameweeks (int): The number of gameweeks to optimize over.\n\n    Returns:\n        bool: True if a solution was found, False otherwise.\n    \"\"\"\n    self.problem = LpProblem(\"FPL Squad Multi-Week Optimization\", LpMaximize)\n\n    # Decision variables for player selection, indexed by player and gameweek\n    player_vars = LpVariable.dicts(\n        \"Player\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n    )\n    starting_xi_vars = LpVariable.dicts(\n        \"StartingXI\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n    )\n    captain_var = LpVariable.dicts(\n        \"Captain\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n    )\n\n    # Binary variables for chip usage, indexed by gameweek\n    use_bench_boost = LpVariable.dicts(\n        \"Use_Bench_Boost\", range(num_gameweeks), 0, 1, LpBinary\n    )\n    use_triple_captain = LpVariable.dicts(\n        \"Use_Triple_Captain\", range(num_gameweeks), 0, 1, LpBinary\n    )\n\n    # Transfer variables\n    transfer_in_vars = LpVariable.dicts(\n        \"Transfer_In\",\n        (self.player_data.index, range(1, num_gameweeks)),\n        0,\n        1,\n        LpBinary,\n    )\n    transfer_out_vars = LpVariable.dicts(\n        \"Transfer_Out\",\n        (self.player_data.index, range(1, num_gameweeks)),\n        0,\n        1,\n        LpBinary,\n    )\n\n    # Total transfers made in a gameweek (absolute count)\n    transfers_made = LpVariable.dicts(\n        \"Transfers_Made\", range(1, num_gameweeks), 0, None, LpInteger\n    )\n    # Free transfers available at the start of a gameweek\n    free_transfers_available = LpVariable.dicts(\n        \"Free_Transfers_Available\",\n        range(num_gameweeks),\n        0,\n        MAX_FREE_TRANSFERS_SAVED + 1,\n        LpInteger,\n    )\n    # Number of transfer hits taken in a gameweek\n    transfer_hits = LpVariable.dicts(\n        \"Transfer_Hits\", range(1, num_gameweeks), 0, None, LpInteger\n    )\n\n    # Auxiliary variables for linearizing chip effects\n    is_bench_player = LpVariable.dicts(\n        \"Is_Bench_Player\",\n        (self.player_data.index, range(num_gameweeks)),\n        0,\n        1,\n        LpBinary,\n    )\n    actual_bench_boost_points = LpVariable.dicts(\n        \"Actual_Bench_Boost_Points\",\n        (self.player_data.index, range(num_gameweeks)),\n        0,\n        None,\n        LpContinuous,\n    )\n    actual_triple_captain_bonus = LpVariable.dicts(\n        \"Actual_Triple_Captain_Bonus\",\n        (self.player_data.index, range(num_gameweeks)),\n        0,\n        None,\n        LpContinuous,\n    )\n\n    # --- Objective Function ---\n    total_objective_points = []\n\n    # Get the first gameweek number from the player data to correctly index expected_points_by_gw\n    first_gw_key = next(\n        iter(\n            self.player_data.loc[\n                self.player_data.index[0], \"expected_points_by_gw\"\n            ].keys()\n        )\n    )\n    current_gameweek_number_start = int(first_gw_key)\n\n    for w in range(num_gameweeks):\n        # The actual gameweek number (1-indexed)\n        gw_actual = current_gameweek_number_start + w\n\n        # Base expected points from the selected starting 11 for this gameweek\n        base_points_expression_gw = lpSum(\n            self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n            * starting_xi_vars[i][w]\n            for i in self.player_data.index\n        )\n        total_objective_points.append(base_points_expression_gw)\n\n        # Regular Captaincy points (additional 1x for captain)\n        captain_points_bonus_gw = lpSum(\n            self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n            * captain_var[i][w]\n            for i in self.player_data.index\n        )\n        total_objective_points.append(captain_points_bonus_gw)\n\n        # Define auxiliary variables and constraints for chips for each gameweek\n        for i in self.player_data.index:\n            # Use gameweek-specific player xP for chip calculations\n            player_xp = self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n\n            # Bench Boost auxiliary variables and constraints\n            self.problem += (\n                is_bench_player[i][w] &lt;= player_vars[i][w],\n                f\"IsBench_Squad_{i}_{w}\",\n            )\n            self.problem += (\n                is_bench_player[i][w] &lt;= 1 - starting_xi_vars[i][w],\n                f\"IsBench_NotStarter_{i}_{w}\",\n            )\n            self.problem += (\n                is_bench_player[i][w]\n                &gt;= player_vars[i][w] + (1 - starting_xi_vars[i][w]) - 1,\n                f\"IsBench_Logical_{i}_{w}\",\n            )\n\n            self.problem += (\n                actual_bench_boost_points[i][w]\n                &lt;= player_xp * is_bench_player[i][w],\n                f\"BenchBoost_Contr_1_{i}_{w}\",\n            )\n            self.problem += (\n                actual_bench_boost_points[i][w] &lt;= player_xp * use_bench_boost[w],\n                f\"BenchBoost_Contr_2_{i}_{w}\",\n            )\n            self.problem += (\n                actual_bench_boost_points[i][w]\n                &gt;= player_xp * (is_bench_player[i][w] + use_bench_boost[w] - 1),\n                f\"BenchBoost_Contr_3_{i}_{w}\",\n            )\n            self.problem += (\n                actual_bench_boost_points[i][w] &gt;= 0,\n                f\"BenchBoost_Contr_4_{i}_{w}\",\n            )\n\n            # Triple Captain auxiliary variables and constraints\n            # Changed player_xp * 2 to player_xp to reflect additional 1x bonus\n            self.problem += (\n                actual_triple_captain_bonus[i][w] &lt;= player_xp * captain_var[i][w],\n                f\"TripleCaptain_Contr_1_{i}_{w}\",\n            )\n            self.problem += (\n                actual_triple_captain_bonus[i][w]\n                &lt;= player_xp * use_triple_captain[w],\n                f\"TripleCaptain_Contr_2_{i}_{w}\",\n            )\n            self.problem += (\n                actual_triple_captain_bonus[i][w]\n                &gt;= player_xp * (captain_var[i][w] + use_triple_captain[w] - 1),\n                f\"TripleCaptain_Contr_3_{i}_{w}\",\n            )\n            self.problem += (\n                actual_triple_captain_bonus[i][w] &gt;= 0,\n                f\"TripleCaptain_Contr_4_{i}_{w}\",\n            )\n\n        # Add points from bench boost and triple captain bonus for this gameweek\n        total_bench_boost_points_gw = lpSum(\n            actual_bench_boost_points[i][w] for i in self.player_data.index\n        )\n        total_triple_captain_bonus_points_gw = lpSum(\n            actual_triple_captain_bonus[i][w] for i in self.player_data.index\n        )\n\n        total_objective_points.append(total_bench_boost_points_gw)\n        total_objective_points.append(total_triple_captain_bonus_points_gw)\n\n    # Subtract transfer hits from the total objective\n    total_objective_points.append(\n        -POINTS_PER_HIT * lpSum(transfer_hits[w] for w in range(1, num_gameweeks))\n    )\n\n    self.problem += (\n        lpSum(total_objective_points),\n        \"Total Expected Points Over Gameweeks\",\n    )\n\n    # --- Constraints ---\n\n    # Apply constraints for each gameweek\n    for w in range(num_gameweeks):\n        # 1. Select exactly 15 players for the squad\n        self.problem += (\n            lpSum(player_vars[i][w] for i in self.player_data.index) == 15,\n            f\"Total_Players_GW{w}\",\n        )\n\n        # 2. Squad position constraints (2 GKs, 5 DEFs, 5 MIDs, 3 FWDs)\n        gks = self.player_data[self.player_data[\"position\"] == \"GK\"].index\n        defs = self.player_data[self.player_data[\"position\"] == \"DEF\"].index\n        mids = self.player_data[self.player_data[\"position\"] == \"MID\"].index\n        fwds = self.player_data[self.player_data[\"position\"] == \"FWD\"].index\n\n        self.problem += (\n            lpSum(player_vars[i][w] for i in gks) == 2,\n            f\"Goalkeepers_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(player_vars[i][w] for i in defs) == 5,\n            f\"Defenders_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(player_vars[i][w] for i in mids) == 5,\n            f\"Midfielders_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(player_vars[i][w] for i in fwds) == 3,\n            f\"Forwards_Count_GW{w}\",\n        )\n\n        # 3. Budget constraint\n        # This applies to the cost of the squad for the current gameweek.\n        self.problem += (\n            lpSum(\n                self.player_data.loc[i, \"cost\"] * player_vars[i][w]\n                for i in self.player_data.index\n            )\n            &lt;= budget,\n            f\"Total_Budget_GW{w}\",\n        )\n\n        # 4. Maximum players per team constraint\n        for team in self.player_data[\"team\"].unique():\n            team_players = self.player_data[self.player_data[\"team\"] == team].index\n            self.problem += (\n                lpSum(player_vars[i][w] for i in team_players)\n                &lt;= max_players_per_team,\n                f\"Max_Players_from_{team}_GW{w}\",\n            )\n\n        # 5. Starting XI constraints\n        # 5.1 Select exactly 11 players for the starting XI\n        self.problem += (\n            lpSum(starting_xi_vars[i][w] for i in self.player_data.index) == 11,\n            f\"Total_Starting_XI_Players_GW{w}\",\n        )\n\n        # 5.2 A player can only be in the starting XI if they are in the squad\n        for i in self.player_data.index:\n            self.problem += (\n                starting_xi_vars[i][w] &lt;= player_vars[i][w],\n                f\"StartingXI_in_Squad_{i}_{w}\",\n            )\n\n        # 5.3 Starting XI position constraints (FPL allows flexible formations, so use minimums)\n        self.problem += (\n            lpSum(starting_xi_vars[i][w] for i in gks) == 1,\n            f\"Starting_Goalkeepers_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(starting_xi_vars[i][w] for i in defs) &gt;= 3,\n            f\"Min_Starting_Defenders_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(starting_xi_vars[i][w] for i in mids) &gt;= 2,\n            f\"Min_Starting_Midfielders_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(starting_xi_vars[i][w] for i in fwds) &gt;= 1,\n            f\"Min_Starting_Forwards_Count_GW{w}\",\n        )\n\n        # 6. Captain Constraints\n        # 6.1 Select exactly one captain from the starting XI\n        self.problem += (\n            lpSum(captain_var[i][w] for i in self.player_data.index) == 1,\n            f\"One_Captain_GW{w}\",\n        )\n\n        # 6.2 A player can only be captain if they are in the starting XI\n        for i in self.player_data.index:\n            self.problem += (\n                captain_var[i][w] &lt;= starting_xi_vars[i][w],\n                f\"Captain_in_StartingXI_{i}_{w}\",\n            )\n\n        # --- Enforced Player Constraints---\n        for player_idx in self.enforced_player_indices:\n            self.problem += (\n                player_vars[player_idx][w] == 1,\n                f\"Enforce_Player_{self.player_data.loc[player_idx, 'name']}_GW{w}\",\n            )\n\n        for team, position in self.enforced_team_pos_requirements:\n            # Filter players for the current team and position\n            team_pos_players = self.player_data[\n                (self.player_data[\"team\"] == team)\n                &amp; (self.player_data[\"position\"] == position)\n            ].index\n            if not team_pos_players.empty:\n                self.problem += (\n                    lpSum(player_vars[i][w] for i in team_pos_players) &gt;= 1,\n                    f\"Enforce_One_{position}_from_{team}_GW{w}\",\n                )\n            else:\n                print(\n                    f\"Warning: No players found for enforced requirement: at least one {position} from {team} for GW{gw_actual}.\"\n                )\n\n    # --- Chip Usage Constraints (TOTAL usage over all gameweeks) ---\n    # These constraints should be outside the per-gameweek loop to avoid duplicates.\n    self.problem += (\n        lpSum(use_bench_boost[j] for j in range(num_gameweeks))\n        &lt;= chip_allowances.get(\"bench_boost\", 0),\n        f\"Max_Bench_Boost_Usage_Total\",\n    )\n    self.problem += (\n        lpSum(use_triple_captain[j] for j in range(num_gameweeks))\n        &lt;= chip_allowances.get(\"triple_captain\", 0),\n        f\"Max_Triple_Captain_Usage_Total\",\n    )\n\n    # --- Inter-Gameweek Constraints (Transfers and Transfer Rules) ---\n    # Initialize free transfers for GW0 (first gameweek of optimization horizon)\n    # This assumes the optimization starts at GW0, and it has INITIAL_FREE_TRANSFERS.\n    # If the model starts at an arbitrary GW, this would need to be an input.\n    self.problem += (\n        free_transfers_available[0] == INITIAL_FREE_TRANSFERS,\n        f\"Initial_Free_Transfers_GW0\",\n    )\n\n    for w in range(1, num_gameweeks):\n        # Calculate total transfers made in this gameweek\n        self.problem += (\n            transfers_made[w]\n            == lpSum(transfer_in_vars[i][w] for i in self.player_data.index),\n            f\"Transfers_Made_GW{w}\",\n        )\n        # Total transfers in must equal total transfers out for each gameweek after the first\n        self.problem += (\n            lpSum(transfer_in_vars[i][w] for i in self.player_data.index)\n            == lpSum(transfer_out_vars[i][w] for i in self.player_data.index),\n            f\"Transfers_In_Equals_Out_GW{w}\",\n        )\n\n        # Calculate free transfers available for the current gameweek (w)\n        # Free transfers for GW_w = min(free transfers from GW_w-1 - transfers made in GW_w + 1, MAX_FREE_TRANSFERS_SAVED + 1)\n        # The + 1 in MAX_FREE_TRANSFERS_SAVED + 1 is because MAX_FREE_TRANSFERS_SAVED implies how many can be *saved*,\n        # so if you save 1, you have 1 (current) + 1 (saved) = 2.\n        self.problem += (\n            free_transfers_available[w]\n            &lt;= free_transfers_available[w - 1] - transfers_made[w] + 1,\n            f\"Free_Transfers_Calc_1_GW{w}\",\n        )\n        self.problem += (\n            free_transfers_available[w] &lt;= MAX_FREE_TRANSFERS_SAVED + 1,\n            f\"Free_Transfers_Calc_2_GW{w}\",\n        )\n        self.problem += (\n            free_transfers_available[w] &gt;= 0,  # Cannot have negative free transfers\n            f\"Free_Transfers_Non_Negative_GW{w}\",\n        )\n\n        # Calculate transfer hits\n        # transfer_hits[w] = max(0, transfers_made[w] - free_transfers_available_at_start_of_gw_w)\n        # This needs to be linearized. If transfers_made[w] &gt; free_transfers_available[w-1], then hit.\n        # free_transfers_available[w-1] represents transfers available *before* making transfers for GW_w\n        self.problem += (\n            transfer_hits[w] &gt;= transfers_made[w] - free_transfers_available[w - 1],\n            f\"Transfer_Hits_Calc_1_GW{w}\",\n        )\n        self.problem += (\n            transfer_hits[w] &gt;= 0,\n            f\"Transfer_Hits_Calc_2_GW{w}\",\n        )\n\n        for i in self.player_data.index:\n            # Squad continuity: player_vars[i][w] (in squad at start of GW w)\n            #                 = player_vars[i][w-1] (in squad at start of GW w-1)\n            #                 - transfer_out_vars[i][w] (transferred out for GW w)\n            #                 + transfer_in_vars[i][w] (transferred in for GW w)\n            self.problem += (\n                player_vars[i][w]\n                == player_vars[i][w - 1]\n                - transfer_out_vars[i][w]\n                + transfer_in_vars[i][w],\n                f\"Squad_Continuity_{i}_GW{w}\",\n            )\n            # A player cannot be transferred in and out in the same gameweek\n            self.problem += (\n                transfer_in_vars[i][w] + transfer_out_vars[i][w] &lt;= 1,\n                f\"No_Simultaneous_Transfer_{i}_{w}\",\n            )\n\n    try:\n        # The solver is called with the GLPK_CMD solver\n        self.problem.solve(PULP_CBC_CMD(msg=0))  # msg=0 suppresses verbose output\n    except Exception as e:\n        print(f\"Error solving the problem: {e}\")\n        return False\n\n    if LpStatus[self.problem.status] == \"Optimal\":\n        print(\"Optimization successful! Optimal solution found.\")\n\n        self.selected_squad_history = {}\n        self.total_transfer_hits = 0\n        for w in range(num_gameweeks):\n            # The actual gameweek number (1-indexed)\n            gw_actual = current_gameweek_number_start + w\n\n            # Get selected players for the current gameweek\n            selected_squad_gw = self.player_data[\n                [player_vars[i][w].varValue == 1 for i in self.player_data.index]\n            ].copy()\n\n            # Get starter and captain info for this gameweek\n            is_starter_series_gw = pd.Series(\n                [\n                    starting_xi_vars[i][w].varValue == 1\n                    for i in self.player_data.index\n                ],\n                index=self.player_data.index,\n            )\n            is_captain_series_gw = pd.Series(\n                [captain_var[i][w].varValue == 1 for i in self.player_data.index],\n                index=self.player_data.index,\n            )\n\n            selected_squad_gw[\"is_starter\"] = is_starter_series_gw.loc[\n                selected_squad_gw.index\n            ]\n            selected_squad_gw[\"is_captain\"] = is_captain_series_gw.loc[\n                selected_squad_gw.index\n            ]\n\n            transfers_in_gw = 0\n            transfers_out_gw = 0\n            hits_gw = 0\n\n            # Store transfer details for gameweeks &gt; 0\n            if (\n                w &gt; 0\n            ):  # Check for transfers only from GW1 onwards (index 1 in 0-indexed loop)\n                transfer_in_flags = pd.Series(\n                    [\n                        transfer_in_vars[i][w].varValue == 1\n                        for i in self.player_data.index\n                    ],\n                    index=self.player_data.index,\n                )\n                transfer_out_flags = pd.Series(\n                    [\n                        transfer_out_vars[i][w].varValue == 1\n                        for i in self.player_data.index\n                    ],\n                    index=self.player_data.index,\n                )\n\n                selected_squad_gw[\"transfer_in\"] = transfer_in_flags.loc[\n                    selected_squad_gw.index\n                ]\n                selected_squad_gw[\"transfer_out\"] = transfer_out_flags.loc[\n                    selected_squad_gw.index\n                ]\n\n                transfers_in_gw = int(round(transfer_in_flags.sum()))\n                transfers_out_gw = int(round(transfer_out_flags.sum()))\n                hits_gw = int(round(transfer_hits[w].varValue))\n                self.total_transfer_hits += hits_gw\n            else:\n                selected_squad_gw[\"transfer_in\"] = False  # No transfers in for GW0\n                selected_squad_gw[\"transfer_out\"] = (\n                    False  # No transfers out for GW0\n                )\n\n            self.selected_squad_history[f\"GW{gw_actual}\"] = {\n                \"squad\": selected_squad_gw,\n                \"total_cost\": selected_squad_gw[\"cost\"].sum(),\n                \"expected_points_from_xi\": sum(\n                    self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n                    * starting_xi_vars[i][w].varValue\n                    for i in self.player_data.index\n                ),\n                \"bench_boost_used\": bool(use_bench_boost[w].varValue),\n                \"triple_captain_used\": bool(use_triple_captain[w].varValue),\n                \"total_bench_boost_points\": value(\n                    lpSum(\n                        actual_bench_boost_points[i][w]\n                        for i in self.player_data.index\n                    )\n                ),\n                \"total_triple_captain_bonus\": value(\n                    lpSum(\n                        actual_triple_captain_bonus[i][w]\n                        for i in self.player_data.index\n                    )\n                ),\n                \"transfers_in_count\": transfers_in_gw,\n                \"transfers_out_count\": transfers_out_gw,\n                \"transfer_hits\": hits_gw,  # New\n                \"free_transfers_available_next_gw\": (\n                    int(round(free_transfers_available[w].varValue))\n                    if w &lt; num_gameweeks - 1\n                    else 0\n                ),  # Free transfers available *after* this GW's transfers are made\n            }\n\n        # Overall totals\n        self.total_cost = self.selected_squad_history[\n            f\"GW{current_gameweek_number_start + num_gameweeks - 1}\"\n        ][\n            \"total_cost\"\n        ]  # Cost of final squad\n        self.total_expected_points = value(\n            self.problem.objective\n        )  # Total objective value from solver\n        self.used_chips = {\n            f\"GW{current_gameweek_number_start + w}\": {\n                \"bench_boost\": bool(use_bench_boost[w].varValue),\n                \"triple_captain\": bool(use_triple_captain[w].varValue),\n            }\n            for w in range(num_gameweeks)\n        }\n\n        return True\n    else:\n        print(f\"No optimal solution found. Status: {LpStatus[self.problem.status]}\")\n        self.selected_squad_history = {}\n        self.total_cost = 0\n        self.total_expected_points = 0\n        self.used_chips = {}\n        self.total_transfer_hits = 0\n        return False\n</code></pre>"},{"location":"autoapi/fpl_solver/#fpl_solver.xp_predictor","title":"<code>xp_predictor</code>","text":"<p>FPL Expected Points (xP) Predictor Module.</p> <p>This module provides functionality to predict Fantasy Premier League (FPL) points for players based on historical data, team strengths, and fixture difficulty.</p>"},{"location":"autoapi/fpl_solver/#fpl_solver.xp_predictor.FPLPredictor","title":"<code>FPLPredictor</code>","text":"<p>Predictive algorithm for Expected Points (xP) in Fantasy Premier League, using real data from the FPL API.</p> <p>This class handles: - Fetching and processing FPL API data - Calculating expected points based on multiple factors - Managing player exclusions and filtering - Providing fixture and player data for optimization</p> <p>Attributes:</p> Name Type Description <code>gameweeks_to_predict</code> <code>int</code> <p>Number of future gameweeks to analyze</p> <code>players_data</code> <code>Dict</code> <p>Player statistics and information</p> <code>teams_data</code> <code>Dict</code> <p>Team statistics and attributes</p> <code>fixtures_data</code> <code>Dict</code> <p>Upcoming and historical match data</p> <code>all_players_xp_calculated_data</code> <code>List</code> <p>Processed xP calculations</p> Source code in <code>fpl_solver/xp_predictor.py</code> <pre><code>class FPLPredictor:\n    \"\"\"\n    Predictive algorithm for Expected Points (xP) in Fantasy Premier League,\n    using real data from the FPL API.\n\n    This class handles:\n    - Fetching and processing FPL API data\n    - Calculating expected points based on multiple factors\n    - Managing player exclusions and filtering\n    - Providing fixture and player data for optimization\n\n    Attributes:\n        gameweeks_to_predict (int): Number of future gameweeks to analyze\n        players_data (Dict): Player statistics and information\n        teams_data (Dict): Team statistics and attributes\n        fixtures_data (Dict): Upcoming and historical match data\n        all_players_xp_calculated_data (List): Processed xP calculations\n    \"\"\"\n\n    def __init__(self, gameweeks_to_predict: int = 1):\n        \"\"\"\n        Initialize the FPLPredictor with data structures and fetch initial data.\n\n        Args:\n            gameweeks_to_predict: Number of upcoming gameweeks to calculate\n                                expected points for. Default is 1 (next gameweek).\n\n        Raises:\n            ValueError: If gameweeks_to_predict is not a positive integer\n        \"\"\"\n        self.logger = setup_logger(__name__)\n        if not isinstance(gameweeks_to_predict, int) or gameweeks_to_predict &lt; 1:\n            msg = f\"gameweeks_to_predict must be a positive integer, got {gameweeks_to_predict}\"\n            self.logger.error(msg)\n            raise ValueError(msg)\n\n        self.gameweeks_to_predict = gameweeks_to_predict\n        self.logger.info(f\"Initializing FPL Predictor for {gameweeks_to_predict} gameweek(s)\")\n\n        # Initialize cache manager\n        cache_dir = os.path.join(os.path.dirname(__file__), 'cache')\n        self.cache_manager = CacheManager(cache_dir)\n\n        # Configuration and static data\n        self.fpl_points: Dict[str, float] = FPL_POINTS\n        self.position_definitions: Dict[int, str] = {\n            1: \"GK\",\n            2: \"DEF\",\n            3: \"MID\",\n            4: \"FWD\",\n        }\n\n        # Data structures for FPL information\n        self.players_data: Dict[int, Dict] = {}\n        self.teams_data: Dict[int, Dict] = {}\n        self.fixtures_data: Dict[int, Dict] = {}\n        self.all_players_xp_calculated_data: List[Dict] = []\n\n        # Initialize data\n        try:\n            self._fetch_fpl_data()\n            self._calculate_all_players_xp()\n        except Exception as e:\n            self.logger.error(f\"Failed to initialize FPL Predictor: {str(e)}\")\n            raise\n\n    def _fetch_fpl_data(self) -&gt; None:\n        \"\"\"\n        Fetch and process data from the FPL API.\n\n        This method retrieves player, team, and fixture data from the FPL API,\n        processes it, and stores it in the appropriate data structures. It also\n        applies any configured player exclusions.\n\n        Raises:\n            requests.RequestException: If API requests fail\n            ValueError: If required data is missing from API response\n            Exception: For other unexpected errors\n        \"\"\"\n        self.logger.info(\"Fetching FPL data from API...\")\n\n        try:\n            # Helper function to fetch from API with caching\n            def fetch_api_data(url: str, endpoint: str) -&gt; dict:\n                # Try to get from cache first\n                cached_data = self.cache_manager.get_cached_response(endpoint)\n                if cached_data is not None:\n                    self.logger.info(f\"Using cached {endpoint} data\")\n                    return cached_data\n\n                # If not in cache or expired, fetch from API\n                try:\n                    self.logger.info(f\"Fetching {endpoint} data from API\")\n                    response = requests.get(url, timeout=10)\n                    response.raise_for_status()\n                    data = response.json()\n\n                    # Cache the response\n                    self.cache_manager.save_response(endpoint, data)\n                    return data\n\n                except requests.RequestException as e:\n                    self.logger.error(f\"Failed to fetch {endpoint} data: {str(e)}\")\n                    raise\n\n            # Fetch both endpoints\n            static_data = fetch_api_data(\n                \"https://fantasy.premierleague.com/api/bootstrap-static/\",\n                \"static\"\n            )\n            fixtures_data = fetch_api_data(\n                \"https://fantasy.premierleague.com/api/fixtures/\",\n                \"fixtures\"\n            )\n\n            # Process players data\n            if \"elements\" not in static_data:\n                raise ValueError(\"No player elements found in API response\")\n\n            self.logger.info(f\"Processing {len(static_data['elements'])} players...\")\n\n            def process_player_data(element: Dict) -&gt; Tuple[int, Dict]:\n                \"\"\"Helper function to process individual player data\"\"\"\n                try:\n                    player_id = element[\"id\"]\n                    return player_id, {\n                        \"name\": f\"{element['first_name']} {element['second_name']}\",\n                        \"web_name\": element[\"web_name\"],\n                        \"team_id\": element[\"team\"],\n                        \"element_type\": element[\"element_type\"],\n                        \"position\": self.position_definitions.get(\n                            element[\"element_type\"], \"Unknown\"\n                        ),\n                        \"cost_pence\": element[\"now_cost\"],\n                        \"status\": element[\"status\"],\n                        \"news\": element[\"news\"],\n                        \"total_points\": element[\"total_points\"],\n                        \"minutes\": element[\"minutes\"],\n                        \"goals_scored\": element[\"goals_scored\"],\n                        \"assists\": element[\"assists\"],\n                        \"clean_sheets\": element[\"clean_sheets\"],\n                        \"goals_conceded\": element[\"goals_conceded\"],\n                        \"penalties_saved\": element[\"penalties_saved\"],\n                        \"penalties_missed\": element[\"penalties_missed\"],\n                        \"yellow_cards\": element[\"yellow_cards\"],\n                        \"red_cards\": element[\"red_cards\"],\n                        \"own_goals\": element[\"own_goals\"],\n                        \"saves\": element[\"saves\"],\n                        \"bonus\": element[\"bonus\"],\n                        \"bps\": element[\"bps\"],\n                        \"threat\": float(element.get(\"threat\", 0)),\n                        \"creativity\": float(element.get(\"creativity\", 0)),\n                        \"influence\": float(element.get(\"influence\", 0)),\n                        \"form\": float(element.get(\"form\", 0)),\n                        \"points_per_game\": float(element.get(\"points_per_game\", 0)),\n                        \"value_season\": float(element.get(\"value_season\", 0)),\n                        \"value_form\": float(element.get(\"value_form\", 0)),\n                        \"ict_index\": float(element.get(\"ict_index\", 0)),\n                        \"defensive_contribution\": float(element.get(\"defensive_contribution\", 0)),\n                    }\n                except KeyError as e:\n                    self.logger.warning(f\"Missing required field for player: {str(e)}\")\n                    return None\n                except ValueError as e:\n                    self.logger.warning(f\"Invalid numeric value for player {element.get('id')}: {str(e)}\")\n                    return None\n\n            # Process all players with error handling\n            for element in static_data[\"elements\"]:\n                result = process_player_data(element)\n                if result:\n                    player_id, player_data = result\n                    self.players_data[player_id] = player_data\n\n            # Apply Player Exclusions\n            def apply_player_exclusions() -&gt; Dict[int, Dict]:\n                \"\"\"Apply configured player exclusions and return filtered player data\"\"\"\n                initial_count = len(self.players_data)\n                players_to_keep = {}\n\n                for player_id, player_info in self.players_data.items():\n                    # Track exclusion reason if player is excluded\n                    exclusion_reason = None\n\n                    # Check ID exclusions\n                    if player_id in EXCLUDED_PLAYERS_BY_ID:\n                        exclusion_reason = f\"ID exclusion: {player_id}\"\n\n                    # Check name exclusions\n                    elif player_info[\"name\"] in EXCLUDED_PLAYERS_BY_NAME:\n                        exclusion_reason = f\"Name exclusion: {player_info['name']}\"\n\n                    # Check team/position exclusions\n                    else:\n                        team_name = self.teams_data.get(player_info[\"team_id\"], {}).get(\"name\")\n                        for rule in EXCLUDED_PLAYERS_BY_TEAM_AND_POSITION:\n                            if (team_name == rule.get(\"team\") and \n                                player_info[\"position\"] == rule.get(\"position\")):\n                                exclusion_reason = f\"Team/Position exclusion: {team_name}/{player_info['position']}\"\n                                break\n\n                    # Log exclusion or keep player\n                    if exclusion_reason:\n                        self.logger.info(\n                            f\"Excluding player {player_info['name']} - {exclusion_reason}\"\n                        )\n                    else:\n                        players_to_keep[player_id] = player_info\n\n                filtered_count = len(players_to_keep)\n                self.logger.info(\n                    f\"Player filtering complete. {initial_count - filtered_count} \"\n                    f\"players excluded. {filtered_count} players remaining.\"\n                )\n                return players_to_keep\n\n            self.players_data = apply_player_exclusions()\n\n            # Process teams data\n            if \"teams\" not in static_data:\n                raise ValueError(\"No team data found in API response\")\n\n            self.logger.info(f\"Processing {len(static_data['teams'])} teams...\")\n\n            def process_team_data(team: Dict) -&gt; Tuple[int, Dict]:\n                \"\"\"Helper function to process individual team data\"\"\"\n                try:\n                    return team[\"id\"], {\n                        \"name\": team[\"name\"],\n                        \"short_name\": team[\"short_name\"],\n                        \"strength\": team[\"strength\"],\n                        \"strength_overall_home\": team[\"strength_overall_home\"],\n                        \"strength_overall_away\": team[\"strength_overall_away\"],\n                        \"strength_attack_home\": team[\"strength_attack_home\"],\n                        \"strength_attack_away\": team[\"strength_attack_away\"],\n                        \"strength_defence_home\": team[\"strength_defence_home\"],\n                        \"strength_defence_away\": team[\"strength_defence_away\"],\n                    }\n                except KeyError as e:\n                    self.logger.warning(f\"Missing required field for team: {str(e)}\")\n                    return None\n\n            # Process all teams with error handling\n            for team in static_data[\"teams\"]:\n                result = process_team_data(team)\n                if result:\n                    team_id, team_data = result\n                    self.teams_data[team_id] = team_data\n\n            # Process fixtures data\n            self.logger.info(f\"Processing {len(fixtures_data)} fixtures...\")\n\n            def process_fixture_data(fixture: Dict) -&gt; Tuple[int, Dict]:\n                \"\"\"Helper function to process individual fixture data\"\"\"\n                try:\n                    fixture_id = fixture[\"id\"]\n                    # Validate required fields\n                    required_fields = [\"team_h\", \"team_a\", \"event\", \"finished\"]\n                    if not all(field in fixture for field in required_fields):\n                        missing = [f for f in required_fields if f not in fixture]\n                        raise KeyError(f\"Missing required fields: {', '.join(missing)}\")\n                    return fixture_id, fixture\n                except KeyError as e:\n                    self.logger.warning(f\"Invalid fixture data: {str(e)}\")\n                    return None\n\n            # Process all fixtures with error handling\n            for fixture in fixtures_data:\n                result = process_fixture_data(fixture)\n                if result:\n                    fixture_id, fixture_data = result\n                    self.fixtures_data[fixture_id] = fixture_data\n\n            self.logger.info(\"FPL data fetched and processed successfully.\")\n\n        except requests.exceptions.RequestException as e:\n            self.logger.error(f\"Failed to fetch FPL data: {str(e)}\")\n            self._reset_data_structures()\n            raise\n        except ValueError as e:\n            self.logger.error(f\"Invalid data received from FPL API: {str(e)}\")\n            self._reset_data_structures()\n            raise\n        except Exception as e:\n            self.logger.error(f\"Unexpected error during data processing: {str(e)}\")\n            self._reset_data_structures()\n            raise\n\n    def _reset_data_structures(self) -&gt; None:\n        \"\"\"Reset all data structures to empty state\"\"\"\n        self.players_data = {}\n        self.teams_data = {}\n        self.fixtures_data = {}\n\n    def _get_team_strength(self, team_id, is_home):\n        \"\"\"Get team strength based on home/away status.\"\"\"\n        team = self.teams_data.get(team_id, {})\n        if is_home:\n            return team.get(\"strength_overall_home\", 1000)  # Default if not found\n        return team.get(\"strength_overall_away\", 1000)  # Default if not found\n\n    def _predict_minutes(self, player_id):\n        \"\"\"\n        Predicts expected minutes for a player based on historical data.\n        More sophisticated logic for handling very low minute players.\n        \"\"\"\n        player = self.players_data.get(player_id)\n        if not player:\n            return 0.0\n\n        status = player[\"status\"]\n        news = player[\"news\"].lower()\n        minutes_played = player[\"minutes\"]\n\n        # 1. Unavailable players (injured, suspended, doubtful)\n        if status != \"a\" or any(\n            x in news\n            for x in [\n                \"injured\",\n                \"doubtful\",\n                \"suspension\",\n                \"red card\",\n                \"expected back\",\n            ]\n        ):\n            return 0.0\n\n        # 2. Players with significant minutes (starters/key rotation)\n        if minutes_played &gt;= MIN_MINUTES_THRESHOLD:\n            # Average minutes per game started (assuming most minutes come from starts)\n            # This is a heuristic; real FPL API doesn't give starts directly.\n            # We assume a player with &gt; MIN_MINUTES_THRESHOLD plays ~80-90 minutes when on pitch.\n            # So, (minutes_played / number_of_appearances) is a rough proxy.\n            # For simplicity, let's use a cap of 90 minutes.\n            if player[\"total_points\"] &gt; 0:  # Player has played at least one game\n                avg_minutes_per_appearance = minutes_played / (\n                    player[\"total_points\"] / player[\"points_per_game\"]\n                )\n                return min(avg_minutes_per_appearance, 90.0)\n            return 70.0  # Reasonable default for established player with points but no clear avg\n\n        # 3. Players with very low minutes (rarely play, new, youth)\n        if minutes_played &lt; VERY_LOW_MINUTES_THRESHOLD:\n            # If news suggests they might get a chance, assign default sub minutes.\n            # Otherwise, very low expected minutes or zero.\n            if any(x in news for x in [\"return imminent\", \"close to return\"]):\n                return DEFAULT_SUB_MINUTES  # Might get some minutes\n            return DEFAULT_UNKNOWN_PLAYER_MINUTES  # Very unlikely to play significant minutes\n\n        # 4. Players with some minutes but below significant threshold (regular subs)\n        return DEFAULT_SUB_MINUTES\n\n    def _calculate_expected_goals(self, team_attack_strength, opp_defence_strength):\n        \"\"\"\n        Calculates expected goals for a team based on its attack strength and\n        opponent's defensive strength. This is a simplified heuristic.\n        \"\"\"\n        # A simple ratio model: Higher attack strength and lower opponent defense means more goals\n        # Normalization factor can be adjusted based on average league goals\n        expected_goals = (\n            team_attack_strength / opp_defence_strength\n        ) * 1.5  # 1.5 is an arbitrary scaling factor\n        return max(0.0, expected_goals)\n\n    def _calculate_expected_conceded_goals(\n        self, team_defence_strength, opp_attack_strength\n    ):\n        \"\"\"\n        Calculates expected goals conceded by a team based on its defense strength\n        and opponent's attacking strength.\n        \"\"\"\n        # A simple ratio model: Higher opponent attack and lower team defense means more conceded goals\n        expected_conceded_goals = (\n            opp_attack_strength / team_defence_strength\n        ) * 1.5  # 1.5 is an arbitrary scaling factor\n        return max(0.0, expected_conceded_goals)\n\n    def calculate_xp_for_player(self, player_id, fixture_id):\n        \"\"\"\n        Calculates Expected Points (xP) for a single player in a given fixture.\n        Considers various factors: minutes, goals, assists, clean sheets, saves,\n        bonus points, and negative events, adjusted for fixture difficulty.\n        \"\"\"\n        player = self.players_data.get(player_id)\n        fixture = self.fixtures_data.get(fixture_id)\n\n        if not player or not fixture:\n            return {\"xp\": 0.0, \"reason\": \"Player or fixture data missing.\"}\n\n        # Handle unavailable players\n        if (\n            player[\"status\"] != \"a\"\n        ):  # 'd' for doubtful, 'i' for injured, 's' for suspended\n            return {\"xp\": 0.0, \"reason\": f\"Player status: {player['status']}\"}\n        if any(\n            x in player[\"news\"].lower()\n            for x in [\"injured\", \"doubtful\", \"suspension\", \"red card\"]\n        ):\n            return {\"xp\": 0.0, \"reason\": f\"Player news: {player['news']}\"}\n\n        # Predict minutes\n        expected_minutes = self._predict_minutes(player_id)\n        if expected_minutes &lt; 1.0:  # If expected to play very little or none\n            return {\"xp\": 0.0, \"reason\": \"Expected minutes too low.\"}\n\n        xp = 0.0\n        position = player[\"position\"]\n        # Use 'team_h' for home team ID\n        is_home_fixture = player[\"team_id\"] == fixture[\"team_h\"]\n\n        # Determine attacking and defensive strengths for the fixture\n        player_team_strength_attack = (\n            self.teams_data.get(fixture[\"team_h\"], {}).get(\n                \"strength_attack_home\"\n            )  # Use 'team_h'\n            if is_home_fixture\n            else self.teams_data.get(fixture[\"team_a\"], {}).get(\n                \"strength_attack_away\"\n            )  # Use 'team_a'\n        )\n        player_team_strength_defence = (\n            self.teams_data.get(fixture[\"team_h\"], {}).get(\n                \"strength_defence_home\"\n            )  # Use 'team_h'\n            if is_home_fixture\n            else self.teams_data.get(fixture[\"team_a\"], {}).get(\n                \"strength_defence_away\"\n            )  # Use 'team_a'\n        )\n        opponent_team_strength_attack = (\n            self.teams_data.get(fixture[\"team_a\"], {}).get(\n                \"strength_attack_away\"\n            )  # Use 'team_a'\n            if is_home_fixture\n            else self.teams_data.get(fixture[\"team_h\"], {}).get(\n                \"strength_attack_home\"\n            )  # Use 'team_h'\n        )\n        opponent_team_strength_defence = (\n            self.teams_data.get(fixture[\"team_a\"], {}).get(\n                \"strength_defence_away\"\n            )  # Use 'team_a'\n            if is_home_fixture\n            else self.teams_data.get(fixture[\"team_h\"], {}).get(\n                \"strength_defence_home\"\n            )  # Use 'team_h'\n        )\n\n        if None in [\n            player_team_strength_attack,\n            player_team_strength_defence,\n            opponent_team_strength_attack,\n            opponent_team_strength_defence,\n        ]:\n            # Fallback if strength data is missing (shouldn't happen with robust data fetch)\n            return {\"xp\": 0.0, \"reason\": \"Team strength data missing for fixture.\"}\n\n        # Apply confidence factor based on historical minutes\n        minutes_played = player.get(\"minutes\", 0)\n        confidence_factor = XP_CONFIDENCE_FACTORS[\"proven\"]  # Default to proven player\n        if minutes_played &lt; VERY_LOW_MINUTES_THRESHOLD:\n            confidence_factor = XP_CONFIDENCE_FACTORS[\"very_low_minutes\"]\n        elif minutes_played &lt; MIN_MINUTES_THRESHOLD:\n            confidence_factor = XP_CONFIDENCE_FACTORS[\"low_minutes\"]\n\n        # 1. Appearance points\n        if expected_minutes &gt;= 60:\n            xp += self.fpl_points[\"appearance_points_gte_60\"]\n        elif expected_minutes &gt; 0:\n            xp += self.fpl_points[\"appearance_points_lt_60\"]\n\n        # 2. Expected Goals (scaled by historical goals per 90 and opponent difficulty)\n        # Use player's form and total goals as a basis\n        goals_per_90_hist = (\n            (player[\"goals_scored\"] / player[\"minutes\"] * 90)\n            if player[\"minutes\"] &gt; 0\n            else 0.0\n        )\n        expected_team_goals = self._calculate_expected_goals(\n            player_team_strength_attack, opponent_team_strength_defence\n        )\n\n        expected_goals_player_contribution = (\n            (goals_per_90_hist / 90.0) * expected_minutes * (expected_team_goals / 1.5)\n        )  # Scale player's goal contribution by team's expected goals\n\n        if position == \"GK\":\n            xp += expected_goals_player_contribution * self.fpl_points[\"goal_gk\"]\n        elif position == \"DEF\":\n            xp += expected_goals_player_contribution * self.fpl_points[\"goal_def\"]\n        elif position == \"MID\":\n            xp += expected_goals_player_contribution * self.fpl_points[\"goal_mid\"]\n        elif position == \"FWD\":\n            xp += expected_goals_player_contribution * self.fpl_points[\"goal_fwd\"]\n\n        # 3. Expected Assists (scaled by historical assists per 90 and opponent difficulty)\n        assists_per_90_hist = (\n            (player[\"assists\"] / player[\"minutes\"] * 90)\n            if player[\"minutes\"] &gt; 0\n            else 0.0\n        )\n        # Assuming team's attacking strength correlates with assist opportunities\n        expected_assists_player_contribution = (\n            (assists_per_90_hist / 90.0)\n            * expected_minutes\n            * (expected_team_goals / 1.5)\n        )  # Similarly scale by team's expected goals\n        xp += expected_assists_player_contribution * self.fpl_points[\"assist_points\"]\n\n        # 4. Expected Clean Sheets (for GKs/DEFs/MIDs) and Conceded Goals deduction\n        expected_conceded = self._calculate_expected_conceded_goals(\n            player_team_strength_defence, opponent_team_strength_attack\n        )\n\n        # Probability of clean sheet\n        # Simplified: higher team defense / lower opponent attack -&gt; higher CS prob\n        # Use logistic or sigmoid for probability\n        cs_prob = 1.0 / (\n            1.0 + math.exp(expected_conceded - 1.0)\n        )  # Sigmoid centered at 1 goal\n\n        if position in [\"GK\", \"DEF\"]:\n            xp += cs_prob * self.fpl_points[\"clean_sheet_gk_def\"]\n\n            # Conceded goals deduction: Apply penalty for every 2 goals conceded *probability*\n            # For simplicity, calculate expected deduction: (expected_conceded / 2) * deduction\n            xp += (expected_conceded / 2.0) * self.fpl_points[\n                \"conceded_2_goals_deduction\"\n            ]\n        elif position == \"MID\":\n            xp += cs_prob * self.fpl_points[\"clean_sheet_mid\"]\n\n        # 5. Expected Saves (for GKs)\n        if position == \"GK\":\n            saves_per_90_hist = (\n                (player[\"saves\"] / player[\"minutes\"] * 90)\n                if player[\"minutes\"] &gt; 0\n                else 0.0\n            )\n            # Expected saves scaled by opponent's attacking strength (more attacking -&gt; more shots -&gt; more saves)\n            expected_saves_player_contribution = (\n                (saves_per_90_hist / 90.0)\n                * expected_minutes\n                * (opponent_team_strength_attack / player_team_strength_defence)\n            )\n            xp += (expected_saves_player_contribution / 3.0) * self.fpl_points[\n                \"saves_3_points\"\n            ]  # Using the new config point value\n\n            # Penalty saves (low probability, use historical rate)\n            penalty_saves_hist_per_game = (\n                player[\"penalties_saved\"] / (player[\"minutes\"] / 90.0)\n                if player[\"minutes\"] &gt; 0\n                else 0.0\n            )\n            xp += (\n                penalty_saves_hist_per_game\n                * (expected_minutes / 90.0)\n                * self.fpl_points[\"penalty_save_points\"]\n            )\n\n        # 6. Expected Bonus Points\n        # Use BPS (Bonus Points System) as a proxy. Scale player's average BPS by form and expected minutes.\n        bps_per_90_hist = (\n            (player[\"bps\"] / player[\"minutes\"] * 90) if player[\"minutes\"] &gt; 0 else 0.0\n        )\n        expected_bps = (bps_per_90_hist / 90.0) * expected_minutes * player[\"form\"]\n        xp += expected_bps * self.fpl_points[\"bonus_points_scaling_factor\"]\n\n        # 7. Minor Negative Events (Probabilistic)\n        # These are rare, so a simple probability based on expected minutes.\n        xp += (expected_minutes / 90.0) * (\n            self.fpl_points[\"yellow_card_deduction\"] * YELLOW_CARD_PROB\n            + self.fpl_points[\"red_card_deduction\"] * RED_CARD_PROB\n            + self.fpl_points[\"own_goal_deduction\"] * OWN_GOAL_PROB\n            + self.fpl_points[\"penalty_miss_deduction\"] * PENALTY_MISS_PROB\n        )\n\n        # 8. Defensive Contribution Points (for 2025/26 season)\n        # Use actual defensive_contribution data from API\n        defensive_contribution_per_90 = (\n            (player[\"defensive_contribution\"] / player[\"minutes\"] * 90)\n            if player[\"minutes\"] &gt; 0\n            else 0.0\n        )\n        expected_defensive_contribution = (defensive_contribution_per_90 / 90.0) * expected_minutes\n\n        # Award defensive contribution points based on position thresholds\n        if position in [\"DEF\", \"MID\", \"FWD\"]:  # Goalkeepers do not earn defensive contribution points\n            xp += expected_defensive_contribution * self.fpl_points[\"defensive_contribution_points\"]\n\n        # Apply confidence factor to final xP\n        xp = xp * confidence_factor\n\n        return {\"xp\": round(xp, 2), \"reason\": \"Success\", \"confidence\": confidence_factor}\n\n    def _calculate_all_players_xp(self):\n        \"\"\"\n        Calculates the Expected Points (xP) for all players over multiple upcoming gameweeks\n        and populates self.all_players_xp_calculated_data with xP per gameweek.\n        \"\"\"\n        print(\n            f\"Calculating xP for all players over {self.gameweeks_to_predict} gameweek(s)...\"\n        )\n\n        # Get all upcoming fixtures and sort them by gameweek\n        all_upcoming_fixtures_items = sorted(\n            [\n                (fid, fdict)\n                for fid, fdict in self.fixtures_data.items()\n                if not fdict[\"finished\"]\n            ],\n            key=lambda item: item[1][\"event\"],\n        )\n\n        if not all_upcoming_fixtures_items:\n            print(\"No upcoming fixtures found. Cannot calculate xP.\")\n            return\n\n        # Determine the current gameweek (the gameweek of the earliest upcoming fixture)\n        current_gameweek = all_upcoming_fixtures_items[0][1][\"event\"]\n        target_gameweeks = range(\n            current_gameweek, current_gameweek + self.gameweeks_to_predict\n        )\n\n        # Create a mapping of team_id_code to a list of their fixtures within the target gameweeks\n        team_fixtures_in_range = {team_code: [] for team_code in self.teams_data.keys()}\n        for fixture_id, fixture_data in all_upcoming_fixtures_items:\n            if fixture_data[\"event\"] in target_gameweeks:\n                home_team_code = fixture_data[\"team_h\"]\n                away_team_code = fixture_data[\"team_a\"]\n\n                team_fixtures_in_range[home_team_code].append(fixture_id)\n                team_fixtures_in_range[away_team_code].append(fixture_id)\n\n        # Calculate total xP for each player across the specified gameweeks\n        for player_id, player_data in self.players_data.items():\n            player_team_code = player_data[\"team_id\"]\n            player_position = player_data[\"position\"]\n\n            # Calculate xP for each relevant fixture and store by gameweek\n            expected_points_by_gw = {}\n            for fixture_id in team_fixtures_in_range.get(player_team_code, []):\n                fixture_gameweek = self.fixtures_data[fixture_id][\"event\"]\n                xp_result_single_gw = self.calculate_xp_for_player(\n                    player_id, fixture_id\n                )\n                if xp_result_single_gw and xp_result_single_gw[\"xp\"] is not None:\n                    if fixture_gameweek not in expected_points_by_gw:\n                        expected_points_by_gw[fixture_gameweek] = 0.0\n                    expected_points_by_gw[fixture_gameweek] += xp_result_single_gw[\"xp\"]\n\n            # Ensure all target gameweeks are present, even if xP is 0 for a given GW\n            for gw in target_gameweeks:\n                if gw not in expected_points_by_gw:\n                    expected_points_by_gw[gw] = 0.0\n\n            # Sort the dictionary by gameweek for consistent output\n            expected_points_by_gw = dict(sorted(expected_points_by_gw.items()))\n\n            # Prepare data for the optimizer\n            player_cost_m = player_data[\"cost_pence\"] / 10.0\n            team_name_full = self.teams_data.get(player_team_code, {}).get(\n                \"name\", \"Unknown Team\"\n            )\n\n            self.all_players_xp_calculated_data.append(\n                {\n                    \"name\": player_data[\"name\"],\n                    \"web_name\": player_data[\"web_name\"],\n                    \"team\": team_name_full,\n                    \"position\": player_position,\n                    \"cost\": player_cost_m,\n                    \"expected_points_by_gw\": expected_points_by_gw,  # Changed key and format\n                }\n            )\n        print(\"xP calculation for all players complete.\")\n\n    def get_upcoming_fixtures(self, limit=None):\n        \"\"\"\n        Returns a list of upcoming fixtures, sorted by gameweek and kickoff time.\n        Optionally limits the number of fixtures returned.\n        \"\"\"\n        upcoming = []\n        now = datetime.now()\n\n        # Sort all fixtures by gameweek and then by kickoff time\n        sorted_fixtures = sorted(\n            self.fixtures_data.values(),\n            key=lambda x: (\n                x.get(\"event\", 0),\n                x.get(\"kickoff_time\", \"9999-12-31T00:00:00Z\"),\n            ),\n        )\n\n        current_gameweek = None\n        for fixture_data in sorted_fixtures:\n            # Determine current gameweek from the earliest upcoming fixture\n            if not fixture_data[\"finished\"] and current_gameweek is None:\n                current_gameweek = fixture_data.get(\"event\", 0)\n\n            # Filter for upcoming fixtures within the prediction horizon\n            if (\n                fixture_data.get(\"event\", 0) &lt; current_gameweek  # Skip past gameweeks\n                or fixture_data.get(\"event\", 0)\n                &gt;= current_gameweek + self.gameweeks_to_predict\n            ):\n                continue  # Skip fixtures outside the prediction horizon\n\n            home_team_name = self.teams_data.get(\n                fixture_data[\"team_h\"], {}\n            ).get(  # Use 'team_h'\n                \"name\", \"Unknown\"\n            )\n            away_team_name = self.teams_data.get(\n                fixture_data[\"team_a\"], {}\n            ).get(  # Use 'team_a'\n                \"name\", \"Unknown\"\n            )\n\n            # Only add fixtures that are not finished\n            if not fixture_data[\"finished\"]:\n                upcoming.append(\n                    {\n                        \"fixture_id\": fixture_data[\"id\"],\n                        \"gameweek\": fixture_data.get(\"event\"),\n                        \"home_team_id\": fixture_data[\"team_h\"],  # Use 'team_h'\n                        \"away_team_id\": fixture_data[\"team_a\"],  # Use 'team_a'\n                        \"match\": f\"{home_team_name} vs {away_team_name}\",\n                        \"kickoff_time\": fixture_data.get(\"kickoff_time\"),\n                        \"home_team_difficulty\": fixture_data[\"team_h_difficulty\"],\n                        \"away_team_difficulty\": fixture_data[\"team_a_difficulty\"],\n                    }\n                )\n            if limit is not None and len(upcoming) &gt;= limit:\n                break\n        return upcoming\n\n    def get_players_for_optimizer(self):\n        \"\"\"\n        Returns the list of player data with calculated xP per gameweek,\n        formatted for the FPLOptimizer.\n        \"\"\"\n        return self.all_players_xp_calculated_data\n\n    def clear_cache(self):\n        \"\"\"\n        Clear all cached API responses. Use this when you want to force fresh data\n        from the FPL API.\n        \"\"\"\n        self.cache_manager.clear_cache()\n        self.logger.info(\"Cleared API response cache\")\n</code></pre>"},{"location":"autoapi/fpl_solver/#fpl_solver.xp_predictor.FPLPredictor.__init__","title":"<code>__init__(gameweeks_to_predict=1)</code>","text":"<p>Initialize the FPLPredictor with data structures and fetch initial data.</p> <p>Parameters:</p> Name Type Description Default <code>gameweeks_to_predict</code> <code>int</code> <p>Number of upcoming gameweeks to calculate                 expected points for. Default is 1 (next gameweek).</p> <code>1</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If gameweeks_to_predict is not a positive integer</p> Source code in <code>fpl_solver/xp_predictor.py</code> <pre><code>def __init__(self, gameweeks_to_predict: int = 1):\n    \"\"\"\n    Initialize the FPLPredictor with data structures and fetch initial data.\n\n    Args:\n        gameweeks_to_predict: Number of upcoming gameweeks to calculate\n                            expected points for. Default is 1 (next gameweek).\n\n    Raises:\n        ValueError: If gameweeks_to_predict is not a positive integer\n    \"\"\"\n    self.logger = setup_logger(__name__)\n    if not isinstance(gameweeks_to_predict, int) or gameweeks_to_predict &lt; 1:\n        msg = f\"gameweeks_to_predict must be a positive integer, got {gameweeks_to_predict}\"\n        self.logger.error(msg)\n        raise ValueError(msg)\n\n    self.gameweeks_to_predict = gameweeks_to_predict\n    self.logger.info(f\"Initializing FPL Predictor for {gameweeks_to_predict} gameweek(s)\")\n\n    # Initialize cache manager\n    cache_dir = os.path.join(os.path.dirname(__file__), 'cache')\n    self.cache_manager = CacheManager(cache_dir)\n\n    # Configuration and static data\n    self.fpl_points: Dict[str, float] = FPL_POINTS\n    self.position_definitions: Dict[int, str] = {\n        1: \"GK\",\n        2: \"DEF\",\n        3: \"MID\",\n        4: \"FWD\",\n    }\n\n    # Data structures for FPL information\n    self.players_data: Dict[int, Dict] = {}\n    self.teams_data: Dict[int, Dict] = {}\n    self.fixtures_data: Dict[int, Dict] = {}\n    self.all_players_xp_calculated_data: List[Dict] = []\n\n    # Initialize data\n    try:\n        self._fetch_fpl_data()\n        self._calculate_all_players_xp()\n    except Exception as e:\n        self.logger.error(f\"Failed to initialize FPL Predictor: {str(e)}\")\n        raise\n</code></pre>"},{"location":"autoapi/fpl_solver/#fpl_solver.xp_predictor.FPLPredictor.calculate_xp_for_player","title":"<code>calculate_xp_for_player(player_id, fixture_id)</code>","text":"<p>Calculates Expected Points (xP) for a single player in a given fixture. Considers various factors: minutes, goals, assists, clean sheets, saves, bonus points, and negative events, adjusted for fixture difficulty.</p> Source code in <code>fpl_solver/xp_predictor.py</code> <pre><code>def calculate_xp_for_player(self, player_id, fixture_id):\n    \"\"\"\n    Calculates Expected Points (xP) for a single player in a given fixture.\n    Considers various factors: minutes, goals, assists, clean sheets, saves,\n    bonus points, and negative events, adjusted for fixture difficulty.\n    \"\"\"\n    player = self.players_data.get(player_id)\n    fixture = self.fixtures_data.get(fixture_id)\n\n    if not player or not fixture:\n        return {\"xp\": 0.0, \"reason\": \"Player or fixture data missing.\"}\n\n    # Handle unavailable players\n    if (\n        player[\"status\"] != \"a\"\n    ):  # 'd' for doubtful, 'i' for injured, 's' for suspended\n        return {\"xp\": 0.0, \"reason\": f\"Player status: {player['status']}\"}\n    if any(\n        x in player[\"news\"].lower()\n        for x in [\"injured\", \"doubtful\", \"suspension\", \"red card\"]\n    ):\n        return {\"xp\": 0.0, \"reason\": f\"Player news: {player['news']}\"}\n\n    # Predict minutes\n    expected_minutes = self._predict_minutes(player_id)\n    if expected_minutes &lt; 1.0:  # If expected to play very little or none\n        return {\"xp\": 0.0, \"reason\": \"Expected minutes too low.\"}\n\n    xp = 0.0\n    position = player[\"position\"]\n    # Use 'team_h' for home team ID\n    is_home_fixture = player[\"team_id\"] == fixture[\"team_h\"]\n\n    # Determine attacking and defensive strengths for the fixture\n    player_team_strength_attack = (\n        self.teams_data.get(fixture[\"team_h\"], {}).get(\n            \"strength_attack_home\"\n        )  # Use 'team_h'\n        if is_home_fixture\n        else self.teams_data.get(fixture[\"team_a\"], {}).get(\n            \"strength_attack_away\"\n        )  # Use 'team_a'\n    )\n    player_team_strength_defence = (\n        self.teams_data.get(fixture[\"team_h\"], {}).get(\n            \"strength_defence_home\"\n        )  # Use 'team_h'\n        if is_home_fixture\n        else self.teams_data.get(fixture[\"team_a\"], {}).get(\n            \"strength_defence_away\"\n        )  # Use 'team_a'\n    )\n    opponent_team_strength_attack = (\n        self.teams_data.get(fixture[\"team_a\"], {}).get(\n            \"strength_attack_away\"\n        )  # Use 'team_a'\n        if is_home_fixture\n        else self.teams_data.get(fixture[\"team_h\"], {}).get(\n            \"strength_attack_home\"\n        )  # Use 'team_h'\n    )\n    opponent_team_strength_defence = (\n        self.teams_data.get(fixture[\"team_a\"], {}).get(\n            \"strength_defence_away\"\n        )  # Use 'team_a'\n        if is_home_fixture\n        else self.teams_data.get(fixture[\"team_h\"], {}).get(\n            \"strength_defence_home\"\n        )  # Use 'team_h'\n    )\n\n    if None in [\n        player_team_strength_attack,\n        player_team_strength_defence,\n        opponent_team_strength_attack,\n        opponent_team_strength_defence,\n    ]:\n        # Fallback if strength data is missing (shouldn't happen with robust data fetch)\n        return {\"xp\": 0.0, \"reason\": \"Team strength data missing for fixture.\"}\n\n    # Apply confidence factor based on historical minutes\n    minutes_played = player.get(\"minutes\", 0)\n    confidence_factor = XP_CONFIDENCE_FACTORS[\"proven\"]  # Default to proven player\n    if minutes_played &lt; VERY_LOW_MINUTES_THRESHOLD:\n        confidence_factor = XP_CONFIDENCE_FACTORS[\"very_low_minutes\"]\n    elif minutes_played &lt; MIN_MINUTES_THRESHOLD:\n        confidence_factor = XP_CONFIDENCE_FACTORS[\"low_minutes\"]\n\n    # 1. Appearance points\n    if expected_minutes &gt;= 60:\n        xp += self.fpl_points[\"appearance_points_gte_60\"]\n    elif expected_minutes &gt; 0:\n        xp += self.fpl_points[\"appearance_points_lt_60\"]\n\n    # 2. Expected Goals (scaled by historical goals per 90 and opponent difficulty)\n    # Use player's form and total goals as a basis\n    goals_per_90_hist = (\n        (player[\"goals_scored\"] / player[\"minutes\"] * 90)\n        if player[\"minutes\"] &gt; 0\n        else 0.0\n    )\n    expected_team_goals = self._calculate_expected_goals(\n        player_team_strength_attack, opponent_team_strength_defence\n    )\n\n    expected_goals_player_contribution = (\n        (goals_per_90_hist / 90.0) * expected_minutes * (expected_team_goals / 1.5)\n    )  # Scale player's goal contribution by team's expected goals\n\n    if position == \"GK\":\n        xp += expected_goals_player_contribution * self.fpl_points[\"goal_gk\"]\n    elif position == \"DEF\":\n        xp += expected_goals_player_contribution * self.fpl_points[\"goal_def\"]\n    elif position == \"MID\":\n        xp += expected_goals_player_contribution * self.fpl_points[\"goal_mid\"]\n    elif position == \"FWD\":\n        xp += expected_goals_player_contribution * self.fpl_points[\"goal_fwd\"]\n\n    # 3. Expected Assists (scaled by historical assists per 90 and opponent difficulty)\n    assists_per_90_hist = (\n        (player[\"assists\"] / player[\"minutes\"] * 90)\n        if player[\"minutes\"] &gt; 0\n        else 0.0\n    )\n    # Assuming team's attacking strength correlates with assist opportunities\n    expected_assists_player_contribution = (\n        (assists_per_90_hist / 90.0)\n        * expected_minutes\n        * (expected_team_goals / 1.5)\n    )  # Similarly scale by team's expected goals\n    xp += expected_assists_player_contribution * self.fpl_points[\"assist_points\"]\n\n    # 4. Expected Clean Sheets (for GKs/DEFs/MIDs) and Conceded Goals deduction\n    expected_conceded = self._calculate_expected_conceded_goals(\n        player_team_strength_defence, opponent_team_strength_attack\n    )\n\n    # Probability of clean sheet\n    # Simplified: higher team defense / lower opponent attack -&gt; higher CS prob\n    # Use logistic or sigmoid for probability\n    cs_prob = 1.0 / (\n        1.0 + math.exp(expected_conceded - 1.0)\n    )  # Sigmoid centered at 1 goal\n\n    if position in [\"GK\", \"DEF\"]:\n        xp += cs_prob * self.fpl_points[\"clean_sheet_gk_def\"]\n\n        # Conceded goals deduction: Apply penalty for every 2 goals conceded *probability*\n        # For simplicity, calculate expected deduction: (expected_conceded / 2) * deduction\n        xp += (expected_conceded / 2.0) * self.fpl_points[\n            \"conceded_2_goals_deduction\"\n        ]\n    elif position == \"MID\":\n        xp += cs_prob * self.fpl_points[\"clean_sheet_mid\"]\n\n    # 5. Expected Saves (for GKs)\n    if position == \"GK\":\n        saves_per_90_hist = (\n            (player[\"saves\"] / player[\"minutes\"] * 90)\n            if player[\"minutes\"] &gt; 0\n            else 0.0\n        )\n        # Expected saves scaled by opponent's attacking strength (more attacking -&gt; more shots -&gt; more saves)\n        expected_saves_player_contribution = (\n            (saves_per_90_hist / 90.0)\n            * expected_minutes\n            * (opponent_team_strength_attack / player_team_strength_defence)\n        )\n        xp += (expected_saves_player_contribution / 3.0) * self.fpl_points[\n            \"saves_3_points\"\n        ]  # Using the new config point value\n\n        # Penalty saves (low probability, use historical rate)\n        penalty_saves_hist_per_game = (\n            player[\"penalties_saved\"] / (player[\"minutes\"] / 90.0)\n            if player[\"minutes\"] &gt; 0\n            else 0.0\n        )\n        xp += (\n            penalty_saves_hist_per_game\n            * (expected_minutes / 90.0)\n            * self.fpl_points[\"penalty_save_points\"]\n        )\n\n    # 6. Expected Bonus Points\n    # Use BPS (Bonus Points System) as a proxy. Scale player's average BPS by form and expected minutes.\n    bps_per_90_hist = (\n        (player[\"bps\"] / player[\"minutes\"] * 90) if player[\"minutes\"] &gt; 0 else 0.0\n    )\n    expected_bps = (bps_per_90_hist / 90.0) * expected_minutes * player[\"form\"]\n    xp += expected_bps * self.fpl_points[\"bonus_points_scaling_factor\"]\n\n    # 7. Minor Negative Events (Probabilistic)\n    # These are rare, so a simple probability based on expected minutes.\n    xp += (expected_minutes / 90.0) * (\n        self.fpl_points[\"yellow_card_deduction\"] * YELLOW_CARD_PROB\n        + self.fpl_points[\"red_card_deduction\"] * RED_CARD_PROB\n        + self.fpl_points[\"own_goal_deduction\"] * OWN_GOAL_PROB\n        + self.fpl_points[\"penalty_miss_deduction\"] * PENALTY_MISS_PROB\n    )\n\n    # 8. Defensive Contribution Points (for 2025/26 season)\n    # Use actual defensive_contribution data from API\n    defensive_contribution_per_90 = (\n        (player[\"defensive_contribution\"] / player[\"minutes\"] * 90)\n        if player[\"minutes\"] &gt; 0\n        else 0.0\n    )\n    expected_defensive_contribution = (defensive_contribution_per_90 / 90.0) * expected_minutes\n\n    # Award defensive contribution points based on position thresholds\n    if position in [\"DEF\", \"MID\", \"FWD\"]:  # Goalkeepers do not earn defensive contribution points\n        xp += expected_defensive_contribution * self.fpl_points[\"defensive_contribution_points\"]\n\n    # Apply confidence factor to final xP\n    xp = xp * confidence_factor\n\n    return {\"xp\": round(xp, 2), \"reason\": \"Success\", \"confidence\": confidence_factor}\n</code></pre>"},{"location":"autoapi/fpl_solver/#fpl_solver.xp_predictor.FPLPredictor.clear_cache","title":"<code>clear_cache()</code>","text":"<p>Clear all cached API responses. Use this when you want to force fresh data from the FPL API.</p> Source code in <code>fpl_solver/xp_predictor.py</code> <pre><code>def clear_cache(self):\n    \"\"\"\n    Clear all cached API responses. Use this when you want to force fresh data\n    from the FPL API.\n    \"\"\"\n    self.cache_manager.clear_cache()\n    self.logger.info(\"Cleared API response cache\")\n</code></pre>"},{"location":"autoapi/fpl_solver/#fpl_solver.xp_predictor.FPLPredictor.get_players_for_optimizer","title":"<code>get_players_for_optimizer()</code>","text":"<p>Returns the list of player data with calculated xP per gameweek, formatted for the FPLOptimizer.</p> Source code in <code>fpl_solver/xp_predictor.py</code> <pre><code>def get_players_for_optimizer(self):\n    \"\"\"\n    Returns the list of player data with calculated xP per gameweek,\n    formatted for the FPLOptimizer.\n    \"\"\"\n    return self.all_players_xp_calculated_data\n</code></pre>"},{"location":"autoapi/fpl_solver/#fpl_solver.xp_predictor.FPLPredictor.get_upcoming_fixtures","title":"<code>get_upcoming_fixtures(limit=None)</code>","text":"<p>Returns a list of upcoming fixtures, sorted by gameweek and kickoff time. Optionally limits the number of fixtures returned.</p> Source code in <code>fpl_solver/xp_predictor.py</code> <pre><code>def get_upcoming_fixtures(self, limit=None):\n    \"\"\"\n    Returns a list of upcoming fixtures, sorted by gameweek and kickoff time.\n    Optionally limits the number of fixtures returned.\n    \"\"\"\n    upcoming = []\n    now = datetime.now()\n\n    # Sort all fixtures by gameweek and then by kickoff time\n    sorted_fixtures = sorted(\n        self.fixtures_data.values(),\n        key=lambda x: (\n            x.get(\"event\", 0),\n            x.get(\"kickoff_time\", \"9999-12-31T00:00:00Z\"),\n        ),\n    )\n\n    current_gameweek = None\n    for fixture_data in sorted_fixtures:\n        # Determine current gameweek from the earliest upcoming fixture\n        if not fixture_data[\"finished\"] and current_gameweek is None:\n            current_gameweek = fixture_data.get(\"event\", 0)\n\n        # Filter for upcoming fixtures within the prediction horizon\n        if (\n            fixture_data.get(\"event\", 0) &lt; current_gameweek  # Skip past gameweeks\n            or fixture_data.get(\"event\", 0)\n            &gt;= current_gameweek + self.gameweeks_to_predict\n        ):\n            continue  # Skip fixtures outside the prediction horizon\n\n        home_team_name = self.teams_data.get(\n            fixture_data[\"team_h\"], {}\n        ).get(  # Use 'team_h'\n            \"name\", \"Unknown\"\n        )\n        away_team_name = self.teams_data.get(\n            fixture_data[\"team_a\"], {}\n        ).get(  # Use 'team_a'\n            \"name\", \"Unknown\"\n        )\n\n        # Only add fixtures that are not finished\n        if not fixture_data[\"finished\"]:\n            upcoming.append(\n                {\n                    \"fixture_id\": fixture_data[\"id\"],\n                    \"gameweek\": fixture_data.get(\"event\"),\n                    \"home_team_id\": fixture_data[\"team_h\"],  # Use 'team_h'\n                    \"away_team_id\": fixture_data[\"team_a\"],  # Use 'team_a'\n                    \"match\": f\"{home_team_name} vs {away_team_name}\",\n                    \"kickoff_time\": fixture_data.get(\"kickoff_time\"),\n                    \"home_team_difficulty\": fixture_data[\"team_h_difficulty\"],\n                    \"away_team_difficulty\": fixture_data[\"team_a_difficulty\"],\n                }\n            )\n        if limit is not None and len(upcoming) &gt;= limit:\n            break\n    return upcoming\n</code></pre>"},{"location":"autoapi/fpl_solver/cache_manager/","title":"cache_manager","text":"<p>Cache manager for FPL API responses.</p> <p>This module provides functionality to cache API responses locally and manage their expiry.</p>"},{"location":"autoapi/fpl_solver/cache_manager/#fpl_solver.cache_manager.CacheManager","title":"<code>CacheManager</code>","text":"Source code in <code>fpl_solver/cache_manager.py</code> <pre><code>class CacheManager:\n    def __init__(self, cache_dir: str, cache_expiry_hours: int = 3):\n        \"\"\"\n        Initialize the cache manager.\n\n        Args:\n            cache_dir: Directory to store cache files\n            cache_expiry_hours: Number of hours after which cache should be considered stale\n        \"\"\"\n        self.cache_dir = cache_dir\n        self.cache_expiry = timedelta(hours=cache_expiry_hours)\n\n        # Create cache directory if it doesn't exist\n        if not os.path.exists(cache_dir):\n            os.makedirs(cache_dir)\n\n    def _get_cache_path(self, endpoint: str) -&gt; str:\n        \"\"\"Get the full path for a cache file.\"\"\"\n        return os.path.join(self.cache_dir, f\"{endpoint}.json\")\n\n    def get_cached_response(self, endpoint: str) -&gt; Optional[Dict[str, Any]]:\n        \"\"\"\n        Retrieve cached response if it exists and is not expired.\n\n        Args:\n            endpoint: API endpoint identifier (e.g., 'static' or 'fixtures')\n\n        Returns:\n            Cached data if valid, None otherwise\n        \"\"\"\n        cache_path = self._get_cache_path(endpoint)\n\n        if not os.path.exists(cache_path):\n            return None\n\n        try:\n            with open(cache_path, 'r') as f:\n                cached_data = json.load(f)\n\n            # Check if cache has expired\n            cached_time = datetime.fromtimestamp(cached_data['cached_at'])\n            if datetime.now() - cached_time &gt; self.cache_expiry:\n                return None\n\n            return cached_data['data']\n\n        except (json.JSONDecodeError, KeyError, ValueError) as e:\n            # If there's any issue with the cache file, ignore it\n            return None\n\n    def save_response(self, endpoint: str, data: Dict[str, Any]) -&gt; None:\n        \"\"\"\n        Save API response to cache.\n\n        Args:\n            endpoint: API endpoint identifier\n            data: Response data to cache\n        \"\"\"\n        cache_path = self._get_cache_path(endpoint)\n\n        cache_data = {\n            'cached_at': time.time(),\n            'data': data\n        }\n\n        with open(cache_path, 'w') as f:\n            json.dump(cache_data, f)\n\n    def clear_cache(self) -&gt; None:\n        \"\"\"Clear all cached data.\"\"\"\n        for filename in os.listdir(self.cache_dir):\n            if filename.endswith('.json'):\n                os.remove(os.path.join(self.cache_dir, filename))\n</code></pre>"},{"location":"autoapi/fpl_solver/cache_manager/#fpl_solver.cache_manager.CacheManager.__init__","title":"<code>__init__(cache_dir, cache_expiry_hours=3)</code>","text":"<p>Initialize the cache manager.</p> <p>Parameters:</p> Name Type Description Default <code>cache_dir</code> <code>str</code> <p>Directory to store cache files</p> required <code>cache_expiry_hours</code> <code>int</code> <p>Number of hours after which cache should be considered stale</p> <code>3</code> Source code in <code>fpl_solver/cache_manager.py</code> <pre><code>def __init__(self, cache_dir: str, cache_expiry_hours: int = 3):\n    \"\"\"\n    Initialize the cache manager.\n\n    Args:\n        cache_dir: Directory to store cache files\n        cache_expiry_hours: Number of hours after which cache should be considered stale\n    \"\"\"\n    self.cache_dir = cache_dir\n    self.cache_expiry = timedelta(hours=cache_expiry_hours)\n\n    # Create cache directory if it doesn't exist\n    if not os.path.exists(cache_dir):\n        os.makedirs(cache_dir)\n</code></pre>"},{"location":"autoapi/fpl_solver/cache_manager/#fpl_solver.cache_manager.CacheManager.clear_cache","title":"<code>clear_cache()</code>","text":"<p>Clear all cached data.</p> Source code in <code>fpl_solver/cache_manager.py</code> <pre><code>def clear_cache(self) -&gt; None:\n    \"\"\"Clear all cached data.\"\"\"\n    for filename in os.listdir(self.cache_dir):\n        if filename.endswith('.json'):\n            os.remove(os.path.join(self.cache_dir, filename))\n</code></pre>"},{"location":"autoapi/fpl_solver/cache_manager/#fpl_solver.cache_manager.CacheManager.get_cached_response","title":"<code>get_cached_response(endpoint)</code>","text":"<p>Retrieve cached response if it exists and is not expired.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>API endpoint identifier (e.g., 'static' or 'fixtures')</p> required <p>Returns:</p> Type Description <code>Optional[Dict[str, Any]]</code> <p>Cached data if valid, None otherwise</p> Source code in <code>fpl_solver/cache_manager.py</code> <pre><code>def get_cached_response(self, endpoint: str) -&gt; Optional[Dict[str, Any]]:\n    \"\"\"\n    Retrieve cached response if it exists and is not expired.\n\n    Args:\n        endpoint: API endpoint identifier (e.g., 'static' or 'fixtures')\n\n    Returns:\n        Cached data if valid, None otherwise\n    \"\"\"\n    cache_path = self._get_cache_path(endpoint)\n\n    if not os.path.exists(cache_path):\n        return None\n\n    try:\n        with open(cache_path, 'r') as f:\n            cached_data = json.load(f)\n\n        # Check if cache has expired\n        cached_time = datetime.fromtimestamp(cached_data['cached_at'])\n        if datetime.now() - cached_time &gt; self.cache_expiry:\n            return None\n\n        return cached_data['data']\n\n    except (json.JSONDecodeError, KeyError, ValueError) as e:\n        # If there's any issue with the cache file, ignore it\n        return None\n</code></pre>"},{"location":"autoapi/fpl_solver/cache_manager/#fpl_solver.cache_manager.CacheManager.save_response","title":"<code>save_response(endpoint, data)</code>","text":"<p>Save API response to cache.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>API endpoint identifier</p> required <code>data</code> <code>Dict[str, Any]</code> <p>Response data to cache</p> required Source code in <code>fpl_solver/cache_manager.py</code> <pre><code>def save_response(self, endpoint: str, data: Dict[str, Any]) -&gt; None:\n    \"\"\"\n    Save API response to cache.\n\n    Args:\n        endpoint: API endpoint identifier\n        data: Response data to cache\n    \"\"\"\n    cache_path = self._get_cache_path(endpoint)\n\n    cache_data = {\n        'cached_at': time.time(),\n        'data': data\n    }\n\n    with open(cache_path, 'w') as f:\n        json.dump(cache_data, f)\n</code></pre>"},{"location":"autoapi/fpl_solver/logger/","title":"logger","text":"<p>Logging configuration for the FPL Solver package.</p>"},{"location":"autoapi/fpl_solver/logger/#fpl_solver.logger.setup_logger","title":"<code>setup_logger(name, level=None)</code>","text":"<p>Set up a logger with consistent formatting and optional level override.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the logger</p> required <code>level</code> <code>Optional[int]</code> <p>Optional logging level override. If None, uses INFO</p> <code>None</code> <p>Returns:</p> Type Description <code>Logger</code> <p>logging.Logger: Configured logger instance</p> Source code in <code>fpl_solver/logger.py</code> <pre><code>def setup_logger(name: str, level: Optional[int] = None) -&gt; logging.Logger:\n    \"\"\"\n    Set up a logger with consistent formatting and optional level override.\n\n    Args:\n        name: The name of the logger\n        level: Optional logging level override. If None, uses INFO\n\n    Returns:\n        logging.Logger: Configured logger instance\n    \"\"\"\n    logger = logging.getLogger(name)\n\n    if not logger.handlers:  # Only add handler if logger doesn't have one\n        handler = logging.StreamHandler(sys.stdout)\n        formatter = logging.Formatter(\n            '%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n            datefmt='%Y-%m-%d %H:%M:%S'\n        )\n        handler.setFormatter(formatter)\n        logger.addHandler(handler)\n\n    logger.setLevel(level or logging.INFO)\n    return logger\n</code></pre>"},{"location":"autoapi/fpl_solver/solver/","title":"solver","text":"<p>FPL Squad Optimizer using PuLP for Integer Linear Programming (ILP).</p> <p>This module provides optimization functionality to select the best possible FPL squad over multiple gameweeks, considering transfer constraints and chips.</p>"},{"location":"autoapi/fpl_solver/solver/#fpl_solver.solver.FPLOptimizer","title":"<code>FPLOptimizer</code>","text":"<p>A class to optimize Fantasy Premier League (FPL) squad selection using Integer Linear Programming (ILP).</p> <p>The optimizer aims to select a 15-player squad (2 GKs, 5 DEFs, 5 MIDs, 3 FWDs) within a budget, with a maximum number of players from any single team, to maximize the total expected points.</p> Source code in <code>fpl_solver/solver.py</code> <pre><code>class FPLOptimizer:\n    \"\"\"\n    A class to optimize Fantasy Premier League (FPL) squad selection\n    using Integer Linear Programming (ILP).\n\n    The optimizer aims to select a 15-player squad (2 GKs, 5 DEFs, 5 MIDs, 3 FWDs)\n    within a budget, with a maximum number of players from any single team,\n    to maximize the total expected points.\n    \"\"\"\n\n    def __init__(self, player_data: pd.DataFrame):\n        \"\"\"\n        Initializes the FPLOptimizer with player data.\n\n        Args:\n            player_data (pd.DataFrame): A DataFrame containing player information\n                                        with columns: 'name', 'team', 'position',\n                                        'cost', 'expected_points_by_gw' (a dict of xP per GW).\n        \"\"\"\n        required_columns = [\"name\", \"team\", \"position\", \"cost\", \"expected_points_by_gw\"]\n        if not all(col in player_data.columns for col in required_columns):\n            missing_cols = [\n                col for col in required_columns if col not in player_data.columns\n            ]\n            raise ValueError(\n                f\"player_data DataFrame must contain {required_columns} columns. Missing: {missing_cols}\"\n            )\n\n        self.player_data = player_data\n        self.problem = None\n        self.selected_squad_history = {}  # To store squad for each gameweek\n        self.total_cost = 0\n        self.total_expected_points = 0\n        self.total_transfer_hits = 0\n\n        # --- Process Enforced Players ---\n        self.enforced_player_indices = set()\n        self.enforced_team_pos_requirements = []\n\n        print(\"\\n--- Processing Enforced Players ---\")\n\n        # Enforce by Player ID\n        for player_id in ENFORCED_PLAYERS_BY_ID:\n            found_player = self.player_data[self.player_data[\"id\"] == player_id]\n            if not found_player.empty:\n                player_idx = found_player.index[0]\n                self.enforced_player_indices.add(player_idx)\n                print(\n                    f\"Enforcing player by ID: {found_player.loc[player_idx, 'name']} (ID: {player_id})\"\n                )\n            else:\n                print(\n                    f\"Warning: Enforced player with ID {player_id} not found in data.\"\n                )\n\n        # Enforce by Player Name\n        for player_name in ENFORCED_PLAYERS_BY_NAME:\n            found_player = self.player_data[self.player_data[\"name\"] == player_name]\n            if not found_player.empty:\n                player_idx = found_player.index[0]\n                self.enforced_player_indices.add(player_idx)\n                print(f\"Enforcing player by name: {player_name}\")\n            else:\n                print(f\"Warning: Enforced player '{player_name}' not found in data.\")\n\n        # Enforce by Team and Position\n        for requirement in ENFORCED_PLAYERS_BY_TEAM_AND_POSITION:\n            team = requirement.get(\"team\")\n            position = requirement.get(\"position\")\n            if team and position:\n                # Validate team and position exist in data\n                if team not in self.player_data[\"team\"].unique():\n                    print(\n                        f\"Warning: Enforced team '{team}' for position '{position}' not found in data.\"\n                    )\n                    continue\n                if position not in self.player_data[\"position\"].unique():\n                    print(\n                        f\"Warning: Enforced position '{position}' for team '{team}' not found in data.\"\n                    )\n                    continue\n\n                self.enforced_team_pos_requirements.append((team, position))\n                print(f\"Enforcing at least one {position} from {team}.\")\n            else:\n                print(\n                    f\"Warning: Invalid enforced team/position requirement: {requirement}\"\n                )\n\n        if not (\n            self.enforced_player_indices\n            or self.enforced_team_pos_requirements\n            or ENFORCED_PLAYERS_BY_ID\n            or ENFORCED_PLAYERS_BY_NAME\n            or ENFORCED_PLAYERS_BY_TEAM_AND_POSITION\n        ):\n            print(\"No players or team/position combinations are enforced.\")\n        print(\"-----------------------------------\\n\")\n\n    def solve(\n        self,\n        budget: float,\n        max_players_per_team: int,\n        chip_allowances: dict,\n        num_gameweeks: int,\n    ) -&gt; bool:\n        \"\"\"\n        Solves the FPL optimization problem using PuLP.\n\n        Args:\n            budget (float): The maximum budget in millions of pounds.\n            max_players_per_team (int): The maximum number of players allowed from\n                                        any single Premier League team.\n            chip_allowances (dict): A dictionary specifying the maximum usage for each chip.\n            num_gameweeks (int): The number of gameweeks to optimize over.\n\n        Returns:\n            bool: True if a solution was found, False otherwise.\n        \"\"\"\n        self.problem = LpProblem(\"FPL Squad Multi-Week Optimization\", LpMaximize)\n\n        # Decision variables for player selection, indexed by player and gameweek\n        player_vars = LpVariable.dicts(\n            \"Player\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n        )\n        starting_xi_vars = LpVariable.dicts(\n            \"StartingXI\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n        )\n        captain_var = LpVariable.dicts(\n            \"Captain\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n        )\n\n        # Binary variables for chip usage, indexed by gameweek\n        use_bench_boost = LpVariable.dicts(\n            \"Use_Bench_Boost\", range(num_gameweeks), 0, 1, LpBinary\n        )\n        use_triple_captain = LpVariable.dicts(\n            \"Use_Triple_Captain\", range(num_gameweeks), 0, 1, LpBinary\n        )\n\n        # Transfer variables\n        transfer_in_vars = LpVariable.dicts(\n            \"Transfer_In\",\n            (self.player_data.index, range(1, num_gameweeks)),\n            0,\n            1,\n            LpBinary,\n        )\n        transfer_out_vars = LpVariable.dicts(\n            \"Transfer_Out\",\n            (self.player_data.index, range(1, num_gameweeks)),\n            0,\n            1,\n            LpBinary,\n        )\n\n        # Total transfers made in a gameweek (absolute count)\n        transfers_made = LpVariable.dicts(\n            \"Transfers_Made\", range(1, num_gameweeks), 0, None, LpInteger\n        )\n        # Free transfers available at the start of a gameweek\n        free_transfers_available = LpVariable.dicts(\n            \"Free_Transfers_Available\",\n            range(num_gameweeks),\n            0,\n            MAX_FREE_TRANSFERS_SAVED + 1,\n            LpInteger,\n        )\n        # Number of transfer hits taken in a gameweek\n        transfer_hits = LpVariable.dicts(\n            \"Transfer_Hits\", range(1, num_gameweeks), 0, None, LpInteger\n        )\n\n        # Auxiliary variables for linearizing chip effects\n        is_bench_player = LpVariable.dicts(\n            \"Is_Bench_Player\",\n            (self.player_data.index, range(num_gameweeks)),\n            0,\n            1,\n            LpBinary,\n        )\n        actual_bench_boost_points = LpVariable.dicts(\n            \"Actual_Bench_Boost_Points\",\n            (self.player_data.index, range(num_gameweeks)),\n            0,\n            None,\n            LpContinuous,\n        )\n        actual_triple_captain_bonus = LpVariable.dicts(\n            \"Actual_Triple_Captain_Bonus\",\n            (self.player_data.index, range(num_gameweeks)),\n            0,\n            None,\n            LpContinuous,\n        )\n\n        # --- Objective Function ---\n        total_objective_points = []\n\n        # Get the first gameweek number from the player data to correctly index expected_points_by_gw\n        first_gw_key = next(\n            iter(\n                self.player_data.loc[\n                    self.player_data.index[0], \"expected_points_by_gw\"\n                ].keys()\n            )\n        )\n        current_gameweek_number_start = int(first_gw_key)\n\n        for w in range(num_gameweeks):\n            # The actual gameweek number (1-indexed)\n            gw_actual = current_gameweek_number_start + w\n\n            # Base expected points from the selected starting 11 for this gameweek\n            base_points_expression_gw = lpSum(\n                self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n                * starting_xi_vars[i][w]\n                for i in self.player_data.index\n            )\n            total_objective_points.append(base_points_expression_gw)\n\n            # Regular Captaincy points (additional 1x for captain)\n            captain_points_bonus_gw = lpSum(\n                self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n                * captain_var[i][w]\n                for i in self.player_data.index\n            )\n            total_objective_points.append(captain_points_bonus_gw)\n\n            # Define auxiliary variables and constraints for chips for each gameweek\n            for i in self.player_data.index:\n                # Use gameweek-specific player xP for chip calculations\n                player_xp = self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n\n                # Bench Boost auxiliary variables and constraints\n                self.problem += (\n                    is_bench_player[i][w] &lt;= player_vars[i][w],\n                    f\"IsBench_Squad_{i}_{w}\",\n                )\n                self.problem += (\n                    is_bench_player[i][w] &lt;= 1 - starting_xi_vars[i][w],\n                    f\"IsBench_NotStarter_{i}_{w}\",\n                )\n                self.problem += (\n                    is_bench_player[i][w]\n                    &gt;= player_vars[i][w] + (1 - starting_xi_vars[i][w]) - 1,\n                    f\"IsBench_Logical_{i}_{w}\",\n                )\n\n                self.problem += (\n                    actual_bench_boost_points[i][w]\n                    &lt;= player_xp * is_bench_player[i][w],\n                    f\"BenchBoost_Contr_1_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_bench_boost_points[i][w] &lt;= player_xp * use_bench_boost[w],\n                    f\"BenchBoost_Contr_2_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_bench_boost_points[i][w]\n                    &gt;= player_xp * (is_bench_player[i][w] + use_bench_boost[w] - 1),\n                    f\"BenchBoost_Contr_3_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_bench_boost_points[i][w] &gt;= 0,\n                    f\"BenchBoost_Contr_4_{i}_{w}\",\n                )\n\n                # Triple Captain auxiliary variables and constraints\n                # Changed player_xp * 2 to player_xp to reflect additional 1x bonus\n                self.problem += (\n                    actual_triple_captain_bonus[i][w] &lt;= player_xp * captain_var[i][w],\n                    f\"TripleCaptain_Contr_1_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_triple_captain_bonus[i][w]\n                    &lt;= player_xp * use_triple_captain[w],\n                    f\"TripleCaptain_Contr_2_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_triple_captain_bonus[i][w]\n                    &gt;= player_xp * (captain_var[i][w] + use_triple_captain[w] - 1),\n                    f\"TripleCaptain_Contr_3_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_triple_captain_bonus[i][w] &gt;= 0,\n                    f\"TripleCaptain_Contr_4_{i}_{w}\",\n                )\n\n            # Add points from bench boost and triple captain bonus for this gameweek\n            total_bench_boost_points_gw = lpSum(\n                actual_bench_boost_points[i][w] for i in self.player_data.index\n            )\n            total_triple_captain_bonus_points_gw = lpSum(\n                actual_triple_captain_bonus[i][w] for i in self.player_data.index\n            )\n\n            total_objective_points.append(total_bench_boost_points_gw)\n            total_objective_points.append(total_triple_captain_bonus_points_gw)\n\n        # Subtract transfer hits from the total objective\n        total_objective_points.append(\n            -POINTS_PER_HIT * lpSum(transfer_hits[w] for w in range(1, num_gameweeks))\n        )\n\n        self.problem += (\n            lpSum(total_objective_points),\n            \"Total Expected Points Over Gameweeks\",\n        )\n\n        # --- Constraints ---\n\n        # Apply constraints for each gameweek\n        for w in range(num_gameweeks):\n            # 1. Select exactly 15 players for the squad\n            self.problem += (\n                lpSum(player_vars[i][w] for i in self.player_data.index) == 15,\n                f\"Total_Players_GW{w}\",\n            )\n\n            # 2. Squad position constraints (2 GKs, 5 DEFs, 5 MIDs, 3 FWDs)\n            gks = self.player_data[self.player_data[\"position\"] == \"GK\"].index\n            defs = self.player_data[self.player_data[\"position\"] == \"DEF\"].index\n            mids = self.player_data[self.player_data[\"position\"] == \"MID\"].index\n            fwds = self.player_data[self.player_data[\"position\"] == \"FWD\"].index\n\n            self.problem += (\n                lpSum(player_vars[i][w] for i in gks) == 2,\n                f\"Goalkeepers_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(player_vars[i][w] for i in defs) == 5,\n                f\"Defenders_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(player_vars[i][w] for i in mids) == 5,\n                f\"Midfielders_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(player_vars[i][w] for i in fwds) == 3,\n                f\"Forwards_Count_GW{w}\",\n            )\n\n            # 3. Budget constraint\n            # This applies to the cost of the squad for the current gameweek.\n            self.problem += (\n                lpSum(\n                    self.player_data.loc[i, \"cost\"] * player_vars[i][w]\n                    for i in self.player_data.index\n                )\n                &lt;= budget,\n                f\"Total_Budget_GW{w}\",\n            )\n\n            # 4. Maximum players per team constraint\n            for team in self.player_data[\"team\"].unique():\n                team_players = self.player_data[self.player_data[\"team\"] == team].index\n                self.problem += (\n                    lpSum(player_vars[i][w] for i in team_players)\n                    &lt;= max_players_per_team,\n                    f\"Max_Players_from_{team}_GW{w}\",\n                )\n\n            # 5. Starting XI constraints\n            # 5.1 Select exactly 11 players for the starting XI\n            self.problem += (\n                lpSum(starting_xi_vars[i][w] for i in self.player_data.index) == 11,\n                f\"Total_Starting_XI_Players_GW{w}\",\n            )\n\n            # 5.2 A player can only be in the starting XI if they are in the squad\n            for i in self.player_data.index:\n                self.problem += (\n                    starting_xi_vars[i][w] &lt;= player_vars[i][w],\n                    f\"StartingXI_in_Squad_{i}_{w}\",\n                )\n\n            # 5.3 Starting XI position constraints (FPL allows flexible formations, so use minimums)\n            self.problem += (\n                lpSum(starting_xi_vars[i][w] for i in gks) == 1,\n                f\"Starting_Goalkeepers_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(starting_xi_vars[i][w] for i in defs) &gt;= 3,\n                f\"Min_Starting_Defenders_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(starting_xi_vars[i][w] for i in mids) &gt;= 2,\n                f\"Min_Starting_Midfielders_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(starting_xi_vars[i][w] for i in fwds) &gt;= 1,\n                f\"Min_Starting_Forwards_Count_GW{w}\",\n            )\n\n            # 6. Captain Constraints\n            # 6.1 Select exactly one captain from the starting XI\n            self.problem += (\n                lpSum(captain_var[i][w] for i in self.player_data.index) == 1,\n                f\"One_Captain_GW{w}\",\n            )\n\n            # 6.2 A player can only be captain if they are in the starting XI\n            for i in self.player_data.index:\n                self.problem += (\n                    captain_var[i][w] &lt;= starting_xi_vars[i][w],\n                    f\"Captain_in_StartingXI_{i}_{w}\",\n                )\n\n            # --- Enforced Player Constraints---\n            for player_idx in self.enforced_player_indices:\n                self.problem += (\n                    player_vars[player_idx][w] == 1,\n                    f\"Enforce_Player_{self.player_data.loc[player_idx, 'name']}_GW{w}\",\n                )\n\n            for team, position in self.enforced_team_pos_requirements:\n                # Filter players for the current team and position\n                team_pos_players = self.player_data[\n                    (self.player_data[\"team\"] == team)\n                    &amp; (self.player_data[\"position\"] == position)\n                ].index\n                if not team_pos_players.empty:\n                    self.problem += (\n                        lpSum(player_vars[i][w] for i in team_pos_players) &gt;= 1,\n                        f\"Enforce_One_{position}_from_{team}_GW{w}\",\n                    )\n                else:\n                    print(\n                        f\"Warning: No players found for enforced requirement: at least one {position} from {team} for GW{gw_actual}.\"\n                    )\n\n        # --- Chip Usage Constraints (TOTAL usage over all gameweeks) ---\n        # These constraints should be outside the per-gameweek loop to avoid duplicates.\n        self.problem += (\n            lpSum(use_bench_boost[j] for j in range(num_gameweeks))\n            &lt;= chip_allowances.get(\"bench_boost\", 0),\n            f\"Max_Bench_Boost_Usage_Total\",\n        )\n        self.problem += (\n            lpSum(use_triple_captain[j] for j in range(num_gameweeks))\n            &lt;= chip_allowances.get(\"triple_captain\", 0),\n            f\"Max_Triple_Captain_Usage_Total\",\n        )\n\n        # --- Inter-Gameweek Constraints (Transfers and Transfer Rules) ---\n        # Initialize free transfers for GW0 (first gameweek of optimization horizon)\n        # This assumes the optimization starts at GW0, and it has INITIAL_FREE_TRANSFERS.\n        # If the model starts at an arbitrary GW, this would need to be an input.\n        self.problem += (\n            free_transfers_available[0] == INITIAL_FREE_TRANSFERS,\n            f\"Initial_Free_Transfers_GW0\",\n        )\n\n        for w in range(1, num_gameweeks):\n            # Calculate total transfers made in this gameweek\n            self.problem += (\n                transfers_made[w]\n                == lpSum(transfer_in_vars[i][w] for i in self.player_data.index),\n                f\"Transfers_Made_GW{w}\",\n            )\n            # Total transfers in must equal total transfers out for each gameweek after the first\n            self.problem += (\n                lpSum(transfer_in_vars[i][w] for i in self.player_data.index)\n                == lpSum(transfer_out_vars[i][w] for i in self.player_data.index),\n                f\"Transfers_In_Equals_Out_GW{w}\",\n            )\n\n            # Calculate free transfers available for the current gameweek (w)\n            # Free transfers for GW_w = min(free transfers from GW_w-1 - transfers made in GW_w + 1, MAX_FREE_TRANSFERS_SAVED + 1)\n            # The + 1 in MAX_FREE_TRANSFERS_SAVED + 1 is because MAX_FREE_TRANSFERS_SAVED implies how many can be *saved*,\n            # so if you save 1, you have 1 (current) + 1 (saved) = 2.\n            self.problem += (\n                free_transfers_available[w]\n                &lt;= free_transfers_available[w - 1] - transfers_made[w] + 1,\n                f\"Free_Transfers_Calc_1_GW{w}\",\n            )\n            self.problem += (\n                free_transfers_available[w] &lt;= MAX_FREE_TRANSFERS_SAVED + 1,\n                f\"Free_Transfers_Calc_2_GW{w}\",\n            )\n            self.problem += (\n                free_transfers_available[w] &gt;= 0,  # Cannot have negative free transfers\n                f\"Free_Transfers_Non_Negative_GW{w}\",\n            )\n\n            # Calculate transfer hits\n            # transfer_hits[w] = max(0, transfers_made[w] - free_transfers_available_at_start_of_gw_w)\n            # This needs to be linearized. If transfers_made[w] &gt; free_transfers_available[w-1], then hit.\n            # free_transfers_available[w-1] represents transfers available *before* making transfers for GW_w\n            self.problem += (\n                transfer_hits[w] &gt;= transfers_made[w] - free_transfers_available[w - 1],\n                f\"Transfer_Hits_Calc_1_GW{w}\",\n            )\n            self.problem += (\n                transfer_hits[w] &gt;= 0,\n                f\"Transfer_Hits_Calc_2_GW{w}\",\n            )\n\n            for i in self.player_data.index:\n                # Squad continuity: player_vars[i][w] (in squad at start of GW w)\n                #                 = player_vars[i][w-1] (in squad at start of GW w-1)\n                #                 - transfer_out_vars[i][w] (transferred out for GW w)\n                #                 + transfer_in_vars[i][w] (transferred in for GW w)\n                self.problem += (\n                    player_vars[i][w]\n                    == player_vars[i][w - 1]\n                    - transfer_out_vars[i][w]\n                    + transfer_in_vars[i][w],\n                    f\"Squad_Continuity_{i}_GW{w}\",\n                )\n                # A player cannot be transferred in and out in the same gameweek\n                self.problem += (\n                    transfer_in_vars[i][w] + transfer_out_vars[i][w] &lt;= 1,\n                    f\"No_Simultaneous_Transfer_{i}_{w}\",\n                )\n\n        try:\n            # The solver is called with the GLPK_CMD solver\n            self.problem.solve(PULP_CBC_CMD(msg=0))  # msg=0 suppresses verbose output\n        except Exception as e:\n            print(f\"Error solving the problem: {e}\")\n            return False\n\n        if LpStatus[self.problem.status] == \"Optimal\":\n            print(\"Optimization successful! Optimal solution found.\")\n\n            self.selected_squad_history = {}\n            self.total_transfer_hits = 0\n            for w in range(num_gameweeks):\n                # The actual gameweek number (1-indexed)\n                gw_actual = current_gameweek_number_start + w\n\n                # Get selected players for the current gameweek\n                selected_squad_gw = self.player_data[\n                    [player_vars[i][w].varValue == 1 for i in self.player_data.index]\n                ].copy()\n\n                # Get starter and captain info for this gameweek\n                is_starter_series_gw = pd.Series(\n                    [\n                        starting_xi_vars[i][w].varValue == 1\n                        for i in self.player_data.index\n                    ],\n                    index=self.player_data.index,\n                )\n                is_captain_series_gw = pd.Series(\n                    [captain_var[i][w].varValue == 1 for i in self.player_data.index],\n                    index=self.player_data.index,\n                )\n\n                selected_squad_gw[\"is_starter\"] = is_starter_series_gw.loc[\n                    selected_squad_gw.index\n                ]\n                selected_squad_gw[\"is_captain\"] = is_captain_series_gw.loc[\n                    selected_squad_gw.index\n                ]\n\n                transfers_in_gw = 0\n                transfers_out_gw = 0\n                hits_gw = 0\n\n                # Store transfer details for gameweeks &gt; 0\n                if (\n                    w &gt; 0\n                ):  # Check for transfers only from GW1 onwards (index 1 in 0-indexed loop)\n                    transfer_in_flags = pd.Series(\n                        [\n                            transfer_in_vars[i][w].varValue == 1\n                            for i in self.player_data.index\n                        ],\n                        index=self.player_data.index,\n                    )\n                    transfer_out_flags = pd.Series(\n                        [\n                            transfer_out_vars[i][w].varValue == 1\n                            for i in self.player_data.index\n                        ],\n                        index=self.player_data.index,\n                    )\n\n                    selected_squad_gw[\"transfer_in\"] = transfer_in_flags.loc[\n                        selected_squad_gw.index\n                    ]\n                    selected_squad_gw[\"transfer_out\"] = transfer_out_flags.loc[\n                        selected_squad_gw.index\n                    ]\n\n                    transfers_in_gw = int(round(transfer_in_flags.sum()))\n                    transfers_out_gw = int(round(transfer_out_flags.sum()))\n                    hits_gw = int(round(transfer_hits[w].varValue))\n                    self.total_transfer_hits += hits_gw\n                else:\n                    selected_squad_gw[\"transfer_in\"] = False  # No transfers in for GW0\n                    selected_squad_gw[\"transfer_out\"] = (\n                        False  # No transfers out for GW0\n                    )\n\n                self.selected_squad_history[f\"GW{gw_actual}\"] = {\n                    \"squad\": selected_squad_gw,\n                    \"total_cost\": selected_squad_gw[\"cost\"].sum(),\n                    \"expected_points_from_xi\": sum(\n                        self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n                        * starting_xi_vars[i][w].varValue\n                        for i in self.player_data.index\n                    ),\n                    \"bench_boost_used\": bool(use_bench_boost[w].varValue),\n                    \"triple_captain_used\": bool(use_triple_captain[w].varValue),\n                    \"total_bench_boost_points\": value(\n                        lpSum(\n                            actual_bench_boost_points[i][w]\n                            for i in self.player_data.index\n                        )\n                    ),\n                    \"total_triple_captain_bonus\": value(\n                        lpSum(\n                            actual_triple_captain_bonus[i][w]\n                            for i in self.player_data.index\n                        )\n                    ),\n                    \"transfers_in_count\": transfers_in_gw,\n                    \"transfers_out_count\": transfers_out_gw,\n                    \"transfer_hits\": hits_gw,  # New\n                    \"free_transfers_available_next_gw\": (\n                        int(round(free_transfers_available[w].varValue))\n                        if w &lt; num_gameweeks - 1\n                        else 0\n                    ),  # Free transfers available *after* this GW's transfers are made\n                }\n\n            # Overall totals\n            self.total_cost = self.selected_squad_history[\n                f\"GW{current_gameweek_number_start + num_gameweeks - 1}\"\n            ][\n                \"total_cost\"\n            ]  # Cost of final squad\n            self.total_expected_points = value(\n                self.problem.objective\n            )  # Total objective value from solver\n            self.used_chips = {\n                f\"GW{current_gameweek_number_start + w}\": {\n                    \"bench_boost\": bool(use_bench_boost[w].varValue),\n                    \"triple_captain\": bool(use_triple_captain[w].varValue),\n                }\n                for w in range(num_gameweeks)\n            }\n\n            return True\n        else:\n            print(f\"No optimal solution found. Status: {LpStatus[self.problem.status]}\")\n            self.selected_squad_history = {}\n            self.total_cost = 0\n            self.total_expected_points = 0\n            self.used_chips = {}\n            self.total_transfer_hits = 0\n            return False\n\n    def get_selected_squad(self, gameweek: int = None) -&gt; pd.DataFrame | None:\n        \"\"\"\n        Returns the selected squad for a specific gameweek (1-indexed).\n        If no gameweek is specified, returns the squad for the last optimized gameweek.\n        \"\"\"\n        if not self.selected_squad_history:\n            return None\n\n        # Get the first GW key to determine the range of available GWs\n        first_gw_in_history = min(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n        last_gw_in_history = max(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n\n        if gameweek is None:\n            return self.selected_squad_history[f\"GW{last_gw_in_history}\"][\"squad\"]\n\n        if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n            print(\n                f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n            )\n            return None\n\n        return self.selected_squad_history.get(f\"GW{gameweek}\", {}).get(\"squad\")\n\n    def get_total_cost(self, gameweek: int = None) -&gt; float:\n        \"\"\"\n        Returns the total cost for a specific gameweek (1-indexed).\n        If no gameweek is specified, returns the cost of the squad in the last optimized gameweek.\n        \"\"\"\n        if not self.selected_squad_history:\n            return 0\n        first_gw_in_history = min(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n        last_gw_in_history = max(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n\n        if gameweek is None:\n            return self.selected_squad_history[f\"GW{last_gw_in_history}\"][\"total_cost\"]\n\n        if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n            print(\n                f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n            )\n            return 0  # Or raise an error\n\n        return self.selected_squad_history.get(f\"GW{gameweek}\", {}).get(\"total_cost\", 0)\n\n    def get_total_expected_points(self) -&gt; float:\n        \"\"\"\n        Returns the overall total expected points across all optimized gameweeks.\n        \"\"\"\n        return self.total_expected_points\n\n    def get_gameweek_summary(self, gameweek: int):\n        \"\"\"\n        Returns a dictionary summary for a specific gameweek.\n        \"\"\"\n        if not self.selected_squad_history:\n            return None\n        first_gw_in_history = min(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n        last_gw_in_history = max(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n\n        if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n            print(\n                f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n            )\n            return None\n\n        return self.selected_squad_history.get(f\"GW{gameweek}\")\n\n    def print_squad_summary(self, gameweek: int):\n        \"\"\"\n        Prints a formatted summary of the selected squad for a specific gameweek.\n        \"\"\"\n        if not self.selected_squad_history:\n            print(\"No squad has been selected yet. Run the 'solve' method first.\")\n            return\n\n        gw_data = self.get_gameweek_summary(gameweek)\n        if not gw_data:\n            return  # get_gameweek_summary already prints error message\n\n        selected_squad = gw_data[\"squad\"]\n        total_cost = gw_data[\"total_cost\"]\n        expected_points_from_xi = gw_data[\"expected_points_from_xi\"]\n        bench_boost_used = gw_data[\"bench_boost_used\"]\n        triple_captain_used = gw_data[\"triple_captain_used\"]\n        total_bench_boost_points = gw_data[\"total_bench_boost_points\"]\n        total_triple_captain_bonus = gw_data[\"total_triple_captain_bonus\"]\n        transfers_in_count = gw_data[\"transfers_in_count\"]  # New\n        transfers_out_count = gw_data[\"transfers_out_count\"]  # New\n        transfer_hits_taken = gw_data[\"transfer_hits\"]  # New\n        free_transfers_available_next_gw = gw_data[\n            \"free_transfers_available_next_gw\"\n        ]  # New\n\n        print(f\"\\n--- FPL Optimized Squad for Gameweek {gameweek} ---\")\n        print(f\"Squad Cost: \u00a3{total_cost:.1f}m\")\n        print(f\"Expected Points (Starting XI): {expected_points_from_xi:.2f}\")\n        print(\n            f\"Total Expected Points for GW{gameweek} (including chips): {expected_points_from_xi + total_bench_boost_points + total_triple_captain_bonus:.2f}\"\n        )\n        print(\"\\n--- Chips Used This Gameweek ---\")\n        if bench_boost_used:\n            print(f\"- Bench Boost (Added {total_bench_boost_points:.2f} points)\")\n        if triple_captain_used:\n            print(\n                f\"- Triple Captain (Added {total_triple_captain_bonus:.2f} bonus points)\"\n            )\n        if not (bench_boost_used or triple_captain_used):\n            print(\"No chips used this gameweek.\")\n\n        print(\"\\n--- Goalkeepers (Starting XI marked with *) ---\")\n        for index, row in selected_squad[selected_squad[\"position\"] == \"GK\"].iterrows():\n            starter_str = \"*\" if row[\"is_starter\"] else \"\"\n            captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n            transfer_status = \"\"\n            if row[\"transfer_in\"]:\n                transfer_status = \"(IN)\"\n            elif row[\"transfer_out\"]:\n                transfer_status = \"(OUT)\"\n\n            # Access gameweek-specific xP correctly\n            player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n            print(\n                f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n            )\n        print(\"\\n--- Defenders (Starting XI marked with *) ---\")\n        for index, row in selected_squad[\n            selected_squad[\"position\"] == \"DEF\"\n        ].iterrows():\n            starter_str = \"*\" if row[\"is_starter\"] else \"\"\n            captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n            transfer_status = \"\"\n            if row[\"transfer_in\"]:\n                transfer_status = \"(IN)\"\n            elif row[\"transfer_out\"]:\n                transfer_status = \"(OUT)\"\n\n            player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n            print(\n                f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n            )\n        print(\"\\n--- Midfielders (Starting XI marked with *) ---\")\n        for index, row in selected_squad[\n            selected_squad[\"position\"] == \"MID\"\n        ].iterrows():\n            starter_str = \"*\" if row[\"is_starter\"] else \"\"\n            captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n            transfer_status = \"\"\n            if row[\"transfer_in\"]:\n                transfer_status = \"(IN)\"\n            elif row[\"transfer_out\"]:\n                transfer_status = \"(OUT)\"\n\n            player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n            print(\n                f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n            )\n        print(\"\\n--- Forwards (Starting XI marked with *) ---\")\n        for index, row in selected_squad[\n            selected_squad[\"position\"] == \"FWD\"\n        ].iterrows():\n            starter_str = \"*\" if row[\"is_starter\"] else \"\"\n            captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n            transfer_status = \"\"\n            if row[\"transfer_in\"]:\n                transfer_status = \"(IN)\"\n            elif row[\"transfer_out\"]:\n                transfer_status = \"(OUT)\"\n\n            player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n            print(\n                f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n            )\n\n        print(f\"\\n--- Team Breakdown for GW{gameweek} ---\")\n        print(selected_squad[\"team\"].value_counts())\n\n        # Transfers are relevant from Gameweek 2 (index 1) onwards in the optimization horizon\n        # For display, if the current GW is the initial one (GW1 in the current context), no transfers are made\n        # If it's a subsequent GW, check if transfers occurred.\n        first_gw_in_history = min(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n        if (\n            gameweek &gt;= first_gw_in_history\n        ):  # Changed from &gt; to &gt;=, to show initial free transfers\n            # Display transfer info for this gameweek\n            print(\n                f\"  Transfers In: {transfers_in_count}, Transfers Out: {transfers_out_count}\"\n            )\n            print(\n                f\"  Transfer Hits: {transfer_hits_taken} (-{transfer_hits_taken * POINTS_PER_HIT} points)\"\n            )\n            # Only show free transfers for the *next* gameweek if it's not the last gameweek in the horizon\n            if gameweek &lt; max(\n                int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n            ):\n                print(\n                    f\"  Free Transfers Available for Next GW: {free_transfers_available_next_gw}\"\n                )\n        print(\"---------------------------\\n\")\n\n    def print_overall_summary(self):\n        \"\"\"\n        Prints an overall summary of the multi-week optimization results.\n        \"\"\"\n        if not self.selected_squad_history:\n            print(\"No optimization results to summarize.\")\n            return\n\n        print(\"\\n=== Overall Multi-Week FPL Optimization Summary ===\")\n        print(\n            f\"Total Expected Points Across All Gameweeks: {self.total_expected_points:.2f}\"\n        )\n\n        # Get the latest gameweek's cost\n        last_gw_key = max(\n            self.selected_squad_history.keys(), key=lambda k: int(k.replace(\"GW\", \"\"))\n        )\n        print(\n            f\"Squad Cost ({last_gw_key}): \u00a3{self.selected_squad_history[last_gw_key]['total_cost']:.1f}m\"\n        )\n        print(\n            f\"Total Transfer Hits Taken: {self.total_transfer_hits} (-{self.total_transfer_hits * POINTS_PER_HIT} points)\"\n        )\n\n        print(\"\\n--- Chip Usage Across Gameweeks ---\")\n        # Ensure consistent order by sorting gameweek keys\n        sorted_gw_keys = sorted(\n            self.used_chips.keys(), key=lambda k: int(k.replace(\"GW\", \"\"))\n        )\n        for gw_str in sorted_gw_keys:\n            chips = self.used_chips[gw_str]\n            chip_summary = []\n            if chips[\"bench_boost\"]:\n                chip_summary.append(\"Bench Boost\")\n            if chips[\"triple_captain\"]:\n                chip_summary.append(\"Triple Captain\")\n\n            if chip_summary:\n                print(f\"{gw_str}: {', '.join(chip_summary)}\")\n            else:\n                print(f\"{gw_str}: No chips used\")\n\n        print(\"\\n--- Gameweek-by-Gameweek Summary ---\")\n        # Iterate and print basic summary for each gameweek\n        for gw_str in sorted_gw_keys:\n            gw_data = self.selected_squad_history[gw_str]\n            print(f\"\\n--- {gw_str} ---\")\n            print(f\"  Squad Cost: \u00a3{gw_data['total_cost']:.1f}m\")\n            print(\n                f\"  Expected Points (Starting XI): {gw_data['expected_points_from_xi']:.2f}\"\n            )\n            print(\n                f\"  Total GW Points (incl. chips): {gw_data['expected_points_from_xi'] + gw_data['total_bench_boost_points'] + gw_data['total_triple_captain_bonus']:.2f}\"\n            )\n\n            # Display transfer info for this gameweek\n            transfers_in_count = gw_data[\"transfers_in_count\"]\n            transfers_out_count = gw_data[\"transfers_out_count\"]\n            transfer_hits_taken = gw_data[\"transfer_hits\"]\n            free_transfers_available_next_gw = gw_data[\n                \"free_transfers_available_next_gw\"\n            ]\n\n            print(\n                f\"  Transfers In: {transfers_in_count}, Transfers Out: {transfers_out_count}\"\n            )\n            print(\n                f\"  Transfer Hits: {transfer_hits_taken} (-{transfer_hits_taken * POINTS_PER_HIT} points)\"\n            )\n            # Only show free transfers for the *next* gameweek if it's not the last gameweek in the horizon\n            if int(gw_str.replace(\"GW\", \"\")) &lt; max(\n                int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n            ):\n                print(\n                    f\"  Free Transfers Available for Next GW: {free_transfers_available_next_gw}\"\n                )\n            print(\"-----------------------------------\")\n</code></pre>"},{"location":"autoapi/fpl_solver/solver/#fpl_solver.solver.FPLOptimizer.__init__","title":"<code>__init__(player_data)</code>","text":"<p>Initializes the FPLOptimizer with player data.</p> <p>Parameters:</p> Name Type Description Default <code>player_data</code> <code>DataFrame</code> <p>A DataFrame containing player information                         with columns: 'name', 'team', 'position',                         'cost', 'expected_points_by_gw' (a dict of xP per GW).</p> required Source code in <code>fpl_solver/solver.py</code> <pre><code>def __init__(self, player_data: pd.DataFrame):\n    \"\"\"\n    Initializes the FPLOptimizer with player data.\n\n    Args:\n        player_data (pd.DataFrame): A DataFrame containing player information\n                                    with columns: 'name', 'team', 'position',\n                                    'cost', 'expected_points_by_gw' (a dict of xP per GW).\n    \"\"\"\n    required_columns = [\"name\", \"team\", \"position\", \"cost\", \"expected_points_by_gw\"]\n    if not all(col in player_data.columns for col in required_columns):\n        missing_cols = [\n            col for col in required_columns if col not in player_data.columns\n        ]\n        raise ValueError(\n            f\"player_data DataFrame must contain {required_columns} columns. Missing: {missing_cols}\"\n        )\n\n    self.player_data = player_data\n    self.problem = None\n    self.selected_squad_history = {}  # To store squad for each gameweek\n    self.total_cost = 0\n    self.total_expected_points = 0\n    self.total_transfer_hits = 0\n\n    # --- Process Enforced Players ---\n    self.enforced_player_indices = set()\n    self.enforced_team_pos_requirements = []\n\n    print(\"\\n--- Processing Enforced Players ---\")\n\n    # Enforce by Player ID\n    for player_id in ENFORCED_PLAYERS_BY_ID:\n        found_player = self.player_data[self.player_data[\"id\"] == player_id]\n        if not found_player.empty:\n            player_idx = found_player.index[0]\n            self.enforced_player_indices.add(player_idx)\n            print(\n                f\"Enforcing player by ID: {found_player.loc[player_idx, 'name']} (ID: {player_id})\"\n            )\n        else:\n            print(\n                f\"Warning: Enforced player with ID {player_id} not found in data.\"\n            )\n\n    # Enforce by Player Name\n    for player_name in ENFORCED_PLAYERS_BY_NAME:\n        found_player = self.player_data[self.player_data[\"name\"] == player_name]\n        if not found_player.empty:\n            player_idx = found_player.index[0]\n            self.enforced_player_indices.add(player_idx)\n            print(f\"Enforcing player by name: {player_name}\")\n        else:\n            print(f\"Warning: Enforced player '{player_name}' not found in data.\")\n\n    # Enforce by Team and Position\n    for requirement in ENFORCED_PLAYERS_BY_TEAM_AND_POSITION:\n        team = requirement.get(\"team\")\n        position = requirement.get(\"position\")\n        if team and position:\n            # Validate team and position exist in data\n            if team not in self.player_data[\"team\"].unique():\n                print(\n                    f\"Warning: Enforced team '{team}' for position '{position}' not found in data.\"\n                )\n                continue\n            if position not in self.player_data[\"position\"].unique():\n                print(\n                    f\"Warning: Enforced position '{position}' for team '{team}' not found in data.\"\n                )\n                continue\n\n            self.enforced_team_pos_requirements.append((team, position))\n            print(f\"Enforcing at least one {position} from {team}.\")\n        else:\n            print(\n                f\"Warning: Invalid enforced team/position requirement: {requirement}\"\n            )\n\n    if not (\n        self.enforced_player_indices\n        or self.enforced_team_pos_requirements\n        or ENFORCED_PLAYERS_BY_ID\n        or ENFORCED_PLAYERS_BY_NAME\n        or ENFORCED_PLAYERS_BY_TEAM_AND_POSITION\n    ):\n        print(\"No players or team/position combinations are enforced.\")\n    print(\"-----------------------------------\\n\")\n</code></pre>"},{"location":"autoapi/fpl_solver/solver/#fpl_solver.solver.FPLOptimizer.get_gameweek_summary","title":"<code>get_gameweek_summary(gameweek)</code>","text":"<p>Returns a dictionary summary for a specific gameweek.</p> Source code in <code>fpl_solver/solver.py</code> <pre><code>def get_gameweek_summary(self, gameweek: int):\n    \"\"\"\n    Returns a dictionary summary for a specific gameweek.\n    \"\"\"\n    if not self.selected_squad_history:\n        return None\n    first_gw_in_history = min(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n    last_gw_in_history = max(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n\n    if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n        print(\n            f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n        )\n        return None\n\n    return self.selected_squad_history.get(f\"GW{gameweek}\")\n</code></pre>"},{"location":"autoapi/fpl_solver/solver/#fpl_solver.solver.FPLOptimizer.get_selected_squad","title":"<code>get_selected_squad(gameweek=None)</code>","text":"<p>Returns the selected squad for a specific gameweek (1-indexed). If no gameweek is specified, returns the squad for the last optimized gameweek.</p> Source code in <code>fpl_solver/solver.py</code> <pre><code>def get_selected_squad(self, gameweek: int = None) -&gt; pd.DataFrame | None:\n    \"\"\"\n    Returns the selected squad for a specific gameweek (1-indexed).\n    If no gameweek is specified, returns the squad for the last optimized gameweek.\n    \"\"\"\n    if not self.selected_squad_history:\n        return None\n\n    # Get the first GW key to determine the range of available GWs\n    first_gw_in_history = min(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n    last_gw_in_history = max(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n\n    if gameweek is None:\n        return self.selected_squad_history[f\"GW{last_gw_in_history}\"][\"squad\"]\n\n    if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n        print(\n            f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n        )\n        return None\n\n    return self.selected_squad_history.get(f\"GW{gameweek}\", {}).get(\"squad\")\n</code></pre>"},{"location":"autoapi/fpl_solver/solver/#fpl_solver.solver.FPLOptimizer.get_total_cost","title":"<code>get_total_cost(gameweek=None)</code>","text":"<p>Returns the total cost for a specific gameweek (1-indexed). If no gameweek is specified, returns the cost of the squad in the last optimized gameweek.</p> Source code in <code>fpl_solver/solver.py</code> <pre><code>def get_total_cost(self, gameweek: int = None) -&gt; float:\n    \"\"\"\n    Returns the total cost for a specific gameweek (1-indexed).\n    If no gameweek is specified, returns the cost of the squad in the last optimized gameweek.\n    \"\"\"\n    if not self.selected_squad_history:\n        return 0\n    first_gw_in_history = min(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n    last_gw_in_history = max(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n\n    if gameweek is None:\n        return self.selected_squad_history[f\"GW{last_gw_in_history}\"][\"total_cost\"]\n\n    if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n        print(\n            f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n        )\n        return 0  # Or raise an error\n\n    return self.selected_squad_history.get(f\"GW{gameweek}\", {}).get(\"total_cost\", 0)\n</code></pre>"},{"location":"autoapi/fpl_solver/solver/#fpl_solver.solver.FPLOptimizer.get_total_expected_points","title":"<code>get_total_expected_points()</code>","text":"<p>Returns the overall total expected points across all optimized gameweeks.</p> Source code in <code>fpl_solver/solver.py</code> <pre><code>def get_total_expected_points(self) -&gt; float:\n    \"\"\"\n    Returns the overall total expected points across all optimized gameweeks.\n    \"\"\"\n    return self.total_expected_points\n</code></pre>"},{"location":"autoapi/fpl_solver/solver/#fpl_solver.solver.FPLOptimizer.print_overall_summary","title":"<code>print_overall_summary()</code>","text":"<p>Prints an overall summary of the multi-week optimization results.</p> Source code in <code>fpl_solver/solver.py</code> <pre><code>def print_overall_summary(self):\n    \"\"\"\n    Prints an overall summary of the multi-week optimization results.\n    \"\"\"\n    if not self.selected_squad_history:\n        print(\"No optimization results to summarize.\")\n        return\n\n    print(\"\\n=== Overall Multi-Week FPL Optimization Summary ===\")\n    print(\n        f\"Total Expected Points Across All Gameweeks: {self.total_expected_points:.2f}\"\n    )\n\n    # Get the latest gameweek's cost\n    last_gw_key = max(\n        self.selected_squad_history.keys(), key=lambda k: int(k.replace(\"GW\", \"\"))\n    )\n    print(\n        f\"Squad Cost ({last_gw_key}): \u00a3{self.selected_squad_history[last_gw_key]['total_cost']:.1f}m\"\n    )\n    print(\n        f\"Total Transfer Hits Taken: {self.total_transfer_hits} (-{self.total_transfer_hits * POINTS_PER_HIT} points)\"\n    )\n\n    print(\"\\n--- Chip Usage Across Gameweeks ---\")\n    # Ensure consistent order by sorting gameweek keys\n    sorted_gw_keys = sorted(\n        self.used_chips.keys(), key=lambda k: int(k.replace(\"GW\", \"\"))\n    )\n    for gw_str in sorted_gw_keys:\n        chips = self.used_chips[gw_str]\n        chip_summary = []\n        if chips[\"bench_boost\"]:\n            chip_summary.append(\"Bench Boost\")\n        if chips[\"triple_captain\"]:\n            chip_summary.append(\"Triple Captain\")\n\n        if chip_summary:\n            print(f\"{gw_str}: {', '.join(chip_summary)}\")\n        else:\n            print(f\"{gw_str}: No chips used\")\n\n    print(\"\\n--- Gameweek-by-Gameweek Summary ---\")\n    # Iterate and print basic summary for each gameweek\n    for gw_str in sorted_gw_keys:\n        gw_data = self.selected_squad_history[gw_str]\n        print(f\"\\n--- {gw_str} ---\")\n        print(f\"  Squad Cost: \u00a3{gw_data['total_cost']:.1f}m\")\n        print(\n            f\"  Expected Points (Starting XI): {gw_data['expected_points_from_xi']:.2f}\"\n        )\n        print(\n            f\"  Total GW Points (incl. chips): {gw_data['expected_points_from_xi'] + gw_data['total_bench_boost_points'] + gw_data['total_triple_captain_bonus']:.2f}\"\n        )\n\n        # Display transfer info for this gameweek\n        transfers_in_count = gw_data[\"transfers_in_count\"]\n        transfers_out_count = gw_data[\"transfers_out_count\"]\n        transfer_hits_taken = gw_data[\"transfer_hits\"]\n        free_transfers_available_next_gw = gw_data[\n            \"free_transfers_available_next_gw\"\n        ]\n\n        print(\n            f\"  Transfers In: {transfers_in_count}, Transfers Out: {transfers_out_count}\"\n        )\n        print(\n            f\"  Transfer Hits: {transfer_hits_taken} (-{transfer_hits_taken * POINTS_PER_HIT} points)\"\n        )\n        # Only show free transfers for the *next* gameweek if it's not the last gameweek in the horizon\n        if int(gw_str.replace(\"GW\", \"\")) &lt; max(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        ):\n            print(\n                f\"  Free Transfers Available for Next GW: {free_transfers_available_next_gw}\"\n            )\n        print(\"-----------------------------------\")\n</code></pre>"},{"location":"autoapi/fpl_solver/solver/#fpl_solver.solver.FPLOptimizer.print_squad_summary","title":"<code>print_squad_summary(gameweek)</code>","text":"<p>Prints a formatted summary of the selected squad for a specific gameweek.</p> Source code in <code>fpl_solver/solver.py</code> <pre><code>def print_squad_summary(self, gameweek: int):\n    \"\"\"\n    Prints a formatted summary of the selected squad for a specific gameweek.\n    \"\"\"\n    if not self.selected_squad_history:\n        print(\"No squad has been selected yet. Run the 'solve' method first.\")\n        return\n\n    gw_data = self.get_gameweek_summary(gameweek)\n    if not gw_data:\n        return  # get_gameweek_summary already prints error message\n\n    selected_squad = gw_data[\"squad\"]\n    total_cost = gw_data[\"total_cost\"]\n    expected_points_from_xi = gw_data[\"expected_points_from_xi\"]\n    bench_boost_used = gw_data[\"bench_boost_used\"]\n    triple_captain_used = gw_data[\"triple_captain_used\"]\n    total_bench_boost_points = gw_data[\"total_bench_boost_points\"]\n    total_triple_captain_bonus = gw_data[\"total_triple_captain_bonus\"]\n    transfers_in_count = gw_data[\"transfers_in_count\"]  # New\n    transfers_out_count = gw_data[\"transfers_out_count\"]  # New\n    transfer_hits_taken = gw_data[\"transfer_hits\"]  # New\n    free_transfers_available_next_gw = gw_data[\n        \"free_transfers_available_next_gw\"\n    ]  # New\n\n    print(f\"\\n--- FPL Optimized Squad for Gameweek {gameweek} ---\")\n    print(f\"Squad Cost: \u00a3{total_cost:.1f}m\")\n    print(f\"Expected Points (Starting XI): {expected_points_from_xi:.2f}\")\n    print(\n        f\"Total Expected Points for GW{gameweek} (including chips): {expected_points_from_xi + total_bench_boost_points + total_triple_captain_bonus:.2f}\"\n    )\n    print(\"\\n--- Chips Used This Gameweek ---\")\n    if bench_boost_used:\n        print(f\"- Bench Boost (Added {total_bench_boost_points:.2f} points)\")\n    if triple_captain_used:\n        print(\n            f\"- Triple Captain (Added {total_triple_captain_bonus:.2f} bonus points)\"\n        )\n    if not (bench_boost_used or triple_captain_used):\n        print(\"No chips used this gameweek.\")\n\n    print(\"\\n--- Goalkeepers (Starting XI marked with *) ---\")\n    for index, row in selected_squad[selected_squad[\"position\"] == \"GK\"].iterrows():\n        starter_str = \"*\" if row[\"is_starter\"] else \"\"\n        captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n        transfer_status = \"\"\n        if row[\"transfer_in\"]:\n            transfer_status = \"(IN)\"\n        elif row[\"transfer_out\"]:\n            transfer_status = \"(OUT)\"\n\n        # Access gameweek-specific xP correctly\n        player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n        print(\n            f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n        )\n    print(\"\\n--- Defenders (Starting XI marked with *) ---\")\n    for index, row in selected_squad[\n        selected_squad[\"position\"] == \"DEF\"\n    ].iterrows():\n        starter_str = \"*\" if row[\"is_starter\"] else \"\"\n        captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n        transfer_status = \"\"\n        if row[\"transfer_in\"]:\n            transfer_status = \"(IN)\"\n        elif row[\"transfer_out\"]:\n            transfer_status = \"(OUT)\"\n\n        player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n        print(\n            f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n        )\n    print(\"\\n--- Midfielders (Starting XI marked with *) ---\")\n    for index, row in selected_squad[\n        selected_squad[\"position\"] == \"MID\"\n    ].iterrows():\n        starter_str = \"*\" if row[\"is_starter\"] else \"\"\n        captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n        transfer_status = \"\"\n        if row[\"transfer_in\"]:\n            transfer_status = \"(IN)\"\n        elif row[\"transfer_out\"]:\n            transfer_status = \"(OUT)\"\n\n        player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n        print(\n            f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n        )\n    print(\"\\n--- Forwards (Starting XI marked with *) ---\")\n    for index, row in selected_squad[\n        selected_squad[\"position\"] == \"FWD\"\n    ].iterrows():\n        starter_str = \"*\" if row[\"is_starter\"] else \"\"\n        captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n        transfer_status = \"\"\n        if row[\"transfer_in\"]:\n            transfer_status = \"(IN)\"\n        elif row[\"transfer_out\"]:\n            transfer_status = \"(OUT)\"\n\n        player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n        print(\n            f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n        )\n\n    print(f\"\\n--- Team Breakdown for GW{gameweek} ---\")\n    print(selected_squad[\"team\"].value_counts())\n\n    # Transfers are relevant from Gameweek 2 (index 1) onwards in the optimization horizon\n    # For display, if the current GW is the initial one (GW1 in the current context), no transfers are made\n    # If it's a subsequent GW, check if transfers occurred.\n    first_gw_in_history = min(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n    if (\n        gameweek &gt;= first_gw_in_history\n    ):  # Changed from &gt; to &gt;=, to show initial free transfers\n        # Display transfer info for this gameweek\n        print(\n            f\"  Transfers In: {transfers_in_count}, Transfers Out: {transfers_out_count}\"\n        )\n        print(\n            f\"  Transfer Hits: {transfer_hits_taken} (-{transfer_hits_taken * POINTS_PER_HIT} points)\"\n        )\n        # Only show free transfers for the *next* gameweek if it's not the last gameweek in the horizon\n        if gameweek &lt; max(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        ):\n            print(\n                f\"  Free Transfers Available for Next GW: {free_transfers_available_next_gw}\"\n            )\n    print(\"---------------------------\\n\")\n</code></pre>"},{"location":"autoapi/fpl_solver/solver/#fpl_solver.solver.FPLOptimizer.solve","title":"<code>solve(budget, max_players_per_team, chip_allowances, num_gameweeks)</code>","text":"<p>Solves the FPL optimization problem using PuLP.</p> <p>Parameters:</p> Name Type Description Default <code>budget</code> <code>float</code> <p>The maximum budget in millions of pounds.</p> required <code>max_players_per_team</code> <code>int</code> <p>The maximum number of players allowed from                         any single Premier League team.</p> required <code>chip_allowances</code> <code>dict</code> <p>A dictionary specifying the maximum usage for each chip.</p> required <code>num_gameweeks</code> <code>int</code> <p>The number of gameweeks to optimize over.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if a solution was found, False otherwise.</p> Source code in <code>fpl_solver/solver.py</code> <pre><code>def solve(\n    self,\n    budget: float,\n    max_players_per_team: int,\n    chip_allowances: dict,\n    num_gameweeks: int,\n) -&gt; bool:\n    \"\"\"\n    Solves the FPL optimization problem using PuLP.\n\n    Args:\n        budget (float): The maximum budget in millions of pounds.\n        max_players_per_team (int): The maximum number of players allowed from\n                                    any single Premier League team.\n        chip_allowances (dict): A dictionary specifying the maximum usage for each chip.\n        num_gameweeks (int): The number of gameweeks to optimize over.\n\n    Returns:\n        bool: True if a solution was found, False otherwise.\n    \"\"\"\n    self.problem = LpProblem(\"FPL Squad Multi-Week Optimization\", LpMaximize)\n\n    # Decision variables for player selection, indexed by player and gameweek\n    player_vars = LpVariable.dicts(\n        \"Player\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n    )\n    starting_xi_vars = LpVariable.dicts(\n        \"StartingXI\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n    )\n    captain_var = LpVariable.dicts(\n        \"Captain\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n    )\n\n    # Binary variables for chip usage, indexed by gameweek\n    use_bench_boost = LpVariable.dicts(\n        \"Use_Bench_Boost\", range(num_gameweeks), 0, 1, LpBinary\n    )\n    use_triple_captain = LpVariable.dicts(\n        \"Use_Triple_Captain\", range(num_gameweeks), 0, 1, LpBinary\n    )\n\n    # Transfer variables\n    transfer_in_vars = LpVariable.dicts(\n        \"Transfer_In\",\n        (self.player_data.index, range(1, num_gameweeks)),\n        0,\n        1,\n        LpBinary,\n    )\n    transfer_out_vars = LpVariable.dicts(\n        \"Transfer_Out\",\n        (self.player_data.index, range(1, num_gameweeks)),\n        0,\n        1,\n        LpBinary,\n    )\n\n    # Total transfers made in a gameweek (absolute count)\n    transfers_made = LpVariable.dicts(\n        \"Transfers_Made\", range(1, num_gameweeks), 0, None, LpInteger\n    )\n    # Free transfers available at the start of a gameweek\n    free_transfers_available = LpVariable.dicts(\n        \"Free_Transfers_Available\",\n        range(num_gameweeks),\n        0,\n        MAX_FREE_TRANSFERS_SAVED + 1,\n        LpInteger,\n    )\n    # Number of transfer hits taken in a gameweek\n    transfer_hits = LpVariable.dicts(\n        \"Transfer_Hits\", range(1, num_gameweeks), 0, None, LpInteger\n    )\n\n    # Auxiliary variables for linearizing chip effects\n    is_bench_player = LpVariable.dicts(\n        \"Is_Bench_Player\",\n        (self.player_data.index, range(num_gameweeks)),\n        0,\n        1,\n        LpBinary,\n    )\n    actual_bench_boost_points = LpVariable.dicts(\n        \"Actual_Bench_Boost_Points\",\n        (self.player_data.index, range(num_gameweeks)),\n        0,\n        None,\n        LpContinuous,\n    )\n    actual_triple_captain_bonus = LpVariable.dicts(\n        \"Actual_Triple_Captain_Bonus\",\n        (self.player_data.index, range(num_gameweeks)),\n        0,\n        None,\n        LpContinuous,\n    )\n\n    # --- Objective Function ---\n    total_objective_points = []\n\n    # Get the first gameweek number from the player data to correctly index expected_points_by_gw\n    first_gw_key = next(\n        iter(\n            self.player_data.loc[\n                self.player_data.index[0], \"expected_points_by_gw\"\n            ].keys()\n        )\n    )\n    current_gameweek_number_start = int(first_gw_key)\n\n    for w in range(num_gameweeks):\n        # The actual gameweek number (1-indexed)\n        gw_actual = current_gameweek_number_start + w\n\n        # Base expected points from the selected starting 11 for this gameweek\n        base_points_expression_gw = lpSum(\n            self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n            * starting_xi_vars[i][w]\n            for i in self.player_data.index\n        )\n        total_objective_points.append(base_points_expression_gw)\n\n        # Regular Captaincy points (additional 1x for captain)\n        captain_points_bonus_gw = lpSum(\n            self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n            * captain_var[i][w]\n            for i in self.player_data.index\n        )\n        total_objective_points.append(captain_points_bonus_gw)\n\n        # Define auxiliary variables and constraints for chips for each gameweek\n        for i in self.player_data.index:\n            # Use gameweek-specific player xP for chip calculations\n            player_xp = self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n\n            # Bench Boost auxiliary variables and constraints\n            self.problem += (\n                is_bench_player[i][w] &lt;= player_vars[i][w],\n                f\"IsBench_Squad_{i}_{w}\",\n            )\n            self.problem += (\n                is_bench_player[i][w] &lt;= 1 - starting_xi_vars[i][w],\n                f\"IsBench_NotStarter_{i}_{w}\",\n            )\n            self.problem += (\n                is_bench_player[i][w]\n                &gt;= player_vars[i][w] + (1 - starting_xi_vars[i][w]) - 1,\n                f\"IsBench_Logical_{i}_{w}\",\n            )\n\n            self.problem += (\n                actual_bench_boost_points[i][w]\n                &lt;= player_xp * is_bench_player[i][w],\n                f\"BenchBoost_Contr_1_{i}_{w}\",\n            )\n            self.problem += (\n                actual_bench_boost_points[i][w] &lt;= player_xp * use_bench_boost[w],\n                f\"BenchBoost_Contr_2_{i}_{w}\",\n            )\n            self.problem += (\n                actual_bench_boost_points[i][w]\n                &gt;= player_xp * (is_bench_player[i][w] + use_bench_boost[w] - 1),\n                f\"BenchBoost_Contr_3_{i}_{w}\",\n            )\n            self.problem += (\n                actual_bench_boost_points[i][w] &gt;= 0,\n                f\"BenchBoost_Contr_4_{i}_{w}\",\n            )\n\n            # Triple Captain auxiliary variables and constraints\n            # Changed player_xp * 2 to player_xp to reflect additional 1x bonus\n            self.problem += (\n                actual_triple_captain_bonus[i][w] &lt;= player_xp * captain_var[i][w],\n                f\"TripleCaptain_Contr_1_{i}_{w}\",\n            )\n            self.problem += (\n                actual_triple_captain_bonus[i][w]\n                &lt;= player_xp * use_triple_captain[w],\n                f\"TripleCaptain_Contr_2_{i}_{w}\",\n            )\n            self.problem += (\n                actual_triple_captain_bonus[i][w]\n                &gt;= player_xp * (captain_var[i][w] + use_triple_captain[w] - 1),\n                f\"TripleCaptain_Contr_3_{i}_{w}\",\n            )\n            self.problem += (\n                actual_triple_captain_bonus[i][w] &gt;= 0,\n                f\"TripleCaptain_Contr_4_{i}_{w}\",\n            )\n\n        # Add points from bench boost and triple captain bonus for this gameweek\n        total_bench_boost_points_gw = lpSum(\n            actual_bench_boost_points[i][w] for i in self.player_data.index\n        )\n        total_triple_captain_bonus_points_gw = lpSum(\n            actual_triple_captain_bonus[i][w] for i in self.player_data.index\n        )\n\n        total_objective_points.append(total_bench_boost_points_gw)\n        total_objective_points.append(total_triple_captain_bonus_points_gw)\n\n    # Subtract transfer hits from the total objective\n    total_objective_points.append(\n        -POINTS_PER_HIT * lpSum(transfer_hits[w] for w in range(1, num_gameweeks))\n    )\n\n    self.problem += (\n        lpSum(total_objective_points),\n        \"Total Expected Points Over Gameweeks\",\n    )\n\n    # --- Constraints ---\n\n    # Apply constraints for each gameweek\n    for w in range(num_gameweeks):\n        # 1. Select exactly 15 players for the squad\n        self.problem += (\n            lpSum(player_vars[i][w] for i in self.player_data.index) == 15,\n            f\"Total_Players_GW{w}\",\n        )\n\n        # 2. Squad position constraints (2 GKs, 5 DEFs, 5 MIDs, 3 FWDs)\n        gks = self.player_data[self.player_data[\"position\"] == \"GK\"].index\n        defs = self.player_data[self.player_data[\"position\"] == \"DEF\"].index\n        mids = self.player_data[self.player_data[\"position\"] == \"MID\"].index\n        fwds = self.player_data[self.player_data[\"position\"] == \"FWD\"].index\n\n        self.problem += (\n            lpSum(player_vars[i][w] for i in gks) == 2,\n            f\"Goalkeepers_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(player_vars[i][w] for i in defs) == 5,\n            f\"Defenders_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(player_vars[i][w] for i in mids) == 5,\n            f\"Midfielders_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(player_vars[i][w] for i in fwds) == 3,\n            f\"Forwards_Count_GW{w}\",\n        )\n\n        # 3. Budget constraint\n        # This applies to the cost of the squad for the current gameweek.\n        self.problem += (\n            lpSum(\n                self.player_data.loc[i, \"cost\"] * player_vars[i][w]\n                for i in self.player_data.index\n            )\n            &lt;= budget,\n            f\"Total_Budget_GW{w}\",\n        )\n\n        # 4. Maximum players per team constraint\n        for team in self.player_data[\"team\"].unique():\n            team_players = self.player_data[self.player_data[\"team\"] == team].index\n            self.problem += (\n                lpSum(player_vars[i][w] for i in team_players)\n                &lt;= max_players_per_team,\n                f\"Max_Players_from_{team}_GW{w}\",\n            )\n\n        # 5. Starting XI constraints\n        # 5.1 Select exactly 11 players for the starting XI\n        self.problem += (\n            lpSum(starting_xi_vars[i][w] for i in self.player_data.index) == 11,\n            f\"Total_Starting_XI_Players_GW{w}\",\n        )\n\n        # 5.2 A player can only be in the starting XI if they are in the squad\n        for i in self.player_data.index:\n            self.problem += (\n                starting_xi_vars[i][w] &lt;= player_vars[i][w],\n                f\"StartingXI_in_Squad_{i}_{w}\",\n            )\n\n        # 5.3 Starting XI position constraints (FPL allows flexible formations, so use minimums)\n        self.problem += (\n            lpSum(starting_xi_vars[i][w] for i in gks) == 1,\n            f\"Starting_Goalkeepers_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(starting_xi_vars[i][w] for i in defs) &gt;= 3,\n            f\"Min_Starting_Defenders_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(starting_xi_vars[i][w] for i in mids) &gt;= 2,\n            f\"Min_Starting_Midfielders_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(starting_xi_vars[i][w] for i in fwds) &gt;= 1,\n            f\"Min_Starting_Forwards_Count_GW{w}\",\n        )\n\n        # 6. Captain Constraints\n        # 6.1 Select exactly one captain from the starting XI\n        self.problem += (\n            lpSum(captain_var[i][w] for i in self.player_data.index) == 1,\n            f\"One_Captain_GW{w}\",\n        )\n\n        # 6.2 A player can only be captain if they are in the starting XI\n        for i in self.player_data.index:\n            self.problem += (\n                captain_var[i][w] &lt;= starting_xi_vars[i][w],\n                f\"Captain_in_StartingXI_{i}_{w}\",\n            )\n\n        # --- Enforced Player Constraints---\n        for player_idx in self.enforced_player_indices:\n            self.problem += (\n                player_vars[player_idx][w] == 1,\n                f\"Enforce_Player_{self.player_data.loc[player_idx, 'name']}_GW{w}\",\n            )\n\n        for team, position in self.enforced_team_pos_requirements:\n            # Filter players for the current team and position\n            team_pos_players = self.player_data[\n                (self.player_data[\"team\"] == team)\n                &amp; (self.player_data[\"position\"] == position)\n            ].index\n            if not team_pos_players.empty:\n                self.problem += (\n                    lpSum(player_vars[i][w] for i in team_pos_players) &gt;= 1,\n                    f\"Enforce_One_{position}_from_{team}_GW{w}\",\n                )\n            else:\n                print(\n                    f\"Warning: No players found for enforced requirement: at least one {position} from {team} for GW{gw_actual}.\"\n                )\n\n    # --- Chip Usage Constraints (TOTAL usage over all gameweeks) ---\n    # These constraints should be outside the per-gameweek loop to avoid duplicates.\n    self.problem += (\n        lpSum(use_bench_boost[j] for j in range(num_gameweeks))\n        &lt;= chip_allowances.get(\"bench_boost\", 0),\n        f\"Max_Bench_Boost_Usage_Total\",\n    )\n    self.problem += (\n        lpSum(use_triple_captain[j] for j in range(num_gameweeks))\n        &lt;= chip_allowances.get(\"triple_captain\", 0),\n        f\"Max_Triple_Captain_Usage_Total\",\n    )\n\n    # --- Inter-Gameweek Constraints (Transfers and Transfer Rules) ---\n    # Initialize free transfers for GW0 (first gameweek of optimization horizon)\n    # This assumes the optimization starts at GW0, and it has INITIAL_FREE_TRANSFERS.\n    # If the model starts at an arbitrary GW, this would need to be an input.\n    self.problem += (\n        free_transfers_available[0] == INITIAL_FREE_TRANSFERS,\n        f\"Initial_Free_Transfers_GW0\",\n    )\n\n    for w in range(1, num_gameweeks):\n        # Calculate total transfers made in this gameweek\n        self.problem += (\n            transfers_made[w]\n            == lpSum(transfer_in_vars[i][w] for i in self.player_data.index),\n            f\"Transfers_Made_GW{w}\",\n        )\n        # Total transfers in must equal total transfers out for each gameweek after the first\n        self.problem += (\n            lpSum(transfer_in_vars[i][w] for i in self.player_data.index)\n            == lpSum(transfer_out_vars[i][w] for i in self.player_data.index),\n            f\"Transfers_In_Equals_Out_GW{w}\",\n        )\n\n        # Calculate free transfers available for the current gameweek (w)\n        # Free transfers for GW_w = min(free transfers from GW_w-1 - transfers made in GW_w + 1, MAX_FREE_TRANSFERS_SAVED + 1)\n        # The + 1 in MAX_FREE_TRANSFERS_SAVED + 1 is because MAX_FREE_TRANSFERS_SAVED implies how many can be *saved*,\n        # so if you save 1, you have 1 (current) + 1 (saved) = 2.\n        self.problem += (\n            free_transfers_available[w]\n            &lt;= free_transfers_available[w - 1] - transfers_made[w] + 1,\n            f\"Free_Transfers_Calc_1_GW{w}\",\n        )\n        self.problem += (\n            free_transfers_available[w] &lt;= MAX_FREE_TRANSFERS_SAVED + 1,\n            f\"Free_Transfers_Calc_2_GW{w}\",\n        )\n        self.problem += (\n            free_transfers_available[w] &gt;= 0,  # Cannot have negative free transfers\n            f\"Free_Transfers_Non_Negative_GW{w}\",\n        )\n\n        # Calculate transfer hits\n        # transfer_hits[w] = max(0, transfers_made[w] - free_transfers_available_at_start_of_gw_w)\n        # This needs to be linearized. If transfers_made[w] &gt; free_transfers_available[w-1], then hit.\n        # free_transfers_available[w-1] represents transfers available *before* making transfers for GW_w\n        self.problem += (\n            transfer_hits[w] &gt;= transfers_made[w] - free_transfers_available[w - 1],\n            f\"Transfer_Hits_Calc_1_GW{w}\",\n        )\n        self.problem += (\n            transfer_hits[w] &gt;= 0,\n            f\"Transfer_Hits_Calc_2_GW{w}\",\n        )\n\n        for i in self.player_data.index:\n            # Squad continuity: player_vars[i][w] (in squad at start of GW w)\n            #                 = player_vars[i][w-1] (in squad at start of GW w-1)\n            #                 - transfer_out_vars[i][w] (transferred out for GW w)\n            #                 + transfer_in_vars[i][w] (transferred in for GW w)\n            self.problem += (\n                player_vars[i][w]\n                == player_vars[i][w - 1]\n                - transfer_out_vars[i][w]\n                + transfer_in_vars[i][w],\n                f\"Squad_Continuity_{i}_GW{w}\",\n            )\n            # A player cannot be transferred in and out in the same gameweek\n            self.problem += (\n                transfer_in_vars[i][w] + transfer_out_vars[i][w] &lt;= 1,\n                f\"No_Simultaneous_Transfer_{i}_{w}\",\n            )\n\n    try:\n        # The solver is called with the GLPK_CMD solver\n        self.problem.solve(PULP_CBC_CMD(msg=0))  # msg=0 suppresses verbose output\n    except Exception as e:\n        print(f\"Error solving the problem: {e}\")\n        return False\n\n    if LpStatus[self.problem.status] == \"Optimal\":\n        print(\"Optimization successful! Optimal solution found.\")\n\n        self.selected_squad_history = {}\n        self.total_transfer_hits = 0\n        for w in range(num_gameweeks):\n            # The actual gameweek number (1-indexed)\n            gw_actual = current_gameweek_number_start + w\n\n            # Get selected players for the current gameweek\n            selected_squad_gw = self.player_data[\n                [player_vars[i][w].varValue == 1 for i in self.player_data.index]\n            ].copy()\n\n            # Get starter and captain info for this gameweek\n            is_starter_series_gw = pd.Series(\n                [\n                    starting_xi_vars[i][w].varValue == 1\n                    for i in self.player_data.index\n                ],\n                index=self.player_data.index,\n            )\n            is_captain_series_gw = pd.Series(\n                [captain_var[i][w].varValue == 1 for i in self.player_data.index],\n                index=self.player_data.index,\n            )\n\n            selected_squad_gw[\"is_starter\"] = is_starter_series_gw.loc[\n                selected_squad_gw.index\n            ]\n            selected_squad_gw[\"is_captain\"] = is_captain_series_gw.loc[\n                selected_squad_gw.index\n            ]\n\n            transfers_in_gw = 0\n            transfers_out_gw = 0\n            hits_gw = 0\n\n            # Store transfer details for gameweeks &gt; 0\n            if (\n                w &gt; 0\n            ):  # Check for transfers only from GW1 onwards (index 1 in 0-indexed loop)\n                transfer_in_flags = pd.Series(\n                    [\n                        transfer_in_vars[i][w].varValue == 1\n                        for i in self.player_data.index\n                    ],\n                    index=self.player_data.index,\n                )\n                transfer_out_flags = pd.Series(\n                    [\n                        transfer_out_vars[i][w].varValue == 1\n                        for i in self.player_data.index\n                    ],\n                    index=self.player_data.index,\n                )\n\n                selected_squad_gw[\"transfer_in\"] = transfer_in_flags.loc[\n                    selected_squad_gw.index\n                ]\n                selected_squad_gw[\"transfer_out\"] = transfer_out_flags.loc[\n                    selected_squad_gw.index\n                ]\n\n                transfers_in_gw = int(round(transfer_in_flags.sum()))\n                transfers_out_gw = int(round(transfer_out_flags.sum()))\n                hits_gw = int(round(transfer_hits[w].varValue))\n                self.total_transfer_hits += hits_gw\n            else:\n                selected_squad_gw[\"transfer_in\"] = False  # No transfers in for GW0\n                selected_squad_gw[\"transfer_out\"] = (\n                    False  # No transfers out for GW0\n                )\n\n            self.selected_squad_history[f\"GW{gw_actual}\"] = {\n                \"squad\": selected_squad_gw,\n                \"total_cost\": selected_squad_gw[\"cost\"].sum(),\n                \"expected_points_from_xi\": sum(\n                    self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n                    * starting_xi_vars[i][w].varValue\n                    for i in self.player_data.index\n                ),\n                \"bench_boost_used\": bool(use_bench_boost[w].varValue),\n                \"triple_captain_used\": bool(use_triple_captain[w].varValue),\n                \"total_bench_boost_points\": value(\n                    lpSum(\n                        actual_bench_boost_points[i][w]\n                        for i in self.player_data.index\n                    )\n                ),\n                \"total_triple_captain_bonus\": value(\n                    lpSum(\n                        actual_triple_captain_bonus[i][w]\n                        for i in self.player_data.index\n                    )\n                ),\n                \"transfers_in_count\": transfers_in_gw,\n                \"transfers_out_count\": transfers_out_gw,\n                \"transfer_hits\": hits_gw,  # New\n                \"free_transfers_available_next_gw\": (\n                    int(round(free_transfers_available[w].varValue))\n                    if w &lt; num_gameweeks - 1\n                    else 0\n                ),  # Free transfers available *after* this GW's transfers are made\n            }\n\n        # Overall totals\n        self.total_cost = self.selected_squad_history[\n            f\"GW{current_gameweek_number_start + num_gameweeks - 1}\"\n        ][\n            \"total_cost\"\n        ]  # Cost of final squad\n        self.total_expected_points = value(\n            self.problem.objective\n        )  # Total objective value from solver\n        self.used_chips = {\n            f\"GW{current_gameweek_number_start + w}\": {\n                \"bench_boost\": bool(use_bench_boost[w].varValue),\n                \"triple_captain\": bool(use_triple_captain[w].varValue),\n            }\n            for w in range(num_gameweeks)\n        }\n\n        return True\n    else:\n        print(f\"No optimal solution found. Status: {LpStatus[self.problem.status]}\")\n        self.selected_squad_history = {}\n        self.total_cost = 0\n        self.total_expected_points = 0\n        self.used_chips = {}\n        self.total_transfer_hits = 0\n        return False\n</code></pre>"},{"location":"autoapi/fpl_solver/xp_predictor/","title":"xp_predictor","text":"<p>FPL Expected Points (xP) Predictor Module.</p> <p>This module provides functionality to predict Fantasy Premier League (FPL) points for players based on historical data, team strengths, and fixture difficulty.</p>"},{"location":"autoapi/fpl_solver/xp_predictor/#fpl_solver.xp_predictor.FPLPredictor","title":"<code>FPLPredictor</code>","text":"<p>Predictive algorithm for Expected Points (xP) in Fantasy Premier League, using real data from the FPL API.</p> <p>This class handles: - Fetching and processing FPL API data - Calculating expected points based on multiple factors - Managing player exclusions and filtering - Providing fixture and player data for optimization</p> <p>Attributes:</p> Name Type Description <code>gameweeks_to_predict</code> <code>int</code> <p>Number of future gameweeks to analyze</p> <code>players_data</code> <code>Dict</code> <p>Player statistics and information</p> <code>teams_data</code> <code>Dict</code> <p>Team statistics and attributes</p> <code>fixtures_data</code> <code>Dict</code> <p>Upcoming and historical match data</p> <code>all_players_xp_calculated_data</code> <code>List</code> <p>Processed xP calculations</p> Source code in <code>fpl_solver/xp_predictor.py</code> <pre><code>class FPLPredictor:\n    \"\"\"\n    Predictive algorithm for Expected Points (xP) in Fantasy Premier League,\n    using real data from the FPL API.\n\n    This class handles:\n    - Fetching and processing FPL API data\n    - Calculating expected points based on multiple factors\n    - Managing player exclusions and filtering\n    - Providing fixture and player data for optimization\n\n    Attributes:\n        gameweeks_to_predict (int): Number of future gameweeks to analyze\n        players_data (Dict): Player statistics and information\n        teams_data (Dict): Team statistics and attributes\n        fixtures_data (Dict): Upcoming and historical match data\n        all_players_xp_calculated_data (List): Processed xP calculations\n    \"\"\"\n\n    def __init__(self, gameweeks_to_predict: int = 1):\n        \"\"\"\n        Initialize the FPLPredictor with data structures and fetch initial data.\n\n        Args:\n            gameweeks_to_predict: Number of upcoming gameweeks to calculate\n                                expected points for. Default is 1 (next gameweek).\n\n        Raises:\n            ValueError: If gameweeks_to_predict is not a positive integer\n        \"\"\"\n        self.logger = setup_logger(__name__)\n        if not isinstance(gameweeks_to_predict, int) or gameweeks_to_predict &lt; 1:\n            msg = f\"gameweeks_to_predict must be a positive integer, got {gameweeks_to_predict}\"\n            self.logger.error(msg)\n            raise ValueError(msg)\n\n        self.gameweeks_to_predict = gameweeks_to_predict\n        self.logger.info(f\"Initializing FPL Predictor for {gameweeks_to_predict} gameweek(s)\")\n\n        # Initialize cache manager\n        cache_dir = os.path.join(os.path.dirname(__file__), 'cache')\n        self.cache_manager = CacheManager(cache_dir)\n\n        # Configuration and static data\n        self.fpl_points: Dict[str, float] = FPL_POINTS\n        self.position_definitions: Dict[int, str] = {\n            1: \"GK\",\n            2: \"DEF\",\n            3: \"MID\",\n            4: \"FWD\",\n        }\n\n        # Data structures for FPL information\n        self.players_data: Dict[int, Dict] = {}\n        self.teams_data: Dict[int, Dict] = {}\n        self.fixtures_data: Dict[int, Dict] = {}\n        self.all_players_xp_calculated_data: List[Dict] = []\n\n        # Initialize data\n        try:\n            self._fetch_fpl_data()\n            self._calculate_all_players_xp()\n        except Exception as e:\n            self.logger.error(f\"Failed to initialize FPL Predictor: {str(e)}\")\n            raise\n\n    def _fetch_fpl_data(self) -&gt; None:\n        \"\"\"\n        Fetch and process data from the FPL API.\n\n        This method retrieves player, team, and fixture data from the FPL API,\n        processes it, and stores it in the appropriate data structures. It also\n        applies any configured player exclusions.\n\n        Raises:\n            requests.RequestException: If API requests fail\n            ValueError: If required data is missing from API response\n            Exception: For other unexpected errors\n        \"\"\"\n        self.logger.info(\"Fetching FPL data from API...\")\n\n        try:\n            # Helper function to fetch from API with caching\n            def fetch_api_data(url: str, endpoint: str) -&gt; dict:\n                # Try to get from cache first\n                cached_data = self.cache_manager.get_cached_response(endpoint)\n                if cached_data is not None:\n                    self.logger.info(f\"Using cached {endpoint} data\")\n                    return cached_data\n\n                # If not in cache or expired, fetch from API\n                try:\n                    self.logger.info(f\"Fetching {endpoint} data from API\")\n                    response = requests.get(url, timeout=10)\n                    response.raise_for_status()\n                    data = response.json()\n\n                    # Cache the response\n                    self.cache_manager.save_response(endpoint, data)\n                    return data\n\n                except requests.RequestException as e:\n                    self.logger.error(f\"Failed to fetch {endpoint} data: {str(e)}\")\n                    raise\n\n            # Fetch both endpoints\n            static_data = fetch_api_data(\n                \"https://fantasy.premierleague.com/api/bootstrap-static/\",\n                \"static\"\n            )\n            fixtures_data = fetch_api_data(\n                \"https://fantasy.premierleague.com/api/fixtures/\",\n                \"fixtures\"\n            )\n\n            # Process players data\n            if \"elements\" not in static_data:\n                raise ValueError(\"No player elements found in API response\")\n\n            self.logger.info(f\"Processing {len(static_data['elements'])} players...\")\n\n            def process_player_data(element: Dict) -&gt; Tuple[int, Dict]:\n                \"\"\"Helper function to process individual player data\"\"\"\n                try:\n                    player_id = element[\"id\"]\n                    return player_id, {\n                        \"name\": f\"{element['first_name']} {element['second_name']}\",\n                        \"web_name\": element[\"web_name\"],\n                        \"team_id\": element[\"team\"],\n                        \"element_type\": element[\"element_type\"],\n                        \"position\": self.position_definitions.get(\n                            element[\"element_type\"], \"Unknown\"\n                        ),\n                        \"cost_pence\": element[\"now_cost\"],\n                        \"status\": element[\"status\"],\n                        \"news\": element[\"news\"],\n                        \"total_points\": element[\"total_points\"],\n                        \"minutes\": element[\"minutes\"],\n                        \"goals_scored\": element[\"goals_scored\"],\n                        \"assists\": element[\"assists\"],\n                        \"clean_sheets\": element[\"clean_sheets\"],\n                        \"goals_conceded\": element[\"goals_conceded\"],\n                        \"penalties_saved\": element[\"penalties_saved\"],\n                        \"penalties_missed\": element[\"penalties_missed\"],\n                        \"yellow_cards\": element[\"yellow_cards\"],\n                        \"red_cards\": element[\"red_cards\"],\n                        \"own_goals\": element[\"own_goals\"],\n                        \"saves\": element[\"saves\"],\n                        \"bonus\": element[\"bonus\"],\n                        \"bps\": element[\"bps\"],\n                        \"threat\": float(element.get(\"threat\", 0)),\n                        \"creativity\": float(element.get(\"creativity\", 0)),\n                        \"influence\": float(element.get(\"influence\", 0)),\n                        \"form\": float(element.get(\"form\", 0)),\n                        \"points_per_game\": float(element.get(\"points_per_game\", 0)),\n                        \"value_season\": float(element.get(\"value_season\", 0)),\n                        \"value_form\": float(element.get(\"value_form\", 0)),\n                        \"ict_index\": float(element.get(\"ict_index\", 0)),\n                        \"defensive_contribution\": float(element.get(\"defensive_contribution\", 0)),\n                    }\n                except KeyError as e:\n                    self.logger.warning(f\"Missing required field for player: {str(e)}\")\n                    return None\n                except ValueError as e:\n                    self.logger.warning(f\"Invalid numeric value for player {element.get('id')}: {str(e)}\")\n                    return None\n\n            # Process all players with error handling\n            for element in static_data[\"elements\"]:\n                result = process_player_data(element)\n                if result:\n                    player_id, player_data = result\n                    self.players_data[player_id] = player_data\n\n            # Apply Player Exclusions\n            def apply_player_exclusions() -&gt; Dict[int, Dict]:\n                \"\"\"Apply configured player exclusions and return filtered player data\"\"\"\n                initial_count = len(self.players_data)\n                players_to_keep = {}\n\n                for player_id, player_info in self.players_data.items():\n                    # Track exclusion reason if player is excluded\n                    exclusion_reason = None\n\n                    # Check ID exclusions\n                    if player_id in EXCLUDED_PLAYERS_BY_ID:\n                        exclusion_reason = f\"ID exclusion: {player_id}\"\n\n                    # Check name exclusions\n                    elif player_info[\"name\"] in EXCLUDED_PLAYERS_BY_NAME:\n                        exclusion_reason = f\"Name exclusion: {player_info['name']}\"\n\n                    # Check team/position exclusions\n                    else:\n                        team_name = self.teams_data.get(player_info[\"team_id\"], {}).get(\"name\")\n                        for rule in EXCLUDED_PLAYERS_BY_TEAM_AND_POSITION:\n                            if (team_name == rule.get(\"team\") and \n                                player_info[\"position\"] == rule.get(\"position\")):\n                                exclusion_reason = f\"Team/Position exclusion: {team_name}/{player_info['position']}\"\n                                break\n\n                    # Log exclusion or keep player\n                    if exclusion_reason:\n                        self.logger.info(\n                            f\"Excluding player {player_info['name']} - {exclusion_reason}\"\n                        )\n                    else:\n                        players_to_keep[player_id] = player_info\n\n                filtered_count = len(players_to_keep)\n                self.logger.info(\n                    f\"Player filtering complete. {initial_count - filtered_count} \"\n                    f\"players excluded. {filtered_count} players remaining.\"\n                )\n                return players_to_keep\n\n            self.players_data = apply_player_exclusions()\n\n            # Process teams data\n            if \"teams\" not in static_data:\n                raise ValueError(\"No team data found in API response\")\n\n            self.logger.info(f\"Processing {len(static_data['teams'])} teams...\")\n\n            def process_team_data(team: Dict) -&gt; Tuple[int, Dict]:\n                \"\"\"Helper function to process individual team data\"\"\"\n                try:\n                    return team[\"id\"], {\n                        \"name\": team[\"name\"],\n                        \"short_name\": team[\"short_name\"],\n                        \"strength\": team[\"strength\"],\n                        \"strength_overall_home\": team[\"strength_overall_home\"],\n                        \"strength_overall_away\": team[\"strength_overall_away\"],\n                        \"strength_attack_home\": team[\"strength_attack_home\"],\n                        \"strength_attack_away\": team[\"strength_attack_away\"],\n                        \"strength_defence_home\": team[\"strength_defence_home\"],\n                        \"strength_defence_away\": team[\"strength_defence_away\"],\n                    }\n                except KeyError as e:\n                    self.logger.warning(f\"Missing required field for team: {str(e)}\")\n                    return None\n\n            # Process all teams with error handling\n            for team in static_data[\"teams\"]:\n                result = process_team_data(team)\n                if result:\n                    team_id, team_data = result\n                    self.teams_data[team_id] = team_data\n\n            # Process fixtures data\n            self.logger.info(f\"Processing {len(fixtures_data)} fixtures...\")\n\n            def process_fixture_data(fixture: Dict) -&gt; Tuple[int, Dict]:\n                \"\"\"Helper function to process individual fixture data\"\"\"\n                try:\n                    fixture_id = fixture[\"id\"]\n                    # Validate required fields\n                    required_fields = [\"team_h\", \"team_a\", \"event\", \"finished\"]\n                    if not all(field in fixture for field in required_fields):\n                        missing = [f for f in required_fields if f not in fixture]\n                        raise KeyError(f\"Missing required fields: {', '.join(missing)}\")\n                    return fixture_id, fixture\n                except KeyError as e:\n                    self.logger.warning(f\"Invalid fixture data: {str(e)}\")\n                    return None\n\n            # Process all fixtures with error handling\n            for fixture in fixtures_data:\n                result = process_fixture_data(fixture)\n                if result:\n                    fixture_id, fixture_data = result\n                    self.fixtures_data[fixture_id] = fixture_data\n\n            self.logger.info(\"FPL data fetched and processed successfully.\")\n\n        except requests.exceptions.RequestException as e:\n            self.logger.error(f\"Failed to fetch FPL data: {str(e)}\")\n            self._reset_data_structures()\n            raise\n        except ValueError as e:\n            self.logger.error(f\"Invalid data received from FPL API: {str(e)}\")\n            self._reset_data_structures()\n            raise\n        except Exception as e:\n            self.logger.error(f\"Unexpected error during data processing: {str(e)}\")\n            self._reset_data_structures()\n            raise\n\n    def _reset_data_structures(self) -&gt; None:\n        \"\"\"Reset all data structures to empty state\"\"\"\n        self.players_data = {}\n        self.teams_data = {}\n        self.fixtures_data = {}\n\n    def _get_team_strength(self, team_id, is_home):\n        \"\"\"Get team strength based on home/away status.\"\"\"\n        team = self.teams_data.get(team_id, {})\n        if is_home:\n            return team.get(\"strength_overall_home\", 1000)  # Default if not found\n        return team.get(\"strength_overall_away\", 1000)  # Default if not found\n\n    def _predict_minutes(self, player_id):\n        \"\"\"\n        Predicts expected minutes for a player based on historical data.\n        More sophisticated logic for handling very low minute players.\n        \"\"\"\n        player = self.players_data.get(player_id)\n        if not player:\n            return 0.0\n\n        status = player[\"status\"]\n        news = player[\"news\"].lower()\n        minutes_played = player[\"minutes\"]\n\n        # 1. Unavailable players (injured, suspended, doubtful)\n        if status != \"a\" or any(\n            x in news\n            for x in [\n                \"injured\",\n                \"doubtful\",\n                \"suspension\",\n                \"red card\",\n                \"expected back\",\n            ]\n        ):\n            return 0.0\n\n        # 2. Players with significant minutes (starters/key rotation)\n        if minutes_played &gt;= MIN_MINUTES_THRESHOLD:\n            # Average minutes per game started (assuming most minutes come from starts)\n            # This is a heuristic; real FPL API doesn't give starts directly.\n            # We assume a player with &gt; MIN_MINUTES_THRESHOLD plays ~80-90 minutes when on pitch.\n            # So, (minutes_played / number_of_appearances) is a rough proxy.\n            # For simplicity, let's use a cap of 90 minutes.\n            if player[\"total_points\"] &gt; 0:  # Player has played at least one game\n                avg_minutes_per_appearance = minutes_played / (\n                    player[\"total_points\"] / player[\"points_per_game\"]\n                )\n                return min(avg_minutes_per_appearance, 90.0)\n            return 70.0  # Reasonable default for established player with points but no clear avg\n\n        # 3. Players with very low minutes (rarely play, new, youth)\n        if minutes_played &lt; VERY_LOW_MINUTES_THRESHOLD:\n            # If news suggests they might get a chance, assign default sub minutes.\n            # Otherwise, very low expected minutes or zero.\n            if any(x in news for x in [\"return imminent\", \"close to return\"]):\n                return DEFAULT_SUB_MINUTES  # Might get some minutes\n            return DEFAULT_UNKNOWN_PLAYER_MINUTES  # Very unlikely to play significant minutes\n\n        # 4. Players with some minutes but below significant threshold (regular subs)\n        return DEFAULT_SUB_MINUTES\n\n    def _calculate_expected_goals(self, team_attack_strength, opp_defence_strength):\n        \"\"\"\n        Calculates expected goals for a team based on its attack strength and\n        opponent's defensive strength. This is a simplified heuristic.\n        \"\"\"\n        # A simple ratio model: Higher attack strength and lower opponent defense means more goals\n        # Normalization factor can be adjusted based on average league goals\n        expected_goals = (\n            team_attack_strength / opp_defence_strength\n        ) * 1.5  # 1.5 is an arbitrary scaling factor\n        return max(0.0, expected_goals)\n\n    def _calculate_expected_conceded_goals(\n        self, team_defence_strength, opp_attack_strength\n    ):\n        \"\"\"\n        Calculates expected goals conceded by a team based on its defense strength\n        and opponent's attacking strength.\n        \"\"\"\n        # A simple ratio model: Higher opponent attack and lower team defense means more conceded goals\n        expected_conceded_goals = (\n            opp_attack_strength / team_defence_strength\n        ) * 1.5  # 1.5 is an arbitrary scaling factor\n        return max(0.0, expected_conceded_goals)\n\n    def calculate_xp_for_player(self, player_id, fixture_id):\n        \"\"\"\n        Calculates Expected Points (xP) for a single player in a given fixture.\n        Considers various factors: minutes, goals, assists, clean sheets, saves,\n        bonus points, and negative events, adjusted for fixture difficulty.\n        \"\"\"\n        player = self.players_data.get(player_id)\n        fixture = self.fixtures_data.get(fixture_id)\n\n        if not player or not fixture:\n            return {\"xp\": 0.0, \"reason\": \"Player or fixture data missing.\"}\n\n        # Handle unavailable players\n        if (\n            player[\"status\"] != \"a\"\n        ):  # 'd' for doubtful, 'i' for injured, 's' for suspended\n            return {\"xp\": 0.0, \"reason\": f\"Player status: {player['status']}\"}\n        if any(\n            x in player[\"news\"].lower()\n            for x in [\"injured\", \"doubtful\", \"suspension\", \"red card\"]\n        ):\n            return {\"xp\": 0.0, \"reason\": f\"Player news: {player['news']}\"}\n\n        # Predict minutes\n        expected_minutes = self._predict_minutes(player_id)\n        if expected_minutes &lt; 1.0:  # If expected to play very little or none\n            return {\"xp\": 0.0, \"reason\": \"Expected minutes too low.\"}\n\n        xp = 0.0\n        position = player[\"position\"]\n        # Use 'team_h' for home team ID\n        is_home_fixture = player[\"team_id\"] == fixture[\"team_h\"]\n\n        # Determine attacking and defensive strengths for the fixture\n        player_team_strength_attack = (\n            self.teams_data.get(fixture[\"team_h\"], {}).get(\n                \"strength_attack_home\"\n            )  # Use 'team_h'\n            if is_home_fixture\n            else self.teams_data.get(fixture[\"team_a\"], {}).get(\n                \"strength_attack_away\"\n            )  # Use 'team_a'\n        )\n        player_team_strength_defence = (\n            self.teams_data.get(fixture[\"team_h\"], {}).get(\n                \"strength_defence_home\"\n            )  # Use 'team_h'\n            if is_home_fixture\n            else self.teams_data.get(fixture[\"team_a\"], {}).get(\n                \"strength_defence_away\"\n            )  # Use 'team_a'\n        )\n        opponent_team_strength_attack = (\n            self.teams_data.get(fixture[\"team_a\"], {}).get(\n                \"strength_attack_away\"\n            )  # Use 'team_a'\n            if is_home_fixture\n            else self.teams_data.get(fixture[\"team_h\"], {}).get(\n                \"strength_attack_home\"\n            )  # Use 'team_h'\n        )\n        opponent_team_strength_defence = (\n            self.teams_data.get(fixture[\"team_a\"], {}).get(\n                \"strength_defence_away\"\n            )  # Use 'team_a'\n            if is_home_fixture\n            else self.teams_data.get(fixture[\"team_h\"], {}).get(\n                \"strength_defence_home\"\n            )  # Use 'team_h'\n        )\n\n        if None in [\n            player_team_strength_attack,\n            player_team_strength_defence,\n            opponent_team_strength_attack,\n            opponent_team_strength_defence,\n        ]:\n            # Fallback if strength data is missing (shouldn't happen with robust data fetch)\n            return {\"xp\": 0.0, \"reason\": \"Team strength data missing for fixture.\"}\n\n        # Apply confidence factor based on historical minutes\n        minutes_played = player.get(\"minutes\", 0)\n        confidence_factor = XP_CONFIDENCE_FACTORS[\"proven\"]  # Default to proven player\n        if minutes_played &lt; VERY_LOW_MINUTES_THRESHOLD:\n            confidence_factor = XP_CONFIDENCE_FACTORS[\"very_low_minutes\"]\n        elif minutes_played &lt; MIN_MINUTES_THRESHOLD:\n            confidence_factor = XP_CONFIDENCE_FACTORS[\"low_minutes\"]\n\n        # 1. Appearance points\n        if expected_minutes &gt;= 60:\n            xp += self.fpl_points[\"appearance_points_gte_60\"]\n        elif expected_minutes &gt; 0:\n            xp += self.fpl_points[\"appearance_points_lt_60\"]\n\n        # 2. Expected Goals (scaled by historical goals per 90 and opponent difficulty)\n        # Use player's form and total goals as a basis\n        goals_per_90_hist = (\n            (player[\"goals_scored\"] / player[\"minutes\"] * 90)\n            if player[\"minutes\"] &gt; 0\n            else 0.0\n        )\n        expected_team_goals = self._calculate_expected_goals(\n            player_team_strength_attack, opponent_team_strength_defence\n        )\n\n        expected_goals_player_contribution = (\n            (goals_per_90_hist / 90.0) * expected_minutes * (expected_team_goals / 1.5)\n        )  # Scale player's goal contribution by team's expected goals\n\n        if position == \"GK\":\n            xp += expected_goals_player_contribution * self.fpl_points[\"goal_gk\"]\n        elif position == \"DEF\":\n            xp += expected_goals_player_contribution * self.fpl_points[\"goal_def\"]\n        elif position == \"MID\":\n            xp += expected_goals_player_contribution * self.fpl_points[\"goal_mid\"]\n        elif position == \"FWD\":\n            xp += expected_goals_player_contribution * self.fpl_points[\"goal_fwd\"]\n\n        # 3. Expected Assists (scaled by historical assists per 90 and opponent difficulty)\n        assists_per_90_hist = (\n            (player[\"assists\"] / player[\"minutes\"] * 90)\n            if player[\"minutes\"] &gt; 0\n            else 0.0\n        )\n        # Assuming team's attacking strength correlates with assist opportunities\n        expected_assists_player_contribution = (\n            (assists_per_90_hist / 90.0)\n            * expected_minutes\n            * (expected_team_goals / 1.5)\n        )  # Similarly scale by team's expected goals\n        xp += expected_assists_player_contribution * self.fpl_points[\"assist_points\"]\n\n        # 4. Expected Clean Sheets (for GKs/DEFs/MIDs) and Conceded Goals deduction\n        expected_conceded = self._calculate_expected_conceded_goals(\n            player_team_strength_defence, opponent_team_strength_attack\n        )\n\n        # Probability of clean sheet\n        # Simplified: higher team defense / lower opponent attack -&gt; higher CS prob\n        # Use logistic or sigmoid for probability\n        cs_prob = 1.0 / (\n            1.0 + math.exp(expected_conceded - 1.0)\n        )  # Sigmoid centered at 1 goal\n\n        if position in [\"GK\", \"DEF\"]:\n            xp += cs_prob * self.fpl_points[\"clean_sheet_gk_def\"]\n\n            # Conceded goals deduction: Apply penalty for every 2 goals conceded *probability*\n            # For simplicity, calculate expected deduction: (expected_conceded / 2) * deduction\n            xp += (expected_conceded / 2.0) * self.fpl_points[\n                \"conceded_2_goals_deduction\"\n            ]\n        elif position == \"MID\":\n            xp += cs_prob * self.fpl_points[\"clean_sheet_mid\"]\n\n        # 5. Expected Saves (for GKs)\n        if position == \"GK\":\n            saves_per_90_hist = (\n                (player[\"saves\"] / player[\"minutes\"] * 90)\n                if player[\"minutes\"] &gt; 0\n                else 0.0\n            )\n            # Expected saves scaled by opponent's attacking strength (more attacking -&gt; more shots -&gt; more saves)\n            expected_saves_player_contribution = (\n                (saves_per_90_hist / 90.0)\n                * expected_minutes\n                * (opponent_team_strength_attack / player_team_strength_defence)\n            )\n            xp += (expected_saves_player_contribution / 3.0) * self.fpl_points[\n                \"saves_3_points\"\n            ]  # Using the new config point value\n\n            # Penalty saves (low probability, use historical rate)\n            penalty_saves_hist_per_game = (\n                player[\"penalties_saved\"] / (player[\"minutes\"] / 90.0)\n                if player[\"minutes\"] &gt; 0\n                else 0.0\n            )\n            xp += (\n                penalty_saves_hist_per_game\n                * (expected_minutes / 90.0)\n                * self.fpl_points[\"penalty_save_points\"]\n            )\n\n        # 6. Expected Bonus Points\n        # Use BPS (Bonus Points System) as a proxy. Scale player's average BPS by form and expected minutes.\n        bps_per_90_hist = (\n            (player[\"bps\"] / player[\"minutes\"] * 90) if player[\"minutes\"] &gt; 0 else 0.0\n        )\n        expected_bps = (bps_per_90_hist / 90.0) * expected_minutes * player[\"form\"]\n        xp += expected_bps * self.fpl_points[\"bonus_points_scaling_factor\"]\n\n        # 7. Minor Negative Events (Probabilistic)\n        # These are rare, so a simple probability based on expected minutes.\n        xp += (expected_minutes / 90.0) * (\n            self.fpl_points[\"yellow_card_deduction\"] * YELLOW_CARD_PROB\n            + self.fpl_points[\"red_card_deduction\"] * RED_CARD_PROB\n            + self.fpl_points[\"own_goal_deduction\"] * OWN_GOAL_PROB\n            + self.fpl_points[\"penalty_miss_deduction\"] * PENALTY_MISS_PROB\n        )\n\n        # 8. Defensive Contribution Points (for 2025/26 season)\n        # Use actual defensive_contribution data from API\n        defensive_contribution_per_90 = (\n            (player[\"defensive_contribution\"] / player[\"minutes\"] * 90)\n            if player[\"minutes\"] &gt; 0\n            else 0.0\n        )\n        expected_defensive_contribution = (defensive_contribution_per_90 / 90.0) * expected_minutes\n\n        # Award defensive contribution points based on position thresholds\n        if position in [\"DEF\", \"MID\", \"FWD\"]:  # Goalkeepers do not earn defensive contribution points\n            xp += expected_defensive_contribution * self.fpl_points[\"defensive_contribution_points\"]\n\n        # Apply confidence factor to final xP\n        xp = xp * confidence_factor\n\n        return {\"xp\": round(xp, 2), \"reason\": \"Success\", \"confidence\": confidence_factor}\n\n    def _calculate_all_players_xp(self):\n        \"\"\"\n        Calculates the Expected Points (xP) for all players over multiple upcoming gameweeks\n        and populates self.all_players_xp_calculated_data with xP per gameweek.\n        \"\"\"\n        print(\n            f\"Calculating xP for all players over {self.gameweeks_to_predict} gameweek(s)...\"\n        )\n\n        # Get all upcoming fixtures and sort them by gameweek\n        all_upcoming_fixtures_items = sorted(\n            [\n                (fid, fdict)\n                for fid, fdict in self.fixtures_data.items()\n                if not fdict[\"finished\"]\n            ],\n            key=lambda item: item[1][\"event\"],\n        )\n\n        if not all_upcoming_fixtures_items:\n            print(\"No upcoming fixtures found. Cannot calculate xP.\")\n            return\n\n        # Determine the current gameweek (the gameweek of the earliest upcoming fixture)\n        current_gameweek = all_upcoming_fixtures_items[0][1][\"event\"]\n        target_gameweeks = range(\n            current_gameweek, current_gameweek + self.gameweeks_to_predict\n        )\n\n        # Create a mapping of team_id_code to a list of their fixtures within the target gameweeks\n        team_fixtures_in_range = {team_code: [] for team_code in self.teams_data.keys()}\n        for fixture_id, fixture_data in all_upcoming_fixtures_items:\n            if fixture_data[\"event\"] in target_gameweeks:\n                home_team_code = fixture_data[\"team_h\"]\n                away_team_code = fixture_data[\"team_a\"]\n\n                team_fixtures_in_range[home_team_code].append(fixture_id)\n                team_fixtures_in_range[away_team_code].append(fixture_id)\n\n        # Calculate total xP for each player across the specified gameweeks\n        for player_id, player_data in self.players_data.items():\n            player_team_code = player_data[\"team_id\"]\n            player_position = player_data[\"position\"]\n\n            # Calculate xP for each relevant fixture and store by gameweek\n            expected_points_by_gw = {}\n            for fixture_id in team_fixtures_in_range.get(player_team_code, []):\n                fixture_gameweek = self.fixtures_data[fixture_id][\"event\"]\n                xp_result_single_gw = self.calculate_xp_for_player(\n                    player_id, fixture_id\n                )\n                if xp_result_single_gw and xp_result_single_gw[\"xp\"] is not None:\n                    if fixture_gameweek not in expected_points_by_gw:\n                        expected_points_by_gw[fixture_gameweek] = 0.0\n                    expected_points_by_gw[fixture_gameweek] += xp_result_single_gw[\"xp\"]\n\n            # Ensure all target gameweeks are present, even if xP is 0 for a given GW\n            for gw in target_gameweeks:\n                if gw not in expected_points_by_gw:\n                    expected_points_by_gw[gw] = 0.0\n\n            # Sort the dictionary by gameweek for consistent output\n            expected_points_by_gw = dict(sorted(expected_points_by_gw.items()))\n\n            # Prepare data for the optimizer\n            player_cost_m = player_data[\"cost_pence\"] / 10.0\n            team_name_full = self.teams_data.get(player_team_code, {}).get(\n                \"name\", \"Unknown Team\"\n            )\n\n            self.all_players_xp_calculated_data.append(\n                {\n                    \"name\": player_data[\"name\"],\n                    \"web_name\": player_data[\"web_name\"],\n                    \"team\": team_name_full,\n                    \"position\": player_position,\n                    \"cost\": player_cost_m,\n                    \"expected_points_by_gw\": expected_points_by_gw,  # Changed key and format\n                }\n            )\n        print(\"xP calculation for all players complete.\")\n\n    def get_upcoming_fixtures(self, limit=None):\n        \"\"\"\n        Returns a list of upcoming fixtures, sorted by gameweek and kickoff time.\n        Optionally limits the number of fixtures returned.\n        \"\"\"\n        upcoming = []\n        now = datetime.now()\n\n        # Sort all fixtures by gameweek and then by kickoff time\n        sorted_fixtures = sorted(\n            self.fixtures_data.values(),\n            key=lambda x: (\n                x.get(\"event\", 0),\n                x.get(\"kickoff_time\", \"9999-12-31T00:00:00Z\"),\n            ),\n        )\n\n        current_gameweek = None\n        for fixture_data in sorted_fixtures:\n            # Determine current gameweek from the earliest upcoming fixture\n            if not fixture_data[\"finished\"] and current_gameweek is None:\n                current_gameweek = fixture_data.get(\"event\", 0)\n\n            # Filter for upcoming fixtures within the prediction horizon\n            if (\n                fixture_data.get(\"event\", 0) &lt; current_gameweek  # Skip past gameweeks\n                or fixture_data.get(\"event\", 0)\n                &gt;= current_gameweek + self.gameweeks_to_predict\n            ):\n                continue  # Skip fixtures outside the prediction horizon\n\n            home_team_name = self.teams_data.get(\n                fixture_data[\"team_h\"], {}\n            ).get(  # Use 'team_h'\n                \"name\", \"Unknown\"\n            )\n            away_team_name = self.teams_data.get(\n                fixture_data[\"team_a\"], {}\n            ).get(  # Use 'team_a'\n                \"name\", \"Unknown\"\n            )\n\n            # Only add fixtures that are not finished\n            if not fixture_data[\"finished\"]:\n                upcoming.append(\n                    {\n                        \"fixture_id\": fixture_data[\"id\"],\n                        \"gameweek\": fixture_data.get(\"event\"),\n                        \"home_team_id\": fixture_data[\"team_h\"],  # Use 'team_h'\n                        \"away_team_id\": fixture_data[\"team_a\"],  # Use 'team_a'\n                        \"match\": f\"{home_team_name} vs {away_team_name}\",\n                        \"kickoff_time\": fixture_data.get(\"kickoff_time\"),\n                        \"home_team_difficulty\": fixture_data[\"team_h_difficulty\"],\n                        \"away_team_difficulty\": fixture_data[\"team_a_difficulty\"],\n                    }\n                )\n            if limit is not None and len(upcoming) &gt;= limit:\n                break\n        return upcoming\n\n    def get_players_for_optimizer(self):\n        \"\"\"\n        Returns the list of player data with calculated xP per gameweek,\n        formatted for the FPLOptimizer.\n        \"\"\"\n        return self.all_players_xp_calculated_data\n\n    def clear_cache(self):\n        \"\"\"\n        Clear all cached API responses. Use this when you want to force fresh data\n        from the FPL API.\n        \"\"\"\n        self.cache_manager.clear_cache()\n        self.logger.info(\"Cleared API response cache\")\n</code></pre>"},{"location":"autoapi/fpl_solver/xp_predictor/#fpl_solver.xp_predictor.FPLPredictor.__init__","title":"<code>__init__(gameweeks_to_predict=1)</code>","text":"<p>Initialize the FPLPredictor with data structures and fetch initial data.</p> <p>Parameters:</p> Name Type Description Default <code>gameweeks_to_predict</code> <code>int</code> <p>Number of upcoming gameweeks to calculate                 expected points for. Default is 1 (next gameweek).</p> <code>1</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If gameweeks_to_predict is not a positive integer</p> Source code in <code>fpl_solver/xp_predictor.py</code> <pre><code>def __init__(self, gameweeks_to_predict: int = 1):\n    \"\"\"\n    Initialize the FPLPredictor with data structures and fetch initial data.\n\n    Args:\n        gameweeks_to_predict: Number of upcoming gameweeks to calculate\n                            expected points for. Default is 1 (next gameweek).\n\n    Raises:\n        ValueError: If gameweeks_to_predict is not a positive integer\n    \"\"\"\n    self.logger = setup_logger(__name__)\n    if not isinstance(gameweeks_to_predict, int) or gameweeks_to_predict &lt; 1:\n        msg = f\"gameweeks_to_predict must be a positive integer, got {gameweeks_to_predict}\"\n        self.logger.error(msg)\n        raise ValueError(msg)\n\n    self.gameweeks_to_predict = gameweeks_to_predict\n    self.logger.info(f\"Initializing FPL Predictor for {gameweeks_to_predict} gameweek(s)\")\n\n    # Initialize cache manager\n    cache_dir = os.path.join(os.path.dirname(__file__), 'cache')\n    self.cache_manager = CacheManager(cache_dir)\n\n    # Configuration and static data\n    self.fpl_points: Dict[str, float] = FPL_POINTS\n    self.position_definitions: Dict[int, str] = {\n        1: \"GK\",\n        2: \"DEF\",\n        3: \"MID\",\n        4: \"FWD\",\n    }\n\n    # Data structures for FPL information\n    self.players_data: Dict[int, Dict] = {}\n    self.teams_data: Dict[int, Dict] = {}\n    self.fixtures_data: Dict[int, Dict] = {}\n    self.all_players_xp_calculated_data: List[Dict] = []\n\n    # Initialize data\n    try:\n        self._fetch_fpl_data()\n        self._calculate_all_players_xp()\n    except Exception as e:\n        self.logger.error(f\"Failed to initialize FPL Predictor: {str(e)}\")\n        raise\n</code></pre>"},{"location":"autoapi/fpl_solver/xp_predictor/#fpl_solver.xp_predictor.FPLPredictor.calculate_xp_for_player","title":"<code>calculate_xp_for_player(player_id, fixture_id)</code>","text":"<p>Calculates Expected Points (xP) for a single player in a given fixture. Considers various factors: minutes, goals, assists, clean sheets, saves, bonus points, and negative events, adjusted for fixture difficulty.</p> Source code in <code>fpl_solver/xp_predictor.py</code> <pre><code>def calculate_xp_for_player(self, player_id, fixture_id):\n    \"\"\"\n    Calculates Expected Points (xP) for a single player in a given fixture.\n    Considers various factors: minutes, goals, assists, clean sheets, saves,\n    bonus points, and negative events, adjusted for fixture difficulty.\n    \"\"\"\n    player = self.players_data.get(player_id)\n    fixture = self.fixtures_data.get(fixture_id)\n\n    if not player or not fixture:\n        return {\"xp\": 0.0, \"reason\": \"Player or fixture data missing.\"}\n\n    # Handle unavailable players\n    if (\n        player[\"status\"] != \"a\"\n    ):  # 'd' for doubtful, 'i' for injured, 's' for suspended\n        return {\"xp\": 0.0, \"reason\": f\"Player status: {player['status']}\"}\n    if any(\n        x in player[\"news\"].lower()\n        for x in [\"injured\", \"doubtful\", \"suspension\", \"red card\"]\n    ):\n        return {\"xp\": 0.0, \"reason\": f\"Player news: {player['news']}\"}\n\n    # Predict minutes\n    expected_minutes = self._predict_minutes(player_id)\n    if expected_minutes &lt; 1.0:  # If expected to play very little or none\n        return {\"xp\": 0.0, \"reason\": \"Expected minutes too low.\"}\n\n    xp = 0.0\n    position = player[\"position\"]\n    # Use 'team_h' for home team ID\n    is_home_fixture = player[\"team_id\"] == fixture[\"team_h\"]\n\n    # Determine attacking and defensive strengths for the fixture\n    player_team_strength_attack = (\n        self.teams_data.get(fixture[\"team_h\"], {}).get(\n            \"strength_attack_home\"\n        )  # Use 'team_h'\n        if is_home_fixture\n        else self.teams_data.get(fixture[\"team_a\"], {}).get(\n            \"strength_attack_away\"\n        )  # Use 'team_a'\n    )\n    player_team_strength_defence = (\n        self.teams_data.get(fixture[\"team_h\"], {}).get(\n            \"strength_defence_home\"\n        )  # Use 'team_h'\n        if is_home_fixture\n        else self.teams_data.get(fixture[\"team_a\"], {}).get(\n            \"strength_defence_away\"\n        )  # Use 'team_a'\n    )\n    opponent_team_strength_attack = (\n        self.teams_data.get(fixture[\"team_a\"], {}).get(\n            \"strength_attack_away\"\n        )  # Use 'team_a'\n        if is_home_fixture\n        else self.teams_data.get(fixture[\"team_h\"], {}).get(\n            \"strength_attack_home\"\n        )  # Use 'team_h'\n    )\n    opponent_team_strength_defence = (\n        self.teams_data.get(fixture[\"team_a\"], {}).get(\n            \"strength_defence_away\"\n        )  # Use 'team_a'\n        if is_home_fixture\n        else self.teams_data.get(fixture[\"team_h\"], {}).get(\n            \"strength_defence_home\"\n        )  # Use 'team_h'\n    )\n\n    if None in [\n        player_team_strength_attack,\n        player_team_strength_defence,\n        opponent_team_strength_attack,\n        opponent_team_strength_defence,\n    ]:\n        # Fallback if strength data is missing (shouldn't happen with robust data fetch)\n        return {\"xp\": 0.0, \"reason\": \"Team strength data missing for fixture.\"}\n\n    # Apply confidence factor based on historical minutes\n    minutes_played = player.get(\"minutes\", 0)\n    confidence_factor = XP_CONFIDENCE_FACTORS[\"proven\"]  # Default to proven player\n    if minutes_played &lt; VERY_LOW_MINUTES_THRESHOLD:\n        confidence_factor = XP_CONFIDENCE_FACTORS[\"very_low_minutes\"]\n    elif minutes_played &lt; MIN_MINUTES_THRESHOLD:\n        confidence_factor = XP_CONFIDENCE_FACTORS[\"low_minutes\"]\n\n    # 1. Appearance points\n    if expected_minutes &gt;= 60:\n        xp += self.fpl_points[\"appearance_points_gte_60\"]\n    elif expected_minutes &gt; 0:\n        xp += self.fpl_points[\"appearance_points_lt_60\"]\n\n    # 2. Expected Goals (scaled by historical goals per 90 and opponent difficulty)\n    # Use player's form and total goals as a basis\n    goals_per_90_hist = (\n        (player[\"goals_scored\"] / player[\"minutes\"] * 90)\n        if player[\"minutes\"] &gt; 0\n        else 0.0\n    )\n    expected_team_goals = self._calculate_expected_goals(\n        player_team_strength_attack, opponent_team_strength_defence\n    )\n\n    expected_goals_player_contribution = (\n        (goals_per_90_hist / 90.0) * expected_minutes * (expected_team_goals / 1.5)\n    )  # Scale player's goal contribution by team's expected goals\n\n    if position == \"GK\":\n        xp += expected_goals_player_contribution * self.fpl_points[\"goal_gk\"]\n    elif position == \"DEF\":\n        xp += expected_goals_player_contribution * self.fpl_points[\"goal_def\"]\n    elif position == \"MID\":\n        xp += expected_goals_player_contribution * self.fpl_points[\"goal_mid\"]\n    elif position == \"FWD\":\n        xp += expected_goals_player_contribution * self.fpl_points[\"goal_fwd\"]\n\n    # 3. Expected Assists (scaled by historical assists per 90 and opponent difficulty)\n    assists_per_90_hist = (\n        (player[\"assists\"] / player[\"minutes\"] * 90)\n        if player[\"minutes\"] &gt; 0\n        else 0.0\n    )\n    # Assuming team's attacking strength correlates with assist opportunities\n    expected_assists_player_contribution = (\n        (assists_per_90_hist / 90.0)\n        * expected_minutes\n        * (expected_team_goals / 1.5)\n    )  # Similarly scale by team's expected goals\n    xp += expected_assists_player_contribution * self.fpl_points[\"assist_points\"]\n\n    # 4. Expected Clean Sheets (for GKs/DEFs/MIDs) and Conceded Goals deduction\n    expected_conceded = self._calculate_expected_conceded_goals(\n        player_team_strength_defence, opponent_team_strength_attack\n    )\n\n    # Probability of clean sheet\n    # Simplified: higher team defense / lower opponent attack -&gt; higher CS prob\n    # Use logistic or sigmoid for probability\n    cs_prob = 1.0 / (\n        1.0 + math.exp(expected_conceded - 1.0)\n    )  # Sigmoid centered at 1 goal\n\n    if position in [\"GK\", \"DEF\"]:\n        xp += cs_prob * self.fpl_points[\"clean_sheet_gk_def\"]\n\n        # Conceded goals deduction: Apply penalty for every 2 goals conceded *probability*\n        # For simplicity, calculate expected deduction: (expected_conceded / 2) * deduction\n        xp += (expected_conceded / 2.0) * self.fpl_points[\n            \"conceded_2_goals_deduction\"\n        ]\n    elif position == \"MID\":\n        xp += cs_prob * self.fpl_points[\"clean_sheet_mid\"]\n\n    # 5. Expected Saves (for GKs)\n    if position == \"GK\":\n        saves_per_90_hist = (\n            (player[\"saves\"] / player[\"minutes\"] * 90)\n            if player[\"minutes\"] &gt; 0\n            else 0.0\n        )\n        # Expected saves scaled by opponent's attacking strength (more attacking -&gt; more shots -&gt; more saves)\n        expected_saves_player_contribution = (\n            (saves_per_90_hist / 90.0)\n            * expected_minutes\n            * (opponent_team_strength_attack / player_team_strength_defence)\n        )\n        xp += (expected_saves_player_contribution / 3.0) * self.fpl_points[\n            \"saves_3_points\"\n        ]  # Using the new config point value\n\n        # Penalty saves (low probability, use historical rate)\n        penalty_saves_hist_per_game = (\n            player[\"penalties_saved\"] / (player[\"minutes\"] / 90.0)\n            if player[\"minutes\"] &gt; 0\n            else 0.0\n        )\n        xp += (\n            penalty_saves_hist_per_game\n            * (expected_minutes / 90.0)\n            * self.fpl_points[\"penalty_save_points\"]\n        )\n\n    # 6. Expected Bonus Points\n    # Use BPS (Bonus Points System) as a proxy. Scale player's average BPS by form and expected minutes.\n    bps_per_90_hist = (\n        (player[\"bps\"] / player[\"minutes\"] * 90) if player[\"minutes\"] &gt; 0 else 0.0\n    )\n    expected_bps = (bps_per_90_hist / 90.0) * expected_minutes * player[\"form\"]\n    xp += expected_bps * self.fpl_points[\"bonus_points_scaling_factor\"]\n\n    # 7. Minor Negative Events (Probabilistic)\n    # These are rare, so a simple probability based on expected minutes.\n    xp += (expected_minutes / 90.0) * (\n        self.fpl_points[\"yellow_card_deduction\"] * YELLOW_CARD_PROB\n        + self.fpl_points[\"red_card_deduction\"] * RED_CARD_PROB\n        + self.fpl_points[\"own_goal_deduction\"] * OWN_GOAL_PROB\n        + self.fpl_points[\"penalty_miss_deduction\"] * PENALTY_MISS_PROB\n    )\n\n    # 8. Defensive Contribution Points (for 2025/26 season)\n    # Use actual defensive_contribution data from API\n    defensive_contribution_per_90 = (\n        (player[\"defensive_contribution\"] / player[\"minutes\"] * 90)\n        if player[\"minutes\"] &gt; 0\n        else 0.0\n    )\n    expected_defensive_contribution = (defensive_contribution_per_90 / 90.0) * expected_minutes\n\n    # Award defensive contribution points based on position thresholds\n    if position in [\"DEF\", \"MID\", \"FWD\"]:  # Goalkeepers do not earn defensive contribution points\n        xp += expected_defensive_contribution * self.fpl_points[\"defensive_contribution_points\"]\n\n    # Apply confidence factor to final xP\n    xp = xp * confidence_factor\n\n    return {\"xp\": round(xp, 2), \"reason\": \"Success\", \"confidence\": confidence_factor}\n</code></pre>"},{"location":"autoapi/fpl_solver/xp_predictor/#fpl_solver.xp_predictor.FPLPredictor.clear_cache","title":"<code>clear_cache()</code>","text":"<p>Clear all cached API responses. Use this when you want to force fresh data from the FPL API.</p> Source code in <code>fpl_solver/xp_predictor.py</code> <pre><code>def clear_cache(self):\n    \"\"\"\n    Clear all cached API responses. Use this when you want to force fresh data\n    from the FPL API.\n    \"\"\"\n    self.cache_manager.clear_cache()\n    self.logger.info(\"Cleared API response cache\")\n</code></pre>"},{"location":"autoapi/fpl_solver/xp_predictor/#fpl_solver.xp_predictor.FPLPredictor.get_players_for_optimizer","title":"<code>get_players_for_optimizer()</code>","text":"<p>Returns the list of player data with calculated xP per gameweek, formatted for the FPLOptimizer.</p> Source code in <code>fpl_solver/xp_predictor.py</code> <pre><code>def get_players_for_optimizer(self):\n    \"\"\"\n    Returns the list of player data with calculated xP per gameweek,\n    formatted for the FPLOptimizer.\n    \"\"\"\n    return self.all_players_xp_calculated_data\n</code></pre>"},{"location":"autoapi/fpl_solver/xp_predictor/#fpl_solver.xp_predictor.FPLPredictor.get_upcoming_fixtures","title":"<code>get_upcoming_fixtures(limit=None)</code>","text":"<p>Returns a list of upcoming fixtures, sorted by gameweek and kickoff time. Optionally limits the number of fixtures returned.</p> Source code in <code>fpl_solver/xp_predictor.py</code> <pre><code>def get_upcoming_fixtures(self, limit=None):\n    \"\"\"\n    Returns a list of upcoming fixtures, sorted by gameweek and kickoff time.\n    Optionally limits the number of fixtures returned.\n    \"\"\"\n    upcoming = []\n    now = datetime.now()\n\n    # Sort all fixtures by gameweek and then by kickoff time\n    sorted_fixtures = sorted(\n        self.fixtures_data.values(),\n        key=lambda x: (\n            x.get(\"event\", 0),\n            x.get(\"kickoff_time\", \"9999-12-31T00:00:00Z\"),\n        ),\n    )\n\n    current_gameweek = None\n    for fixture_data in sorted_fixtures:\n        # Determine current gameweek from the earliest upcoming fixture\n        if not fixture_data[\"finished\"] and current_gameweek is None:\n            current_gameweek = fixture_data.get(\"event\", 0)\n\n        # Filter for upcoming fixtures within the prediction horizon\n        if (\n            fixture_data.get(\"event\", 0) &lt; current_gameweek  # Skip past gameweeks\n            or fixture_data.get(\"event\", 0)\n            &gt;= current_gameweek + self.gameweeks_to_predict\n        ):\n            continue  # Skip fixtures outside the prediction horizon\n\n        home_team_name = self.teams_data.get(\n            fixture_data[\"team_h\"], {}\n        ).get(  # Use 'team_h'\n            \"name\", \"Unknown\"\n        )\n        away_team_name = self.teams_data.get(\n            fixture_data[\"team_a\"], {}\n        ).get(  # Use 'team_a'\n            \"name\", \"Unknown\"\n        )\n\n        # Only add fixtures that are not finished\n        if not fixture_data[\"finished\"]:\n            upcoming.append(\n                {\n                    \"fixture_id\": fixture_data[\"id\"],\n                    \"gameweek\": fixture_data.get(\"event\"),\n                    \"home_team_id\": fixture_data[\"team_h\"],  # Use 'team_h'\n                    \"away_team_id\": fixture_data[\"team_a\"],  # Use 'team_a'\n                    \"match\": f\"{home_team_name} vs {away_team_name}\",\n                    \"kickoff_time\": fixture_data.get(\"kickoff_time\"),\n                    \"home_team_difficulty\": fixture_data[\"team_h_difficulty\"],\n                    \"away_team_difficulty\": fixture_data[\"team_a_difficulty\"],\n                }\n            )\n        if limit is not None and len(upcoming) &gt;= limit:\n            break\n    return upcoming\n</code></pre>"}]}