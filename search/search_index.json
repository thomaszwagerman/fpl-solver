{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FPL Squad Optimizer","text":"<p>This project provides a Python-based solution to optimize Fantasy Premier League (FPL) squad selection using Integer Linear Programming (ILP). It fetches player, team, and fixture data from the official FPL API, calculates Expected Points (xP) for all players, and then uses an optimization algorithm to build the highest-scoring 15-player squad within a specified budget and team limits.</p> <p>This project aims to provide a free and open-source xP prediction algorithm, that is directly integrated with a solver. It only uses freely available data from the FPL API.</p> <p>This has obvious limitations compared to algorithms and solvers which can use pay-walled data (such as Opta, FFH), but we give the user flexibility to adjust the algorithm using a configuration file.</p>"},{"location":"#features","title":"\u2728 Features","text":"<ul> <li> <p>FPL Data Integration: Fetches up-to-date player, team, and fixture information directly from the official FPL API.</p> </li> <li> <p>Expected Points (xP) Prediction: Calculates a player's expected points based on historical performance, team strengths, opponent difficulty (Fixture Difficulty Rating - FDR), and expected minutes played.</p> </li> <li> <p>Granular Expected Minutes: Refined logic to predict player minutes, especially for those with low historical play, ensuring more realistic xP values.</p> </li> <li> <p>Multi-Gameweek Optimization: Optimize your squad over multiple upcoming gameweeks to plan for future fixtures.</p> </li> <li> <p>Configurable Parameters: Easily adjust probabilities, low-minute penalties, chip usage, player exclusion, xP thresholds, budget, and team limits via a dedicated configuration file.</p> </li> </ul>"},{"location":"#how-it-works","title":"\ud83d\ude80 How It Works","text":"<p>The project is structured into three main components:</p> <ol> <li> <p><code>fpl_config.py</code>:    This file centralizes all configurable parameters for the predictor and the optimizer. You can adjust FPL point values, minute thresholds for xP calculation, the optimization horizon (number of gameweeks), total budget, and the maximum players allowed per team here.</p> </li> <li> <p><code>fpl_xp_predictor.py</code>:    This module is responsible for:</p> </li> <li> <p>Fetching raw FPL data from the API.</p> </li> <li> <p>Processing team and fixture data, including calculating team strengths and incorporating FDR.</p> </li> <li> <p>Calculating each player's Expected Points (xP) for upcoming gameweeks. This involves logic for goals, assists, clean sheets, saves (for GKs), bonus points (using BPS as a proxy), and minor negative events like cards.</p> </li> <li> <p>Crucially, it includes refined logic for <code>expected_minutes</code> to accurately assess playing time, especially for players with limited past appearances.</p> </li> <li> <p><code>fpl_solver.py</code>:    This is the core optimization engine. It takes the xP-calculated player data from <code>fpl_xp_predictor.py</code> and:</p> </li> <li> <p>Sets up an Integer Linear Programming (ILP) problem using the <code>PuLP</code> library.</p> </li> <li> <p>Defines constraints for squad size (15 players), position counts (2 GKs, 5 DEFs, 5 MIDs, 3 FWDs), total budget, and maximum players per team.</p> </li> <li> <p>Maximizes the total expected points of the selected squad.</p> </li> <li> <p>Prints a detailed summary of the optimal squad, including costs and xP breakdown by position, and a team-by-team player count.</p> </li> </ol>"},{"location":"#setup-and-installation","title":"\ud83d\udee0\ufe0f Setup and Installation","text":"<p>To get the FPL Squad Optimizer running on your local machine, follow these steps:</p> <ol> <li>Clone the Repository (if applicable):</li> </ol> <pre><code>git clone git@github.com:thomaszwagerman/fpl-solver.git\ncd fpl-solver\n</code></pre> <ol> <li>Create a Virtual Environment (Recommended):</li> </ol> <pre><code>python -m venv venv\nsource venv/bin/activate\n</code></pre> <ol> <li>Install locally:    Install <code>fpl-solver</code> locally:</li> </ol> <pre><code>pip install .\n</code></pre>"},{"location":"#usage","title":"\ud83d\ude80 Usage","text":"<p>Once you have set up the environment and installed the dependencies, you can run the optimizer from your terminal:</p> <pre><code>python fpl_solver.py\n</code></pre> <p>The script will:</p> <ol> <li> <p>Initialize the FPL Predictor to fetch the latest data.</p> </li> <li> <p>Calculate expected points for all players over the number of gameweeks specified in <code>fpl_config.py</code>.</p> </li> <li> <p>Run the optimization solver.</p> </li> <li> <p>Print the optimal 15-player squad, its total cost, and total expected points.</p> </li> </ol>"},{"location":"#configuration","title":"\u2699\ufe0f Configuration","text":"<p>All key parameters are located in <code>fpl_config.py</code>. You can modify these values to experiment with different scenarios:</p> <ul> <li> <p><code>OPTIMIZATION_GAMEWEEKS</code>: The number of upcoming gameweeks the solver should consider for xP calculation (e.g., <code>1</code> for the next gameweek, <code>3</code> for the next three).</p> </li> <li> <p><code>BUDGET</code>: Your total FPL budget in millions of pounds (e.g., <code>100.0</code>).</p> </li> <li> <p><code>MAX_PLAYERS_PER_TEAM</code>: The maximum number of players you want from any single Premier League team (FPL limit is usually <code>3</code>).</p> </li> <li> <p><code>FPL_POINTS</code>: A dictionary defining the points awarded for various FPL events (goals, assists, clean sheets, etc.).</p> </li> <li> <p><code>MIN_MINUTES_THRESHOLD</code>: Minimum minutes played for a player's per-90 stats to be considered fully reliable.</p> </li> <li> <p><code>VERY_LOW_MINUTES_THRESHOLD</code>: Minutes threshold below which per-90 stats are heavily regressed.</p> </li> <li> <p><code>YELLOW_CARD_PROB</code>, <code>RED_CARD_PROB</code>, <code>PENALTY_MISS_PROB</code>, <code>OWN_GOAL_PROB</code>: Heuristic probabilities for negative events.</p> </li> <li> <p><code>DEFAULT_SUB_MINUTES</code>: Assumed average minutes for players who get some minutes but rarely start.</p> </li> <li> <p><code>DEFAULT_UNKNOWN_PLAYER_MINUTES</code>: Very low default minutes for players with almost no historical data.</p> </li> </ul>"},{"location":"#output","title":"\ud83d\udcca Output","text":"<p>The script will output a detailed summary of your optimized FPL squad to the console, similar to this:</p> <pre><code>--- FPL Optimized Squad ---\nTotal Cost: \u00a3XX.Xm\nTotal Expected Points: XXX.XX\n\n--- Goalkeepers ---\n   name        team  cost  expected_points\n...\n\n--- Defenders ---\n   name        team  cost  expected_points\n...\n\n--- Midfielders ---\n   name        team  cost  expected_points\n...\n\n--- Forwards ---\n   name        team  cost  expected_points\n...\n\n--- Team Breakdown ---\nteam\nTeam A    3\nTeam B    2\n...\n</code></pre>"},{"location":"#future-improvements","title":"\ud83d\udca1 Future Improvements","text":"<ul> <li> <p>Improved Data Source: The FPL API is limited in the type of data it provides, we cannot really calculate defensive contributions.</p> </li> <li> <p>Captaincy and Vice-Captaincy Selection: Integrate logic to select the best captain and vice-captain for double points.</p> </li> <li> <p>Transfer Optimization: Add functionality to suggest optimal transfers week-to-week, considering free transfers and hits.</p> </li> <li> <p>Chip Uses: Chip usage is currently not a feature.</p> </li> </ul>"},{"location":"fpl_config/","title":"Configuration","text":"<p>The <code>fpl_config.py</code> file centralizes all configurable parameters for the FPL Expected Points Predictor and Solver. This allows for easy adjustment of FPL scoring rules, thresholds, and optimization settings without modifying the core logic of the predictor or optimizer.</p>"},{"location":"fpl_config/#fpl-point-system-fpl_points","title":"FPL Point System (<code>FPL_POINTS</code>)","text":"<p>A dictionary defining the points awarded for various events in Fantasy Premier League. These values are based on the 2025/26 season rules as specified.</p> Key Description Default Value <code>appearance_points_lt_60</code> Points for playing up to 60 minutes. <code>1</code> <code>appearance_points_gte_60</code> Points for playing 60 minutes or more (excluding stoppage time). <code>2</code> <code>goal_gk</code> Points for each goal scored by a goalkeeper. <code>10</code> <code>goal_def</code> Points for each goal scored by a defender. <code>6</code> <code>goal_mid</code> Points for each goal scored by a midfielder. <code>5</code> <code>goal_fwd</code> Points for each goal scored by a forward. <code>4</code> <code>assist_points</code> Points for each goal assist. <code>3</code> <code>clean_sheet_gk_def</code> Points for a clean sheet by a goalkeeper or defender. <code>4</code> <code>clean_sheet_mid</code> Points for a clean sheet by a midfielder (New for 2025/26 rules). <code>1</code> <code>saves_3_points</code> Points for every 3 shot saves by a goalkeeper. <code>1</code> <code>cbit_def_points</code> For accumulating 10 or more Clearances, Blocks, Interceptions (CBI) &amp; Tackles (defenders). <code>2</code> <code>cbirt_mid_fwd_prob</code> For accumulating 12 or more Clearances, Blocks, Interceptions (CBI), Tackles &amp; Recoveries (midfielders &amp; forwards). <code>2</code> <code>penalty_save_points</code> For each penalty save. <code>5</code> <code>conceded_2_goals_deduction</code> Per 2 goals conceded by a goalkeeper or defender. <code>-1</code> <code>yellow_card_deduction</code> For each yellow card. <code>-1</code> <code>red_card_deduction</code> For each red card. <code>-3</code> <code>penalty_miss_deduction</code> For each penalty miss. <code>-2</code> <code>own_goal_deduction</code> For each own goal. <code>-2</code> <code>bonus_points_scaling_factor</code> A small factor to convert BPS score to expected bonus points (Model specific heuristic). <code>0.005</code>"},{"location":"fpl_config/#thresholds-for-minutes-played","title":"Thresholds for Minutes Played","text":"<p>These constants define thresholds used in predicting player minutes and assessing the reliability of per-90 statistics.</p> <ul> <li> <p><code>MIN_MINUTES_THRESHOLD</code>: Players must have played at least this many minutes for their per-90 stats to be considered reliable.</p> </li> <li> <p>Default: <code>2500</code></p> </li> <li> <p><code>VERY_LOW_MINUTES_THRESHOLD</code>: Players below this minute threshold will have their per-90 stats effectively zeroed out, indicating they are unlikely to play significant minutes.</p> </li> <li> <p>Default: <code>450</code></p> </li> </ul>"},{"location":"fpl_config/#probabilities-for-minor-negative-events","title":"Probabilities for Minor Negative Events","text":"<p>These probabilities are used in the xP calculation for rare negative events.</p> <ul> <li> <p><code>YELLOW_CARD_PROB</code>: Probability of a player receiving a yellow card in a given match.</p> </li> <li> <p>Default: <code>0.05</code></p> </li> <li> <p><code>RED_CARD_PROB</code>: Probability of a player receiving a red card in a given match.</p> </li> <li> <p>Default: <code>0.005</code></p> </li> <li> <p><code>PENALTY_MISS_PROB</code>: Probability of a player missing a penalty.</p> </li> <li> <p>Default: <code>0.01</code></p> </li> <li> <p><code>OWN_GOAL_PROB</code>: Probability of a player scoring an own goal.</p> </li> <li> <p>Default: <code>0.002</code></p> </li> </ul>"},{"location":"fpl_config/#heuristic-probabilities-for-defensive-contribution-points","title":"Heuristic Probabilities for Defensive Contribution Points","text":"<p>These are internal model parameters used to estimate the likelihood of players achieving the new defensive contribution point thresholds, if direct event data is not available from the FPL API.</p> <ul> <li> <p><code>CBIT_DEF_PROB</code>: Heuristic probability for defenders/goalkeepers to accumulate 10 or more Clearances, Blocks, Interceptions (CBI) &amp; Tackles.</p> </li> <li> <p>Default: <code>0.3</code></p> </li> <li> <p><code>CBIRT_MID_FWD_PROB</code>: Heuristic probability for midfielders/forwards to accumulate 12 or more Clearances, Blocks, Interceptions (CBI), Tackles &amp; Recoveries.</p> </li> <li> <p>Default: <code>0.15</code></p> </li> </ul>"},{"location":"fpl_config/#default-expected-minutes","title":"Default Expected Minutes","text":"<ul> <li> <p><code>DEFAULT_SUB_MINUTES</code>: Default average minutes assigned to players who typically come on as substitutes.</p> </li> <li> <p>Default: <code>30.0</code></p> </li> <li> <p><code>DEFAULT_UNKNOWN_PLAYER_MINUTES</code>: Default expected minutes for new players or those with very sparse historical data.</p> </li> <li> <p>Default: <code>10.0</code></p> </li> </ul>"},{"location":"fpl_config/#solver-configuration","title":"Solver Configuration","text":"<p>These parameters control the behavior of the <code>FPLOptimizer</code>.</p> <ul> <li> <p><code>OPTIMIZATION_GAMEWEEKS</code>: The number of upcoming gameweeks the solver will consider for xP calculation (e.g., <code>1</code> for the next gameweek, <code>3</code> for the next three).</p> </li> <li> <p>Default: <code>3</code></p> </li> <li> <p><code>BUDGET</code>: Your total FPL budget in millions of pounds (e.g., <code>100.0</code>).</p> </li> <li> <p>Default: <code>100.0</code></p> </li> <li> <p><code>MAX_PLAYERS_PER_TEAM</code>: The maximum number of players you want from any single Premier League team (FPL limit is usually <code>3</code>).</p> </li> <li> <p>Default: <code>3</code></p> </li> </ul>"},{"location":"fpl_config/#chip-configuration-chip_allowances","title":"Chip Configuration (<code>CHIP_ALLOWANCES</code>)","text":"<p>A dictionary specifying the maximum number of times each FPL chip can be used within the <code>OPTIMIZATION_GAMEWEEKS</code> horizon.</p> Chip Name Description Default Allowance <code>free_hit</code> Free Hit chip allowance. <code>0</code> <code>wildcard</code> Wildcard chip allowance. <code>0</code> <code>bench_boost</code> Bench Boost chip allowance. <code>1</code> <code>triple_captain</code> Triple Captain chip allowance. <code>0</code>"},{"location":"fpl_config/#transfer-rules","title":"Transfer Rules","text":"<p>These constants define the rules governing transfers between gameweeks.</p> <ul> <li> <p><code>INITIAL_FREE_TRANSFERS</code>: The number of free transfers available at the start of the optimization horizon (typically Gameweek 1).</p> </li> <li> <p>Default: <code>1</code></p> </li> <li> <p><code>MAX_FREE_TRANSFERS_SAVED</code>: The maximum number of free transfers that can be saved for future gameweeks.</p> </li> <li> <p>Default: <code>5</code></p> </li> <li> <p><code>POINTS_PER_HIT</code>: The points deduction incurred for each transfer made beyond the available free transfers.</p> </li> <li> <p>Default: <code>4</code></p> </li> </ul>"},{"location":"fpl_config/#player-exclusion-configuration","title":"Player Exclusion Configuration","text":"<p>These lists allow you to explicitly exclude certain players from being considered by the predictor and optimizer.</p> Variable Description Default Value Example <code>EXCLUDED_PLAYERS_BY_ID</code> A list of FPL player IDs to exclude. <code>[]</code> (empty list) <code>[123, 456]</code> <code>EXCLUDED_PLAYERS_BY_NAME</code> A list of player full names (case-sensitive) to exclude. Ensure names match exactly as they appear in the FPL data. <code>[\"Kepa Arrizabalaga Revuelta\", \"Christian N\u00f8rgaard\"]</code> <code>[\"Erling Haaland\", \"Mohamed Salah\"]</code> <code>EXCLUDED_PLAYERS_BY_TEAM_AND_POSITION</code> A list of dictionaries, each specifying a team and position from which all players should be excluded. <code>[]</code> (empty list) <code>[{\"team\": \"Man City\", \"position\": \"GK\"}, {\"team\": \"Arsenal\", \"position\": \"FWD\"}]</code>"},{"location":"fpl_config/#enforced-player-configuration","title":"Enforced Player Configuration","text":"<p>These lists allow you to explicitly enforce certain players or player types to be included in the optimized squad.</p> Variable Description Default Value Example <code>ENFORCED_PLAYERS_BY_ID</code> A list of FPL player IDs to enforce in the squad for the entire optimization horizon. <code>[]</code> (empty list) <code>[101, 202]</code> <code>ENFORCED_PLAYERS_BY_NAME</code> A list of player full names (case-sensitive) to enforce in the squad. <code>[]</code> (empty list) <code>[\"Mohamed Salah\", \"Erling Haaland\"]</code> <code>ENFORCED_PLAYERS_BY_TEAM_AND_POSITION</code> A list of dictionaries, each specifying a team and position from which at least one player must be enforced. You can also specify <code>min_players</code> to enforce more than one. <code>[]</code> (empty list) <code>[{\"team\": \"Liverpool\", \"position\": \"DEF\", \"min_players\": 1}, {\"team\": \"Man City\", \"position\": \"MID\", \"min_players\": 2}]</code>"},{"location":"autoapi/summary/","title":"Summary","text":"<ul> <li>build<ul> <li>lib<ul> <li>build<ul> <li>lib<ul> <li>fpl_solver<ul> <li>fpl_config</li> <li>fpl_solver</li> <li>fpl_xp_predictor</li> </ul> </li> </ul> </li> </ul> </li> <li>fpl_solver<ul> <li>fpl_config</li> <li>fpl_solver</li> <li>fpl_xp_predictor</li> </ul> </li> </ul> </li> </ul> </li> <li>fpl_solver<ul> <li>fpl_solver</li> <li>fpl_xp_predictor</li> </ul> </li> </ul>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/","title":"fpl_solver","text":""},{"location":"autoapi/build/lib/build/lib/fpl_solver/#build.lib.build.lib.fpl_solver.fpl_config","title":"<code>fpl_config</code>","text":"<p>fpl_config.py</p> <p>Configuration settings for the FPL Expected Points Predictor and Solver. This file centralizes all constants related to FPL scoring, thresholds, and optimization parameters.</p>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/#build.lib.build.lib.fpl_solver.fpl_solver","title":"<code>fpl_solver</code>","text":""},{"location":"autoapi/build/lib/build/lib/fpl_solver/#build.lib.build.lib.fpl_solver.fpl_solver.FPLOptimizer","title":"<code>FPLOptimizer</code>","text":"<p>A class to optimize Fantasy Premier League (FPL) squad selection using Integer Linear Programming (ILP).</p> <p>The optimizer aims to select a 15-player squad (2 GKs, 5 DEFs, 5 MIDs, 3 FWDs) within a budget, with a maximum number of players from any single team, to maximize the total expected points.</p> Source code in <code>build/lib/build/lib/fpl_solver/fpl_solver.py</code> <pre><code>class FPLOptimizer:\n    \"\"\"\n    A class to optimize Fantasy Premier League (FPL) squad selection\n    using Integer Linear Programming (ILP).\n\n    The optimizer aims to select a 15-player squad (2 GKs, 5 DEFs, 5 MIDs, 3 FWDs)\n    within a budget, with a maximum number of players from any single team,\n    to maximize the total expected points.\n    \"\"\"\n\n    def __init__(self, player_data: pd.DataFrame):\n        \"\"\"\n        Initializes the FPLOptimizer with player data.\n\n        Args:\n            player_data (pd.DataFrame): A DataFrame containing player information\n                                        with columns: 'name', 'team', 'position',\n                                        'cost', 'expected_points_by_gw' (a dict of xP per GW).\n        \"\"\"\n        required_columns = [\"name\", \"team\", \"position\", \"cost\", \"expected_points_by_gw\"]\n        if not all(col in player_data.columns for col in required_columns):\n            missing_cols = [\n                col for col in required_columns if col not in player_data.columns\n            ]\n            raise ValueError(\n                f\"player_data DataFrame must contain {required_columns} columns. Missing: {missing_cols}\"\n            )\n\n        self.player_data = player_data\n        self.problem = None\n        self.selected_squad_history = {}  # To store squad for each gameweek\n        self.total_cost = 0\n        self.total_expected_points = 0\n        self.total_transfer_hits = 0\n\n        # --- Process Enforced Players ---\n        self.enforced_player_indices = set()\n        self.enforced_team_pos_requirements = []\n\n        print(\"\\n--- Processing Enforced Players ---\")\n\n        # Enforce by Player ID\n        for player_id in ENFORCED_PLAYERS_BY_ID:\n            found_player = self.player_data[self.player_data[\"id\"] == player_id]\n            if not found_player.empty:\n                player_idx = found_player.index[0]\n                self.enforced_player_indices.add(player_idx)\n                print(\n                    f\"Enforcing player by ID: {found_player.loc[player_idx, 'name']} (ID: {player_id})\"\n                )\n            else:\n                print(\n                    f\"Warning: Enforced player with ID {player_id} not found in data.\"\n                )\n\n        # Enforce by Player Name\n        for player_name in ENFORCED_PLAYERS_BY_NAME:\n            found_player = self.player_data[self.player_data[\"name\"] == player_name]\n            if not found_player.empty:\n                player_idx = found_player.index[0]\n                self.enforced_player_indices.add(player_idx)\n                print(f\"Enforcing player by name: {player_name}\")\n            else:\n                print(f\"Warning: Enforced player '{player_name}' not found in data.\")\n\n        # Enforce by Team and Position\n        for requirement in ENFORCED_PLAYERS_BY_TEAM_AND_POSITION:\n            team = requirement.get(\"team\")\n            position = requirement.get(\"position\")\n            if team and position:\n                # Validate team and position exist in data\n                if team not in self.player_data[\"team\"].unique():\n                    print(\n                        f\"Warning: Enforced team '{team}' for position '{position}' not found in data.\"\n                    )\n                    continue\n                if position not in self.player_data[\"position\"].unique():\n                    print(\n                        f\"Warning: Enforced position '{position}' for team '{team}' not found in data.\"\n                    )\n                    continue\n\n                self.enforced_team_pos_requirements.append((team, position))\n                print(f\"Enforcing at least one {position} from {team}.\")\n            else:\n                print(\n                    f\"Warning: Invalid enforced team/position requirement: {requirement}\"\n                )\n\n        if not (\n            self.enforced_player_indices\n            or self.enforced_team_pos_requirements\n            or ENFORCED_PLAYERS_BY_ID\n            or ENFORCED_PLAYERS_BY_NAME\n            or ENFORCED_PLAYERS_BY_TEAM_AND_POSITION\n        ):\n            print(\"No players or team/position combinations are enforced.\")\n        print(\"-----------------------------------\\n\")\n\n    def solve(\n        self,\n        budget: float,\n        max_players_per_team: int,\n        chip_allowances: dict,\n        num_gameweeks: int,\n    ) -&gt; bool:\n        \"\"\"\n        Solves the FPL optimization problem using PuLP.\n\n        Args:\n            budget (float): The maximum budget in millions of pounds.\n            max_players_per_team (int): The maximum number of players allowed from\n                                        any single Premier League team.\n            chip_allowances (dict): A dictionary specifying the maximum usage for each chip.\n            num_gameweeks (int): The number of gameweeks to optimize over.\n\n        Returns:\n            bool: True if a solution was found, False otherwise.\n        \"\"\"\n        self.problem = LpProblem(\"FPL Squad Multi-Week Optimization\", LpMaximize)\n\n        # Decision variables for player selection, indexed by player and gameweek\n        player_vars = LpVariable.dicts(\n            \"Player\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n        )\n        starting_xi_vars = LpVariable.dicts(\n            \"StartingXI\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n        )\n        captain_var = LpVariable.dicts(\n            \"Captain\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n        )\n\n        # Binary variables for chip usage, indexed by gameweek\n        use_bench_boost = LpVariable.dicts(\n            \"Use_Bench_Boost\", range(num_gameweeks), 0, 1, LpBinary\n        )\n        use_triple_captain = LpVariable.dicts(\n            \"Use_Triple_Captain\", range(num_gameweeks), 0, 1, LpBinary\n        )\n\n        # Transfer variables\n        transfer_in_vars = LpVariable.dicts(\n            \"Transfer_In\",\n            (self.player_data.index, range(1, num_gameweeks)),\n            0,\n            1,\n            LpBinary,\n        )\n        transfer_out_vars = LpVariable.dicts(\n            \"Transfer_Out\",\n            (self.player_data.index, range(1, num_gameweeks)),\n            0,\n            1,\n            LpBinary,\n        )\n\n        # Total transfers made in a gameweek (absolute count)\n        transfers_made = LpVariable.dicts(\n            \"Transfers_Made\", range(1, num_gameweeks), 0, None, LpInteger\n        )\n        # Free transfers available at the start of a gameweek\n        free_transfers_available = LpVariable.dicts(\n            \"Free_Transfers_Available\",\n            range(num_gameweeks),\n            0,\n            MAX_FREE_TRANSFERS_SAVED + 1,\n            LpInteger,\n        )\n        # Number of transfer hits taken in a gameweek\n        transfer_hits = LpVariable.dicts(\n            \"Transfer_Hits\", range(1, num_gameweeks), 0, None, LpInteger\n        )\n\n        # Auxiliary variables for linearizing chip effects\n        is_bench_player = LpVariable.dicts(\n            \"Is_Bench_Player\",\n            (self.player_data.index, range(num_gameweeks)),\n            0,\n            1,\n            LpBinary,\n        )\n        actual_bench_boost_points = LpVariable.dicts(\n            \"Actual_Bench_Boost_Points\",\n            (self.player_data.index, range(num_gameweeks)),\n            0,\n            None,\n            LpContinuous,\n        )\n        actual_triple_captain_bonus = LpVariable.dicts(\n            \"Actual_Triple_Captain_Bonus\",\n            (self.player_data.index, range(num_gameweeks)),\n            0,\n            None,\n            LpContinuous,\n        )\n\n        # --- Objective Function ---\n        total_objective_points = []\n\n        # Get the first gameweek number from the player data to correctly index expected_points_by_gw\n        first_gw_key = next(\n            iter(\n                self.player_data.loc[\n                    self.player_data.index[0], \"expected_points_by_gw\"\n                ].keys()\n            )\n        )\n        current_gameweek_number_start = int(first_gw_key)\n\n        for w in range(num_gameweeks):\n            # The actual gameweek number (1-indexed)\n            gw_actual = current_gameweek_number_start + w\n\n            # Base expected points from the selected starting 11 for this gameweek\n            base_points_expression_gw = lpSum(\n                self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n                * starting_xi_vars[i][w]\n                for i in self.player_data.index\n            )\n            total_objective_points.append(base_points_expression_gw)\n\n            # Regular Captaincy points (additional 1x for captain)\n            captain_points_bonus_gw = lpSum(\n                self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n                * captain_var[i][w]\n                for i in self.player_data.index\n            )\n            total_objective_points.append(captain_points_bonus_gw)\n\n            # Define auxiliary variables and constraints for chips for each gameweek\n            for i in self.player_data.index:\n                # Use gameweek-specific player xP for chip calculations\n                player_xp = self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n\n                # Bench Boost auxiliary variables and constraints\n                self.problem += (\n                    is_bench_player[i][w] &lt;= player_vars[i][w],\n                    f\"IsBench_Squad_{i}_{w}\",\n                )\n                self.problem += (\n                    is_bench_player[i][w] &lt;= 1 - starting_xi_vars[i][w],\n                    f\"IsBench_NotStarter_{i}_{w}\",\n                )\n                self.problem += (\n                    is_bench_player[i][w]\n                    &gt;= player_vars[i][w] + (1 - starting_xi_vars[i][w]) - 1,\n                    f\"IsBench_Logical_{i}_{w}\",\n                )\n\n                self.problem += (\n                    actual_bench_boost_points[i][w]\n                    &lt;= player_xp * is_bench_player[i][w],\n                    f\"BenchBoost_Contr_1_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_bench_boost_points[i][w] &lt;= player_xp * use_bench_boost[w],\n                    f\"BenchBoost_Contr_2_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_bench_boost_points[i][w]\n                    &gt;= player_xp * (is_bench_player[i][w] + use_bench_boost[w] - 1),\n                    f\"BenchBoost_Contr_3_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_bench_boost_points[i][w] &gt;= 0,\n                    f\"BenchBoost_Contr_4_{i}_{w}\",\n                )\n\n                # Triple Captain auxiliary variables and constraints\n                # Changed player_xp * 2 to player_xp to reflect additional 1x bonus\n                self.problem += (\n                    actual_triple_captain_bonus[i][w] &lt;= player_xp * captain_var[i][w],\n                    f\"TripleCaptain_Contr_1_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_triple_captain_bonus[i][w]\n                    &lt;= player_xp * use_triple_captain[w],\n                    f\"TripleCaptain_Contr_2_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_triple_captain_bonus[i][w]\n                    &gt;= player_xp * (captain_var[i][w] + use_triple_captain[w] - 1),\n                    f\"TripleCaptain_Contr_3_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_triple_captain_bonus[i][w] &gt;= 0,\n                    f\"TripleCaptain_Contr_4_{i}_{w}\",\n                )\n\n            # Add points from bench boost and triple captain bonus for this gameweek\n            total_bench_boost_points_gw = lpSum(\n                actual_bench_boost_points[i][w] for i in self.player_data.index\n            )\n            total_triple_captain_bonus_points_gw = lpSum(\n                actual_triple_captain_bonus[i][w] for i in self.player_data.index\n            )\n\n            total_objective_points.append(total_bench_boost_points_gw)\n            total_objective_points.append(total_triple_captain_bonus_points_gw)\n\n        # Subtract transfer hits from the total objective\n        total_objective_points.append(\n            -POINTS_PER_HIT * lpSum(transfer_hits[w] for w in range(1, num_gameweeks))\n        )\n\n        self.problem += (\n            lpSum(total_objective_points),\n            \"Total Expected Points Over Gameweeks\",\n        )\n\n        # --- Constraints ---\n\n        # Apply constraints for each gameweek\n        for w in range(num_gameweeks):\n            # 1. Select exactly 15 players for the squad\n            self.problem += (\n                lpSum(player_vars[i][w] for i in self.player_data.index) == 15,\n                f\"Total_Players_GW{w}\",\n            )\n\n            # 2. Squad position constraints (2 GKs, 5 DEFs, 5 MIDs, 3 FWDs)\n            gks = self.player_data[self.player_data[\"position\"] == \"GK\"].index\n            defs = self.player_data[self.player_data[\"position\"] == \"DEF\"].index\n            mids = self.player_data[self.player_data[\"position\"] == \"MID\"].index\n            fwds = self.player_data[self.player_data[\"position\"] == \"FWD\"].index\n\n            self.problem += (\n                lpSum(player_vars[i][w] for i in gks) == 2,\n                f\"Goalkeepers_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(player_vars[i][w] for i in defs) == 5,\n                f\"Defenders_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(player_vars[i][w] for i in mids) == 5,\n                f\"Midfielders_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(player_vars[i][w] for i in fwds) == 3,\n                f\"Forwards_Count_GW{w}\",\n            )\n\n            # 3. Budget constraint\n            # This applies to the cost of the squad for the current gameweek.\n            self.problem += (\n                lpSum(\n                    self.player_data.loc[i, \"cost\"] * player_vars[i][w]\n                    for i in self.player_data.index\n                )\n                &lt;= budget,\n                f\"Total_Budget_GW{w}\",\n            )\n\n            # 4. Maximum players per team constraint\n            for team in self.player_data[\"team\"].unique():\n                team_players = self.player_data[self.player_data[\"team\"] == team].index\n                self.problem += (\n                    lpSum(player_vars[i][w] for i in team_players)\n                    &lt;= max_players_per_team,\n                    f\"Max_Players_from_{team}_GW{w}\",\n                )\n\n            # 5. Starting XI constraints\n            # 5.1 Select exactly 11 players for the starting XI\n            self.problem += (\n                lpSum(starting_xi_vars[i][w] for i in self.player_data.index) == 11,\n                f\"Total_Starting_XI_Players_GW{w}\",\n            )\n\n            # 5.2 A player can only be in the starting XI if they are in the squad\n            for i in self.player_data.index:\n                self.problem += (\n                    starting_xi_vars[i][w] &lt;= player_vars[i][w],\n                    f\"StartingXI_in_Squad_{i}_{w}\",\n                )\n\n            # 5.3 Starting XI position constraints (FPL allows flexible formations, so use minimums)\n            self.problem += (\n                lpSum(starting_xi_vars[i][w] for i in gks) == 1,\n                f\"Starting_Goalkeepers_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(starting_xi_vars[i][w] for i in defs) &gt;= 3,\n                f\"Min_Starting_Defenders_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(starting_xi_vars[i][w] for i in mids) &gt;= 2,\n                f\"Min_Starting_Midfielders_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(starting_xi_vars[i][w] for i in fwds) &gt;= 1,\n                f\"Min_Starting_Forwards_Count_GW{w}\",\n            )\n\n            # 6. Captain Constraints\n            # 6.1 Select exactly one captain from the starting XI\n            self.problem += (\n                lpSum(captain_var[i][w] for i in self.player_data.index) == 1,\n                f\"One_Captain_GW{w}\",\n            )\n\n            # 6.2 A player can only be captain if they are in the starting XI\n            for i in self.player_data.index:\n                self.problem += (\n                    captain_var[i][w] &lt;= starting_xi_vars[i][w],\n                    f\"Captain_in_StartingXI_{i}_{w}\",\n                )\n\n            # --- Enforced Player Constraints---\n            for player_idx in self.enforced_player_indices:\n                self.problem += (\n                    player_vars[player_idx][w] == 1,\n                    f\"Enforce_Player_{self.player_data.loc[player_idx, 'name']}_GW{w}\",\n                )\n\n            for team, position in self.enforced_team_pos_requirements:\n                # Filter players for the current team and position\n                team_pos_players = self.player_data[\n                    (self.player_data[\"team\"] == team)\n                    &amp; (self.player_data[\"position\"] == position)\n                ].index\n                if not team_pos_players.empty:\n                    self.problem += (\n                        lpSum(player_vars[i][w] for i in team_pos_players) &gt;= 1,\n                        f\"Enforce_One_{position}_from_{team}_GW{w}\",\n                    )\n                else:\n                    print(\n                        f\"Warning: No players found for enforced requirement: at least one {position} from {team} for GW{gw_actual}.\"\n                    )\n\n        # --- Chip Usage Constraints (TOTAL usage over all gameweeks) ---\n        # These constraints should be outside the per-gameweek loop to avoid duplicates.\n        self.problem += (\n            lpSum(use_bench_boost[j] for j in range(num_gameweeks))\n            &lt;= chip_allowances.get(\"bench_boost\", 0),\n            f\"Max_Bench_Boost_Usage_Total\",\n        )\n        self.problem += (\n            lpSum(use_triple_captain[j] for j in range(num_gameweeks))\n            &lt;= chip_allowances.get(\"triple_captain\", 0),\n            f\"Max_Triple_Captain_Usage_Total\",\n        )\n\n        # --- Inter-Gameweek Constraints (Transfers and Transfer Rules) ---\n        # Initialize free transfers for GW0 (first gameweek of optimization horizon)\n        # This assumes the optimization starts at GW0, and it has INITIAL_FREE_TRANSFERS.\n        # If the model starts at an arbitrary GW, this would need to be an input.\n        self.problem += (\n            free_transfers_available[0] == INITIAL_FREE_TRANSFERS,\n            f\"Initial_Free_Transfers_GW0\",\n        )\n\n        for w in range(1, num_gameweeks):\n            # Calculate total transfers made in this gameweek\n            self.problem += (\n                transfers_made[w]\n                == lpSum(transfer_in_vars[i][w] for i in self.player_data.index),\n                f\"Transfers_Made_GW{w}\",\n            )\n            # Total transfers in must equal total transfers out for each gameweek after the first\n            self.problem += (\n                lpSum(transfer_in_vars[i][w] for i in self.player_data.index)\n                == lpSum(transfer_out_vars[i][w] for i in self.player_data.index),\n                f\"Transfers_In_Equals_Out_GW{w}\",\n            )\n\n            # Calculate free transfers available for the current gameweek (w)\n            # Free transfers for GW_w = min(free transfers from GW_w-1 - transfers made in GW_w + 1, MAX_FREE_TRANSFERS_SAVED + 1)\n            # The + 1 in MAX_FREE_TRANSFERS_SAVED + 1 is because MAX_FREE_TRANSFERS_SAVED implies how many can be *saved*,\n            # so if you save 1, you have 1 (current) + 1 (saved) = 2.\n            self.problem += (\n                free_transfers_available[w]\n                &lt;= free_transfers_available[w - 1] - transfers_made[w] + 1,\n                f\"Free_Transfers_Calc_1_GW{w}\",\n            )\n            self.problem += (\n                free_transfers_available[w] &lt;= MAX_FREE_TRANSFERS_SAVED + 1,\n                f\"Free_Transfers_Calc_2_GW{w}\",\n            )\n            self.problem += (\n                free_transfers_available[w] &gt;= 0,  # Cannot have negative free transfers\n                f\"Free_Transfers_Non_Negative_GW{w}\",\n            )\n\n            # Calculate transfer hits\n            # transfer_hits[w] = max(0, transfers_made[w] - free_transfers_available_at_start_of_gw_w)\n            # This needs to be linearized. If transfers_made[w] &gt; free_transfers_available[w-1], then hit.\n            # free_transfers_available[w-1] represents transfers available *before* making transfers for GW_w\n            self.problem += (\n                transfer_hits[w] &gt;= transfers_made[w] - free_transfers_available[w - 1],\n                f\"Transfer_Hits_Calc_1_GW{w}\",\n            )\n            self.problem += (\n                transfer_hits[w] &gt;= 0,\n                f\"Transfer_Hits_Calc_2_GW{w}\",\n            )\n\n            for i in self.player_data.index:\n                # Squad continuity: player_vars[i][w] (in squad at start of GW w)\n                #                 = player_vars[i][w-1] (in squad at start of GW w-1)\n                #                 - transfer_out_vars[i][w] (transferred out for GW w)\n                #                 + transfer_in_vars[i][w] (transferred in for GW w)\n                self.problem += (\n                    player_vars[i][w]\n                    == player_vars[i][w - 1]\n                    - transfer_out_vars[i][w]\n                    + transfer_in_vars[i][w],\n                    f\"Squad_Continuity_{i}_GW{w}\",\n                )\n                # A player cannot be transferred in and out in the same gameweek\n                self.problem += (\n                    transfer_in_vars[i][w] + transfer_out_vars[i][w] &lt;= 1,\n                    f\"No_Simultaneous_Transfer_{i}_{w}\",\n                )\n\n        try:\n            # The solver is called with the GLPK_CMD solver\n            self.problem.solve(PULP_CBC_CMD(msg=0))  # msg=0 suppresses verbose output\n        except Exception as e:\n            print(f\"Error solving the problem: {e}\")\n            return False\n\n        if LpStatus[self.problem.status] == \"Optimal\":\n            print(\"Optimization successful! Optimal solution found.\")\n\n            self.selected_squad_history = {}\n            self.total_transfer_hits = 0\n            for w in range(num_gameweeks):\n                # The actual gameweek number (1-indexed)\n                gw_actual = current_gameweek_number_start + w\n\n                # Get selected players for the current gameweek\n                selected_squad_gw = self.player_data[\n                    [player_vars[i][w].varValue == 1 for i in self.player_data.index]\n                ].copy()\n\n                # Get starter and captain info for this gameweek\n                is_starter_series_gw = pd.Series(\n                    [\n                        starting_xi_vars[i][w].varValue == 1\n                        for i in self.player_data.index\n                    ],\n                    index=self.player_data.index,\n                )\n                is_captain_series_gw = pd.Series(\n                    [captain_var[i][w].varValue == 1 for i in self.player_data.index],\n                    index=self.player_data.index,\n                )\n\n                selected_squad_gw[\"is_starter\"] = is_starter_series_gw.loc[\n                    selected_squad_gw.index\n                ]\n                selected_squad_gw[\"is_captain\"] = is_captain_series_gw.loc[\n                    selected_squad_gw.index\n                ]\n\n                transfers_in_gw = 0\n                transfers_out_gw = 0\n                hits_gw = 0\n\n                # Store transfer details for gameweeks &gt; 0\n                if (\n                    w &gt; 0\n                ):  # Check for transfers only from GW1 onwards (index 1 in 0-indexed loop)\n                    transfer_in_flags = pd.Series(\n                        [\n                            transfer_in_vars[i][w].varValue == 1\n                            for i in self.player_data.index\n                        ],\n                        index=self.player_data.index,\n                    )\n                    transfer_out_flags = pd.Series(\n                        [\n                            transfer_out_vars[i][w].varValue == 1\n                            for i in self.player_data.index\n                        ],\n                        index=self.player_data.index,\n                    )\n\n                    selected_squad_gw[\"transfer_in\"] = transfer_in_flags.loc[\n                        selected_squad_gw.index\n                    ]\n                    selected_squad_gw[\"transfer_out\"] = transfer_out_flags.loc[\n                        selected_squad_gw.index\n                    ]\n\n                    transfers_in_gw = int(round(transfer_in_flags.sum()))\n                    transfers_out_gw = int(round(transfer_out_flags.sum()))\n                    hits_gw = int(round(transfer_hits[w].varValue))\n                    self.total_transfer_hits += hits_gw\n                else:\n                    selected_squad_gw[\"transfer_in\"] = False  # No transfers in for GW0\n                    selected_squad_gw[\"transfer_out\"] = (\n                        False  # No transfers out for GW0\n                    )\n\n                self.selected_squad_history[f\"GW{gw_actual}\"] = {\n                    \"squad\": selected_squad_gw,\n                    \"total_cost\": selected_squad_gw[\"cost\"].sum(),\n                    \"expected_points_from_xi\": sum(\n                        self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n                        * starting_xi_vars[i][w].varValue\n                        for i in self.player_data.index\n                    ),\n                    \"bench_boost_used\": bool(use_bench_boost[w].varValue),\n                    \"triple_captain_used\": bool(use_triple_captain[w].varValue),\n                    \"total_bench_boost_points\": value(\n                        lpSum(\n                            actual_bench_boost_points[i][w]\n                            for i in self.player_data.index\n                        )\n                    ),\n                    \"total_triple_captain_bonus\": value(\n                        lpSum(\n                            actual_triple_captain_bonus[i][w]\n                            for i in self.player_data.index\n                        )\n                    ),\n                    \"transfers_in_count\": transfers_in_gw,\n                    \"transfers_out_count\": transfers_out_gw,\n                    \"transfer_hits\": hits_gw,  # New\n                    \"free_transfers_available_next_gw\": (\n                        int(round(free_transfers_available[w].varValue))\n                        if w &lt; num_gameweeks - 1\n                        else 0\n                    ),  # Free transfers available *after* this GW's transfers are made\n                }\n\n            # Overall totals\n            self.total_cost = self.selected_squad_history[\n                f\"GW{current_gameweek_number_start + num_gameweeks - 1}\"\n            ][\n                \"total_cost\"\n            ]  # Cost of final squad\n            self.total_expected_points = value(\n                self.problem.objective\n            )  # Total objective value from solver\n            self.used_chips = {\n                f\"GW{current_gameweek_number_start + w}\": {\n                    \"bench_boost\": bool(use_bench_boost[w].varValue),\n                    \"triple_captain\": bool(use_triple_captain[w].varValue),\n                }\n                for w in range(num_gameweeks)\n            }\n\n            return True\n        else:\n            print(f\"No optimal solution found. Status: {LpStatus[self.problem.status]}\")\n            self.selected_squad_history = {}\n            self.total_cost = 0\n            self.total_expected_points = 0\n            self.used_chips = {}\n            self.total_transfer_hits = 0\n            return False\n\n    def get_selected_squad(self, gameweek: int = None) -&gt; pd.DataFrame | None:\n        \"\"\"\n        Returns the selected squad for a specific gameweek (1-indexed).\n        If no gameweek is specified, returns the squad for the last optimized gameweek.\n        \"\"\"\n        if not self.selected_squad_history:\n            return None\n\n        # Get the first GW key to determine the range of available GWs\n        first_gw_in_history = min(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n        last_gw_in_history = max(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n\n        if gameweek is None:\n            return self.selected_squad_history[f\"GW{last_gw_in_history}\"][\"squad\"]\n\n        if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n            print(\n                f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n            )\n            return None\n\n        return self.selected_squad_history.get(f\"GW{gameweek}\", {}).get(\"squad\")\n\n    def get_total_cost(self, gameweek: int = None) -&gt; float:\n        \"\"\"\n        Returns the total cost for a specific gameweek (1-indexed).\n        If no gameweek is specified, returns the cost of the squad in the last optimized gameweek.\n        \"\"\"\n        if not self.selected_squad_history:\n            return 0\n        first_gw_in_history = min(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n        last_gw_in_history = max(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n\n        if gameweek is None:\n            return self.selected_squad_history[f\"GW{last_gw_in_history}\"][\"total_cost\"]\n\n        if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n            print(\n                f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n            )\n            return 0  # Or raise an error\n\n        return self.selected_squad_history.get(f\"GW{gameweek}\", {}).get(\"total_cost\", 0)\n\n    def get_total_expected_points(self) -&gt; float:\n        \"\"\"\n        Returns the overall total expected points across all optimized gameweeks.\n        \"\"\"\n        return self.total_expected_points\n\n    def get_gameweek_summary(self, gameweek: int):\n        \"\"\"\n        Returns a dictionary summary for a specific gameweek.\n        \"\"\"\n        if not self.selected_squad_history:\n            return None\n        first_gw_in_history = min(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n        last_gw_in_history = max(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n\n        if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n            print(\n                f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n            )\n            return None\n\n        return self.selected_squad_history.get(f\"GW{gameweek}\")\n\n    def print_squad_summary(self, gameweek: int):\n        \"\"\"\n        Prints a formatted summary of the selected squad for a specific gameweek.\n        \"\"\"\n        if not self.selected_squad_history:\n            print(\"No squad has been selected yet. Run the 'solve' method first.\")\n            return\n\n        gw_data = self.get_gameweek_summary(gameweek)\n        if not gw_data:\n            return  # get_gameweek_summary already prints error message\n\n        selected_squad = gw_data[\"squad\"]\n        total_cost = gw_data[\"total_cost\"]\n        expected_points_from_xi = gw_data[\"expected_points_from_xi\"]\n        bench_boost_used = gw_data[\"bench_boost_used\"]\n        triple_captain_used = gw_data[\"triple_captain_used\"]\n        total_bench_boost_points = gw_data[\"total_bench_boost_points\"]\n        total_triple_captain_bonus = gw_data[\"total_triple_captain_bonus\"]\n        transfers_in_count = gw_data[\"transfers_in_count\"]  # New\n        transfers_out_count = gw_data[\"transfers_out_count\"]  # New\n        transfer_hits_taken = gw_data[\"transfer_hits\"]  # New\n        free_transfers_available_next_gw = gw_data[\n            \"free_transfers_available_next_gw\"\n        ]  # New\n\n        print(f\"\\n--- FPL Optimized Squad for Gameweek {gameweek} ---\")\n        print(f\"Squad Cost: \u00a3{total_cost:.1f}m\")\n        print(f\"Expected Points (Starting XI): {expected_points_from_xi:.2f}\")\n        print(\n            f\"Total Expected Points for GW{gameweek} (including chips): {expected_points_from_xi + total_bench_boost_points + total_triple_captain_bonus:.2f}\"\n        )\n        print(\"\\n--- Chips Used This Gameweek ---\")\n        if bench_boost_used:\n            print(f\"- Bench Boost (Added {total_bench_boost_points:.2f} points)\")\n        if triple_captain_used:\n            print(\n                f\"- Triple Captain (Added {total_triple_captain_bonus:.2f} bonus points)\"\n            )\n        if not (bench_boost_used or triple_captain_used):\n            print(\"No chips used this gameweek.\")\n\n        print(\"\\n--- Goalkeepers (Starting XI marked with *) ---\")\n        for index, row in selected_squad[selected_squad[\"position\"] == \"GK\"].iterrows():\n            starter_str = \"*\" if row[\"is_starter\"] else \"\"\n            captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n            transfer_status = \"\"\n            if row[\"transfer_in\"]:\n                transfer_status = \"(IN)\"\n            elif row[\"transfer_out\"]:\n                transfer_status = \"(OUT)\"\n\n            # Access gameweek-specific xP correctly\n            player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n            print(\n                f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n            )\n        print(\"\\n--- Defenders (Starting XI marked with *) ---\")\n        for index, row in selected_squad[\n            selected_squad[\"position\"] == \"DEF\"\n        ].iterrows():\n            starter_str = \"*\" if row[\"is_starter\"] else \"\"\n            captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n            transfer_status = \"\"\n            if row[\"transfer_in\"]:\n                transfer_status = \"(IN)\"\n            elif row[\"transfer_out\"]:\n                transfer_status = \"(OUT)\"\n\n            player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n            print(\n                f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n            )\n        print(\"\\n--- Midfielders (Starting XI marked with *) ---\")\n        for index, row in selected_squad[\n            selected_squad[\"position\"] == \"MID\"\n        ].iterrows():\n            starter_str = \"*\" if row[\"is_starter\"] else \"\"\n            captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n            transfer_status = \"\"\n            if row[\"transfer_in\"]:\n                transfer_status = \"(IN)\"\n            elif row[\"transfer_out\"]:\n                transfer_status = \"(OUT)\"\n\n            player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n            print(\n                f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n            )\n        print(\"\\n--- Forwards (Starting XI marked with *) ---\")\n        for index, row in selected_squad[\n            selected_squad[\"position\"] == \"FWD\"\n        ].iterrows():\n            starter_str = \"*\" if row[\"is_starter\"] else \"\"\n            captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n            transfer_status = \"\"\n            if row[\"transfer_in\"]:\n                transfer_status = \"(IN)\"\n            elif row[\"transfer_out\"]:\n                transfer_status = \"(OUT)\"\n\n            player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n            print(\n                f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n            )\n\n        print(f\"\\n--- Team Breakdown for GW{gameweek} ---\")\n        print(selected_squad[\"team\"].value_counts())\n\n        # Transfers are relevant from Gameweek 2 (index 1) onwards in the optimization horizon\n        # For display, if the current GW is the initial one (GW1 in the current context), no transfers are made\n        # If it's a subsequent GW, check if transfers occurred.\n        first_gw_in_history = min(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n        if (\n            gameweek &gt;= first_gw_in_history\n        ):  # Changed from &gt; to &gt;=, to show initial free transfers\n            # Display transfer info for this gameweek\n            print(\n                f\"  Transfers In: {transfers_in_count}, Transfers Out: {transfers_out_count}\"\n            )\n            print(\n                f\"  Transfer Hits: {transfer_hits_taken} (-{transfer_hits_taken * POINTS_PER_HIT} points)\"\n            )\n            # Only show free transfers for the *next* gameweek if it's not the last gameweek in the horizon\n            if gameweek &lt; max(\n                int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n            ):\n                print(\n                    f\"  Free Transfers Available for Next GW: {free_transfers_available_next_gw}\"\n                )\n        print(\"---------------------------\\n\")\n\n    def print_overall_summary(self):\n        \"\"\"\n        Prints an overall summary of the multi-week optimization results.\n        \"\"\"\n        if not self.selected_squad_history:\n            print(\"No optimization results to summarize.\")\n            return\n\n        print(\"\\n=== Overall Multi-Week FPL Optimization Summary ===\")\n        print(\n            f\"Total Expected Points Across All Gameweeks: {self.total_expected_points:.2f}\"\n        )\n\n        # Get the latest gameweek's cost\n        last_gw_key = max(\n            self.selected_squad_history.keys(), key=lambda k: int(k.replace(\"GW\", \"\"))\n        )\n        print(\n            f\"Squad Cost ({last_gw_key}): \u00a3{self.selected_squad_history[last_gw_key]['total_cost']:.1f}m\"\n        )\n        print(\n            f\"Total Transfer Hits Taken: {self.total_transfer_hits} (-{self.total_transfer_hits * POINTS_PER_HIT} points)\"\n        )\n\n        print(\"\\n--- Chip Usage Across Gameweeks ---\")\n        # Ensure consistent order by sorting gameweek keys\n        sorted_gw_keys = sorted(\n            self.used_chips.keys(), key=lambda k: int(k.replace(\"GW\", \"\"))\n        )\n        for gw_str in sorted_gw_keys:\n            chips = self.used_chips[gw_str]\n            chip_summary = []\n            if chips[\"bench_boost\"]:\n                chip_summary.append(\"Bench Boost\")\n            if chips[\"triple_captain\"]:\n                chip_summary.append(\"Triple Captain\")\n\n            if chip_summary:\n                print(f\"{gw_str}: {', '.join(chip_summary)}\")\n            else:\n                print(f\"{gw_str}: No chips used\")\n\n        print(\"\\n--- Gameweek-by-Gameweek Summary ---\")\n        # Iterate and print basic summary for each gameweek\n        for gw_str in sorted_gw_keys:\n            gw_data = self.selected_squad_history[gw_str]\n            print(f\"\\n--- {gw_str} ---\")\n            print(f\"  Squad Cost: \u00a3{gw_data['total_cost']:.1f}m\")\n            print(\n                f\"  Expected Points (Starting XI): {gw_data['expected_points_from_xi']:.2f}\"\n            )\n            print(\n                f\"  Total GW Points (incl. chips): {gw_data['expected_points_from_xi'] + gw_data['total_bench_boost_points'] + gw_data['total_triple_captain_bonus']:.2f}\"\n            )\n\n            # Display transfer info for this gameweek\n            transfers_in_count = gw_data[\"transfers_in_count\"]\n            transfers_out_count = gw_data[\"transfers_out_count\"]\n            transfer_hits_taken = gw_data[\"transfer_hits\"]\n            free_transfers_available_next_gw = gw_data[\n                \"free_transfers_available_next_gw\"\n            ]\n\n            print(\n                f\"  Transfers In: {transfers_in_count}, Transfers Out: {transfers_out_count}\"\n            )\n            print(\n                f\"  Transfer Hits: {transfer_hits_taken} (-{transfer_hits_taken * POINTS_PER_HIT} points)\"\n            )\n            # Only show free transfers for the *next* gameweek if it's not the last gameweek in the horizon\n            if int(gw_str.replace(\"GW\", \"\")) &lt; max(\n                int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n            ):\n                print(\n                    f\"  Free Transfers Available for Next GW: {free_transfers_available_next_gw}\"\n                )\n            print(\"-----------------------------------\")\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/#build.lib.build.lib.fpl_solver.fpl_solver.FPLOptimizer.__init__","title":"<code>__init__(player_data)</code>","text":"<p>Initializes the FPLOptimizer with player data.</p> <p>Parameters:</p> Name Type Description Default <code>player_data</code> <code>DataFrame</code> <p>A DataFrame containing player information                         with columns: 'name', 'team', 'position',                         'cost', 'expected_points_by_gw' (a dict of xP per GW).</p> required Source code in <code>build/lib/build/lib/fpl_solver/fpl_solver.py</code> <pre><code>def __init__(self, player_data: pd.DataFrame):\n    \"\"\"\n    Initializes the FPLOptimizer with player data.\n\n    Args:\n        player_data (pd.DataFrame): A DataFrame containing player information\n                                    with columns: 'name', 'team', 'position',\n                                    'cost', 'expected_points_by_gw' (a dict of xP per GW).\n    \"\"\"\n    required_columns = [\"name\", \"team\", \"position\", \"cost\", \"expected_points_by_gw\"]\n    if not all(col in player_data.columns for col in required_columns):\n        missing_cols = [\n            col for col in required_columns if col not in player_data.columns\n        ]\n        raise ValueError(\n            f\"player_data DataFrame must contain {required_columns} columns. Missing: {missing_cols}\"\n        )\n\n    self.player_data = player_data\n    self.problem = None\n    self.selected_squad_history = {}  # To store squad for each gameweek\n    self.total_cost = 0\n    self.total_expected_points = 0\n    self.total_transfer_hits = 0\n\n    # --- Process Enforced Players ---\n    self.enforced_player_indices = set()\n    self.enforced_team_pos_requirements = []\n\n    print(\"\\n--- Processing Enforced Players ---\")\n\n    # Enforce by Player ID\n    for player_id in ENFORCED_PLAYERS_BY_ID:\n        found_player = self.player_data[self.player_data[\"id\"] == player_id]\n        if not found_player.empty:\n            player_idx = found_player.index[0]\n            self.enforced_player_indices.add(player_idx)\n            print(\n                f\"Enforcing player by ID: {found_player.loc[player_idx, 'name']} (ID: {player_id})\"\n            )\n        else:\n            print(\n                f\"Warning: Enforced player with ID {player_id} not found in data.\"\n            )\n\n    # Enforce by Player Name\n    for player_name in ENFORCED_PLAYERS_BY_NAME:\n        found_player = self.player_data[self.player_data[\"name\"] == player_name]\n        if not found_player.empty:\n            player_idx = found_player.index[0]\n            self.enforced_player_indices.add(player_idx)\n            print(f\"Enforcing player by name: {player_name}\")\n        else:\n            print(f\"Warning: Enforced player '{player_name}' not found in data.\")\n\n    # Enforce by Team and Position\n    for requirement in ENFORCED_PLAYERS_BY_TEAM_AND_POSITION:\n        team = requirement.get(\"team\")\n        position = requirement.get(\"position\")\n        if team and position:\n            # Validate team and position exist in data\n            if team not in self.player_data[\"team\"].unique():\n                print(\n                    f\"Warning: Enforced team '{team}' for position '{position}' not found in data.\"\n                )\n                continue\n            if position not in self.player_data[\"position\"].unique():\n                print(\n                    f\"Warning: Enforced position '{position}' for team '{team}' not found in data.\"\n                )\n                continue\n\n            self.enforced_team_pos_requirements.append((team, position))\n            print(f\"Enforcing at least one {position} from {team}.\")\n        else:\n            print(\n                f\"Warning: Invalid enforced team/position requirement: {requirement}\"\n            )\n\n    if not (\n        self.enforced_player_indices\n        or self.enforced_team_pos_requirements\n        or ENFORCED_PLAYERS_BY_ID\n        or ENFORCED_PLAYERS_BY_NAME\n        or ENFORCED_PLAYERS_BY_TEAM_AND_POSITION\n    ):\n        print(\"No players or team/position combinations are enforced.\")\n    print(\"-----------------------------------\\n\")\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/#build.lib.build.lib.fpl_solver.fpl_solver.FPLOptimizer.get_gameweek_summary","title":"<code>get_gameweek_summary(gameweek)</code>","text":"<p>Returns a dictionary summary for a specific gameweek.</p> Source code in <code>build/lib/build/lib/fpl_solver/fpl_solver.py</code> <pre><code>def get_gameweek_summary(self, gameweek: int):\n    \"\"\"\n    Returns a dictionary summary for a specific gameweek.\n    \"\"\"\n    if not self.selected_squad_history:\n        return None\n    first_gw_in_history = min(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n    last_gw_in_history = max(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n\n    if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n        print(\n            f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n        )\n        return None\n\n    return self.selected_squad_history.get(f\"GW{gameweek}\")\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/#build.lib.build.lib.fpl_solver.fpl_solver.FPLOptimizer.get_selected_squad","title":"<code>get_selected_squad(gameweek=None)</code>","text":"<p>Returns the selected squad for a specific gameweek (1-indexed). If no gameweek is specified, returns the squad for the last optimized gameweek.</p> Source code in <code>build/lib/build/lib/fpl_solver/fpl_solver.py</code> <pre><code>def get_selected_squad(self, gameweek: int = None) -&gt; pd.DataFrame | None:\n    \"\"\"\n    Returns the selected squad for a specific gameweek (1-indexed).\n    If no gameweek is specified, returns the squad for the last optimized gameweek.\n    \"\"\"\n    if not self.selected_squad_history:\n        return None\n\n    # Get the first GW key to determine the range of available GWs\n    first_gw_in_history = min(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n    last_gw_in_history = max(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n\n    if gameweek is None:\n        return self.selected_squad_history[f\"GW{last_gw_in_history}\"][\"squad\"]\n\n    if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n        print(\n            f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n        )\n        return None\n\n    return self.selected_squad_history.get(f\"GW{gameweek}\", {}).get(\"squad\")\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/#build.lib.build.lib.fpl_solver.fpl_solver.FPLOptimizer.get_total_cost","title":"<code>get_total_cost(gameweek=None)</code>","text":"<p>Returns the total cost for a specific gameweek (1-indexed). If no gameweek is specified, returns the cost of the squad in the last optimized gameweek.</p> Source code in <code>build/lib/build/lib/fpl_solver/fpl_solver.py</code> <pre><code>def get_total_cost(self, gameweek: int = None) -&gt; float:\n    \"\"\"\n    Returns the total cost for a specific gameweek (1-indexed).\n    If no gameweek is specified, returns the cost of the squad in the last optimized gameweek.\n    \"\"\"\n    if not self.selected_squad_history:\n        return 0\n    first_gw_in_history = min(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n    last_gw_in_history = max(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n\n    if gameweek is None:\n        return self.selected_squad_history[f\"GW{last_gw_in_history}\"][\"total_cost\"]\n\n    if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n        print(\n            f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n        )\n        return 0  # Or raise an error\n\n    return self.selected_squad_history.get(f\"GW{gameweek}\", {}).get(\"total_cost\", 0)\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/#build.lib.build.lib.fpl_solver.fpl_solver.FPLOptimizer.get_total_expected_points","title":"<code>get_total_expected_points()</code>","text":"<p>Returns the overall total expected points across all optimized gameweeks.</p> Source code in <code>build/lib/build/lib/fpl_solver/fpl_solver.py</code> <pre><code>def get_total_expected_points(self) -&gt; float:\n    \"\"\"\n    Returns the overall total expected points across all optimized gameweeks.\n    \"\"\"\n    return self.total_expected_points\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/#build.lib.build.lib.fpl_solver.fpl_solver.FPLOptimizer.print_overall_summary","title":"<code>print_overall_summary()</code>","text":"<p>Prints an overall summary of the multi-week optimization results.</p> Source code in <code>build/lib/build/lib/fpl_solver/fpl_solver.py</code> <pre><code>def print_overall_summary(self):\n    \"\"\"\n    Prints an overall summary of the multi-week optimization results.\n    \"\"\"\n    if not self.selected_squad_history:\n        print(\"No optimization results to summarize.\")\n        return\n\n    print(\"\\n=== Overall Multi-Week FPL Optimization Summary ===\")\n    print(\n        f\"Total Expected Points Across All Gameweeks: {self.total_expected_points:.2f}\"\n    )\n\n    # Get the latest gameweek's cost\n    last_gw_key = max(\n        self.selected_squad_history.keys(), key=lambda k: int(k.replace(\"GW\", \"\"))\n    )\n    print(\n        f\"Squad Cost ({last_gw_key}): \u00a3{self.selected_squad_history[last_gw_key]['total_cost']:.1f}m\"\n    )\n    print(\n        f\"Total Transfer Hits Taken: {self.total_transfer_hits} (-{self.total_transfer_hits * POINTS_PER_HIT} points)\"\n    )\n\n    print(\"\\n--- Chip Usage Across Gameweeks ---\")\n    # Ensure consistent order by sorting gameweek keys\n    sorted_gw_keys = sorted(\n        self.used_chips.keys(), key=lambda k: int(k.replace(\"GW\", \"\"))\n    )\n    for gw_str in sorted_gw_keys:\n        chips = self.used_chips[gw_str]\n        chip_summary = []\n        if chips[\"bench_boost\"]:\n            chip_summary.append(\"Bench Boost\")\n        if chips[\"triple_captain\"]:\n            chip_summary.append(\"Triple Captain\")\n\n        if chip_summary:\n            print(f\"{gw_str}: {', '.join(chip_summary)}\")\n        else:\n            print(f\"{gw_str}: No chips used\")\n\n    print(\"\\n--- Gameweek-by-Gameweek Summary ---\")\n    # Iterate and print basic summary for each gameweek\n    for gw_str in sorted_gw_keys:\n        gw_data = self.selected_squad_history[gw_str]\n        print(f\"\\n--- {gw_str} ---\")\n        print(f\"  Squad Cost: \u00a3{gw_data['total_cost']:.1f}m\")\n        print(\n            f\"  Expected Points (Starting XI): {gw_data['expected_points_from_xi']:.2f}\"\n        )\n        print(\n            f\"  Total GW Points (incl. chips): {gw_data['expected_points_from_xi'] + gw_data['total_bench_boost_points'] + gw_data['total_triple_captain_bonus']:.2f}\"\n        )\n\n        # Display transfer info for this gameweek\n        transfers_in_count = gw_data[\"transfers_in_count\"]\n        transfers_out_count = gw_data[\"transfers_out_count\"]\n        transfer_hits_taken = gw_data[\"transfer_hits\"]\n        free_transfers_available_next_gw = gw_data[\n            \"free_transfers_available_next_gw\"\n        ]\n\n        print(\n            f\"  Transfers In: {transfers_in_count}, Transfers Out: {transfers_out_count}\"\n        )\n        print(\n            f\"  Transfer Hits: {transfer_hits_taken} (-{transfer_hits_taken * POINTS_PER_HIT} points)\"\n        )\n        # Only show free transfers for the *next* gameweek if it's not the last gameweek in the horizon\n        if int(gw_str.replace(\"GW\", \"\")) &lt; max(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        ):\n            print(\n                f\"  Free Transfers Available for Next GW: {free_transfers_available_next_gw}\"\n            )\n        print(\"-----------------------------------\")\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/#build.lib.build.lib.fpl_solver.fpl_solver.FPLOptimizer.print_squad_summary","title":"<code>print_squad_summary(gameweek)</code>","text":"<p>Prints a formatted summary of the selected squad for a specific gameweek.</p> Source code in <code>build/lib/build/lib/fpl_solver/fpl_solver.py</code> <pre><code>def print_squad_summary(self, gameweek: int):\n    \"\"\"\n    Prints a formatted summary of the selected squad for a specific gameweek.\n    \"\"\"\n    if not self.selected_squad_history:\n        print(\"No squad has been selected yet. Run the 'solve' method first.\")\n        return\n\n    gw_data = self.get_gameweek_summary(gameweek)\n    if not gw_data:\n        return  # get_gameweek_summary already prints error message\n\n    selected_squad = gw_data[\"squad\"]\n    total_cost = gw_data[\"total_cost\"]\n    expected_points_from_xi = gw_data[\"expected_points_from_xi\"]\n    bench_boost_used = gw_data[\"bench_boost_used\"]\n    triple_captain_used = gw_data[\"triple_captain_used\"]\n    total_bench_boost_points = gw_data[\"total_bench_boost_points\"]\n    total_triple_captain_bonus = gw_data[\"total_triple_captain_bonus\"]\n    transfers_in_count = gw_data[\"transfers_in_count\"]  # New\n    transfers_out_count = gw_data[\"transfers_out_count\"]  # New\n    transfer_hits_taken = gw_data[\"transfer_hits\"]  # New\n    free_transfers_available_next_gw = gw_data[\n        \"free_transfers_available_next_gw\"\n    ]  # New\n\n    print(f\"\\n--- FPL Optimized Squad for Gameweek {gameweek} ---\")\n    print(f\"Squad Cost: \u00a3{total_cost:.1f}m\")\n    print(f\"Expected Points (Starting XI): {expected_points_from_xi:.2f}\")\n    print(\n        f\"Total Expected Points for GW{gameweek} (including chips): {expected_points_from_xi + total_bench_boost_points + total_triple_captain_bonus:.2f}\"\n    )\n    print(\"\\n--- Chips Used This Gameweek ---\")\n    if bench_boost_used:\n        print(f\"- Bench Boost (Added {total_bench_boost_points:.2f} points)\")\n    if triple_captain_used:\n        print(\n            f\"- Triple Captain (Added {total_triple_captain_bonus:.2f} bonus points)\"\n        )\n    if not (bench_boost_used or triple_captain_used):\n        print(\"No chips used this gameweek.\")\n\n    print(\"\\n--- Goalkeepers (Starting XI marked with *) ---\")\n    for index, row in selected_squad[selected_squad[\"position\"] == \"GK\"].iterrows():\n        starter_str = \"*\" if row[\"is_starter\"] else \"\"\n        captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n        transfer_status = \"\"\n        if row[\"transfer_in\"]:\n            transfer_status = \"(IN)\"\n        elif row[\"transfer_out\"]:\n            transfer_status = \"(OUT)\"\n\n        # Access gameweek-specific xP correctly\n        player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n        print(\n            f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n        )\n    print(\"\\n--- Defenders (Starting XI marked with *) ---\")\n    for index, row in selected_squad[\n        selected_squad[\"position\"] == \"DEF\"\n    ].iterrows():\n        starter_str = \"*\" if row[\"is_starter\"] else \"\"\n        captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n        transfer_status = \"\"\n        if row[\"transfer_in\"]:\n            transfer_status = \"(IN)\"\n        elif row[\"transfer_out\"]:\n            transfer_status = \"(OUT)\"\n\n        player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n        print(\n            f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n        )\n    print(\"\\n--- Midfielders (Starting XI marked with *) ---\")\n    for index, row in selected_squad[\n        selected_squad[\"position\"] == \"MID\"\n    ].iterrows():\n        starter_str = \"*\" if row[\"is_starter\"] else \"\"\n        captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n        transfer_status = \"\"\n        if row[\"transfer_in\"]:\n            transfer_status = \"(IN)\"\n        elif row[\"transfer_out\"]:\n            transfer_status = \"(OUT)\"\n\n        player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n        print(\n            f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n        )\n    print(\"\\n--- Forwards (Starting XI marked with *) ---\")\n    for index, row in selected_squad[\n        selected_squad[\"position\"] == \"FWD\"\n    ].iterrows():\n        starter_str = \"*\" if row[\"is_starter\"] else \"\"\n        captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n        transfer_status = \"\"\n        if row[\"transfer_in\"]:\n            transfer_status = \"(IN)\"\n        elif row[\"transfer_out\"]:\n            transfer_status = \"(OUT)\"\n\n        player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n        print(\n            f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n        )\n\n    print(f\"\\n--- Team Breakdown for GW{gameweek} ---\")\n    print(selected_squad[\"team\"].value_counts())\n\n    # Transfers are relevant from Gameweek 2 (index 1) onwards in the optimization horizon\n    # For display, if the current GW is the initial one (GW1 in the current context), no transfers are made\n    # If it's a subsequent GW, check if transfers occurred.\n    first_gw_in_history = min(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n    if (\n        gameweek &gt;= first_gw_in_history\n    ):  # Changed from &gt; to &gt;=, to show initial free transfers\n        # Display transfer info for this gameweek\n        print(\n            f\"  Transfers In: {transfers_in_count}, Transfers Out: {transfers_out_count}\"\n        )\n        print(\n            f\"  Transfer Hits: {transfer_hits_taken} (-{transfer_hits_taken * POINTS_PER_HIT} points)\"\n        )\n        # Only show free transfers for the *next* gameweek if it's not the last gameweek in the horizon\n        if gameweek &lt; max(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        ):\n            print(\n                f\"  Free Transfers Available for Next GW: {free_transfers_available_next_gw}\"\n            )\n    print(\"---------------------------\\n\")\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/#build.lib.build.lib.fpl_solver.fpl_solver.FPLOptimizer.solve","title":"<code>solve(budget, max_players_per_team, chip_allowances, num_gameweeks)</code>","text":"<p>Solves the FPL optimization problem using PuLP.</p> <p>Parameters:</p> Name Type Description Default <code>budget</code> <code>float</code> <p>The maximum budget in millions of pounds.</p> required <code>max_players_per_team</code> <code>int</code> <p>The maximum number of players allowed from                         any single Premier League team.</p> required <code>chip_allowances</code> <code>dict</code> <p>A dictionary specifying the maximum usage for each chip.</p> required <code>num_gameweeks</code> <code>int</code> <p>The number of gameweeks to optimize over.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if a solution was found, False otherwise.</p> Source code in <code>build/lib/build/lib/fpl_solver/fpl_solver.py</code> <pre><code>def solve(\n    self,\n    budget: float,\n    max_players_per_team: int,\n    chip_allowances: dict,\n    num_gameweeks: int,\n) -&gt; bool:\n    \"\"\"\n    Solves the FPL optimization problem using PuLP.\n\n    Args:\n        budget (float): The maximum budget in millions of pounds.\n        max_players_per_team (int): The maximum number of players allowed from\n                                    any single Premier League team.\n        chip_allowances (dict): A dictionary specifying the maximum usage for each chip.\n        num_gameweeks (int): The number of gameweeks to optimize over.\n\n    Returns:\n        bool: True if a solution was found, False otherwise.\n    \"\"\"\n    self.problem = LpProblem(\"FPL Squad Multi-Week Optimization\", LpMaximize)\n\n    # Decision variables for player selection, indexed by player and gameweek\n    player_vars = LpVariable.dicts(\n        \"Player\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n    )\n    starting_xi_vars = LpVariable.dicts(\n        \"StartingXI\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n    )\n    captain_var = LpVariable.dicts(\n        \"Captain\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n    )\n\n    # Binary variables for chip usage, indexed by gameweek\n    use_bench_boost = LpVariable.dicts(\n        \"Use_Bench_Boost\", range(num_gameweeks), 0, 1, LpBinary\n    )\n    use_triple_captain = LpVariable.dicts(\n        \"Use_Triple_Captain\", range(num_gameweeks), 0, 1, LpBinary\n    )\n\n    # Transfer variables\n    transfer_in_vars = LpVariable.dicts(\n        \"Transfer_In\",\n        (self.player_data.index, range(1, num_gameweeks)),\n        0,\n        1,\n        LpBinary,\n    )\n    transfer_out_vars = LpVariable.dicts(\n        \"Transfer_Out\",\n        (self.player_data.index, range(1, num_gameweeks)),\n        0,\n        1,\n        LpBinary,\n    )\n\n    # Total transfers made in a gameweek (absolute count)\n    transfers_made = LpVariable.dicts(\n        \"Transfers_Made\", range(1, num_gameweeks), 0, None, LpInteger\n    )\n    # Free transfers available at the start of a gameweek\n    free_transfers_available = LpVariable.dicts(\n        \"Free_Transfers_Available\",\n        range(num_gameweeks),\n        0,\n        MAX_FREE_TRANSFERS_SAVED + 1,\n        LpInteger,\n    )\n    # Number of transfer hits taken in a gameweek\n    transfer_hits = LpVariable.dicts(\n        \"Transfer_Hits\", range(1, num_gameweeks), 0, None, LpInteger\n    )\n\n    # Auxiliary variables for linearizing chip effects\n    is_bench_player = LpVariable.dicts(\n        \"Is_Bench_Player\",\n        (self.player_data.index, range(num_gameweeks)),\n        0,\n        1,\n        LpBinary,\n    )\n    actual_bench_boost_points = LpVariable.dicts(\n        \"Actual_Bench_Boost_Points\",\n        (self.player_data.index, range(num_gameweeks)),\n        0,\n        None,\n        LpContinuous,\n    )\n    actual_triple_captain_bonus = LpVariable.dicts(\n        \"Actual_Triple_Captain_Bonus\",\n        (self.player_data.index, range(num_gameweeks)),\n        0,\n        None,\n        LpContinuous,\n    )\n\n    # --- Objective Function ---\n    total_objective_points = []\n\n    # Get the first gameweek number from the player data to correctly index expected_points_by_gw\n    first_gw_key = next(\n        iter(\n            self.player_data.loc[\n                self.player_data.index[0], \"expected_points_by_gw\"\n            ].keys()\n        )\n    )\n    current_gameweek_number_start = int(first_gw_key)\n\n    for w in range(num_gameweeks):\n        # The actual gameweek number (1-indexed)\n        gw_actual = current_gameweek_number_start + w\n\n        # Base expected points from the selected starting 11 for this gameweek\n        base_points_expression_gw = lpSum(\n            self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n            * starting_xi_vars[i][w]\n            for i in self.player_data.index\n        )\n        total_objective_points.append(base_points_expression_gw)\n\n        # Regular Captaincy points (additional 1x for captain)\n        captain_points_bonus_gw = lpSum(\n            self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n            * captain_var[i][w]\n            for i in self.player_data.index\n        )\n        total_objective_points.append(captain_points_bonus_gw)\n\n        # Define auxiliary variables and constraints for chips for each gameweek\n        for i in self.player_data.index:\n            # Use gameweek-specific player xP for chip calculations\n            player_xp = self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n\n            # Bench Boost auxiliary variables and constraints\n            self.problem += (\n                is_bench_player[i][w] &lt;= player_vars[i][w],\n                f\"IsBench_Squad_{i}_{w}\",\n            )\n            self.problem += (\n                is_bench_player[i][w] &lt;= 1 - starting_xi_vars[i][w],\n                f\"IsBench_NotStarter_{i}_{w}\",\n            )\n            self.problem += (\n                is_bench_player[i][w]\n                &gt;= player_vars[i][w] + (1 - starting_xi_vars[i][w]) - 1,\n                f\"IsBench_Logical_{i}_{w}\",\n            )\n\n            self.problem += (\n                actual_bench_boost_points[i][w]\n                &lt;= player_xp * is_bench_player[i][w],\n                f\"BenchBoost_Contr_1_{i}_{w}\",\n            )\n            self.problem += (\n                actual_bench_boost_points[i][w] &lt;= player_xp * use_bench_boost[w],\n                f\"BenchBoost_Contr_2_{i}_{w}\",\n            )\n            self.problem += (\n                actual_bench_boost_points[i][w]\n                &gt;= player_xp * (is_bench_player[i][w] + use_bench_boost[w] - 1),\n                f\"BenchBoost_Contr_3_{i}_{w}\",\n            )\n            self.problem += (\n                actual_bench_boost_points[i][w] &gt;= 0,\n                f\"BenchBoost_Contr_4_{i}_{w}\",\n            )\n\n            # Triple Captain auxiliary variables and constraints\n            # Changed player_xp * 2 to player_xp to reflect additional 1x bonus\n            self.problem += (\n                actual_triple_captain_bonus[i][w] &lt;= player_xp * captain_var[i][w],\n                f\"TripleCaptain_Contr_1_{i}_{w}\",\n            )\n            self.problem += (\n                actual_triple_captain_bonus[i][w]\n                &lt;= player_xp * use_triple_captain[w],\n                f\"TripleCaptain_Contr_2_{i}_{w}\",\n            )\n            self.problem += (\n                actual_triple_captain_bonus[i][w]\n                &gt;= player_xp * (captain_var[i][w] + use_triple_captain[w] - 1),\n                f\"TripleCaptain_Contr_3_{i}_{w}\",\n            )\n            self.problem += (\n                actual_triple_captain_bonus[i][w] &gt;= 0,\n                f\"TripleCaptain_Contr_4_{i}_{w}\",\n            )\n\n        # Add points from bench boost and triple captain bonus for this gameweek\n        total_bench_boost_points_gw = lpSum(\n            actual_bench_boost_points[i][w] for i in self.player_data.index\n        )\n        total_triple_captain_bonus_points_gw = lpSum(\n            actual_triple_captain_bonus[i][w] for i in self.player_data.index\n        )\n\n        total_objective_points.append(total_bench_boost_points_gw)\n        total_objective_points.append(total_triple_captain_bonus_points_gw)\n\n    # Subtract transfer hits from the total objective\n    total_objective_points.append(\n        -POINTS_PER_HIT * lpSum(transfer_hits[w] for w in range(1, num_gameweeks))\n    )\n\n    self.problem += (\n        lpSum(total_objective_points),\n        \"Total Expected Points Over Gameweeks\",\n    )\n\n    # --- Constraints ---\n\n    # Apply constraints for each gameweek\n    for w in range(num_gameweeks):\n        # 1. Select exactly 15 players for the squad\n        self.problem += (\n            lpSum(player_vars[i][w] for i in self.player_data.index) == 15,\n            f\"Total_Players_GW{w}\",\n        )\n\n        # 2. Squad position constraints (2 GKs, 5 DEFs, 5 MIDs, 3 FWDs)\n        gks = self.player_data[self.player_data[\"position\"] == \"GK\"].index\n        defs = self.player_data[self.player_data[\"position\"] == \"DEF\"].index\n        mids = self.player_data[self.player_data[\"position\"] == \"MID\"].index\n        fwds = self.player_data[self.player_data[\"position\"] == \"FWD\"].index\n\n        self.problem += (\n            lpSum(player_vars[i][w] for i in gks) == 2,\n            f\"Goalkeepers_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(player_vars[i][w] for i in defs) == 5,\n            f\"Defenders_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(player_vars[i][w] for i in mids) == 5,\n            f\"Midfielders_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(player_vars[i][w] for i in fwds) == 3,\n            f\"Forwards_Count_GW{w}\",\n        )\n\n        # 3. Budget constraint\n        # This applies to the cost of the squad for the current gameweek.\n        self.problem += (\n            lpSum(\n                self.player_data.loc[i, \"cost\"] * player_vars[i][w]\n                for i in self.player_data.index\n            )\n            &lt;= budget,\n            f\"Total_Budget_GW{w}\",\n        )\n\n        # 4. Maximum players per team constraint\n        for team in self.player_data[\"team\"].unique():\n            team_players = self.player_data[self.player_data[\"team\"] == team].index\n            self.problem += (\n                lpSum(player_vars[i][w] for i in team_players)\n                &lt;= max_players_per_team,\n                f\"Max_Players_from_{team}_GW{w}\",\n            )\n\n        # 5. Starting XI constraints\n        # 5.1 Select exactly 11 players for the starting XI\n        self.problem += (\n            lpSum(starting_xi_vars[i][w] for i in self.player_data.index) == 11,\n            f\"Total_Starting_XI_Players_GW{w}\",\n        )\n\n        # 5.2 A player can only be in the starting XI if they are in the squad\n        for i in self.player_data.index:\n            self.problem += (\n                starting_xi_vars[i][w] &lt;= player_vars[i][w],\n                f\"StartingXI_in_Squad_{i}_{w}\",\n            )\n\n        # 5.3 Starting XI position constraints (FPL allows flexible formations, so use minimums)\n        self.problem += (\n            lpSum(starting_xi_vars[i][w] for i in gks) == 1,\n            f\"Starting_Goalkeepers_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(starting_xi_vars[i][w] for i in defs) &gt;= 3,\n            f\"Min_Starting_Defenders_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(starting_xi_vars[i][w] for i in mids) &gt;= 2,\n            f\"Min_Starting_Midfielders_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(starting_xi_vars[i][w] for i in fwds) &gt;= 1,\n            f\"Min_Starting_Forwards_Count_GW{w}\",\n        )\n\n        # 6. Captain Constraints\n        # 6.1 Select exactly one captain from the starting XI\n        self.problem += (\n            lpSum(captain_var[i][w] for i in self.player_data.index) == 1,\n            f\"One_Captain_GW{w}\",\n        )\n\n        # 6.2 A player can only be captain if they are in the starting XI\n        for i in self.player_data.index:\n            self.problem += (\n                captain_var[i][w] &lt;= starting_xi_vars[i][w],\n                f\"Captain_in_StartingXI_{i}_{w}\",\n            )\n\n        # --- Enforced Player Constraints---\n        for player_idx in self.enforced_player_indices:\n            self.problem += (\n                player_vars[player_idx][w] == 1,\n                f\"Enforce_Player_{self.player_data.loc[player_idx, 'name']}_GW{w}\",\n            )\n\n        for team, position in self.enforced_team_pos_requirements:\n            # Filter players for the current team and position\n            team_pos_players = self.player_data[\n                (self.player_data[\"team\"] == team)\n                &amp; (self.player_data[\"position\"] == position)\n            ].index\n            if not team_pos_players.empty:\n                self.problem += (\n                    lpSum(player_vars[i][w] for i in team_pos_players) &gt;= 1,\n                    f\"Enforce_One_{position}_from_{team}_GW{w}\",\n                )\n            else:\n                print(\n                    f\"Warning: No players found for enforced requirement: at least one {position} from {team} for GW{gw_actual}.\"\n                )\n\n    # --- Chip Usage Constraints (TOTAL usage over all gameweeks) ---\n    # These constraints should be outside the per-gameweek loop to avoid duplicates.\n    self.problem += (\n        lpSum(use_bench_boost[j] for j in range(num_gameweeks))\n        &lt;= chip_allowances.get(\"bench_boost\", 0),\n        f\"Max_Bench_Boost_Usage_Total\",\n    )\n    self.problem += (\n        lpSum(use_triple_captain[j] for j in range(num_gameweeks))\n        &lt;= chip_allowances.get(\"triple_captain\", 0),\n        f\"Max_Triple_Captain_Usage_Total\",\n    )\n\n    # --- Inter-Gameweek Constraints (Transfers and Transfer Rules) ---\n    # Initialize free transfers for GW0 (first gameweek of optimization horizon)\n    # This assumes the optimization starts at GW0, and it has INITIAL_FREE_TRANSFERS.\n    # If the model starts at an arbitrary GW, this would need to be an input.\n    self.problem += (\n        free_transfers_available[0] == INITIAL_FREE_TRANSFERS,\n        f\"Initial_Free_Transfers_GW0\",\n    )\n\n    for w in range(1, num_gameweeks):\n        # Calculate total transfers made in this gameweek\n        self.problem += (\n            transfers_made[w]\n            == lpSum(transfer_in_vars[i][w] for i in self.player_data.index),\n            f\"Transfers_Made_GW{w}\",\n        )\n        # Total transfers in must equal total transfers out for each gameweek after the first\n        self.problem += (\n            lpSum(transfer_in_vars[i][w] for i in self.player_data.index)\n            == lpSum(transfer_out_vars[i][w] for i in self.player_data.index),\n            f\"Transfers_In_Equals_Out_GW{w}\",\n        )\n\n        # Calculate free transfers available for the current gameweek (w)\n        # Free transfers for GW_w = min(free transfers from GW_w-1 - transfers made in GW_w + 1, MAX_FREE_TRANSFERS_SAVED + 1)\n        # The + 1 in MAX_FREE_TRANSFERS_SAVED + 1 is because MAX_FREE_TRANSFERS_SAVED implies how many can be *saved*,\n        # so if you save 1, you have 1 (current) + 1 (saved) = 2.\n        self.problem += (\n            free_transfers_available[w]\n            &lt;= free_transfers_available[w - 1] - transfers_made[w] + 1,\n            f\"Free_Transfers_Calc_1_GW{w}\",\n        )\n        self.problem += (\n            free_transfers_available[w] &lt;= MAX_FREE_TRANSFERS_SAVED + 1,\n            f\"Free_Transfers_Calc_2_GW{w}\",\n        )\n        self.problem += (\n            free_transfers_available[w] &gt;= 0,  # Cannot have negative free transfers\n            f\"Free_Transfers_Non_Negative_GW{w}\",\n        )\n\n        # Calculate transfer hits\n        # transfer_hits[w] = max(0, transfers_made[w] - free_transfers_available_at_start_of_gw_w)\n        # This needs to be linearized. If transfers_made[w] &gt; free_transfers_available[w-1], then hit.\n        # free_transfers_available[w-1] represents transfers available *before* making transfers for GW_w\n        self.problem += (\n            transfer_hits[w] &gt;= transfers_made[w] - free_transfers_available[w - 1],\n            f\"Transfer_Hits_Calc_1_GW{w}\",\n        )\n        self.problem += (\n            transfer_hits[w] &gt;= 0,\n            f\"Transfer_Hits_Calc_2_GW{w}\",\n        )\n\n        for i in self.player_data.index:\n            # Squad continuity: player_vars[i][w] (in squad at start of GW w)\n            #                 = player_vars[i][w-1] (in squad at start of GW w-1)\n            #                 - transfer_out_vars[i][w] (transferred out for GW w)\n            #                 + transfer_in_vars[i][w] (transferred in for GW w)\n            self.problem += (\n                player_vars[i][w]\n                == player_vars[i][w - 1]\n                - transfer_out_vars[i][w]\n                + transfer_in_vars[i][w],\n                f\"Squad_Continuity_{i}_GW{w}\",\n            )\n            # A player cannot be transferred in and out in the same gameweek\n            self.problem += (\n                transfer_in_vars[i][w] + transfer_out_vars[i][w] &lt;= 1,\n                f\"No_Simultaneous_Transfer_{i}_{w}\",\n            )\n\n    try:\n        # The solver is called with the GLPK_CMD solver\n        self.problem.solve(PULP_CBC_CMD(msg=0))  # msg=0 suppresses verbose output\n    except Exception as e:\n        print(f\"Error solving the problem: {e}\")\n        return False\n\n    if LpStatus[self.problem.status] == \"Optimal\":\n        print(\"Optimization successful! Optimal solution found.\")\n\n        self.selected_squad_history = {}\n        self.total_transfer_hits = 0\n        for w in range(num_gameweeks):\n            # The actual gameweek number (1-indexed)\n            gw_actual = current_gameweek_number_start + w\n\n            # Get selected players for the current gameweek\n            selected_squad_gw = self.player_data[\n                [player_vars[i][w].varValue == 1 for i in self.player_data.index]\n            ].copy()\n\n            # Get starter and captain info for this gameweek\n            is_starter_series_gw = pd.Series(\n                [\n                    starting_xi_vars[i][w].varValue == 1\n                    for i in self.player_data.index\n                ],\n                index=self.player_data.index,\n            )\n            is_captain_series_gw = pd.Series(\n                [captain_var[i][w].varValue == 1 for i in self.player_data.index],\n                index=self.player_data.index,\n            )\n\n            selected_squad_gw[\"is_starter\"] = is_starter_series_gw.loc[\n                selected_squad_gw.index\n            ]\n            selected_squad_gw[\"is_captain\"] = is_captain_series_gw.loc[\n                selected_squad_gw.index\n            ]\n\n            transfers_in_gw = 0\n            transfers_out_gw = 0\n            hits_gw = 0\n\n            # Store transfer details for gameweeks &gt; 0\n            if (\n                w &gt; 0\n            ):  # Check for transfers only from GW1 onwards (index 1 in 0-indexed loop)\n                transfer_in_flags = pd.Series(\n                    [\n                        transfer_in_vars[i][w].varValue == 1\n                        for i in self.player_data.index\n                    ],\n                    index=self.player_data.index,\n                )\n                transfer_out_flags = pd.Series(\n                    [\n                        transfer_out_vars[i][w].varValue == 1\n                        for i in self.player_data.index\n                    ],\n                    index=self.player_data.index,\n                )\n\n                selected_squad_gw[\"transfer_in\"] = transfer_in_flags.loc[\n                    selected_squad_gw.index\n                ]\n                selected_squad_gw[\"transfer_out\"] = transfer_out_flags.loc[\n                    selected_squad_gw.index\n                ]\n\n                transfers_in_gw = int(round(transfer_in_flags.sum()))\n                transfers_out_gw = int(round(transfer_out_flags.sum()))\n                hits_gw = int(round(transfer_hits[w].varValue))\n                self.total_transfer_hits += hits_gw\n            else:\n                selected_squad_gw[\"transfer_in\"] = False  # No transfers in for GW0\n                selected_squad_gw[\"transfer_out\"] = (\n                    False  # No transfers out for GW0\n                )\n\n            self.selected_squad_history[f\"GW{gw_actual}\"] = {\n                \"squad\": selected_squad_gw,\n                \"total_cost\": selected_squad_gw[\"cost\"].sum(),\n                \"expected_points_from_xi\": sum(\n                    self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n                    * starting_xi_vars[i][w].varValue\n                    for i in self.player_data.index\n                ),\n                \"bench_boost_used\": bool(use_bench_boost[w].varValue),\n                \"triple_captain_used\": bool(use_triple_captain[w].varValue),\n                \"total_bench_boost_points\": value(\n                    lpSum(\n                        actual_bench_boost_points[i][w]\n                        for i in self.player_data.index\n                    )\n                ),\n                \"total_triple_captain_bonus\": value(\n                    lpSum(\n                        actual_triple_captain_bonus[i][w]\n                        for i in self.player_data.index\n                    )\n                ),\n                \"transfers_in_count\": transfers_in_gw,\n                \"transfers_out_count\": transfers_out_gw,\n                \"transfer_hits\": hits_gw,  # New\n                \"free_transfers_available_next_gw\": (\n                    int(round(free_transfers_available[w].varValue))\n                    if w &lt; num_gameweeks - 1\n                    else 0\n                ),  # Free transfers available *after* this GW's transfers are made\n            }\n\n        # Overall totals\n        self.total_cost = self.selected_squad_history[\n            f\"GW{current_gameweek_number_start + num_gameweeks - 1}\"\n        ][\n            \"total_cost\"\n        ]  # Cost of final squad\n        self.total_expected_points = value(\n            self.problem.objective\n        )  # Total objective value from solver\n        self.used_chips = {\n            f\"GW{current_gameweek_number_start + w}\": {\n                \"bench_boost\": bool(use_bench_boost[w].varValue),\n                \"triple_captain\": bool(use_triple_captain[w].varValue),\n            }\n            for w in range(num_gameweeks)\n        }\n\n        return True\n    else:\n        print(f\"No optimal solution found. Status: {LpStatus[self.problem.status]}\")\n        self.selected_squad_history = {}\n        self.total_cost = 0\n        self.total_expected_points = 0\n        self.used_chips = {}\n        self.total_transfer_hits = 0\n        return False\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/#build.lib.build.lib.fpl_solver.fpl_xp_predictor","title":"<code>fpl_xp_predictor</code>","text":""},{"location":"autoapi/build/lib/build/lib/fpl_solver/#build.lib.build.lib.fpl_solver.fpl_xp_predictor.FPLPredictor","title":"<code>FPLPredictor</code>","text":"<p>Predictive algorithm for Expected Points (xP) in Fantasy Premier League, using real data from the FPL API.</p> Source code in <code>build/lib/build/lib/fpl_solver/fpl_xp_predictor.py</code> <pre><code>class FPLPredictor:\n    \"\"\"\n    Predictive algorithm for Expected Points (xP) in Fantasy Premier League,\n    using real data from the FPL API.\n    \"\"\"\n\n    def __init__(self, gameweeks_to_predict: int = 1):\n        \"\"\"\n        Initializes the FPLPredictor with default FPL point rules and\n        data structures, then fetches real data and calculates xP for all players.\n\n        Args:\n            gameweeks_to_predict (int): The number of upcoming gameweeks to calculate\n                                        expected points for. Default is 1 (next gameweek).\n        \"\"\"\n        if not isinstance(gameweeks_to_predict, int) or gameweeks_to_predict &lt; 1:\n            raise ValueError(\"gameweeks_to_predict must be a positive integer.\")\n        self.gameweeks_to_predict = gameweeks_to_predict\n\n        self.fpl_points = FPL_POINTS\n\n        self.players_data = {}\n        self.teams_data = {}\n        self.fixtures_data = {}\n        self.position_definitions = {\n            1: \"GK\",\n            2: \"DEF\",\n            3: \"MID\",\n            4: \"FWD\",\n        }\n        self.all_players_xp_calculated_data = (\n            []\n        )  # To store xP for all players for the optimizer\n\n        self._fetch_fpl_data()\n        self._calculate_all_players_xp()  # Calculate xP for all players after data is loaded\n\n    def _fetch_fpl_data(self):\n        \"\"\"Fetches initial data from the FPL API.\"\"\"\n        print(\"Fetching FPL data...\")\n        try:\n            # Fetch general data\n            static_data = requests.get(\n                \"https://fantasy.premierleague.com/api/bootstrap-static/\"\n            ).json()\n            # Fetch fixtures data\n            fixtures_data = requests.get(\n                \"https://fantasy.premierleague.com/api/fixtures/\"\n            ).json()\n\n            # Process players data\n            for element in static_data[\"elements\"]:\n                player_id = element[\"id\"]\n                self.players_data[player_id] = {\n                    \"name\": element[\"first_name\"] + \" \" + element[\"second_name\"],\n                    \"web_name\": element[\"web_name\"],\n                    \"team_id\": element[\"team\"],\n                    \"element_type\": element[\"element_type\"],\n                    \"position\": self.position_definitions.get(\n                        element[\"element_type\"], \"Unknown\"\n                    ),\n                    \"cost_pence\": element[\"now_cost\"],\n                    \"status\": element[\"status\"],\n                    \"news\": element[\"news\"],\n                    \"total_points\": element[\"total_points\"],\n                    \"minutes\": element[\"minutes\"],\n                    \"goals_scored\": element[\"goals_scored\"],\n                    \"assists\": element[\"assists\"],\n                    \"clean_sheets\": element[\"clean_sheets\"],\n                    \"goals_conceded\": element[\"goals_conceded\"],\n                    \"penalties_saved\": element[\"penalties_saved\"],\n                    \"penalties_missed\": element[\"penalties_missed\"],\n                    \"yellow_cards\": element[\"yellow_cards\"],\n                    \"red_cards\": element[\"red_cards\"],\n                    \"own_goals\": element[\"own_goals\"],\n                    \"saves\": element[\"saves\"],\n                    \"bonus\": element[\"bonus\"],\n                    \"bps\": element[\"bps\"],\n                    \"threat\": element[\"threat\"],\n                    \"creativity\": element[\"creativity\"],\n                    \"influence\": element[\"influence\"],\n                    \"form\": float(element[\"form\"]),\n                    \"points_per_game\": float(element[\"points_per_game\"]),\n                    \"value_season\": float(element[\"value_season\"]),\n                    \"value_form\": float(element[\"value_form\"]),\n                    \"ict_index\": float(element[\"ict_index\"]),\n                }\n\n            # --- Apply Player Exclusions ---\n            initial_player_count = len(self.players_data)\n            players_to_keep = {}\n            for player_id, player_info in self.players_data.items():\n                # Exclude by ID\n                if player_id in EXCLUDED_PLAYERS_BY_ID:\n                    print(\n                        f\"Excluding player by ID: {player_info['name']} (ID: {player_id})\"\n                    )\n                    continue\n\n                # Exclude by Name\n                if player_info[\"name\"] in EXCLUDED_PLAYERS_BY_NAME:\n                    print(\n                        f\"Excluding player by Name: {player_info['name']} (ID: {player_id})\"\n                    )\n                    continue\n\n                # Exclude by Team and Position\n                excluded_by_team_pos = False\n                for exclusion_rule in EXCLUDED_PLAYERS_BY_TEAM_AND_POSITION:\n                    team_name = self.teams_data.get(player_info[\"team_id\"], {}).get(\n                        \"name\"\n                    )\n                    if team_name == exclusion_rule.get(\"team\") and player_info[\n                        \"position\"\n                    ] == exclusion_rule.get(\"position\"):\n                        print(\n                            f\"Excluding player by Team/Position: {player_info['name']} ({team_name}, {player_info['position']})\"\n                        )\n                        excluded_by_team_pos = True\n                        break\n                if excluded_by_team_pos:\n                    continue\n\n                players_to_keep[player_id] = player_info\n\n            self.players_data = players_to_keep\n            print(\n                f\"Filtered {initial_player_count - len(self.players_data)} players. Remaining: {len(self.players_data)}\"\n            )\n\n            # Process teams data\n            for team in static_data[\"teams\"]:\n                self.teams_data[team[\"id\"]] = {\n                    \"name\": team[\"name\"],\n                    \"short_name\": team[\"short_name\"],\n                    \"strength\": team[\"strength\"],\n                    \"strength_overall_home\": team[\"strength_overall_home\"],\n                    \"strength_overall_away\": team[\"strength_overall_away\"],\n                    \"strength_attack_home\": team[\"strength_attack_home\"],\n                    \"strength_attack_away\": team[\"strength_attack_away\"],\n                    \"strength_defence_home\": team[\"strength_defence_home\"],\n                    \"strength_defence_away\": team[\"strength_defence_away\"],\n                }\n\n            # Process fixtures data\n            for fixture in fixtures_data:\n                self.fixtures_data[fixture[\"id\"]] = fixture\n\n            print(\"FPL data fetched successfully.\")\n\n        except requests.exceptions.RequestException as e:\n            print(f\"Error fetching FPL data: {e}\")\n            self.players_data = {}\n            self.teams_data = {}\n            self.fixtures_data = {}\n            print(\"Initialization failed due to data fetching error. Exiting.\")\n            sys.exit(1)\n        except Exception as e:\n            print(f\"An unexpected error occurred during data fetching: {e}\")\n            self.players_data = {}\n            self.teams_data = {}\n            self.fixtures_data = {}\n            print(\"Initialization failed due to unexpected error. Exiting.\")\n            sys.exit(1)\n\n    def _get_team_strength(self, team_id, is_home):\n        \"\"\"Get team strength based on home/away status.\"\"\"\n        team = self.teams_data.get(team_id, {})\n        if is_home:\n            return team.get(\"strength_overall_home\", 1000)  # Default if not found\n        return team.get(\"strength_overall_away\", 1000)  # Default if not found\n\n    def _predict_minutes(self, player_id):\n        \"\"\"\n        Predicts expected minutes for a player based on historical data.\n        More sophisticated logic for handling very low minute players.\n        \"\"\"\n        player = self.players_data.get(player_id)\n        if not player:\n            return 0.0\n\n        status = player[\"status\"]\n        news = player[\"news\"].lower()\n        minutes_played = player[\"minutes\"]\n\n        # 1. Unavailable players (injured, suspended, doubtful)\n        if status != \"a\" or any(\n            x in news\n            for x in [\n                \"injured\",\n                \"doubtful\",\n                \"suspension\",\n                \"red card\",\n                \"expected back\",\n            ]\n        ):\n            return 0.0\n\n        # 2. Players with significant minutes (starters/key rotation)\n        if minutes_played &gt;= MIN_MINUTES_THRESHOLD:\n            # Average minutes per game started (assuming most minutes come from starts)\n            # This is a heuristic; real FPL API doesn't give starts directly.\n            # We assume a player with &gt; MIN_MINUTES_THRESHOLD plays ~80-90 minutes when on pitch.\n            # So, (minutes_played / number_of_appearances) is a rough proxy.\n            # For simplicity, let's use a cap of 90 minutes.\n            if player[\"total_points\"] &gt; 0:  # Player has played at least one game\n                avg_minutes_per_appearance = minutes_played / (\n                    player[\"total_points\"] / player[\"points_per_game\"]\n                )\n                return min(avg_minutes_per_appearance, 90.0)\n            return 70.0  # Reasonable default for established player with points but no clear avg\n\n        # 3. Players with very low minutes (rarely play, new, youth)\n        if minutes_played &lt; VERY_LOW_MINUTES_THRESHOLD:\n            # If news suggests they might get a chance, assign default sub minutes.\n            # Otherwise, very low expected minutes or zero.\n            if any(x in news for x in [\"return imminent\", \"close to return\"]):\n                return DEFAULT_SUB_MINUTES  # Might get some minutes\n            return DEFAULT_UNKNOWN_PLAYER_MINUTES  # Very unlikely to play significant minutes\n\n        # 4. Players with some minutes but below significant threshold (regular subs)\n        return DEFAULT_SUB_MINUTES\n\n    def _calculate_expected_goals(self, team_attack_strength, opp_defence_strength):\n        \"\"\"\n        Calculates expected goals for a team based on its attack strength and\n        opponent's defensive strength. This is a simplified heuristic.\n        \"\"\"\n        # A simple ratio model: Higher attack strength and lower opponent defense means more goals\n        # Normalization factor can be adjusted based on average league goals\n        expected_goals = (\n            team_attack_strength / opp_defence_strength\n        ) * 1.5  # 1.5 is an arbitrary scaling factor\n        return max(0.0, expected_goals)\n\n    def _calculate_expected_conceded_goals(\n        self, team_defence_strength, opp_attack_strength\n    ):\n        \"\"\"\n        Calculates expected goals conceded by a team based on its defense strength\n        and opponent's attacking strength.\n        \"\"\"\n        # A simple ratio model: Higher opponent attack and lower team defense means more conceded goals\n        expected_conceded_goals = (\n            opp_attack_strength / team_defence_strength\n        ) * 1.5  # 1.5 is an arbitrary scaling factor\n        return max(0.0, expected_conceded_goals)\n\n    def calculate_xp_for_player(self, player_id, fixture_id):\n        \"\"\"\n        Calculates Expected Points (xP) for a single player in a given fixture.\n        Considers various factors: minutes, goals, assists, clean sheets, saves,\n        bonus points, and negative events, adjusted for fixture difficulty.\n        \"\"\"\n        player = self.players_data.get(player_id)\n        fixture = self.fixtures_data.get(fixture_id)\n\n        if not player or not fixture:\n            return {\"xp\": 0.0, \"reason\": \"Player or fixture data missing.\"}\n\n        # Handle unavailable players\n        if (\n            player[\"status\"] != \"a\"\n        ):  # 'd' for doubtful, 'i' for injured, 's' for suspended\n            return {\"xp\": 0.0, \"reason\": f\"Player status: {player['status']}\"}\n        if any(\n            x in player[\"news\"].lower()\n            for x in [\"injured\", \"doubtful\", \"suspension\", \"red card\"]\n        ):\n            return {\"xp\": 0.0, \"reason\": f\"Player news: {player['news']}\"}\n\n        # Predict minutes\n        expected_minutes = self._predict_minutes(player_id)\n        if expected_minutes &lt; 1.0:  # If expected to play very little or none\n            return {\"xp\": 0.0, \"reason\": \"Expected minutes too low.\"}\n\n        xp = 0.0\n        position = player[\"position\"]\n        # Use 'team_h' for home team ID\n        is_home_fixture = player[\"team_id\"] == fixture[\"team_h\"]\n\n        # Determine attacking and defensive strengths for the fixture\n        player_team_strength_attack = (\n            self.teams_data.get(fixture[\"team_h\"], {}).get(\n                \"strength_attack_home\"\n            )  # Use 'team_h'\n            if is_home_fixture\n            else self.teams_data.get(fixture[\"team_a\"], {}).get(\n                \"strength_attack_away\"\n            )  # Use 'team_a'\n        )\n        player_team_strength_defence = (\n            self.teams_data.get(fixture[\"team_h\"], {}).get(\n                \"strength_defence_home\"\n            )  # Use 'team_h'\n            if is_home_fixture\n            else self.teams_data.get(fixture[\"team_a\"], {}).get(\n                \"strength_defence_away\"\n            )  # Use 'team_a'\n        )\n        opponent_team_strength_attack = (\n            self.teams_data.get(fixture[\"team_a\"], {}).get(\n                \"strength_attack_away\"\n            )  # Use 'team_a'\n            if is_home_fixture\n            else self.teams_data.get(fixture[\"team_h\"], {}).get(\n                \"strength_attack_home\"\n            )  # Use 'team_h'\n        )\n        opponent_team_strength_defence = (\n            self.teams_data.get(fixture[\"team_a\"], {}).get(\n                \"strength_defence_away\"\n            )  # Use 'team_a'\n            if is_home_fixture\n            else self.teams_data.get(fixture[\"team_h\"], {}).get(\n                \"strength_defence_home\"\n            )  # Use 'team_h'\n        )\n\n        if None in [\n            player_team_strength_attack,\n            player_team_strength_defence,\n            opponent_team_strength_attack,\n            opponent_team_strength_defence,\n        ]:\n            # Fallback if strength data is missing (shouldn't happen with robust data fetch)\n            return {\"xp\": 0.0, \"reason\": \"Team strength data missing for fixture.\"}\n\n        # 1. Appearance points\n        if expected_minutes &gt;= 60:\n            xp += self.fpl_points[\"appearance_points_gte_60\"]\n        elif expected_minutes &gt; 0:\n            xp += self.fpl_points[\"appearance_points_lt_60\"]\n\n        # 2. Expected Goals (scaled by historical goals per 90 and opponent difficulty)\n        # Use player's form and total goals as a basis\n        goals_per_90_hist = (\n            (player[\"goals_scored\"] / player[\"minutes\"] * 90)\n            if player[\"minutes\"] &gt; 0\n            else 0.0\n        )\n        expected_team_goals = self._calculate_expected_goals(\n            player_team_strength_attack, opponent_team_strength_defence\n        )\n\n        expected_goals_player_contribution = (\n            (goals_per_90_hist / 90.0) * expected_minutes * (expected_team_goals / 1.5)\n        )  # Scale player's goal contribution by team's expected goals\n\n        if position == \"GK\":\n            xp += expected_goals_player_contribution * self.fpl_points[\"goal_gk\"]\n        elif position == \"DEF\":\n            xp += expected_goals_player_contribution * self.fpl_points[\"goal_def\"]\n        elif position == \"MID\":\n            xp += expected_goals_player_contribution * self.fpl_points[\"goal_mid\"]\n        elif position == \"FWD\":\n            xp += expected_goals_player_contribution * self.fpl_points[\"goal_fwd\"]\n\n        # 3. Expected Assists (scaled by historical assists per 90 and opponent difficulty)\n        assists_per_90_hist = (\n            (player[\"assists\"] / player[\"minutes\"] * 90)\n            if player[\"minutes\"] &gt; 0\n            else 0.0\n        )\n        # Assuming team's attacking strength correlates with assist opportunities\n        expected_assists_player_contribution = (\n            (assists_per_90_hist / 90.0)\n            * expected_minutes\n            * (expected_team_goals / 1.5)\n        )  # Similarly scale by team's expected goals\n        xp += expected_assists_player_contribution * self.fpl_points[\"assist_points\"]\n\n        # 4. Expected Clean Sheets (for GKs/DEFs/MIDs) and Conceded Goals deduction\n        expected_conceded = self._calculate_expected_conceded_goals(\n            player_team_strength_defence, opponent_team_strength_attack\n        )\n\n        # Probability of clean sheet\n        # Simplified: higher team defense / lower opponent attack -&gt; higher CS prob\n        # Use logistic or sigmoid for probability\n        cs_prob = 1.0 / (\n            1.0 + math.exp(expected_conceded - 1.0)\n        )  # Sigmoid centered at 1 goal\n\n        if position in [\"GK\", \"DEF\"]:\n            xp += cs_prob * self.fpl_points[\"clean_sheet_gk_def\"]\n\n            # Conceded goals deduction: Apply penalty for every 2 goals conceded *probability*\n            # For simplicity, calculate expected deduction: (expected_conceded / 2) * deduction\n            xp += (expected_conceded / 2.0) * self.fpl_points[\n                \"conceded_2_goals_deduction\"\n            ]\n        elif position == \"MID\":\n            xp += cs_prob * self.fpl_points[\"clean_sheet_mid\"]\n\n        # 5. Expected Saves (for GKs)\n        if position == \"GK\":\n            saves_per_90_hist = (\n                (player[\"saves\"] / player[\"minutes\"] * 90)\n                if player[\"minutes\"] &gt; 0\n                else 0.0\n            )\n            # Expected saves scaled by opponent's attacking strength (more attacking -&gt; more shots -&gt; more saves)\n            expected_saves_player_contribution = (\n                (saves_per_90_hist / 90.0)\n                * expected_minutes\n                * (opponent_team_strength_attack / player_team_strength_defence)\n            )\n            xp += (expected_saves_player_contribution / 3.0) * self.fpl_points[\n                \"saves_3_points\"\n            ]  # Using the new config point value\n\n            # Penalty saves (low probability, use historical rate)\n            penalty_saves_hist_per_game = (\n                player[\"penalties_saved\"] / (player[\"minutes\"] / 90.0)\n                if player[\"minutes\"] &gt; 0\n                else 0.0\n            )\n            xp += (\n                penalty_saves_hist_per_game\n                * (expected_minutes / 90.0)\n                * self.fpl_points[\"penalty_save_points\"]\n            )\n\n        # 6. Expected Bonus Points\n        # Use BPS (Bonus Points System) as a proxy. Scale player's average BPS by form and expected minutes.\n        bps_per_90_hist = (\n            (player[\"bps\"] / player[\"minutes\"] * 90) if player[\"minutes\"] &gt; 0 else 0.0\n        )\n        expected_bps = (bps_per_90_hist / 90.0) * expected_minutes * player[\"form\"]\n        xp += expected_bps * self.fpl_points[\"bonus_points_scaling_factor\"]\n\n        # 7. Minor Negative Events (Probabilistic)\n        # These are rare, so a simple probability based on expected minutes.\n        xp += (expected_minutes / 90.0) * (\n            self.fpl_points[\"yellow_card_deduction\"] * YELLOW_CARD_PROB\n            + self.fpl_points[\"red_card_deduction\"] * RED_CARD_PROB\n            + self.fpl_points[\"own_goal_deduction\"] * OWN_GOAL_PROB\n            + self.fpl_points[\"penalty_miss_deduction\"] * PENALTY_MISS_PROB\n        )\n\n        # 8. Defensive Contribution Points (for 2025/26 season heuristic)\n        # Assuming CBIT/CBIRT tracking\n        if position in [\"GK\", \"DEF\"]:\n            xp += CBIT_DEF_PROB * self.fpl_points[\"cbit_def_points\"]\n        elif position in [\"MID\", \"FWD\"]:\n            xp += CBIRT_MID_FWD_PROB * self.fpl_points[\"cbirt_mid_fwd_points\"]\n\n        return {\"xp\": round(xp, 2), \"reason\": \"Success\"}\n\n    def _calculate_all_players_xp(self):\n        \"\"\"\n        Calculates the Expected Points (xP) for all players over multiple upcoming gameweeks\n        and populates self.all_players_xp_calculated_data with xP per gameweek.\n        \"\"\"\n        print(\n            f\"Calculating xP for all players over {self.gameweeks_to_predict} gameweek(s)...\"\n        )\n\n        # Get all upcoming fixtures and sort them by gameweek\n        all_upcoming_fixtures_items = sorted(\n            [\n                (fid, fdict)\n                for fid, fdict in self.fixtures_data.items()\n                if not fdict[\"finished\"]\n            ],\n            key=lambda item: item[1][\"event\"],\n        )\n\n        if not all_upcoming_fixtures_items:\n            print(\"No upcoming fixtures found. Cannot calculate xP.\")\n            return\n\n        # Determine the current gameweek (the gameweek of the earliest upcoming fixture)\n        current_gameweek = all_upcoming_fixtures_items[0][1][\"event\"]\n        target_gameweeks = range(\n            current_gameweek, current_gameweek + self.gameweeks_to_predict\n        )\n\n        # Create a mapping of team_id_code to a list of their fixtures within the target gameweeks\n        team_fixtures_in_range = {team_code: [] for team_code in self.teams_data.keys()}\n        for fixture_id, fixture_data in all_upcoming_fixtures_items:\n            if fixture_data[\"event\"] in target_gameweeks:\n                home_team_code = fixture_data[\"team_h\"]\n                away_team_code = fixture_data[\"team_a\"]\n\n                team_fixtures_in_range[home_team_code].append(fixture_id)\n                team_fixtures_in_range[away_team_code].append(fixture_id)\n\n        # Calculate total xP for each player across the specified gameweeks\n        for player_id, player_data in self.players_data.items():\n            player_team_code = player_data[\"team_id\"]\n            player_position = player_data[\"position\"]\n\n            # Calculate xP for each relevant fixture and store by gameweek\n            expected_points_by_gw = {}\n            for fixture_id in team_fixtures_in_range.get(player_team_code, []):\n                fixture_gameweek = self.fixtures_data[fixture_id][\"event\"]\n                xp_result_single_gw = self.calculate_xp_for_player(\n                    player_id, fixture_id\n                )\n                if xp_result_single_gw and xp_result_single_gw[\"xp\"] is not None:\n                    if fixture_gameweek not in expected_points_by_gw:\n                        expected_points_by_gw[fixture_gameweek] = 0.0\n                    expected_points_by_gw[fixture_gameweek] += xp_result_single_gw[\"xp\"]\n\n            # Ensure all target gameweeks are present, even if xP is 0 for a given GW\n            for gw in target_gameweeks:\n                if gw not in expected_points_by_gw:\n                    expected_points_by_gw[gw] = 0.0\n\n            # Sort the dictionary by gameweek for consistent output\n            expected_points_by_gw = dict(sorted(expected_points_by_gw.items()))\n\n            # Prepare data for the optimizer\n            player_cost_m = player_data[\"cost_pence\"] / 10.0\n            team_name_full = self.teams_data.get(player_team_code, {}).get(\n                \"name\", \"Unknown Team\"\n            )\n\n            self.all_players_xp_calculated_data.append(\n                {\n                    \"name\": player_data[\"name\"],\n                    \"web_name\": player_data[\"web_name\"],\n                    \"team\": team_name_full,\n                    \"position\": player_position,\n                    \"cost\": player_cost_m,\n                    \"expected_points_by_gw\": expected_points_by_gw,  # Changed key and format\n                }\n            )\n        print(\"xP calculation for all players complete.\")\n\n    def get_upcoming_fixtures(self, limit=None):\n        \"\"\"\n        Returns a list of upcoming fixtures, sorted by gameweek and kickoff time.\n        Optionally limits the number of fixtures returned.\n        \"\"\"\n        upcoming = []\n        now = datetime.now()\n\n        # Sort all fixtures by gameweek and then by kickoff time\n        sorted_fixtures = sorted(\n            self.fixtures_data.values(),\n            key=lambda x: (\n                x.get(\"event\", 0),\n                x.get(\"kickoff_time\", \"9999-12-31T00:00:00Z\"),\n            ),\n        )\n\n        current_gameweek = None\n        for fixture_data in sorted_fixtures:\n            # Determine current gameweek from the earliest upcoming fixture\n            if not fixture_data[\"finished\"] and current_gameweek is None:\n                current_gameweek = fixture_data.get(\"event\", 0)\n\n            # Filter for upcoming fixtures within the prediction horizon\n            if (\n                fixture_data.get(\"event\", 0) &lt; current_gameweek  # Skip past gameweeks\n                or fixture_data.get(\"event\", 0)\n                &gt;= current_gameweek + self.gameweeks_to_predict\n            ):\n                continue  # Skip fixtures outside the prediction horizon\n\n            home_team_name = self.teams_data.get(\n                fixture_data[\"team_h\"], {}\n            ).get(  # Use 'team_h'\n                \"name\", \"Unknown\"\n            )\n            away_team_name = self.teams_data.get(\n                fixture_data[\"team_a\"], {}\n            ).get(  # Use 'team_a'\n                \"name\", \"Unknown\"\n            )\n\n            # Only add fixtures that are not finished\n            if not fixture_data[\"finished\"]:\n                upcoming.append(\n                    {\n                        \"fixture_id\": fixture_data[\"id\"],\n                        \"gameweek\": fixture_data.get(\"event\"),\n                        \"home_team_id\": fixture_data[\"team_h\"],  # Use 'team_h'\n                        \"away_team_id\": fixture_data[\"team_a\"],  # Use 'team_a'\n                        \"match\": f\"{home_team_name} vs {away_team_name}\",\n                        \"kickoff_time\": fixture_data.get(\"kickoff_time\"),\n                        \"home_team_difficulty\": fixture_data[\"team_h_difficulty\"],\n                        \"away_team_difficulty\": fixture_data[\"team_a_difficulty\"],\n                    }\n                )\n            if limit is not None and len(upcoming) &gt;= limit:\n                break\n        return upcoming\n\n    def get_players_for_optimizer(self):\n        \"\"\"\n        Returns the list of player data with calculated xP per gameweek,\n        formatted for the FPLOptimizer.\n        \"\"\"\n        return self.all_players_xp_calculated_data\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/#build.lib.build.lib.fpl_solver.fpl_xp_predictor.FPLPredictor.__init__","title":"<code>__init__(gameweeks_to_predict=1)</code>","text":"<p>Initializes the FPLPredictor with default FPL point rules and data structures, then fetches real data and calculates xP for all players.</p> <p>Parameters:</p> Name Type Description Default <code>gameweeks_to_predict</code> <code>int</code> <p>The number of upcoming gameweeks to calculate                         expected points for. Default is 1 (next gameweek).</p> <code>1</code> Source code in <code>build/lib/build/lib/fpl_solver/fpl_xp_predictor.py</code> <pre><code>def __init__(self, gameweeks_to_predict: int = 1):\n    \"\"\"\n    Initializes the FPLPredictor with default FPL point rules and\n    data structures, then fetches real data and calculates xP for all players.\n\n    Args:\n        gameweeks_to_predict (int): The number of upcoming gameweeks to calculate\n                                    expected points for. Default is 1 (next gameweek).\n    \"\"\"\n    if not isinstance(gameweeks_to_predict, int) or gameweeks_to_predict &lt; 1:\n        raise ValueError(\"gameweeks_to_predict must be a positive integer.\")\n    self.gameweeks_to_predict = gameweeks_to_predict\n\n    self.fpl_points = FPL_POINTS\n\n    self.players_data = {}\n    self.teams_data = {}\n    self.fixtures_data = {}\n    self.position_definitions = {\n        1: \"GK\",\n        2: \"DEF\",\n        3: \"MID\",\n        4: \"FWD\",\n    }\n    self.all_players_xp_calculated_data = (\n        []\n    )  # To store xP for all players for the optimizer\n\n    self._fetch_fpl_data()\n    self._calculate_all_players_xp()  # Calculate xP for all players after data is loaded\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/#build.lib.build.lib.fpl_solver.fpl_xp_predictor.FPLPredictor.calculate_xp_for_player","title":"<code>calculate_xp_for_player(player_id, fixture_id)</code>","text":"<p>Calculates Expected Points (xP) for a single player in a given fixture. Considers various factors: minutes, goals, assists, clean sheets, saves, bonus points, and negative events, adjusted for fixture difficulty.</p> Source code in <code>build/lib/build/lib/fpl_solver/fpl_xp_predictor.py</code> <pre><code>def calculate_xp_for_player(self, player_id, fixture_id):\n    \"\"\"\n    Calculates Expected Points (xP) for a single player in a given fixture.\n    Considers various factors: minutes, goals, assists, clean sheets, saves,\n    bonus points, and negative events, adjusted for fixture difficulty.\n    \"\"\"\n    player = self.players_data.get(player_id)\n    fixture = self.fixtures_data.get(fixture_id)\n\n    if not player or not fixture:\n        return {\"xp\": 0.0, \"reason\": \"Player or fixture data missing.\"}\n\n    # Handle unavailable players\n    if (\n        player[\"status\"] != \"a\"\n    ):  # 'd' for doubtful, 'i' for injured, 's' for suspended\n        return {\"xp\": 0.0, \"reason\": f\"Player status: {player['status']}\"}\n    if any(\n        x in player[\"news\"].lower()\n        for x in [\"injured\", \"doubtful\", \"suspension\", \"red card\"]\n    ):\n        return {\"xp\": 0.0, \"reason\": f\"Player news: {player['news']}\"}\n\n    # Predict minutes\n    expected_minutes = self._predict_minutes(player_id)\n    if expected_minutes &lt; 1.0:  # If expected to play very little or none\n        return {\"xp\": 0.0, \"reason\": \"Expected minutes too low.\"}\n\n    xp = 0.0\n    position = player[\"position\"]\n    # Use 'team_h' for home team ID\n    is_home_fixture = player[\"team_id\"] == fixture[\"team_h\"]\n\n    # Determine attacking and defensive strengths for the fixture\n    player_team_strength_attack = (\n        self.teams_data.get(fixture[\"team_h\"], {}).get(\n            \"strength_attack_home\"\n        )  # Use 'team_h'\n        if is_home_fixture\n        else self.teams_data.get(fixture[\"team_a\"], {}).get(\n            \"strength_attack_away\"\n        )  # Use 'team_a'\n    )\n    player_team_strength_defence = (\n        self.teams_data.get(fixture[\"team_h\"], {}).get(\n            \"strength_defence_home\"\n        )  # Use 'team_h'\n        if is_home_fixture\n        else self.teams_data.get(fixture[\"team_a\"], {}).get(\n            \"strength_defence_away\"\n        )  # Use 'team_a'\n    )\n    opponent_team_strength_attack = (\n        self.teams_data.get(fixture[\"team_a\"], {}).get(\n            \"strength_attack_away\"\n        )  # Use 'team_a'\n        if is_home_fixture\n        else self.teams_data.get(fixture[\"team_h\"], {}).get(\n            \"strength_attack_home\"\n        )  # Use 'team_h'\n    )\n    opponent_team_strength_defence = (\n        self.teams_data.get(fixture[\"team_a\"], {}).get(\n            \"strength_defence_away\"\n        )  # Use 'team_a'\n        if is_home_fixture\n        else self.teams_data.get(fixture[\"team_h\"], {}).get(\n            \"strength_defence_home\"\n        )  # Use 'team_h'\n    )\n\n    if None in [\n        player_team_strength_attack,\n        player_team_strength_defence,\n        opponent_team_strength_attack,\n        opponent_team_strength_defence,\n    ]:\n        # Fallback if strength data is missing (shouldn't happen with robust data fetch)\n        return {\"xp\": 0.0, \"reason\": \"Team strength data missing for fixture.\"}\n\n    # 1. Appearance points\n    if expected_minutes &gt;= 60:\n        xp += self.fpl_points[\"appearance_points_gte_60\"]\n    elif expected_minutes &gt; 0:\n        xp += self.fpl_points[\"appearance_points_lt_60\"]\n\n    # 2. Expected Goals (scaled by historical goals per 90 and opponent difficulty)\n    # Use player's form and total goals as a basis\n    goals_per_90_hist = (\n        (player[\"goals_scored\"] / player[\"minutes\"] * 90)\n        if player[\"minutes\"] &gt; 0\n        else 0.0\n    )\n    expected_team_goals = self._calculate_expected_goals(\n        player_team_strength_attack, opponent_team_strength_defence\n    )\n\n    expected_goals_player_contribution = (\n        (goals_per_90_hist / 90.0) * expected_minutes * (expected_team_goals / 1.5)\n    )  # Scale player's goal contribution by team's expected goals\n\n    if position == \"GK\":\n        xp += expected_goals_player_contribution * self.fpl_points[\"goal_gk\"]\n    elif position == \"DEF\":\n        xp += expected_goals_player_contribution * self.fpl_points[\"goal_def\"]\n    elif position == \"MID\":\n        xp += expected_goals_player_contribution * self.fpl_points[\"goal_mid\"]\n    elif position == \"FWD\":\n        xp += expected_goals_player_contribution * self.fpl_points[\"goal_fwd\"]\n\n    # 3. Expected Assists (scaled by historical assists per 90 and opponent difficulty)\n    assists_per_90_hist = (\n        (player[\"assists\"] / player[\"minutes\"] * 90)\n        if player[\"minutes\"] &gt; 0\n        else 0.0\n    )\n    # Assuming team's attacking strength correlates with assist opportunities\n    expected_assists_player_contribution = (\n        (assists_per_90_hist / 90.0)\n        * expected_minutes\n        * (expected_team_goals / 1.5)\n    )  # Similarly scale by team's expected goals\n    xp += expected_assists_player_contribution * self.fpl_points[\"assist_points\"]\n\n    # 4. Expected Clean Sheets (for GKs/DEFs/MIDs) and Conceded Goals deduction\n    expected_conceded = self._calculate_expected_conceded_goals(\n        player_team_strength_defence, opponent_team_strength_attack\n    )\n\n    # Probability of clean sheet\n    # Simplified: higher team defense / lower opponent attack -&gt; higher CS prob\n    # Use logistic or sigmoid for probability\n    cs_prob = 1.0 / (\n        1.0 + math.exp(expected_conceded - 1.0)\n    )  # Sigmoid centered at 1 goal\n\n    if position in [\"GK\", \"DEF\"]:\n        xp += cs_prob * self.fpl_points[\"clean_sheet_gk_def\"]\n\n        # Conceded goals deduction: Apply penalty for every 2 goals conceded *probability*\n        # For simplicity, calculate expected deduction: (expected_conceded / 2) * deduction\n        xp += (expected_conceded / 2.0) * self.fpl_points[\n            \"conceded_2_goals_deduction\"\n        ]\n    elif position == \"MID\":\n        xp += cs_prob * self.fpl_points[\"clean_sheet_mid\"]\n\n    # 5. Expected Saves (for GKs)\n    if position == \"GK\":\n        saves_per_90_hist = (\n            (player[\"saves\"] / player[\"minutes\"] * 90)\n            if player[\"minutes\"] &gt; 0\n            else 0.0\n        )\n        # Expected saves scaled by opponent's attacking strength (more attacking -&gt; more shots -&gt; more saves)\n        expected_saves_player_contribution = (\n            (saves_per_90_hist / 90.0)\n            * expected_minutes\n            * (opponent_team_strength_attack / player_team_strength_defence)\n        )\n        xp += (expected_saves_player_contribution / 3.0) * self.fpl_points[\n            \"saves_3_points\"\n        ]  # Using the new config point value\n\n        # Penalty saves (low probability, use historical rate)\n        penalty_saves_hist_per_game = (\n            player[\"penalties_saved\"] / (player[\"minutes\"] / 90.0)\n            if player[\"minutes\"] &gt; 0\n            else 0.0\n        )\n        xp += (\n            penalty_saves_hist_per_game\n            * (expected_minutes / 90.0)\n            * self.fpl_points[\"penalty_save_points\"]\n        )\n\n    # 6. Expected Bonus Points\n    # Use BPS (Bonus Points System) as a proxy. Scale player's average BPS by form and expected minutes.\n    bps_per_90_hist = (\n        (player[\"bps\"] / player[\"minutes\"] * 90) if player[\"minutes\"] &gt; 0 else 0.0\n    )\n    expected_bps = (bps_per_90_hist / 90.0) * expected_minutes * player[\"form\"]\n    xp += expected_bps * self.fpl_points[\"bonus_points_scaling_factor\"]\n\n    # 7. Minor Negative Events (Probabilistic)\n    # These are rare, so a simple probability based on expected minutes.\n    xp += (expected_minutes / 90.0) * (\n        self.fpl_points[\"yellow_card_deduction\"] * YELLOW_CARD_PROB\n        + self.fpl_points[\"red_card_deduction\"] * RED_CARD_PROB\n        + self.fpl_points[\"own_goal_deduction\"] * OWN_GOAL_PROB\n        + self.fpl_points[\"penalty_miss_deduction\"] * PENALTY_MISS_PROB\n    )\n\n    # 8. Defensive Contribution Points (for 2025/26 season heuristic)\n    # Assuming CBIT/CBIRT tracking\n    if position in [\"GK\", \"DEF\"]:\n        xp += CBIT_DEF_PROB * self.fpl_points[\"cbit_def_points\"]\n    elif position in [\"MID\", \"FWD\"]:\n        xp += CBIRT_MID_FWD_PROB * self.fpl_points[\"cbirt_mid_fwd_points\"]\n\n    return {\"xp\": round(xp, 2), \"reason\": \"Success\"}\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/#build.lib.build.lib.fpl_solver.fpl_xp_predictor.FPLPredictor.get_players_for_optimizer","title":"<code>get_players_for_optimizer()</code>","text":"<p>Returns the list of player data with calculated xP per gameweek, formatted for the FPLOptimizer.</p> Source code in <code>build/lib/build/lib/fpl_solver/fpl_xp_predictor.py</code> <pre><code>def get_players_for_optimizer(self):\n    \"\"\"\n    Returns the list of player data with calculated xP per gameweek,\n    formatted for the FPLOptimizer.\n    \"\"\"\n    return self.all_players_xp_calculated_data\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/#build.lib.build.lib.fpl_solver.fpl_xp_predictor.FPLPredictor.get_upcoming_fixtures","title":"<code>get_upcoming_fixtures(limit=None)</code>","text":"<p>Returns a list of upcoming fixtures, sorted by gameweek and kickoff time. Optionally limits the number of fixtures returned.</p> Source code in <code>build/lib/build/lib/fpl_solver/fpl_xp_predictor.py</code> <pre><code>def get_upcoming_fixtures(self, limit=None):\n    \"\"\"\n    Returns a list of upcoming fixtures, sorted by gameweek and kickoff time.\n    Optionally limits the number of fixtures returned.\n    \"\"\"\n    upcoming = []\n    now = datetime.now()\n\n    # Sort all fixtures by gameweek and then by kickoff time\n    sorted_fixtures = sorted(\n        self.fixtures_data.values(),\n        key=lambda x: (\n            x.get(\"event\", 0),\n            x.get(\"kickoff_time\", \"9999-12-31T00:00:00Z\"),\n        ),\n    )\n\n    current_gameweek = None\n    for fixture_data in sorted_fixtures:\n        # Determine current gameweek from the earliest upcoming fixture\n        if not fixture_data[\"finished\"] and current_gameweek is None:\n            current_gameweek = fixture_data.get(\"event\", 0)\n\n        # Filter for upcoming fixtures within the prediction horizon\n        if (\n            fixture_data.get(\"event\", 0) &lt; current_gameweek  # Skip past gameweeks\n            or fixture_data.get(\"event\", 0)\n            &gt;= current_gameweek + self.gameweeks_to_predict\n        ):\n            continue  # Skip fixtures outside the prediction horizon\n\n        home_team_name = self.teams_data.get(\n            fixture_data[\"team_h\"], {}\n        ).get(  # Use 'team_h'\n            \"name\", \"Unknown\"\n        )\n        away_team_name = self.teams_data.get(\n            fixture_data[\"team_a\"], {}\n        ).get(  # Use 'team_a'\n            \"name\", \"Unknown\"\n        )\n\n        # Only add fixtures that are not finished\n        if not fixture_data[\"finished\"]:\n            upcoming.append(\n                {\n                    \"fixture_id\": fixture_data[\"id\"],\n                    \"gameweek\": fixture_data.get(\"event\"),\n                    \"home_team_id\": fixture_data[\"team_h\"],  # Use 'team_h'\n                    \"away_team_id\": fixture_data[\"team_a\"],  # Use 'team_a'\n                    \"match\": f\"{home_team_name} vs {away_team_name}\",\n                    \"kickoff_time\": fixture_data.get(\"kickoff_time\"),\n                    \"home_team_difficulty\": fixture_data[\"team_h_difficulty\"],\n                    \"away_team_difficulty\": fixture_data[\"team_a_difficulty\"],\n                }\n            )\n        if limit is not None and len(upcoming) &gt;= limit:\n            break\n    return upcoming\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/fpl_config/","title":"fpl_config","text":"<p>fpl_config.py</p> <p>Configuration settings for the FPL Expected Points Predictor and Solver. This file centralizes all constants related to FPL scoring, thresholds, and optimization parameters.</p>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/fpl_solver/","title":"fpl_solver","text":""},{"location":"autoapi/build/lib/build/lib/fpl_solver/fpl_solver/#build.lib.build.lib.fpl_solver.fpl_solver.FPLOptimizer","title":"<code>FPLOptimizer</code>","text":"<p>A class to optimize Fantasy Premier League (FPL) squad selection using Integer Linear Programming (ILP).</p> <p>The optimizer aims to select a 15-player squad (2 GKs, 5 DEFs, 5 MIDs, 3 FWDs) within a budget, with a maximum number of players from any single team, to maximize the total expected points.</p> Source code in <code>build/lib/build/lib/fpl_solver/fpl_solver.py</code> <pre><code>class FPLOptimizer:\n    \"\"\"\n    A class to optimize Fantasy Premier League (FPL) squad selection\n    using Integer Linear Programming (ILP).\n\n    The optimizer aims to select a 15-player squad (2 GKs, 5 DEFs, 5 MIDs, 3 FWDs)\n    within a budget, with a maximum number of players from any single team,\n    to maximize the total expected points.\n    \"\"\"\n\n    def __init__(self, player_data: pd.DataFrame):\n        \"\"\"\n        Initializes the FPLOptimizer with player data.\n\n        Args:\n            player_data (pd.DataFrame): A DataFrame containing player information\n                                        with columns: 'name', 'team', 'position',\n                                        'cost', 'expected_points_by_gw' (a dict of xP per GW).\n        \"\"\"\n        required_columns = [\"name\", \"team\", \"position\", \"cost\", \"expected_points_by_gw\"]\n        if not all(col in player_data.columns for col in required_columns):\n            missing_cols = [\n                col for col in required_columns if col not in player_data.columns\n            ]\n            raise ValueError(\n                f\"player_data DataFrame must contain {required_columns} columns. Missing: {missing_cols}\"\n            )\n\n        self.player_data = player_data\n        self.problem = None\n        self.selected_squad_history = {}  # To store squad for each gameweek\n        self.total_cost = 0\n        self.total_expected_points = 0\n        self.total_transfer_hits = 0\n\n        # --- Process Enforced Players ---\n        self.enforced_player_indices = set()\n        self.enforced_team_pos_requirements = []\n\n        print(\"\\n--- Processing Enforced Players ---\")\n\n        # Enforce by Player ID\n        for player_id in ENFORCED_PLAYERS_BY_ID:\n            found_player = self.player_data[self.player_data[\"id\"] == player_id]\n            if not found_player.empty:\n                player_idx = found_player.index[0]\n                self.enforced_player_indices.add(player_idx)\n                print(\n                    f\"Enforcing player by ID: {found_player.loc[player_idx, 'name']} (ID: {player_id})\"\n                )\n            else:\n                print(\n                    f\"Warning: Enforced player with ID {player_id} not found in data.\"\n                )\n\n        # Enforce by Player Name\n        for player_name in ENFORCED_PLAYERS_BY_NAME:\n            found_player = self.player_data[self.player_data[\"name\"] == player_name]\n            if not found_player.empty:\n                player_idx = found_player.index[0]\n                self.enforced_player_indices.add(player_idx)\n                print(f\"Enforcing player by name: {player_name}\")\n            else:\n                print(f\"Warning: Enforced player '{player_name}' not found in data.\")\n\n        # Enforce by Team and Position\n        for requirement in ENFORCED_PLAYERS_BY_TEAM_AND_POSITION:\n            team = requirement.get(\"team\")\n            position = requirement.get(\"position\")\n            if team and position:\n                # Validate team and position exist in data\n                if team not in self.player_data[\"team\"].unique():\n                    print(\n                        f\"Warning: Enforced team '{team}' for position '{position}' not found in data.\"\n                    )\n                    continue\n                if position not in self.player_data[\"position\"].unique():\n                    print(\n                        f\"Warning: Enforced position '{position}' for team '{team}' not found in data.\"\n                    )\n                    continue\n\n                self.enforced_team_pos_requirements.append((team, position))\n                print(f\"Enforcing at least one {position} from {team}.\")\n            else:\n                print(\n                    f\"Warning: Invalid enforced team/position requirement: {requirement}\"\n                )\n\n        if not (\n            self.enforced_player_indices\n            or self.enforced_team_pos_requirements\n            or ENFORCED_PLAYERS_BY_ID\n            or ENFORCED_PLAYERS_BY_NAME\n            or ENFORCED_PLAYERS_BY_TEAM_AND_POSITION\n        ):\n            print(\"No players or team/position combinations are enforced.\")\n        print(\"-----------------------------------\\n\")\n\n    def solve(\n        self,\n        budget: float,\n        max_players_per_team: int,\n        chip_allowances: dict,\n        num_gameweeks: int,\n    ) -&gt; bool:\n        \"\"\"\n        Solves the FPL optimization problem using PuLP.\n\n        Args:\n            budget (float): The maximum budget in millions of pounds.\n            max_players_per_team (int): The maximum number of players allowed from\n                                        any single Premier League team.\n            chip_allowances (dict): A dictionary specifying the maximum usage for each chip.\n            num_gameweeks (int): The number of gameweeks to optimize over.\n\n        Returns:\n            bool: True if a solution was found, False otherwise.\n        \"\"\"\n        self.problem = LpProblem(\"FPL Squad Multi-Week Optimization\", LpMaximize)\n\n        # Decision variables for player selection, indexed by player and gameweek\n        player_vars = LpVariable.dicts(\n            \"Player\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n        )\n        starting_xi_vars = LpVariable.dicts(\n            \"StartingXI\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n        )\n        captain_var = LpVariable.dicts(\n            \"Captain\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n        )\n\n        # Binary variables for chip usage, indexed by gameweek\n        use_bench_boost = LpVariable.dicts(\n            \"Use_Bench_Boost\", range(num_gameweeks), 0, 1, LpBinary\n        )\n        use_triple_captain = LpVariable.dicts(\n            \"Use_Triple_Captain\", range(num_gameweeks), 0, 1, LpBinary\n        )\n\n        # Transfer variables\n        transfer_in_vars = LpVariable.dicts(\n            \"Transfer_In\",\n            (self.player_data.index, range(1, num_gameweeks)),\n            0,\n            1,\n            LpBinary,\n        )\n        transfer_out_vars = LpVariable.dicts(\n            \"Transfer_Out\",\n            (self.player_data.index, range(1, num_gameweeks)),\n            0,\n            1,\n            LpBinary,\n        )\n\n        # Total transfers made in a gameweek (absolute count)\n        transfers_made = LpVariable.dicts(\n            \"Transfers_Made\", range(1, num_gameweeks), 0, None, LpInteger\n        )\n        # Free transfers available at the start of a gameweek\n        free_transfers_available = LpVariable.dicts(\n            \"Free_Transfers_Available\",\n            range(num_gameweeks),\n            0,\n            MAX_FREE_TRANSFERS_SAVED + 1,\n            LpInteger,\n        )\n        # Number of transfer hits taken in a gameweek\n        transfer_hits = LpVariable.dicts(\n            \"Transfer_Hits\", range(1, num_gameweeks), 0, None, LpInteger\n        )\n\n        # Auxiliary variables for linearizing chip effects\n        is_bench_player = LpVariable.dicts(\n            \"Is_Bench_Player\",\n            (self.player_data.index, range(num_gameweeks)),\n            0,\n            1,\n            LpBinary,\n        )\n        actual_bench_boost_points = LpVariable.dicts(\n            \"Actual_Bench_Boost_Points\",\n            (self.player_data.index, range(num_gameweeks)),\n            0,\n            None,\n            LpContinuous,\n        )\n        actual_triple_captain_bonus = LpVariable.dicts(\n            \"Actual_Triple_Captain_Bonus\",\n            (self.player_data.index, range(num_gameweeks)),\n            0,\n            None,\n            LpContinuous,\n        )\n\n        # --- Objective Function ---\n        total_objective_points = []\n\n        # Get the first gameweek number from the player data to correctly index expected_points_by_gw\n        first_gw_key = next(\n            iter(\n                self.player_data.loc[\n                    self.player_data.index[0], \"expected_points_by_gw\"\n                ].keys()\n            )\n        )\n        current_gameweek_number_start = int(first_gw_key)\n\n        for w in range(num_gameweeks):\n            # The actual gameweek number (1-indexed)\n            gw_actual = current_gameweek_number_start + w\n\n            # Base expected points from the selected starting 11 for this gameweek\n            base_points_expression_gw = lpSum(\n                self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n                * starting_xi_vars[i][w]\n                for i in self.player_data.index\n            )\n            total_objective_points.append(base_points_expression_gw)\n\n            # Regular Captaincy points (additional 1x for captain)\n            captain_points_bonus_gw = lpSum(\n                self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n                * captain_var[i][w]\n                for i in self.player_data.index\n            )\n            total_objective_points.append(captain_points_bonus_gw)\n\n            # Define auxiliary variables and constraints for chips for each gameweek\n            for i in self.player_data.index:\n                # Use gameweek-specific player xP for chip calculations\n                player_xp = self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n\n                # Bench Boost auxiliary variables and constraints\n                self.problem += (\n                    is_bench_player[i][w] &lt;= player_vars[i][w],\n                    f\"IsBench_Squad_{i}_{w}\",\n                )\n                self.problem += (\n                    is_bench_player[i][w] &lt;= 1 - starting_xi_vars[i][w],\n                    f\"IsBench_NotStarter_{i}_{w}\",\n                )\n                self.problem += (\n                    is_bench_player[i][w]\n                    &gt;= player_vars[i][w] + (1 - starting_xi_vars[i][w]) - 1,\n                    f\"IsBench_Logical_{i}_{w}\",\n                )\n\n                self.problem += (\n                    actual_bench_boost_points[i][w]\n                    &lt;= player_xp * is_bench_player[i][w],\n                    f\"BenchBoost_Contr_1_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_bench_boost_points[i][w] &lt;= player_xp * use_bench_boost[w],\n                    f\"BenchBoost_Contr_2_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_bench_boost_points[i][w]\n                    &gt;= player_xp * (is_bench_player[i][w] + use_bench_boost[w] - 1),\n                    f\"BenchBoost_Contr_3_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_bench_boost_points[i][w] &gt;= 0,\n                    f\"BenchBoost_Contr_4_{i}_{w}\",\n                )\n\n                # Triple Captain auxiliary variables and constraints\n                # Changed player_xp * 2 to player_xp to reflect additional 1x bonus\n                self.problem += (\n                    actual_triple_captain_bonus[i][w] &lt;= player_xp * captain_var[i][w],\n                    f\"TripleCaptain_Contr_1_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_triple_captain_bonus[i][w]\n                    &lt;= player_xp * use_triple_captain[w],\n                    f\"TripleCaptain_Contr_2_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_triple_captain_bonus[i][w]\n                    &gt;= player_xp * (captain_var[i][w] + use_triple_captain[w] - 1),\n                    f\"TripleCaptain_Contr_3_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_triple_captain_bonus[i][w] &gt;= 0,\n                    f\"TripleCaptain_Contr_4_{i}_{w}\",\n                )\n\n            # Add points from bench boost and triple captain bonus for this gameweek\n            total_bench_boost_points_gw = lpSum(\n                actual_bench_boost_points[i][w] for i in self.player_data.index\n            )\n            total_triple_captain_bonus_points_gw = lpSum(\n                actual_triple_captain_bonus[i][w] for i in self.player_data.index\n            )\n\n            total_objective_points.append(total_bench_boost_points_gw)\n            total_objective_points.append(total_triple_captain_bonus_points_gw)\n\n        # Subtract transfer hits from the total objective\n        total_objective_points.append(\n            -POINTS_PER_HIT * lpSum(transfer_hits[w] for w in range(1, num_gameweeks))\n        )\n\n        self.problem += (\n            lpSum(total_objective_points),\n            \"Total Expected Points Over Gameweeks\",\n        )\n\n        # --- Constraints ---\n\n        # Apply constraints for each gameweek\n        for w in range(num_gameweeks):\n            # 1. Select exactly 15 players for the squad\n            self.problem += (\n                lpSum(player_vars[i][w] for i in self.player_data.index) == 15,\n                f\"Total_Players_GW{w}\",\n            )\n\n            # 2. Squad position constraints (2 GKs, 5 DEFs, 5 MIDs, 3 FWDs)\n            gks = self.player_data[self.player_data[\"position\"] == \"GK\"].index\n            defs = self.player_data[self.player_data[\"position\"] == \"DEF\"].index\n            mids = self.player_data[self.player_data[\"position\"] == \"MID\"].index\n            fwds = self.player_data[self.player_data[\"position\"] == \"FWD\"].index\n\n            self.problem += (\n                lpSum(player_vars[i][w] for i in gks) == 2,\n                f\"Goalkeepers_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(player_vars[i][w] for i in defs) == 5,\n                f\"Defenders_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(player_vars[i][w] for i in mids) == 5,\n                f\"Midfielders_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(player_vars[i][w] for i in fwds) == 3,\n                f\"Forwards_Count_GW{w}\",\n            )\n\n            # 3. Budget constraint\n            # This applies to the cost of the squad for the current gameweek.\n            self.problem += (\n                lpSum(\n                    self.player_data.loc[i, \"cost\"] * player_vars[i][w]\n                    for i in self.player_data.index\n                )\n                &lt;= budget,\n                f\"Total_Budget_GW{w}\",\n            )\n\n            # 4. Maximum players per team constraint\n            for team in self.player_data[\"team\"].unique():\n                team_players = self.player_data[self.player_data[\"team\"] == team].index\n                self.problem += (\n                    lpSum(player_vars[i][w] for i in team_players)\n                    &lt;= max_players_per_team,\n                    f\"Max_Players_from_{team}_GW{w}\",\n                )\n\n            # 5. Starting XI constraints\n            # 5.1 Select exactly 11 players for the starting XI\n            self.problem += (\n                lpSum(starting_xi_vars[i][w] for i in self.player_data.index) == 11,\n                f\"Total_Starting_XI_Players_GW{w}\",\n            )\n\n            # 5.2 A player can only be in the starting XI if they are in the squad\n            for i in self.player_data.index:\n                self.problem += (\n                    starting_xi_vars[i][w] &lt;= player_vars[i][w],\n                    f\"StartingXI_in_Squad_{i}_{w}\",\n                )\n\n            # 5.3 Starting XI position constraints (FPL allows flexible formations, so use minimums)\n            self.problem += (\n                lpSum(starting_xi_vars[i][w] for i in gks) == 1,\n                f\"Starting_Goalkeepers_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(starting_xi_vars[i][w] for i in defs) &gt;= 3,\n                f\"Min_Starting_Defenders_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(starting_xi_vars[i][w] for i in mids) &gt;= 2,\n                f\"Min_Starting_Midfielders_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(starting_xi_vars[i][w] for i in fwds) &gt;= 1,\n                f\"Min_Starting_Forwards_Count_GW{w}\",\n            )\n\n            # 6. Captain Constraints\n            # 6.1 Select exactly one captain from the starting XI\n            self.problem += (\n                lpSum(captain_var[i][w] for i in self.player_data.index) == 1,\n                f\"One_Captain_GW{w}\",\n            )\n\n            # 6.2 A player can only be captain if they are in the starting XI\n            for i in self.player_data.index:\n                self.problem += (\n                    captain_var[i][w] &lt;= starting_xi_vars[i][w],\n                    f\"Captain_in_StartingXI_{i}_{w}\",\n                )\n\n            # --- Enforced Player Constraints---\n            for player_idx in self.enforced_player_indices:\n                self.problem += (\n                    player_vars[player_idx][w] == 1,\n                    f\"Enforce_Player_{self.player_data.loc[player_idx, 'name']}_GW{w}\",\n                )\n\n            for team, position in self.enforced_team_pos_requirements:\n                # Filter players for the current team and position\n                team_pos_players = self.player_data[\n                    (self.player_data[\"team\"] == team)\n                    &amp; (self.player_data[\"position\"] == position)\n                ].index\n                if not team_pos_players.empty:\n                    self.problem += (\n                        lpSum(player_vars[i][w] for i in team_pos_players) &gt;= 1,\n                        f\"Enforce_One_{position}_from_{team}_GW{w}\",\n                    )\n                else:\n                    print(\n                        f\"Warning: No players found for enforced requirement: at least one {position} from {team} for GW{gw_actual}.\"\n                    )\n\n        # --- Chip Usage Constraints (TOTAL usage over all gameweeks) ---\n        # These constraints should be outside the per-gameweek loop to avoid duplicates.\n        self.problem += (\n            lpSum(use_bench_boost[j] for j in range(num_gameweeks))\n            &lt;= chip_allowances.get(\"bench_boost\", 0),\n            f\"Max_Bench_Boost_Usage_Total\",\n        )\n        self.problem += (\n            lpSum(use_triple_captain[j] for j in range(num_gameweeks))\n            &lt;= chip_allowances.get(\"triple_captain\", 0),\n            f\"Max_Triple_Captain_Usage_Total\",\n        )\n\n        # --- Inter-Gameweek Constraints (Transfers and Transfer Rules) ---\n        # Initialize free transfers for GW0 (first gameweek of optimization horizon)\n        # This assumes the optimization starts at GW0, and it has INITIAL_FREE_TRANSFERS.\n        # If the model starts at an arbitrary GW, this would need to be an input.\n        self.problem += (\n            free_transfers_available[0] == INITIAL_FREE_TRANSFERS,\n            f\"Initial_Free_Transfers_GW0\",\n        )\n\n        for w in range(1, num_gameweeks):\n            # Calculate total transfers made in this gameweek\n            self.problem += (\n                transfers_made[w]\n                == lpSum(transfer_in_vars[i][w] for i in self.player_data.index),\n                f\"Transfers_Made_GW{w}\",\n            )\n            # Total transfers in must equal total transfers out for each gameweek after the first\n            self.problem += (\n                lpSum(transfer_in_vars[i][w] for i in self.player_data.index)\n                == lpSum(transfer_out_vars[i][w] for i in self.player_data.index),\n                f\"Transfers_In_Equals_Out_GW{w}\",\n            )\n\n            # Calculate free transfers available for the current gameweek (w)\n            # Free transfers for GW_w = min(free transfers from GW_w-1 - transfers made in GW_w + 1, MAX_FREE_TRANSFERS_SAVED + 1)\n            # The + 1 in MAX_FREE_TRANSFERS_SAVED + 1 is because MAX_FREE_TRANSFERS_SAVED implies how many can be *saved*,\n            # so if you save 1, you have 1 (current) + 1 (saved) = 2.\n            self.problem += (\n                free_transfers_available[w]\n                &lt;= free_transfers_available[w - 1] - transfers_made[w] + 1,\n                f\"Free_Transfers_Calc_1_GW{w}\",\n            )\n            self.problem += (\n                free_transfers_available[w] &lt;= MAX_FREE_TRANSFERS_SAVED + 1,\n                f\"Free_Transfers_Calc_2_GW{w}\",\n            )\n            self.problem += (\n                free_transfers_available[w] &gt;= 0,  # Cannot have negative free transfers\n                f\"Free_Transfers_Non_Negative_GW{w}\",\n            )\n\n            # Calculate transfer hits\n            # transfer_hits[w] = max(0, transfers_made[w] - free_transfers_available_at_start_of_gw_w)\n            # This needs to be linearized. If transfers_made[w] &gt; free_transfers_available[w-1], then hit.\n            # free_transfers_available[w-1] represents transfers available *before* making transfers for GW_w\n            self.problem += (\n                transfer_hits[w] &gt;= transfers_made[w] - free_transfers_available[w - 1],\n                f\"Transfer_Hits_Calc_1_GW{w}\",\n            )\n            self.problem += (\n                transfer_hits[w] &gt;= 0,\n                f\"Transfer_Hits_Calc_2_GW{w}\",\n            )\n\n            for i in self.player_data.index:\n                # Squad continuity: player_vars[i][w] (in squad at start of GW w)\n                #                 = player_vars[i][w-1] (in squad at start of GW w-1)\n                #                 - transfer_out_vars[i][w] (transferred out for GW w)\n                #                 + transfer_in_vars[i][w] (transferred in for GW w)\n                self.problem += (\n                    player_vars[i][w]\n                    == player_vars[i][w - 1]\n                    - transfer_out_vars[i][w]\n                    + transfer_in_vars[i][w],\n                    f\"Squad_Continuity_{i}_GW{w}\",\n                )\n                # A player cannot be transferred in and out in the same gameweek\n                self.problem += (\n                    transfer_in_vars[i][w] + transfer_out_vars[i][w] &lt;= 1,\n                    f\"No_Simultaneous_Transfer_{i}_{w}\",\n                )\n\n        try:\n            # The solver is called with the GLPK_CMD solver\n            self.problem.solve(PULP_CBC_CMD(msg=0))  # msg=0 suppresses verbose output\n        except Exception as e:\n            print(f\"Error solving the problem: {e}\")\n            return False\n\n        if LpStatus[self.problem.status] == \"Optimal\":\n            print(\"Optimization successful! Optimal solution found.\")\n\n            self.selected_squad_history = {}\n            self.total_transfer_hits = 0\n            for w in range(num_gameweeks):\n                # The actual gameweek number (1-indexed)\n                gw_actual = current_gameweek_number_start + w\n\n                # Get selected players for the current gameweek\n                selected_squad_gw = self.player_data[\n                    [player_vars[i][w].varValue == 1 for i in self.player_data.index]\n                ].copy()\n\n                # Get starter and captain info for this gameweek\n                is_starter_series_gw = pd.Series(\n                    [\n                        starting_xi_vars[i][w].varValue == 1\n                        for i in self.player_data.index\n                    ],\n                    index=self.player_data.index,\n                )\n                is_captain_series_gw = pd.Series(\n                    [captain_var[i][w].varValue == 1 for i in self.player_data.index],\n                    index=self.player_data.index,\n                )\n\n                selected_squad_gw[\"is_starter\"] = is_starter_series_gw.loc[\n                    selected_squad_gw.index\n                ]\n                selected_squad_gw[\"is_captain\"] = is_captain_series_gw.loc[\n                    selected_squad_gw.index\n                ]\n\n                transfers_in_gw = 0\n                transfers_out_gw = 0\n                hits_gw = 0\n\n                # Store transfer details for gameweeks &gt; 0\n                if (\n                    w &gt; 0\n                ):  # Check for transfers only from GW1 onwards (index 1 in 0-indexed loop)\n                    transfer_in_flags = pd.Series(\n                        [\n                            transfer_in_vars[i][w].varValue == 1\n                            for i in self.player_data.index\n                        ],\n                        index=self.player_data.index,\n                    )\n                    transfer_out_flags = pd.Series(\n                        [\n                            transfer_out_vars[i][w].varValue == 1\n                            for i in self.player_data.index\n                        ],\n                        index=self.player_data.index,\n                    )\n\n                    selected_squad_gw[\"transfer_in\"] = transfer_in_flags.loc[\n                        selected_squad_gw.index\n                    ]\n                    selected_squad_gw[\"transfer_out\"] = transfer_out_flags.loc[\n                        selected_squad_gw.index\n                    ]\n\n                    transfers_in_gw = int(round(transfer_in_flags.sum()))\n                    transfers_out_gw = int(round(transfer_out_flags.sum()))\n                    hits_gw = int(round(transfer_hits[w].varValue))\n                    self.total_transfer_hits += hits_gw\n                else:\n                    selected_squad_gw[\"transfer_in\"] = False  # No transfers in for GW0\n                    selected_squad_gw[\"transfer_out\"] = (\n                        False  # No transfers out for GW0\n                    )\n\n                self.selected_squad_history[f\"GW{gw_actual}\"] = {\n                    \"squad\": selected_squad_gw,\n                    \"total_cost\": selected_squad_gw[\"cost\"].sum(),\n                    \"expected_points_from_xi\": sum(\n                        self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n                        * starting_xi_vars[i][w].varValue\n                        for i in self.player_data.index\n                    ),\n                    \"bench_boost_used\": bool(use_bench_boost[w].varValue),\n                    \"triple_captain_used\": bool(use_triple_captain[w].varValue),\n                    \"total_bench_boost_points\": value(\n                        lpSum(\n                            actual_bench_boost_points[i][w]\n                            for i in self.player_data.index\n                        )\n                    ),\n                    \"total_triple_captain_bonus\": value(\n                        lpSum(\n                            actual_triple_captain_bonus[i][w]\n                            for i in self.player_data.index\n                        )\n                    ),\n                    \"transfers_in_count\": transfers_in_gw,\n                    \"transfers_out_count\": transfers_out_gw,\n                    \"transfer_hits\": hits_gw,  # New\n                    \"free_transfers_available_next_gw\": (\n                        int(round(free_transfers_available[w].varValue))\n                        if w &lt; num_gameweeks - 1\n                        else 0\n                    ),  # Free transfers available *after* this GW's transfers are made\n                }\n\n            # Overall totals\n            self.total_cost = self.selected_squad_history[\n                f\"GW{current_gameweek_number_start + num_gameweeks - 1}\"\n            ][\n                \"total_cost\"\n            ]  # Cost of final squad\n            self.total_expected_points = value(\n                self.problem.objective\n            )  # Total objective value from solver\n            self.used_chips = {\n                f\"GW{current_gameweek_number_start + w}\": {\n                    \"bench_boost\": bool(use_bench_boost[w].varValue),\n                    \"triple_captain\": bool(use_triple_captain[w].varValue),\n                }\n                for w in range(num_gameweeks)\n            }\n\n            return True\n        else:\n            print(f\"No optimal solution found. Status: {LpStatus[self.problem.status]}\")\n            self.selected_squad_history = {}\n            self.total_cost = 0\n            self.total_expected_points = 0\n            self.used_chips = {}\n            self.total_transfer_hits = 0\n            return False\n\n    def get_selected_squad(self, gameweek: int = None) -&gt; pd.DataFrame | None:\n        \"\"\"\n        Returns the selected squad for a specific gameweek (1-indexed).\n        If no gameweek is specified, returns the squad for the last optimized gameweek.\n        \"\"\"\n        if not self.selected_squad_history:\n            return None\n\n        # Get the first GW key to determine the range of available GWs\n        first_gw_in_history = min(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n        last_gw_in_history = max(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n\n        if gameweek is None:\n            return self.selected_squad_history[f\"GW{last_gw_in_history}\"][\"squad\"]\n\n        if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n            print(\n                f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n            )\n            return None\n\n        return self.selected_squad_history.get(f\"GW{gameweek}\", {}).get(\"squad\")\n\n    def get_total_cost(self, gameweek: int = None) -&gt; float:\n        \"\"\"\n        Returns the total cost for a specific gameweek (1-indexed).\n        If no gameweek is specified, returns the cost of the squad in the last optimized gameweek.\n        \"\"\"\n        if not self.selected_squad_history:\n            return 0\n        first_gw_in_history = min(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n        last_gw_in_history = max(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n\n        if gameweek is None:\n            return self.selected_squad_history[f\"GW{last_gw_in_history}\"][\"total_cost\"]\n\n        if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n            print(\n                f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n            )\n            return 0  # Or raise an error\n\n        return self.selected_squad_history.get(f\"GW{gameweek}\", {}).get(\"total_cost\", 0)\n\n    def get_total_expected_points(self) -&gt; float:\n        \"\"\"\n        Returns the overall total expected points across all optimized gameweeks.\n        \"\"\"\n        return self.total_expected_points\n\n    def get_gameweek_summary(self, gameweek: int):\n        \"\"\"\n        Returns a dictionary summary for a specific gameweek.\n        \"\"\"\n        if not self.selected_squad_history:\n            return None\n        first_gw_in_history = min(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n        last_gw_in_history = max(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n\n        if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n            print(\n                f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n            )\n            return None\n\n        return self.selected_squad_history.get(f\"GW{gameweek}\")\n\n    def print_squad_summary(self, gameweek: int):\n        \"\"\"\n        Prints a formatted summary of the selected squad for a specific gameweek.\n        \"\"\"\n        if not self.selected_squad_history:\n            print(\"No squad has been selected yet. Run the 'solve' method first.\")\n            return\n\n        gw_data = self.get_gameweek_summary(gameweek)\n        if not gw_data:\n            return  # get_gameweek_summary already prints error message\n\n        selected_squad = gw_data[\"squad\"]\n        total_cost = gw_data[\"total_cost\"]\n        expected_points_from_xi = gw_data[\"expected_points_from_xi\"]\n        bench_boost_used = gw_data[\"bench_boost_used\"]\n        triple_captain_used = gw_data[\"triple_captain_used\"]\n        total_bench_boost_points = gw_data[\"total_bench_boost_points\"]\n        total_triple_captain_bonus = gw_data[\"total_triple_captain_bonus\"]\n        transfers_in_count = gw_data[\"transfers_in_count\"]  # New\n        transfers_out_count = gw_data[\"transfers_out_count\"]  # New\n        transfer_hits_taken = gw_data[\"transfer_hits\"]  # New\n        free_transfers_available_next_gw = gw_data[\n            \"free_transfers_available_next_gw\"\n        ]  # New\n\n        print(f\"\\n--- FPL Optimized Squad for Gameweek {gameweek} ---\")\n        print(f\"Squad Cost: \u00a3{total_cost:.1f}m\")\n        print(f\"Expected Points (Starting XI): {expected_points_from_xi:.2f}\")\n        print(\n            f\"Total Expected Points for GW{gameweek} (including chips): {expected_points_from_xi + total_bench_boost_points + total_triple_captain_bonus:.2f}\"\n        )\n        print(\"\\n--- Chips Used This Gameweek ---\")\n        if bench_boost_used:\n            print(f\"- Bench Boost (Added {total_bench_boost_points:.2f} points)\")\n        if triple_captain_used:\n            print(\n                f\"- Triple Captain (Added {total_triple_captain_bonus:.2f} bonus points)\"\n            )\n        if not (bench_boost_used or triple_captain_used):\n            print(\"No chips used this gameweek.\")\n\n        print(\"\\n--- Goalkeepers (Starting XI marked with *) ---\")\n        for index, row in selected_squad[selected_squad[\"position\"] == \"GK\"].iterrows():\n            starter_str = \"*\" if row[\"is_starter\"] else \"\"\n            captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n            transfer_status = \"\"\n            if row[\"transfer_in\"]:\n                transfer_status = \"(IN)\"\n            elif row[\"transfer_out\"]:\n                transfer_status = \"(OUT)\"\n\n            # Access gameweek-specific xP correctly\n            player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n            print(\n                f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n            )\n        print(\"\\n--- Defenders (Starting XI marked with *) ---\")\n        for index, row in selected_squad[\n            selected_squad[\"position\"] == \"DEF\"\n        ].iterrows():\n            starter_str = \"*\" if row[\"is_starter\"] else \"\"\n            captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n            transfer_status = \"\"\n            if row[\"transfer_in\"]:\n                transfer_status = \"(IN)\"\n            elif row[\"transfer_out\"]:\n                transfer_status = \"(OUT)\"\n\n            player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n            print(\n                f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n            )\n        print(\"\\n--- Midfielders (Starting XI marked with *) ---\")\n        for index, row in selected_squad[\n            selected_squad[\"position\"] == \"MID\"\n        ].iterrows():\n            starter_str = \"*\" if row[\"is_starter\"] else \"\"\n            captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n            transfer_status = \"\"\n            if row[\"transfer_in\"]:\n                transfer_status = \"(IN)\"\n            elif row[\"transfer_out\"]:\n                transfer_status = \"(OUT)\"\n\n            player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n            print(\n                f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n            )\n        print(\"\\n--- Forwards (Starting XI marked with *) ---\")\n        for index, row in selected_squad[\n            selected_squad[\"position\"] == \"FWD\"\n        ].iterrows():\n            starter_str = \"*\" if row[\"is_starter\"] else \"\"\n            captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n            transfer_status = \"\"\n            if row[\"transfer_in\"]:\n                transfer_status = \"(IN)\"\n            elif row[\"transfer_out\"]:\n                transfer_status = \"(OUT)\"\n\n            player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n            print(\n                f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n            )\n\n        print(f\"\\n--- Team Breakdown for GW{gameweek} ---\")\n        print(selected_squad[\"team\"].value_counts())\n\n        # Transfers are relevant from Gameweek 2 (index 1) onwards in the optimization horizon\n        # For display, if the current GW is the initial one (GW1 in the current context), no transfers are made\n        # If it's a subsequent GW, check if transfers occurred.\n        first_gw_in_history = min(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n        if (\n            gameweek &gt;= first_gw_in_history\n        ):  # Changed from &gt; to &gt;=, to show initial free transfers\n            # Display transfer info for this gameweek\n            print(\n                f\"  Transfers In: {transfers_in_count}, Transfers Out: {transfers_out_count}\"\n            )\n            print(\n                f\"  Transfer Hits: {transfer_hits_taken} (-{transfer_hits_taken * POINTS_PER_HIT} points)\"\n            )\n            # Only show free transfers for the *next* gameweek if it's not the last gameweek in the horizon\n            if gameweek &lt; max(\n                int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n            ):\n                print(\n                    f\"  Free Transfers Available for Next GW: {free_transfers_available_next_gw}\"\n                )\n        print(\"---------------------------\\n\")\n\n    def print_overall_summary(self):\n        \"\"\"\n        Prints an overall summary of the multi-week optimization results.\n        \"\"\"\n        if not self.selected_squad_history:\n            print(\"No optimization results to summarize.\")\n            return\n\n        print(\"\\n=== Overall Multi-Week FPL Optimization Summary ===\")\n        print(\n            f\"Total Expected Points Across All Gameweeks: {self.total_expected_points:.2f}\"\n        )\n\n        # Get the latest gameweek's cost\n        last_gw_key = max(\n            self.selected_squad_history.keys(), key=lambda k: int(k.replace(\"GW\", \"\"))\n        )\n        print(\n            f\"Squad Cost ({last_gw_key}): \u00a3{self.selected_squad_history[last_gw_key]['total_cost']:.1f}m\"\n        )\n        print(\n            f\"Total Transfer Hits Taken: {self.total_transfer_hits} (-{self.total_transfer_hits * POINTS_PER_HIT} points)\"\n        )\n\n        print(\"\\n--- Chip Usage Across Gameweeks ---\")\n        # Ensure consistent order by sorting gameweek keys\n        sorted_gw_keys = sorted(\n            self.used_chips.keys(), key=lambda k: int(k.replace(\"GW\", \"\"))\n        )\n        for gw_str in sorted_gw_keys:\n            chips = self.used_chips[gw_str]\n            chip_summary = []\n            if chips[\"bench_boost\"]:\n                chip_summary.append(\"Bench Boost\")\n            if chips[\"triple_captain\"]:\n                chip_summary.append(\"Triple Captain\")\n\n            if chip_summary:\n                print(f\"{gw_str}: {', '.join(chip_summary)}\")\n            else:\n                print(f\"{gw_str}: No chips used\")\n\n        print(\"\\n--- Gameweek-by-Gameweek Summary ---\")\n        # Iterate and print basic summary for each gameweek\n        for gw_str in sorted_gw_keys:\n            gw_data = self.selected_squad_history[gw_str]\n            print(f\"\\n--- {gw_str} ---\")\n            print(f\"  Squad Cost: \u00a3{gw_data['total_cost']:.1f}m\")\n            print(\n                f\"  Expected Points (Starting XI): {gw_data['expected_points_from_xi']:.2f}\"\n            )\n            print(\n                f\"  Total GW Points (incl. chips): {gw_data['expected_points_from_xi'] + gw_data['total_bench_boost_points'] + gw_data['total_triple_captain_bonus']:.2f}\"\n            )\n\n            # Display transfer info for this gameweek\n            transfers_in_count = gw_data[\"transfers_in_count\"]\n            transfers_out_count = gw_data[\"transfers_out_count\"]\n            transfer_hits_taken = gw_data[\"transfer_hits\"]\n            free_transfers_available_next_gw = gw_data[\n                \"free_transfers_available_next_gw\"\n            ]\n\n            print(\n                f\"  Transfers In: {transfers_in_count}, Transfers Out: {transfers_out_count}\"\n            )\n            print(\n                f\"  Transfer Hits: {transfer_hits_taken} (-{transfer_hits_taken * POINTS_PER_HIT} points)\"\n            )\n            # Only show free transfers for the *next* gameweek if it's not the last gameweek in the horizon\n            if int(gw_str.replace(\"GW\", \"\")) &lt; max(\n                int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n            ):\n                print(\n                    f\"  Free Transfers Available for Next GW: {free_transfers_available_next_gw}\"\n                )\n            print(\"-----------------------------------\")\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/fpl_solver/#build.lib.build.lib.fpl_solver.fpl_solver.FPLOptimizer.__init__","title":"<code>__init__(player_data)</code>","text":"<p>Initializes the FPLOptimizer with player data.</p> <p>Parameters:</p> Name Type Description Default <code>player_data</code> <code>DataFrame</code> <p>A DataFrame containing player information                         with columns: 'name', 'team', 'position',                         'cost', 'expected_points_by_gw' (a dict of xP per GW).</p> required Source code in <code>build/lib/build/lib/fpl_solver/fpl_solver.py</code> <pre><code>def __init__(self, player_data: pd.DataFrame):\n    \"\"\"\n    Initializes the FPLOptimizer with player data.\n\n    Args:\n        player_data (pd.DataFrame): A DataFrame containing player information\n                                    with columns: 'name', 'team', 'position',\n                                    'cost', 'expected_points_by_gw' (a dict of xP per GW).\n    \"\"\"\n    required_columns = [\"name\", \"team\", \"position\", \"cost\", \"expected_points_by_gw\"]\n    if not all(col in player_data.columns for col in required_columns):\n        missing_cols = [\n            col for col in required_columns if col not in player_data.columns\n        ]\n        raise ValueError(\n            f\"player_data DataFrame must contain {required_columns} columns. Missing: {missing_cols}\"\n        )\n\n    self.player_data = player_data\n    self.problem = None\n    self.selected_squad_history = {}  # To store squad for each gameweek\n    self.total_cost = 0\n    self.total_expected_points = 0\n    self.total_transfer_hits = 0\n\n    # --- Process Enforced Players ---\n    self.enforced_player_indices = set()\n    self.enforced_team_pos_requirements = []\n\n    print(\"\\n--- Processing Enforced Players ---\")\n\n    # Enforce by Player ID\n    for player_id in ENFORCED_PLAYERS_BY_ID:\n        found_player = self.player_data[self.player_data[\"id\"] == player_id]\n        if not found_player.empty:\n            player_idx = found_player.index[0]\n            self.enforced_player_indices.add(player_idx)\n            print(\n                f\"Enforcing player by ID: {found_player.loc[player_idx, 'name']} (ID: {player_id})\"\n            )\n        else:\n            print(\n                f\"Warning: Enforced player with ID {player_id} not found in data.\"\n            )\n\n    # Enforce by Player Name\n    for player_name in ENFORCED_PLAYERS_BY_NAME:\n        found_player = self.player_data[self.player_data[\"name\"] == player_name]\n        if not found_player.empty:\n            player_idx = found_player.index[0]\n            self.enforced_player_indices.add(player_idx)\n            print(f\"Enforcing player by name: {player_name}\")\n        else:\n            print(f\"Warning: Enforced player '{player_name}' not found in data.\")\n\n    # Enforce by Team and Position\n    for requirement in ENFORCED_PLAYERS_BY_TEAM_AND_POSITION:\n        team = requirement.get(\"team\")\n        position = requirement.get(\"position\")\n        if team and position:\n            # Validate team and position exist in data\n            if team not in self.player_data[\"team\"].unique():\n                print(\n                    f\"Warning: Enforced team '{team}' for position '{position}' not found in data.\"\n                )\n                continue\n            if position not in self.player_data[\"position\"].unique():\n                print(\n                    f\"Warning: Enforced position '{position}' for team '{team}' not found in data.\"\n                )\n                continue\n\n            self.enforced_team_pos_requirements.append((team, position))\n            print(f\"Enforcing at least one {position} from {team}.\")\n        else:\n            print(\n                f\"Warning: Invalid enforced team/position requirement: {requirement}\"\n            )\n\n    if not (\n        self.enforced_player_indices\n        or self.enforced_team_pos_requirements\n        or ENFORCED_PLAYERS_BY_ID\n        or ENFORCED_PLAYERS_BY_NAME\n        or ENFORCED_PLAYERS_BY_TEAM_AND_POSITION\n    ):\n        print(\"No players or team/position combinations are enforced.\")\n    print(\"-----------------------------------\\n\")\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/fpl_solver/#build.lib.build.lib.fpl_solver.fpl_solver.FPLOptimizer.get_gameweek_summary","title":"<code>get_gameweek_summary(gameweek)</code>","text":"<p>Returns a dictionary summary for a specific gameweek.</p> Source code in <code>build/lib/build/lib/fpl_solver/fpl_solver.py</code> <pre><code>def get_gameweek_summary(self, gameweek: int):\n    \"\"\"\n    Returns a dictionary summary for a specific gameweek.\n    \"\"\"\n    if not self.selected_squad_history:\n        return None\n    first_gw_in_history = min(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n    last_gw_in_history = max(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n\n    if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n        print(\n            f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n        )\n        return None\n\n    return self.selected_squad_history.get(f\"GW{gameweek}\")\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/fpl_solver/#build.lib.build.lib.fpl_solver.fpl_solver.FPLOptimizer.get_selected_squad","title":"<code>get_selected_squad(gameweek=None)</code>","text":"<p>Returns the selected squad for a specific gameweek (1-indexed). If no gameweek is specified, returns the squad for the last optimized gameweek.</p> Source code in <code>build/lib/build/lib/fpl_solver/fpl_solver.py</code> <pre><code>def get_selected_squad(self, gameweek: int = None) -&gt; pd.DataFrame | None:\n    \"\"\"\n    Returns the selected squad for a specific gameweek (1-indexed).\n    If no gameweek is specified, returns the squad for the last optimized gameweek.\n    \"\"\"\n    if not self.selected_squad_history:\n        return None\n\n    # Get the first GW key to determine the range of available GWs\n    first_gw_in_history = min(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n    last_gw_in_history = max(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n\n    if gameweek is None:\n        return self.selected_squad_history[f\"GW{last_gw_in_history}\"][\"squad\"]\n\n    if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n        print(\n            f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n        )\n        return None\n\n    return self.selected_squad_history.get(f\"GW{gameweek}\", {}).get(\"squad\")\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/fpl_solver/#build.lib.build.lib.fpl_solver.fpl_solver.FPLOptimizer.get_total_cost","title":"<code>get_total_cost(gameweek=None)</code>","text":"<p>Returns the total cost for a specific gameweek (1-indexed). If no gameweek is specified, returns the cost of the squad in the last optimized gameweek.</p> Source code in <code>build/lib/build/lib/fpl_solver/fpl_solver.py</code> <pre><code>def get_total_cost(self, gameweek: int = None) -&gt; float:\n    \"\"\"\n    Returns the total cost for a specific gameweek (1-indexed).\n    If no gameweek is specified, returns the cost of the squad in the last optimized gameweek.\n    \"\"\"\n    if not self.selected_squad_history:\n        return 0\n    first_gw_in_history = min(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n    last_gw_in_history = max(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n\n    if gameweek is None:\n        return self.selected_squad_history[f\"GW{last_gw_in_history}\"][\"total_cost\"]\n\n    if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n        print(\n            f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n        )\n        return 0  # Or raise an error\n\n    return self.selected_squad_history.get(f\"GW{gameweek}\", {}).get(\"total_cost\", 0)\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/fpl_solver/#build.lib.build.lib.fpl_solver.fpl_solver.FPLOptimizer.get_total_expected_points","title":"<code>get_total_expected_points()</code>","text":"<p>Returns the overall total expected points across all optimized gameweeks.</p> Source code in <code>build/lib/build/lib/fpl_solver/fpl_solver.py</code> <pre><code>def get_total_expected_points(self) -&gt; float:\n    \"\"\"\n    Returns the overall total expected points across all optimized gameweeks.\n    \"\"\"\n    return self.total_expected_points\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/fpl_solver/#build.lib.build.lib.fpl_solver.fpl_solver.FPLOptimizer.print_overall_summary","title":"<code>print_overall_summary()</code>","text":"<p>Prints an overall summary of the multi-week optimization results.</p> Source code in <code>build/lib/build/lib/fpl_solver/fpl_solver.py</code> <pre><code>def print_overall_summary(self):\n    \"\"\"\n    Prints an overall summary of the multi-week optimization results.\n    \"\"\"\n    if not self.selected_squad_history:\n        print(\"No optimization results to summarize.\")\n        return\n\n    print(\"\\n=== Overall Multi-Week FPL Optimization Summary ===\")\n    print(\n        f\"Total Expected Points Across All Gameweeks: {self.total_expected_points:.2f}\"\n    )\n\n    # Get the latest gameweek's cost\n    last_gw_key = max(\n        self.selected_squad_history.keys(), key=lambda k: int(k.replace(\"GW\", \"\"))\n    )\n    print(\n        f\"Squad Cost ({last_gw_key}): \u00a3{self.selected_squad_history[last_gw_key]['total_cost']:.1f}m\"\n    )\n    print(\n        f\"Total Transfer Hits Taken: {self.total_transfer_hits} (-{self.total_transfer_hits * POINTS_PER_HIT} points)\"\n    )\n\n    print(\"\\n--- Chip Usage Across Gameweeks ---\")\n    # Ensure consistent order by sorting gameweek keys\n    sorted_gw_keys = sorted(\n        self.used_chips.keys(), key=lambda k: int(k.replace(\"GW\", \"\"))\n    )\n    for gw_str in sorted_gw_keys:\n        chips = self.used_chips[gw_str]\n        chip_summary = []\n        if chips[\"bench_boost\"]:\n            chip_summary.append(\"Bench Boost\")\n        if chips[\"triple_captain\"]:\n            chip_summary.append(\"Triple Captain\")\n\n        if chip_summary:\n            print(f\"{gw_str}: {', '.join(chip_summary)}\")\n        else:\n            print(f\"{gw_str}: No chips used\")\n\n    print(\"\\n--- Gameweek-by-Gameweek Summary ---\")\n    # Iterate and print basic summary for each gameweek\n    for gw_str in sorted_gw_keys:\n        gw_data = self.selected_squad_history[gw_str]\n        print(f\"\\n--- {gw_str} ---\")\n        print(f\"  Squad Cost: \u00a3{gw_data['total_cost']:.1f}m\")\n        print(\n            f\"  Expected Points (Starting XI): {gw_data['expected_points_from_xi']:.2f}\"\n        )\n        print(\n            f\"  Total GW Points (incl. chips): {gw_data['expected_points_from_xi'] + gw_data['total_bench_boost_points'] + gw_data['total_triple_captain_bonus']:.2f}\"\n        )\n\n        # Display transfer info for this gameweek\n        transfers_in_count = gw_data[\"transfers_in_count\"]\n        transfers_out_count = gw_data[\"transfers_out_count\"]\n        transfer_hits_taken = gw_data[\"transfer_hits\"]\n        free_transfers_available_next_gw = gw_data[\n            \"free_transfers_available_next_gw\"\n        ]\n\n        print(\n            f\"  Transfers In: {transfers_in_count}, Transfers Out: {transfers_out_count}\"\n        )\n        print(\n            f\"  Transfer Hits: {transfer_hits_taken} (-{transfer_hits_taken * POINTS_PER_HIT} points)\"\n        )\n        # Only show free transfers for the *next* gameweek if it's not the last gameweek in the horizon\n        if int(gw_str.replace(\"GW\", \"\")) &lt; max(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        ):\n            print(\n                f\"  Free Transfers Available for Next GW: {free_transfers_available_next_gw}\"\n            )\n        print(\"-----------------------------------\")\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/fpl_solver/#build.lib.build.lib.fpl_solver.fpl_solver.FPLOptimizer.print_squad_summary","title":"<code>print_squad_summary(gameweek)</code>","text":"<p>Prints a formatted summary of the selected squad for a specific gameweek.</p> Source code in <code>build/lib/build/lib/fpl_solver/fpl_solver.py</code> <pre><code>def print_squad_summary(self, gameweek: int):\n    \"\"\"\n    Prints a formatted summary of the selected squad for a specific gameweek.\n    \"\"\"\n    if not self.selected_squad_history:\n        print(\"No squad has been selected yet. Run the 'solve' method first.\")\n        return\n\n    gw_data = self.get_gameweek_summary(gameweek)\n    if not gw_data:\n        return  # get_gameweek_summary already prints error message\n\n    selected_squad = gw_data[\"squad\"]\n    total_cost = gw_data[\"total_cost\"]\n    expected_points_from_xi = gw_data[\"expected_points_from_xi\"]\n    bench_boost_used = gw_data[\"bench_boost_used\"]\n    triple_captain_used = gw_data[\"triple_captain_used\"]\n    total_bench_boost_points = gw_data[\"total_bench_boost_points\"]\n    total_triple_captain_bonus = gw_data[\"total_triple_captain_bonus\"]\n    transfers_in_count = gw_data[\"transfers_in_count\"]  # New\n    transfers_out_count = gw_data[\"transfers_out_count\"]  # New\n    transfer_hits_taken = gw_data[\"transfer_hits\"]  # New\n    free_transfers_available_next_gw = gw_data[\n        \"free_transfers_available_next_gw\"\n    ]  # New\n\n    print(f\"\\n--- FPL Optimized Squad for Gameweek {gameweek} ---\")\n    print(f\"Squad Cost: \u00a3{total_cost:.1f}m\")\n    print(f\"Expected Points (Starting XI): {expected_points_from_xi:.2f}\")\n    print(\n        f\"Total Expected Points for GW{gameweek} (including chips): {expected_points_from_xi + total_bench_boost_points + total_triple_captain_bonus:.2f}\"\n    )\n    print(\"\\n--- Chips Used This Gameweek ---\")\n    if bench_boost_used:\n        print(f\"- Bench Boost (Added {total_bench_boost_points:.2f} points)\")\n    if triple_captain_used:\n        print(\n            f\"- Triple Captain (Added {total_triple_captain_bonus:.2f} bonus points)\"\n        )\n    if not (bench_boost_used or triple_captain_used):\n        print(\"No chips used this gameweek.\")\n\n    print(\"\\n--- Goalkeepers (Starting XI marked with *) ---\")\n    for index, row in selected_squad[selected_squad[\"position\"] == \"GK\"].iterrows():\n        starter_str = \"*\" if row[\"is_starter\"] else \"\"\n        captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n        transfer_status = \"\"\n        if row[\"transfer_in\"]:\n            transfer_status = \"(IN)\"\n        elif row[\"transfer_out\"]:\n            transfer_status = \"(OUT)\"\n\n        # Access gameweek-specific xP correctly\n        player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n        print(\n            f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n        )\n    print(\"\\n--- Defenders (Starting XI marked with *) ---\")\n    for index, row in selected_squad[\n        selected_squad[\"position\"] == \"DEF\"\n    ].iterrows():\n        starter_str = \"*\" if row[\"is_starter\"] else \"\"\n        captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n        transfer_status = \"\"\n        if row[\"transfer_in\"]:\n            transfer_status = \"(IN)\"\n        elif row[\"transfer_out\"]:\n            transfer_status = \"(OUT)\"\n\n        player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n        print(\n            f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n        )\n    print(\"\\n--- Midfielders (Starting XI marked with *) ---\")\n    for index, row in selected_squad[\n        selected_squad[\"position\"] == \"MID\"\n    ].iterrows():\n        starter_str = \"*\" if row[\"is_starter\"] else \"\"\n        captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n        transfer_status = \"\"\n        if row[\"transfer_in\"]:\n            transfer_status = \"(IN)\"\n        elif row[\"transfer_out\"]:\n            transfer_status = \"(OUT)\"\n\n        player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n        print(\n            f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n        )\n    print(\"\\n--- Forwards (Starting XI marked with *) ---\")\n    for index, row in selected_squad[\n        selected_squad[\"position\"] == \"FWD\"\n    ].iterrows():\n        starter_str = \"*\" if row[\"is_starter\"] else \"\"\n        captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n        transfer_status = \"\"\n        if row[\"transfer_in\"]:\n            transfer_status = \"(IN)\"\n        elif row[\"transfer_out\"]:\n            transfer_status = \"(OUT)\"\n\n        player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n        print(\n            f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n        )\n\n    print(f\"\\n--- Team Breakdown for GW{gameweek} ---\")\n    print(selected_squad[\"team\"].value_counts())\n\n    # Transfers are relevant from Gameweek 2 (index 1) onwards in the optimization horizon\n    # For display, if the current GW is the initial one (GW1 in the current context), no transfers are made\n    # If it's a subsequent GW, check if transfers occurred.\n    first_gw_in_history = min(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n    if (\n        gameweek &gt;= first_gw_in_history\n    ):  # Changed from &gt; to &gt;=, to show initial free transfers\n        # Display transfer info for this gameweek\n        print(\n            f\"  Transfers In: {transfers_in_count}, Transfers Out: {transfers_out_count}\"\n        )\n        print(\n            f\"  Transfer Hits: {transfer_hits_taken} (-{transfer_hits_taken * POINTS_PER_HIT} points)\"\n        )\n        # Only show free transfers for the *next* gameweek if it's not the last gameweek in the horizon\n        if gameweek &lt; max(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        ):\n            print(\n                f\"  Free Transfers Available for Next GW: {free_transfers_available_next_gw}\"\n            )\n    print(\"---------------------------\\n\")\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/fpl_solver/#build.lib.build.lib.fpl_solver.fpl_solver.FPLOptimizer.solve","title":"<code>solve(budget, max_players_per_team, chip_allowances, num_gameweeks)</code>","text":"<p>Solves the FPL optimization problem using PuLP.</p> <p>Parameters:</p> Name Type Description Default <code>budget</code> <code>float</code> <p>The maximum budget in millions of pounds.</p> required <code>max_players_per_team</code> <code>int</code> <p>The maximum number of players allowed from                         any single Premier League team.</p> required <code>chip_allowances</code> <code>dict</code> <p>A dictionary specifying the maximum usage for each chip.</p> required <code>num_gameweeks</code> <code>int</code> <p>The number of gameweeks to optimize over.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if a solution was found, False otherwise.</p> Source code in <code>build/lib/build/lib/fpl_solver/fpl_solver.py</code> <pre><code>def solve(\n    self,\n    budget: float,\n    max_players_per_team: int,\n    chip_allowances: dict,\n    num_gameweeks: int,\n) -&gt; bool:\n    \"\"\"\n    Solves the FPL optimization problem using PuLP.\n\n    Args:\n        budget (float): The maximum budget in millions of pounds.\n        max_players_per_team (int): The maximum number of players allowed from\n                                    any single Premier League team.\n        chip_allowances (dict): A dictionary specifying the maximum usage for each chip.\n        num_gameweeks (int): The number of gameweeks to optimize over.\n\n    Returns:\n        bool: True if a solution was found, False otherwise.\n    \"\"\"\n    self.problem = LpProblem(\"FPL Squad Multi-Week Optimization\", LpMaximize)\n\n    # Decision variables for player selection, indexed by player and gameweek\n    player_vars = LpVariable.dicts(\n        \"Player\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n    )\n    starting_xi_vars = LpVariable.dicts(\n        \"StartingXI\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n    )\n    captain_var = LpVariable.dicts(\n        \"Captain\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n    )\n\n    # Binary variables for chip usage, indexed by gameweek\n    use_bench_boost = LpVariable.dicts(\n        \"Use_Bench_Boost\", range(num_gameweeks), 0, 1, LpBinary\n    )\n    use_triple_captain = LpVariable.dicts(\n        \"Use_Triple_Captain\", range(num_gameweeks), 0, 1, LpBinary\n    )\n\n    # Transfer variables\n    transfer_in_vars = LpVariable.dicts(\n        \"Transfer_In\",\n        (self.player_data.index, range(1, num_gameweeks)),\n        0,\n        1,\n        LpBinary,\n    )\n    transfer_out_vars = LpVariable.dicts(\n        \"Transfer_Out\",\n        (self.player_data.index, range(1, num_gameweeks)),\n        0,\n        1,\n        LpBinary,\n    )\n\n    # Total transfers made in a gameweek (absolute count)\n    transfers_made = LpVariable.dicts(\n        \"Transfers_Made\", range(1, num_gameweeks), 0, None, LpInteger\n    )\n    # Free transfers available at the start of a gameweek\n    free_transfers_available = LpVariable.dicts(\n        \"Free_Transfers_Available\",\n        range(num_gameweeks),\n        0,\n        MAX_FREE_TRANSFERS_SAVED + 1,\n        LpInteger,\n    )\n    # Number of transfer hits taken in a gameweek\n    transfer_hits = LpVariable.dicts(\n        \"Transfer_Hits\", range(1, num_gameweeks), 0, None, LpInteger\n    )\n\n    # Auxiliary variables for linearizing chip effects\n    is_bench_player = LpVariable.dicts(\n        \"Is_Bench_Player\",\n        (self.player_data.index, range(num_gameweeks)),\n        0,\n        1,\n        LpBinary,\n    )\n    actual_bench_boost_points = LpVariable.dicts(\n        \"Actual_Bench_Boost_Points\",\n        (self.player_data.index, range(num_gameweeks)),\n        0,\n        None,\n        LpContinuous,\n    )\n    actual_triple_captain_bonus = LpVariable.dicts(\n        \"Actual_Triple_Captain_Bonus\",\n        (self.player_data.index, range(num_gameweeks)),\n        0,\n        None,\n        LpContinuous,\n    )\n\n    # --- Objective Function ---\n    total_objective_points = []\n\n    # Get the first gameweek number from the player data to correctly index expected_points_by_gw\n    first_gw_key = next(\n        iter(\n            self.player_data.loc[\n                self.player_data.index[0], \"expected_points_by_gw\"\n            ].keys()\n        )\n    )\n    current_gameweek_number_start = int(first_gw_key)\n\n    for w in range(num_gameweeks):\n        # The actual gameweek number (1-indexed)\n        gw_actual = current_gameweek_number_start + w\n\n        # Base expected points from the selected starting 11 for this gameweek\n        base_points_expression_gw = lpSum(\n            self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n            * starting_xi_vars[i][w]\n            for i in self.player_data.index\n        )\n        total_objective_points.append(base_points_expression_gw)\n\n        # Regular Captaincy points (additional 1x for captain)\n        captain_points_bonus_gw = lpSum(\n            self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n            * captain_var[i][w]\n            for i in self.player_data.index\n        )\n        total_objective_points.append(captain_points_bonus_gw)\n\n        # Define auxiliary variables and constraints for chips for each gameweek\n        for i in self.player_data.index:\n            # Use gameweek-specific player xP for chip calculations\n            player_xp = self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n\n            # Bench Boost auxiliary variables and constraints\n            self.problem += (\n                is_bench_player[i][w] &lt;= player_vars[i][w],\n                f\"IsBench_Squad_{i}_{w}\",\n            )\n            self.problem += (\n                is_bench_player[i][w] &lt;= 1 - starting_xi_vars[i][w],\n                f\"IsBench_NotStarter_{i}_{w}\",\n            )\n            self.problem += (\n                is_bench_player[i][w]\n                &gt;= player_vars[i][w] + (1 - starting_xi_vars[i][w]) - 1,\n                f\"IsBench_Logical_{i}_{w}\",\n            )\n\n            self.problem += (\n                actual_bench_boost_points[i][w]\n                &lt;= player_xp * is_bench_player[i][w],\n                f\"BenchBoost_Contr_1_{i}_{w}\",\n            )\n            self.problem += (\n                actual_bench_boost_points[i][w] &lt;= player_xp * use_bench_boost[w],\n                f\"BenchBoost_Contr_2_{i}_{w}\",\n            )\n            self.problem += (\n                actual_bench_boost_points[i][w]\n                &gt;= player_xp * (is_bench_player[i][w] + use_bench_boost[w] - 1),\n                f\"BenchBoost_Contr_3_{i}_{w}\",\n            )\n            self.problem += (\n                actual_bench_boost_points[i][w] &gt;= 0,\n                f\"BenchBoost_Contr_4_{i}_{w}\",\n            )\n\n            # Triple Captain auxiliary variables and constraints\n            # Changed player_xp * 2 to player_xp to reflect additional 1x bonus\n            self.problem += (\n                actual_triple_captain_bonus[i][w] &lt;= player_xp * captain_var[i][w],\n                f\"TripleCaptain_Contr_1_{i}_{w}\",\n            )\n            self.problem += (\n                actual_triple_captain_bonus[i][w]\n                &lt;= player_xp * use_triple_captain[w],\n                f\"TripleCaptain_Contr_2_{i}_{w}\",\n            )\n            self.problem += (\n                actual_triple_captain_bonus[i][w]\n                &gt;= player_xp * (captain_var[i][w] + use_triple_captain[w] - 1),\n                f\"TripleCaptain_Contr_3_{i}_{w}\",\n            )\n            self.problem += (\n                actual_triple_captain_bonus[i][w] &gt;= 0,\n                f\"TripleCaptain_Contr_4_{i}_{w}\",\n            )\n\n        # Add points from bench boost and triple captain bonus for this gameweek\n        total_bench_boost_points_gw = lpSum(\n            actual_bench_boost_points[i][w] for i in self.player_data.index\n        )\n        total_triple_captain_bonus_points_gw = lpSum(\n            actual_triple_captain_bonus[i][w] for i in self.player_data.index\n        )\n\n        total_objective_points.append(total_bench_boost_points_gw)\n        total_objective_points.append(total_triple_captain_bonus_points_gw)\n\n    # Subtract transfer hits from the total objective\n    total_objective_points.append(\n        -POINTS_PER_HIT * lpSum(transfer_hits[w] for w in range(1, num_gameweeks))\n    )\n\n    self.problem += (\n        lpSum(total_objective_points),\n        \"Total Expected Points Over Gameweeks\",\n    )\n\n    # --- Constraints ---\n\n    # Apply constraints for each gameweek\n    for w in range(num_gameweeks):\n        # 1. Select exactly 15 players for the squad\n        self.problem += (\n            lpSum(player_vars[i][w] for i in self.player_data.index) == 15,\n            f\"Total_Players_GW{w}\",\n        )\n\n        # 2. Squad position constraints (2 GKs, 5 DEFs, 5 MIDs, 3 FWDs)\n        gks = self.player_data[self.player_data[\"position\"] == \"GK\"].index\n        defs = self.player_data[self.player_data[\"position\"] == \"DEF\"].index\n        mids = self.player_data[self.player_data[\"position\"] == \"MID\"].index\n        fwds = self.player_data[self.player_data[\"position\"] == \"FWD\"].index\n\n        self.problem += (\n            lpSum(player_vars[i][w] for i in gks) == 2,\n            f\"Goalkeepers_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(player_vars[i][w] for i in defs) == 5,\n            f\"Defenders_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(player_vars[i][w] for i in mids) == 5,\n            f\"Midfielders_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(player_vars[i][w] for i in fwds) == 3,\n            f\"Forwards_Count_GW{w}\",\n        )\n\n        # 3. Budget constraint\n        # This applies to the cost of the squad for the current gameweek.\n        self.problem += (\n            lpSum(\n                self.player_data.loc[i, \"cost\"] * player_vars[i][w]\n                for i in self.player_data.index\n            )\n            &lt;= budget,\n            f\"Total_Budget_GW{w}\",\n        )\n\n        # 4. Maximum players per team constraint\n        for team in self.player_data[\"team\"].unique():\n            team_players = self.player_data[self.player_data[\"team\"] == team].index\n            self.problem += (\n                lpSum(player_vars[i][w] for i in team_players)\n                &lt;= max_players_per_team,\n                f\"Max_Players_from_{team}_GW{w}\",\n            )\n\n        # 5. Starting XI constraints\n        # 5.1 Select exactly 11 players for the starting XI\n        self.problem += (\n            lpSum(starting_xi_vars[i][w] for i in self.player_data.index) == 11,\n            f\"Total_Starting_XI_Players_GW{w}\",\n        )\n\n        # 5.2 A player can only be in the starting XI if they are in the squad\n        for i in self.player_data.index:\n            self.problem += (\n                starting_xi_vars[i][w] &lt;= player_vars[i][w],\n                f\"StartingXI_in_Squad_{i}_{w}\",\n            )\n\n        # 5.3 Starting XI position constraints (FPL allows flexible formations, so use minimums)\n        self.problem += (\n            lpSum(starting_xi_vars[i][w] for i in gks) == 1,\n            f\"Starting_Goalkeepers_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(starting_xi_vars[i][w] for i in defs) &gt;= 3,\n            f\"Min_Starting_Defenders_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(starting_xi_vars[i][w] for i in mids) &gt;= 2,\n            f\"Min_Starting_Midfielders_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(starting_xi_vars[i][w] for i in fwds) &gt;= 1,\n            f\"Min_Starting_Forwards_Count_GW{w}\",\n        )\n\n        # 6. Captain Constraints\n        # 6.1 Select exactly one captain from the starting XI\n        self.problem += (\n            lpSum(captain_var[i][w] for i in self.player_data.index) == 1,\n            f\"One_Captain_GW{w}\",\n        )\n\n        # 6.2 A player can only be captain if they are in the starting XI\n        for i in self.player_data.index:\n            self.problem += (\n                captain_var[i][w] &lt;= starting_xi_vars[i][w],\n                f\"Captain_in_StartingXI_{i}_{w}\",\n            )\n\n        # --- Enforced Player Constraints---\n        for player_idx in self.enforced_player_indices:\n            self.problem += (\n                player_vars[player_idx][w] == 1,\n                f\"Enforce_Player_{self.player_data.loc[player_idx, 'name']}_GW{w}\",\n            )\n\n        for team, position in self.enforced_team_pos_requirements:\n            # Filter players for the current team and position\n            team_pos_players = self.player_data[\n                (self.player_data[\"team\"] == team)\n                &amp; (self.player_data[\"position\"] == position)\n            ].index\n            if not team_pos_players.empty:\n                self.problem += (\n                    lpSum(player_vars[i][w] for i in team_pos_players) &gt;= 1,\n                    f\"Enforce_One_{position}_from_{team}_GW{w}\",\n                )\n            else:\n                print(\n                    f\"Warning: No players found for enforced requirement: at least one {position} from {team} for GW{gw_actual}.\"\n                )\n\n    # --- Chip Usage Constraints (TOTAL usage over all gameweeks) ---\n    # These constraints should be outside the per-gameweek loop to avoid duplicates.\n    self.problem += (\n        lpSum(use_bench_boost[j] for j in range(num_gameweeks))\n        &lt;= chip_allowances.get(\"bench_boost\", 0),\n        f\"Max_Bench_Boost_Usage_Total\",\n    )\n    self.problem += (\n        lpSum(use_triple_captain[j] for j in range(num_gameweeks))\n        &lt;= chip_allowances.get(\"triple_captain\", 0),\n        f\"Max_Triple_Captain_Usage_Total\",\n    )\n\n    # --- Inter-Gameweek Constraints (Transfers and Transfer Rules) ---\n    # Initialize free transfers for GW0 (first gameweek of optimization horizon)\n    # This assumes the optimization starts at GW0, and it has INITIAL_FREE_TRANSFERS.\n    # If the model starts at an arbitrary GW, this would need to be an input.\n    self.problem += (\n        free_transfers_available[0] == INITIAL_FREE_TRANSFERS,\n        f\"Initial_Free_Transfers_GW0\",\n    )\n\n    for w in range(1, num_gameweeks):\n        # Calculate total transfers made in this gameweek\n        self.problem += (\n            transfers_made[w]\n            == lpSum(transfer_in_vars[i][w] for i in self.player_data.index),\n            f\"Transfers_Made_GW{w}\",\n        )\n        # Total transfers in must equal total transfers out for each gameweek after the first\n        self.problem += (\n            lpSum(transfer_in_vars[i][w] for i in self.player_data.index)\n            == lpSum(transfer_out_vars[i][w] for i in self.player_data.index),\n            f\"Transfers_In_Equals_Out_GW{w}\",\n        )\n\n        # Calculate free transfers available for the current gameweek (w)\n        # Free transfers for GW_w = min(free transfers from GW_w-1 - transfers made in GW_w + 1, MAX_FREE_TRANSFERS_SAVED + 1)\n        # The + 1 in MAX_FREE_TRANSFERS_SAVED + 1 is because MAX_FREE_TRANSFERS_SAVED implies how many can be *saved*,\n        # so if you save 1, you have 1 (current) + 1 (saved) = 2.\n        self.problem += (\n            free_transfers_available[w]\n            &lt;= free_transfers_available[w - 1] - transfers_made[w] + 1,\n            f\"Free_Transfers_Calc_1_GW{w}\",\n        )\n        self.problem += (\n            free_transfers_available[w] &lt;= MAX_FREE_TRANSFERS_SAVED + 1,\n            f\"Free_Transfers_Calc_2_GW{w}\",\n        )\n        self.problem += (\n            free_transfers_available[w] &gt;= 0,  # Cannot have negative free transfers\n            f\"Free_Transfers_Non_Negative_GW{w}\",\n        )\n\n        # Calculate transfer hits\n        # transfer_hits[w] = max(0, transfers_made[w] - free_transfers_available_at_start_of_gw_w)\n        # This needs to be linearized. If transfers_made[w] &gt; free_transfers_available[w-1], then hit.\n        # free_transfers_available[w-1] represents transfers available *before* making transfers for GW_w\n        self.problem += (\n            transfer_hits[w] &gt;= transfers_made[w] - free_transfers_available[w - 1],\n            f\"Transfer_Hits_Calc_1_GW{w}\",\n        )\n        self.problem += (\n            transfer_hits[w] &gt;= 0,\n            f\"Transfer_Hits_Calc_2_GW{w}\",\n        )\n\n        for i in self.player_data.index:\n            # Squad continuity: player_vars[i][w] (in squad at start of GW w)\n            #                 = player_vars[i][w-1] (in squad at start of GW w-1)\n            #                 - transfer_out_vars[i][w] (transferred out for GW w)\n            #                 + transfer_in_vars[i][w] (transferred in for GW w)\n            self.problem += (\n                player_vars[i][w]\n                == player_vars[i][w - 1]\n                - transfer_out_vars[i][w]\n                + transfer_in_vars[i][w],\n                f\"Squad_Continuity_{i}_GW{w}\",\n            )\n            # A player cannot be transferred in and out in the same gameweek\n            self.problem += (\n                transfer_in_vars[i][w] + transfer_out_vars[i][w] &lt;= 1,\n                f\"No_Simultaneous_Transfer_{i}_{w}\",\n            )\n\n    try:\n        # The solver is called with the GLPK_CMD solver\n        self.problem.solve(PULP_CBC_CMD(msg=0))  # msg=0 suppresses verbose output\n    except Exception as e:\n        print(f\"Error solving the problem: {e}\")\n        return False\n\n    if LpStatus[self.problem.status] == \"Optimal\":\n        print(\"Optimization successful! Optimal solution found.\")\n\n        self.selected_squad_history = {}\n        self.total_transfer_hits = 0\n        for w in range(num_gameweeks):\n            # The actual gameweek number (1-indexed)\n            gw_actual = current_gameweek_number_start + w\n\n            # Get selected players for the current gameweek\n            selected_squad_gw = self.player_data[\n                [player_vars[i][w].varValue == 1 for i in self.player_data.index]\n            ].copy()\n\n            # Get starter and captain info for this gameweek\n            is_starter_series_gw = pd.Series(\n                [\n                    starting_xi_vars[i][w].varValue == 1\n                    for i in self.player_data.index\n                ],\n                index=self.player_data.index,\n            )\n            is_captain_series_gw = pd.Series(\n                [captain_var[i][w].varValue == 1 for i in self.player_data.index],\n                index=self.player_data.index,\n            )\n\n            selected_squad_gw[\"is_starter\"] = is_starter_series_gw.loc[\n                selected_squad_gw.index\n            ]\n            selected_squad_gw[\"is_captain\"] = is_captain_series_gw.loc[\n                selected_squad_gw.index\n            ]\n\n            transfers_in_gw = 0\n            transfers_out_gw = 0\n            hits_gw = 0\n\n            # Store transfer details for gameweeks &gt; 0\n            if (\n                w &gt; 0\n            ):  # Check for transfers only from GW1 onwards (index 1 in 0-indexed loop)\n                transfer_in_flags = pd.Series(\n                    [\n                        transfer_in_vars[i][w].varValue == 1\n                        for i in self.player_data.index\n                    ],\n                    index=self.player_data.index,\n                )\n                transfer_out_flags = pd.Series(\n                    [\n                        transfer_out_vars[i][w].varValue == 1\n                        for i in self.player_data.index\n                    ],\n                    index=self.player_data.index,\n                )\n\n                selected_squad_gw[\"transfer_in\"] = transfer_in_flags.loc[\n                    selected_squad_gw.index\n                ]\n                selected_squad_gw[\"transfer_out\"] = transfer_out_flags.loc[\n                    selected_squad_gw.index\n                ]\n\n                transfers_in_gw = int(round(transfer_in_flags.sum()))\n                transfers_out_gw = int(round(transfer_out_flags.sum()))\n                hits_gw = int(round(transfer_hits[w].varValue))\n                self.total_transfer_hits += hits_gw\n            else:\n                selected_squad_gw[\"transfer_in\"] = False  # No transfers in for GW0\n                selected_squad_gw[\"transfer_out\"] = (\n                    False  # No transfers out for GW0\n                )\n\n            self.selected_squad_history[f\"GW{gw_actual}\"] = {\n                \"squad\": selected_squad_gw,\n                \"total_cost\": selected_squad_gw[\"cost\"].sum(),\n                \"expected_points_from_xi\": sum(\n                    self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n                    * starting_xi_vars[i][w].varValue\n                    for i in self.player_data.index\n                ),\n                \"bench_boost_used\": bool(use_bench_boost[w].varValue),\n                \"triple_captain_used\": bool(use_triple_captain[w].varValue),\n                \"total_bench_boost_points\": value(\n                    lpSum(\n                        actual_bench_boost_points[i][w]\n                        for i in self.player_data.index\n                    )\n                ),\n                \"total_triple_captain_bonus\": value(\n                    lpSum(\n                        actual_triple_captain_bonus[i][w]\n                        for i in self.player_data.index\n                    )\n                ),\n                \"transfers_in_count\": transfers_in_gw,\n                \"transfers_out_count\": transfers_out_gw,\n                \"transfer_hits\": hits_gw,  # New\n                \"free_transfers_available_next_gw\": (\n                    int(round(free_transfers_available[w].varValue))\n                    if w &lt; num_gameweeks - 1\n                    else 0\n                ),  # Free transfers available *after* this GW's transfers are made\n            }\n\n        # Overall totals\n        self.total_cost = self.selected_squad_history[\n            f\"GW{current_gameweek_number_start + num_gameweeks - 1}\"\n        ][\n            \"total_cost\"\n        ]  # Cost of final squad\n        self.total_expected_points = value(\n            self.problem.objective\n        )  # Total objective value from solver\n        self.used_chips = {\n            f\"GW{current_gameweek_number_start + w}\": {\n                \"bench_boost\": bool(use_bench_boost[w].varValue),\n                \"triple_captain\": bool(use_triple_captain[w].varValue),\n            }\n            for w in range(num_gameweeks)\n        }\n\n        return True\n    else:\n        print(f\"No optimal solution found. Status: {LpStatus[self.problem.status]}\")\n        self.selected_squad_history = {}\n        self.total_cost = 0\n        self.total_expected_points = 0\n        self.used_chips = {}\n        self.total_transfer_hits = 0\n        return False\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/fpl_xp_predictor/","title":"fpl_xp_predictor","text":""},{"location":"autoapi/build/lib/build/lib/fpl_solver/fpl_xp_predictor/#build.lib.build.lib.fpl_solver.fpl_xp_predictor.FPLPredictor","title":"<code>FPLPredictor</code>","text":"<p>Predictive algorithm for Expected Points (xP) in Fantasy Premier League, using real data from the FPL API.</p> Source code in <code>build/lib/build/lib/fpl_solver/fpl_xp_predictor.py</code> <pre><code>class FPLPredictor:\n    \"\"\"\n    Predictive algorithm for Expected Points (xP) in Fantasy Premier League,\n    using real data from the FPL API.\n    \"\"\"\n\n    def __init__(self, gameweeks_to_predict: int = 1):\n        \"\"\"\n        Initializes the FPLPredictor with default FPL point rules and\n        data structures, then fetches real data and calculates xP for all players.\n\n        Args:\n            gameweeks_to_predict (int): The number of upcoming gameweeks to calculate\n                                        expected points for. Default is 1 (next gameweek).\n        \"\"\"\n        if not isinstance(gameweeks_to_predict, int) or gameweeks_to_predict &lt; 1:\n            raise ValueError(\"gameweeks_to_predict must be a positive integer.\")\n        self.gameweeks_to_predict = gameweeks_to_predict\n\n        self.fpl_points = FPL_POINTS\n\n        self.players_data = {}\n        self.teams_data = {}\n        self.fixtures_data = {}\n        self.position_definitions = {\n            1: \"GK\",\n            2: \"DEF\",\n            3: \"MID\",\n            4: \"FWD\",\n        }\n        self.all_players_xp_calculated_data = (\n            []\n        )  # To store xP for all players for the optimizer\n\n        self._fetch_fpl_data()\n        self._calculate_all_players_xp()  # Calculate xP for all players after data is loaded\n\n    def _fetch_fpl_data(self):\n        \"\"\"Fetches initial data from the FPL API.\"\"\"\n        print(\"Fetching FPL data...\")\n        try:\n            # Fetch general data\n            static_data = requests.get(\n                \"https://fantasy.premierleague.com/api/bootstrap-static/\"\n            ).json()\n            # Fetch fixtures data\n            fixtures_data = requests.get(\n                \"https://fantasy.premierleague.com/api/fixtures/\"\n            ).json()\n\n            # Process players data\n            for element in static_data[\"elements\"]:\n                player_id = element[\"id\"]\n                self.players_data[player_id] = {\n                    \"name\": element[\"first_name\"] + \" \" + element[\"second_name\"],\n                    \"web_name\": element[\"web_name\"],\n                    \"team_id\": element[\"team\"],\n                    \"element_type\": element[\"element_type\"],\n                    \"position\": self.position_definitions.get(\n                        element[\"element_type\"], \"Unknown\"\n                    ),\n                    \"cost_pence\": element[\"now_cost\"],\n                    \"status\": element[\"status\"],\n                    \"news\": element[\"news\"],\n                    \"total_points\": element[\"total_points\"],\n                    \"minutes\": element[\"minutes\"],\n                    \"goals_scored\": element[\"goals_scored\"],\n                    \"assists\": element[\"assists\"],\n                    \"clean_sheets\": element[\"clean_sheets\"],\n                    \"goals_conceded\": element[\"goals_conceded\"],\n                    \"penalties_saved\": element[\"penalties_saved\"],\n                    \"penalties_missed\": element[\"penalties_missed\"],\n                    \"yellow_cards\": element[\"yellow_cards\"],\n                    \"red_cards\": element[\"red_cards\"],\n                    \"own_goals\": element[\"own_goals\"],\n                    \"saves\": element[\"saves\"],\n                    \"bonus\": element[\"bonus\"],\n                    \"bps\": element[\"bps\"],\n                    \"threat\": element[\"threat\"],\n                    \"creativity\": element[\"creativity\"],\n                    \"influence\": element[\"influence\"],\n                    \"form\": float(element[\"form\"]),\n                    \"points_per_game\": float(element[\"points_per_game\"]),\n                    \"value_season\": float(element[\"value_season\"]),\n                    \"value_form\": float(element[\"value_form\"]),\n                    \"ict_index\": float(element[\"ict_index\"]),\n                }\n\n            # --- Apply Player Exclusions ---\n            initial_player_count = len(self.players_data)\n            players_to_keep = {}\n            for player_id, player_info in self.players_data.items():\n                # Exclude by ID\n                if player_id in EXCLUDED_PLAYERS_BY_ID:\n                    print(\n                        f\"Excluding player by ID: {player_info['name']} (ID: {player_id})\"\n                    )\n                    continue\n\n                # Exclude by Name\n                if player_info[\"name\"] in EXCLUDED_PLAYERS_BY_NAME:\n                    print(\n                        f\"Excluding player by Name: {player_info['name']} (ID: {player_id})\"\n                    )\n                    continue\n\n                # Exclude by Team and Position\n                excluded_by_team_pos = False\n                for exclusion_rule in EXCLUDED_PLAYERS_BY_TEAM_AND_POSITION:\n                    team_name = self.teams_data.get(player_info[\"team_id\"], {}).get(\n                        \"name\"\n                    )\n                    if team_name == exclusion_rule.get(\"team\") and player_info[\n                        \"position\"\n                    ] == exclusion_rule.get(\"position\"):\n                        print(\n                            f\"Excluding player by Team/Position: {player_info['name']} ({team_name}, {player_info['position']})\"\n                        )\n                        excluded_by_team_pos = True\n                        break\n                if excluded_by_team_pos:\n                    continue\n\n                players_to_keep[player_id] = player_info\n\n            self.players_data = players_to_keep\n            print(\n                f\"Filtered {initial_player_count - len(self.players_data)} players. Remaining: {len(self.players_data)}\"\n            )\n\n            # Process teams data\n            for team in static_data[\"teams\"]:\n                self.teams_data[team[\"id\"]] = {\n                    \"name\": team[\"name\"],\n                    \"short_name\": team[\"short_name\"],\n                    \"strength\": team[\"strength\"],\n                    \"strength_overall_home\": team[\"strength_overall_home\"],\n                    \"strength_overall_away\": team[\"strength_overall_away\"],\n                    \"strength_attack_home\": team[\"strength_attack_home\"],\n                    \"strength_attack_away\": team[\"strength_attack_away\"],\n                    \"strength_defence_home\": team[\"strength_defence_home\"],\n                    \"strength_defence_away\": team[\"strength_defence_away\"],\n                }\n\n            # Process fixtures data\n            for fixture in fixtures_data:\n                self.fixtures_data[fixture[\"id\"]] = fixture\n\n            print(\"FPL data fetched successfully.\")\n\n        except requests.exceptions.RequestException as e:\n            print(f\"Error fetching FPL data: {e}\")\n            self.players_data = {}\n            self.teams_data = {}\n            self.fixtures_data = {}\n            print(\"Initialization failed due to data fetching error. Exiting.\")\n            sys.exit(1)\n        except Exception as e:\n            print(f\"An unexpected error occurred during data fetching: {e}\")\n            self.players_data = {}\n            self.teams_data = {}\n            self.fixtures_data = {}\n            print(\"Initialization failed due to unexpected error. Exiting.\")\n            sys.exit(1)\n\n    def _get_team_strength(self, team_id, is_home):\n        \"\"\"Get team strength based on home/away status.\"\"\"\n        team = self.teams_data.get(team_id, {})\n        if is_home:\n            return team.get(\"strength_overall_home\", 1000)  # Default if not found\n        return team.get(\"strength_overall_away\", 1000)  # Default if not found\n\n    def _predict_minutes(self, player_id):\n        \"\"\"\n        Predicts expected minutes for a player based on historical data.\n        More sophisticated logic for handling very low minute players.\n        \"\"\"\n        player = self.players_data.get(player_id)\n        if not player:\n            return 0.0\n\n        status = player[\"status\"]\n        news = player[\"news\"].lower()\n        minutes_played = player[\"minutes\"]\n\n        # 1. Unavailable players (injured, suspended, doubtful)\n        if status != \"a\" or any(\n            x in news\n            for x in [\n                \"injured\",\n                \"doubtful\",\n                \"suspension\",\n                \"red card\",\n                \"expected back\",\n            ]\n        ):\n            return 0.0\n\n        # 2. Players with significant minutes (starters/key rotation)\n        if minutes_played &gt;= MIN_MINUTES_THRESHOLD:\n            # Average minutes per game started (assuming most minutes come from starts)\n            # This is a heuristic; real FPL API doesn't give starts directly.\n            # We assume a player with &gt; MIN_MINUTES_THRESHOLD plays ~80-90 minutes when on pitch.\n            # So, (minutes_played / number_of_appearances) is a rough proxy.\n            # For simplicity, let's use a cap of 90 minutes.\n            if player[\"total_points\"] &gt; 0:  # Player has played at least one game\n                avg_minutes_per_appearance = minutes_played / (\n                    player[\"total_points\"] / player[\"points_per_game\"]\n                )\n                return min(avg_minutes_per_appearance, 90.0)\n            return 70.0  # Reasonable default for established player with points but no clear avg\n\n        # 3. Players with very low minutes (rarely play, new, youth)\n        if minutes_played &lt; VERY_LOW_MINUTES_THRESHOLD:\n            # If news suggests they might get a chance, assign default sub minutes.\n            # Otherwise, very low expected minutes or zero.\n            if any(x in news for x in [\"return imminent\", \"close to return\"]):\n                return DEFAULT_SUB_MINUTES  # Might get some minutes\n            return DEFAULT_UNKNOWN_PLAYER_MINUTES  # Very unlikely to play significant minutes\n\n        # 4. Players with some minutes but below significant threshold (regular subs)\n        return DEFAULT_SUB_MINUTES\n\n    def _calculate_expected_goals(self, team_attack_strength, opp_defence_strength):\n        \"\"\"\n        Calculates expected goals for a team based on its attack strength and\n        opponent's defensive strength. This is a simplified heuristic.\n        \"\"\"\n        # A simple ratio model: Higher attack strength and lower opponent defense means more goals\n        # Normalization factor can be adjusted based on average league goals\n        expected_goals = (\n            team_attack_strength / opp_defence_strength\n        ) * 1.5  # 1.5 is an arbitrary scaling factor\n        return max(0.0, expected_goals)\n\n    def _calculate_expected_conceded_goals(\n        self, team_defence_strength, opp_attack_strength\n    ):\n        \"\"\"\n        Calculates expected goals conceded by a team based on its defense strength\n        and opponent's attacking strength.\n        \"\"\"\n        # A simple ratio model: Higher opponent attack and lower team defense means more conceded goals\n        expected_conceded_goals = (\n            opp_attack_strength / team_defence_strength\n        ) * 1.5  # 1.5 is an arbitrary scaling factor\n        return max(0.0, expected_conceded_goals)\n\n    def calculate_xp_for_player(self, player_id, fixture_id):\n        \"\"\"\n        Calculates Expected Points (xP) for a single player in a given fixture.\n        Considers various factors: minutes, goals, assists, clean sheets, saves,\n        bonus points, and negative events, adjusted for fixture difficulty.\n        \"\"\"\n        player = self.players_data.get(player_id)\n        fixture = self.fixtures_data.get(fixture_id)\n\n        if not player or not fixture:\n            return {\"xp\": 0.0, \"reason\": \"Player or fixture data missing.\"}\n\n        # Handle unavailable players\n        if (\n            player[\"status\"] != \"a\"\n        ):  # 'd' for doubtful, 'i' for injured, 's' for suspended\n            return {\"xp\": 0.0, \"reason\": f\"Player status: {player['status']}\"}\n        if any(\n            x in player[\"news\"].lower()\n            for x in [\"injured\", \"doubtful\", \"suspension\", \"red card\"]\n        ):\n            return {\"xp\": 0.0, \"reason\": f\"Player news: {player['news']}\"}\n\n        # Predict minutes\n        expected_minutes = self._predict_minutes(player_id)\n        if expected_minutes &lt; 1.0:  # If expected to play very little or none\n            return {\"xp\": 0.0, \"reason\": \"Expected minutes too low.\"}\n\n        xp = 0.0\n        position = player[\"position\"]\n        # Use 'team_h' for home team ID\n        is_home_fixture = player[\"team_id\"] == fixture[\"team_h\"]\n\n        # Determine attacking and defensive strengths for the fixture\n        player_team_strength_attack = (\n            self.teams_data.get(fixture[\"team_h\"], {}).get(\n                \"strength_attack_home\"\n            )  # Use 'team_h'\n            if is_home_fixture\n            else self.teams_data.get(fixture[\"team_a\"], {}).get(\n                \"strength_attack_away\"\n            )  # Use 'team_a'\n        )\n        player_team_strength_defence = (\n            self.teams_data.get(fixture[\"team_h\"], {}).get(\n                \"strength_defence_home\"\n            )  # Use 'team_h'\n            if is_home_fixture\n            else self.teams_data.get(fixture[\"team_a\"], {}).get(\n                \"strength_defence_away\"\n            )  # Use 'team_a'\n        )\n        opponent_team_strength_attack = (\n            self.teams_data.get(fixture[\"team_a\"], {}).get(\n                \"strength_attack_away\"\n            )  # Use 'team_a'\n            if is_home_fixture\n            else self.teams_data.get(fixture[\"team_h\"], {}).get(\n                \"strength_attack_home\"\n            )  # Use 'team_h'\n        )\n        opponent_team_strength_defence = (\n            self.teams_data.get(fixture[\"team_a\"], {}).get(\n                \"strength_defence_away\"\n            )  # Use 'team_a'\n            if is_home_fixture\n            else self.teams_data.get(fixture[\"team_h\"], {}).get(\n                \"strength_defence_home\"\n            )  # Use 'team_h'\n        )\n\n        if None in [\n            player_team_strength_attack,\n            player_team_strength_defence,\n            opponent_team_strength_attack,\n            opponent_team_strength_defence,\n        ]:\n            # Fallback if strength data is missing (shouldn't happen with robust data fetch)\n            return {\"xp\": 0.0, \"reason\": \"Team strength data missing for fixture.\"}\n\n        # 1. Appearance points\n        if expected_minutes &gt;= 60:\n            xp += self.fpl_points[\"appearance_points_gte_60\"]\n        elif expected_minutes &gt; 0:\n            xp += self.fpl_points[\"appearance_points_lt_60\"]\n\n        # 2. Expected Goals (scaled by historical goals per 90 and opponent difficulty)\n        # Use player's form and total goals as a basis\n        goals_per_90_hist = (\n            (player[\"goals_scored\"] / player[\"minutes\"] * 90)\n            if player[\"minutes\"] &gt; 0\n            else 0.0\n        )\n        expected_team_goals = self._calculate_expected_goals(\n            player_team_strength_attack, opponent_team_strength_defence\n        )\n\n        expected_goals_player_contribution = (\n            (goals_per_90_hist / 90.0) * expected_minutes * (expected_team_goals / 1.5)\n        )  # Scale player's goal contribution by team's expected goals\n\n        if position == \"GK\":\n            xp += expected_goals_player_contribution * self.fpl_points[\"goal_gk\"]\n        elif position == \"DEF\":\n            xp += expected_goals_player_contribution * self.fpl_points[\"goal_def\"]\n        elif position == \"MID\":\n            xp += expected_goals_player_contribution * self.fpl_points[\"goal_mid\"]\n        elif position == \"FWD\":\n            xp += expected_goals_player_contribution * self.fpl_points[\"goal_fwd\"]\n\n        # 3. Expected Assists (scaled by historical assists per 90 and opponent difficulty)\n        assists_per_90_hist = (\n            (player[\"assists\"] / player[\"minutes\"] * 90)\n            if player[\"minutes\"] &gt; 0\n            else 0.0\n        )\n        # Assuming team's attacking strength correlates with assist opportunities\n        expected_assists_player_contribution = (\n            (assists_per_90_hist / 90.0)\n            * expected_minutes\n            * (expected_team_goals / 1.5)\n        )  # Similarly scale by team's expected goals\n        xp += expected_assists_player_contribution * self.fpl_points[\"assist_points\"]\n\n        # 4. Expected Clean Sheets (for GKs/DEFs/MIDs) and Conceded Goals deduction\n        expected_conceded = self._calculate_expected_conceded_goals(\n            player_team_strength_defence, opponent_team_strength_attack\n        )\n\n        # Probability of clean sheet\n        # Simplified: higher team defense / lower opponent attack -&gt; higher CS prob\n        # Use logistic or sigmoid for probability\n        cs_prob = 1.0 / (\n            1.0 + math.exp(expected_conceded - 1.0)\n        )  # Sigmoid centered at 1 goal\n\n        if position in [\"GK\", \"DEF\"]:\n            xp += cs_prob * self.fpl_points[\"clean_sheet_gk_def\"]\n\n            # Conceded goals deduction: Apply penalty for every 2 goals conceded *probability*\n            # For simplicity, calculate expected deduction: (expected_conceded / 2) * deduction\n            xp += (expected_conceded / 2.0) * self.fpl_points[\n                \"conceded_2_goals_deduction\"\n            ]\n        elif position == \"MID\":\n            xp += cs_prob * self.fpl_points[\"clean_sheet_mid\"]\n\n        # 5. Expected Saves (for GKs)\n        if position == \"GK\":\n            saves_per_90_hist = (\n                (player[\"saves\"] / player[\"minutes\"] * 90)\n                if player[\"minutes\"] &gt; 0\n                else 0.0\n            )\n            # Expected saves scaled by opponent's attacking strength (more attacking -&gt; more shots -&gt; more saves)\n            expected_saves_player_contribution = (\n                (saves_per_90_hist / 90.0)\n                * expected_minutes\n                * (opponent_team_strength_attack / player_team_strength_defence)\n            )\n            xp += (expected_saves_player_contribution / 3.0) * self.fpl_points[\n                \"saves_3_points\"\n            ]  # Using the new config point value\n\n            # Penalty saves (low probability, use historical rate)\n            penalty_saves_hist_per_game = (\n                player[\"penalties_saved\"] / (player[\"minutes\"] / 90.0)\n                if player[\"minutes\"] &gt; 0\n                else 0.0\n            )\n            xp += (\n                penalty_saves_hist_per_game\n                * (expected_minutes / 90.0)\n                * self.fpl_points[\"penalty_save_points\"]\n            )\n\n        # 6. Expected Bonus Points\n        # Use BPS (Bonus Points System) as a proxy. Scale player's average BPS by form and expected minutes.\n        bps_per_90_hist = (\n            (player[\"bps\"] / player[\"minutes\"] * 90) if player[\"minutes\"] &gt; 0 else 0.0\n        )\n        expected_bps = (bps_per_90_hist / 90.0) * expected_minutes * player[\"form\"]\n        xp += expected_bps * self.fpl_points[\"bonus_points_scaling_factor\"]\n\n        # 7. Minor Negative Events (Probabilistic)\n        # These are rare, so a simple probability based on expected minutes.\n        xp += (expected_minutes / 90.0) * (\n            self.fpl_points[\"yellow_card_deduction\"] * YELLOW_CARD_PROB\n            + self.fpl_points[\"red_card_deduction\"] * RED_CARD_PROB\n            + self.fpl_points[\"own_goal_deduction\"] * OWN_GOAL_PROB\n            + self.fpl_points[\"penalty_miss_deduction\"] * PENALTY_MISS_PROB\n        )\n\n        # 8. Defensive Contribution Points (for 2025/26 season heuristic)\n        # Assuming CBIT/CBIRT tracking\n        if position in [\"GK\", \"DEF\"]:\n            xp += CBIT_DEF_PROB * self.fpl_points[\"cbit_def_points\"]\n        elif position in [\"MID\", \"FWD\"]:\n            xp += CBIRT_MID_FWD_PROB * self.fpl_points[\"cbirt_mid_fwd_points\"]\n\n        return {\"xp\": round(xp, 2), \"reason\": \"Success\"}\n\n    def _calculate_all_players_xp(self):\n        \"\"\"\n        Calculates the Expected Points (xP) for all players over multiple upcoming gameweeks\n        and populates self.all_players_xp_calculated_data with xP per gameweek.\n        \"\"\"\n        print(\n            f\"Calculating xP for all players over {self.gameweeks_to_predict} gameweek(s)...\"\n        )\n\n        # Get all upcoming fixtures and sort them by gameweek\n        all_upcoming_fixtures_items = sorted(\n            [\n                (fid, fdict)\n                for fid, fdict in self.fixtures_data.items()\n                if not fdict[\"finished\"]\n            ],\n            key=lambda item: item[1][\"event\"],\n        )\n\n        if not all_upcoming_fixtures_items:\n            print(\"No upcoming fixtures found. Cannot calculate xP.\")\n            return\n\n        # Determine the current gameweek (the gameweek of the earliest upcoming fixture)\n        current_gameweek = all_upcoming_fixtures_items[0][1][\"event\"]\n        target_gameweeks = range(\n            current_gameweek, current_gameweek + self.gameweeks_to_predict\n        )\n\n        # Create a mapping of team_id_code to a list of their fixtures within the target gameweeks\n        team_fixtures_in_range = {team_code: [] for team_code in self.teams_data.keys()}\n        for fixture_id, fixture_data in all_upcoming_fixtures_items:\n            if fixture_data[\"event\"] in target_gameweeks:\n                home_team_code = fixture_data[\"team_h\"]\n                away_team_code = fixture_data[\"team_a\"]\n\n                team_fixtures_in_range[home_team_code].append(fixture_id)\n                team_fixtures_in_range[away_team_code].append(fixture_id)\n\n        # Calculate total xP for each player across the specified gameweeks\n        for player_id, player_data in self.players_data.items():\n            player_team_code = player_data[\"team_id\"]\n            player_position = player_data[\"position\"]\n\n            # Calculate xP for each relevant fixture and store by gameweek\n            expected_points_by_gw = {}\n            for fixture_id in team_fixtures_in_range.get(player_team_code, []):\n                fixture_gameweek = self.fixtures_data[fixture_id][\"event\"]\n                xp_result_single_gw = self.calculate_xp_for_player(\n                    player_id, fixture_id\n                )\n                if xp_result_single_gw and xp_result_single_gw[\"xp\"] is not None:\n                    if fixture_gameweek not in expected_points_by_gw:\n                        expected_points_by_gw[fixture_gameweek] = 0.0\n                    expected_points_by_gw[fixture_gameweek] += xp_result_single_gw[\"xp\"]\n\n            # Ensure all target gameweeks are present, even if xP is 0 for a given GW\n            for gw in target_gameweeks:\n                if gw not in expected_points_by_gw:\n                    expected_points_by_gw[gw] = 0.0\n\n            # Sort the dictionary by gameweek for consistent output\n            expected_points_by_gw = dict(sorted(expected_points_by_gw.items()))\n\n            # Prepare data for the optimizer\n            player_cost_m = player_data[\"cost_pence\"] / 10.0\n            team_name_full = self.teams_data.get(player_team_code, {}).get(\n                \"name\", \"Unknown Team\"\n            )\n\n            self.all_players_xp_calculated_data.append(\n                {\n                    \"name\": player_data[\"name\"],\n                    \"web_name\": player_data[\"web_name\"],\n                    \"team\": team_name_full,\n                    \"position\": player_position,\n                    \"cost\": player_cost_m,\n                    \"expected_points_by_gw\": expected_points_by_gw,  # Changed key and format\n                }\n            )\n        print(\"xP calculation for all players complete.\")\n\n    def get_upcoming_fixtures(self, limit=None):\n        \"\"\"\n        Returns a list of upcoming fixtures, sorted by gameweek and kickoff time.\n        Optionally limits the number of fixtures returned.\n        \"\"\"\n        upcoming = []\n        now = datetime.now()\n\n        # Sort all fixtures by gameweek and then by kickoff time\n        sorted_fixtures = sorted(\n            self.fixtures_data.values(),\n            key=lambda x: (\n                x.get(\"event\", 0),\n                x.get(\"kickoff_time\", \"9999-12-31T00:00:00Z\"),\n            ),\n        )\n\n        current_gameweek = None\n        for fixture_data in sorted_fixtures:\n            # Determine current gameweek from the earliest upcoming fixture\n            if not fixture_data[\"finished\"] and current_gameweek is None:\n                current_gameweek = fixture_data.get(\"event\", 0)\n\n            # Filter for upcoming fixtures within the prediction horizon\n            if (\n                fixture_data.get(\"event\", 0) &lt; current_gameweek  # Skip past gameweeks\n                or fixture_data.get(\"event\", 0)\n                &gt;= current_gameweek + self.gameweeks_to_predict\n            ):\n                continue  # Skip fixtures outside the prediction horizon\n\n            home_team_name = self.teams_data.get(\n                fixture_data[\"team_h\"], {}\n            ).get(  # Use 'team_h'\n                \"name\", \"Unknown\"\n            )\n            away_team_name = self.teams_data.get(\n                fixture_data[\"team_a\"], {}\n            ).get(  # Use 'team_a'\n                \"name\", \"Unknown\"\n            )\n\n            # Only add fixtures that are not finished\n            if not fixture_data[\"finished\"]:\n                upcoming.append(\n                    {\n                        \"fixture_id\": fixture_data[\"id\"],\n                        \"gameweek\": fixture_data.get(\"event\"),\n                        \"home_team_id\": fixture_data[\"team_h\"],  # Use 'team_h'\n                        \"away_team_id\": fixture_data[\"team_a\"],  # Use 'team_a'\n                        \"match\": f\"{home_team_name} vs {away_team_name}\",\n                        \"kickoff_time\": fixture_data.get(\"kickoff_time\"),\n                        \"home_team_difficulty\": fixture_data[\"team_h_difficulty\"],\n                        \"away_team_difficulty\": fixture_data[\"team_a_difficulty\"],\n                    }\n                )\n            if limit is not None and len(upcoming) &gt;= limit:\n                break\n        return upcoming\n\n    def get_players_for_optimizer(self):\n        \"\"\"\n        Returns the list of player data with calculated xP per gameweek,\n        formatted for the FPLOptimizer.\n        \"\"\"\n        return self.all_players_xp_calculated_data\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/fpl_xp_predictor/#build.lib.build.lib.fpl_solver.fpl_xp_predictor.FPLPredictor.__init__","title":"<code>__init__(gameweeks_to_predict=1)</code>","text":"<p>Initializes the FPLPredictor with default FPL point rules and data structures, then fetches real data and calculates xP for all players.</p> <p>Parameters:</p> Name Type Description Default <code>gameweeks_to_predict</code> <code>int</code> <p>The number of upcoming gameweeks to calculate                         expected points for. Default is 1 (next gameweek).</p> <code>1</code> Source code in <code>build/lib/build/lib/fpl_solver/fpl_xp_predictor.py</code> <pre><code>def __init__(self, gameweeks_to_predict: int = 1):\n    \"\"\"\n    Initializes the FPLPredictor with default FPL point rules and\n    data structures, then fetches real data and calculates xP for all players.\n\n    Args:\n        gameweeks_to_predict (int): The number of upcoming gameweeks to calculate\n                                    expected points for. Default is 1 (next gameweek).\n    \"\"\"\n    if not isinstance(gameweeks_to_predict, int) or gameweeks_to_predict &lt; 1:\n        raise ValueError(\"gameweeks_to_predict must be a positive integer.\")\n    self.gameweeks_to_predict = gameweeks_to_predict\n\n    self.fpl_points = FPL_POINTS\n\n    self.players_data = {}\n    self.teams_data = {}\n    self.fixtures_data = {}\n    self.position_definitions = {\n        1: \"GK\",\n        2: \"DEF\",\n        3: \"MID\",\n        4: \"FWD\",\n    }\n    self.all_players_xp_calculated_data = (\n        []\n    )  # To store xP for all players for the optimizer\n\n    self._fetch_fpl_data()\n    self._calculate_all_players_xp()  # Calculate xP for all players after data is loaded\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/fpl_xp_predictor/#build.lib.build.lib.fpl_solver.fpl_xp_predictor.FPLPredictor.calculate_xp_for_player","title":"<code>calculate_xp_for_player(player_id, fixture_id)</code>","text":"<p>Calculates Expected Points (xP) for a single player in a given fixture. Considers various factors: minutes, goals, assists, clean sheets, saves, bonus points, and negative events, adjusted for fixture difficulty.</p> Source code in <code>build/lib/build/lib/fpl_solver/fpl_xp_predictor.py</code> <pre><code>def calculate_xp_for_player(self, player_id, fixture_id):\n    \"\"\"\n    Calculates Expected Points (xP) for a single player in a given fixture.\n    Considers various factors: minutes, goals, assists, clean sheets, saves,\n    bonus points, and negative events, adjusted for fixture difficulty.\n    \"\"\"\n    player = self.players_data.get(player_id)\n    fixture = self.fixtures_data.get(fixture_id)\n\n    if not player or not fixture:\n        return {\"xp\": 0.0, \"reason\": \"Player or fixture data missing.\"}\n\n    # Handle unavailable players\n    if (\n        player[\"status\"] != \"a\"\n    ):  # 'd' for doubtful, 'i' for injured, 's' for suspended\n        return {\"xp\": 0.0, \"reason\": f\"Player status: {player['status']}\"}\n    if any(\n        x in player[\"news\"].lower()\n        for x in [\"injured\", \"doubtful\", \"suspension\", \"red card\"]\n    ):\n        return {\"xp\": 0.0, \"reason\": f\"Player news: {player['news']}\"}\n\n    # Predict minutes\n    expected_minutes = self._predict_minutes(player_id)\n    if expected_minutes &lt; 1.0:  # If expected to play very little or none\n        return {\"xp\": 0.0, \"reason\": \"Expected minutes too low.\"}\n\n    xp = 0.0\n    position = player[\"position\"]\n    # Use 'team_h' for home team ID\n    is_home_fixture = player[\"team_id\"] == fixture[\"team_h\"]\n\n    # Determine attacking and defensive strengths for the fixture\n    player_team_strength_attack = (\n        self.teams_data.get(fixture[\"team_h\"], {}).get(\n            \"strength_attack_home\"\n        )  # Use 'team_h'\n        if is_home_fixture\n        else self.teams_data.get(fixture[\"team_a\"], {}).get(\n            \"strength_attack_away\"\n        )  # Use 'team_a'\n    )\n    player_team_strength_defence = (\n        self.teams_data.get(fixture[\"team_h\"], {}).get(\n            \"strength_defence_home\"\n        )  # Use 'team_h'\n        if is_home_fixture\n        else self.teams_data.get(fixture[\"team_a\"], {}).get(\n            \"strength_defence_away\"\n        )  # Use 'team_a'\n    )\n    opponent_team_strength_attack = (\n        self.teams_data.get(fixture[\"team_a\"], {}).get(\n            \"strength_attack_away\"\n        )  # Use 'team_a'\n        if is_home_fixture\n        else self.teams_data.get(fixture[\"team_h\"], {}).get(\n            \"strength_attack_home\"\n        )  # Use 'team_h'\n    )\n    opponent_team_strength_defence = (\n        self.teams_data.get(fixture[\"team_a\"], {}).get(\n            \"strength_defence_away\"\n        )  # Use 'team_a'\n        if is_home_fixture\n        else self.teams_data.get(fixture[\"team_h\"], {}).get(\n            \"strength_defence_home\"\n        )  # Use 'team_h'\n    )\n\n    if None in [\n        player_team_strength_attack,\n        player_team_strength_defence,\n        opponent_team_strength_attack,\n        opponent_team_strength_defence,\n    ]:\n        # Fallback if strength data is missing (shouldn't happen with robust data fetch)\n        return {\"xp\": 0.0, \"reason\": \"Team strength data missing for fixture.\"}\n\n    # 1. Appearance points\n    if expected_minutes &gt;= 60:\n        xp += self.fpl_points[\"appearance_points_gte_60\"]\n    elif expected_minutes &gt; 0:\n        xp += self.fpl_points[\"appearance_points_lt_60\"]\n\n    # 2. Expected Goals (scaled by historical goals per 90 and opponent difficulty)\n    # Use player's form and total goals as a basis\n    goals_per_90_hist = (\n        (player[\"goals_scored\"] / player[\"minutes\"] * 90)\n        if player[\"minutes\"] &gt; 0\n        else 0.0\n    )\n    expected_team_goals = self._calculate_expected_goals(\n        player_team_strength_attack, opponent_team_strength_defence\n    )\n\n    expected_goals_player_contribution = (\n        (goals_per_90_hist / 90.0) * expected_minutes * (expected_team_goals / 1.5)\n    )  # Scale player's goal contribution by team's expected goals\n\n    if position == \"GK\":\n        xp += expected_goals_player_contribution * self.fpl_points[\"goal_gk\"]\n    elif position == \"DEF\":\n        xp += expected_goals_player_contribution * self.fpl_points[\"goal_def\"]\n    elif position == \"MID\":\n        xp += expected_goals_player_contribution * self.fpl_points[\"goal_mid\"]\n    elif position == \"FWD\":\n        xp += expected_goals_player_contribution * self.fpl_points[\"goal_fwd\"]\n\n    # 3. Expected Assists (scaled by historical assists per 90 and opponent difficulty)\n    assists_per_90_hist = (\n        (player[\"assists\"] / player[\"minutes\"] * 90)\n        if player[\"minutes\"] &gt; 0\n        else 0.0\n    )\n    # Assuming team's attacking strength correlates with assist opportunities\n    expected_assists_player_contribution = (\n        (assists_per_90_hist / 90.0)\n        * expected_minutes\n        * (expected_team_goals / 1.5)\n    )  # Similarly scale by team's expected goals\n    xp += expected_assists_player_contribution * self.fpl_points[\"assist_points\"]\n\n    # 4. Expected Clean Sheets (for GKs/DEFs/MIDs) and Conceded Goals deduction\n    expected_conceded = self._calculate_expected_conceded_goals(\n        player_team_strength_defence, opponent_team_strength_attack\n    )\n\n    # Probability of clean sheet\n    # Simplified: higher team defense / lower opponent attack -&gt; higher CS prob\n    # Use logistic or sigmoid for probability\n    cs_prob = 1.0 / (\n        1.0 + math.exp(expected_conceded - 1.0)\n    )  # Sigmoid centered at 1 goal\n\n    if position in [\"GK\", \"DEF\"]:\n        xp += cs_prob * self.fpl_points[\"clean_sheet_gk_def\"]\n\n        # Conceded goals deduction: Apply penalty for every 2 goals conceded *probability*\n        # For simplicity, calculate expected deduction: (expected_conceded / 2) * deduction\n        xp += (expected_conceded / 2.0) * self.fpl_points[\n            \"conceded_2_goals_deduction\"\n        ]\n    elif position == \"MID\":\n        xp += cs_prob * self.fpl_points[\"clean_sheet_mid\"]\n\n    # 5. Expected Saves (for GKs)\n    if position == \"GK\":\n        saves_per_90_hist = (\n            (player[\"saves\"] / player[\"minutes\"] * 90)\n            if player[\"minutes\"] &gt; 0\n            else 0.0\n        )\n        # Expected saves scaled by opponent's attacking strength (more attacking -&gt; more shots -&gt; more saves)\n        expected_saves_player_contribution = (\n            (saves_per_90_hist / 90.0)\n            * expected_minutes\n            * (opponent_team_strength_attack / player_team_strength_defence)\n        )\n        xp += (expected_saves_player_contribution / 3.0) * self.fpl_points[\n            \"saves_3_points\"\n        ]  # Using the new config point value\n\n        # Penalty saves (low probability, use historical rate)\n        penalty_saves_hist_per_game = (\n            player[\"penalties_saved\"] / (player[\"minutes\"] / 90.0)\n            if player[\"minutes\"] &gt; 0\n            else 0.0\n        )\n        xp += (\n            penalty_saves_hist_per_game\n            * (expected_minutes / 90.0)\n            * self.fpl_points[\"penalty_save_points\"]\n        )\n\n    # 6. Expected Bonus Points\n    # Use BPS (Bonus Points System) as a proxy. Scale player's average BPS by form and expected minutes.\n    bps_per_90_hist = (\n        (player[\"bps\"] / player[\"minutes\"] * 90) if player[\"minutes\"] &gt; 0 else 0.0\n    )\n    expected_bps = (bps_per_90_hist / 90.0) * expected_minutes * player[\"form\"]\n    xp += expected_bps * self.fpl_points[\"bonus_points_scaling_factor\"]\n\n    # 7. Minor Negative Events (Probabilistic)\n    # These are rare, so a simple probability based on expected minutes.\n    xp += (expected_minutes / 90.0) * (\n        self.fpl_points[\"yellow_card_deduction\"] * YELLOW_CARD_PROB\n        + self.fpl_points[\"red_card_deduction\"] * RED_CARD_PROB\n        + self.fpl_points[\"own_goal_deduction\"] * OWN_GOAL_PROB\n        + self.fpl_points[\"penalty_miss_deduction\"] * PENALTY_MISS_PROB\n    )\n\n    # 8. Defensive Contribution Points (for 2025/26 season heuristic)\n    # Assuming CBIT/CBIRT tracking\n    if position in [\"GK\", \"DEF\"]:\n        xp += CBIT_DEF_PROB * self.fpl_points[\"cbit_def_points\"]\n    elif position in [\"MID\", \"FWD\"]:\n        xp += CBIRT_MID_FWD_PROB * self.fpl_points[\"cbirt_mid_fwd_points\"]\n\n    return {\"xp\": round(xp, 2), \"reason\": \"Success\"}\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/fpl_xp_predictor/#build.lib.build.lib.fpl_solver.fpl_xp_predictor.FPLPredictor.get_players_for_optimizer","title":"<code>get_players_for_optimizer()</code>","text":"<p>Returns the list of player data with calculated xP per gameweek, formatted for the FPLOptimizer.</p> Source code in <code>build/lib/build/lib/fpl_solver/fpl_xp_predictor.py</code> <pre><code>def get_players_for_optimizer(self):\n    \"\"\"\n    Returns the list of player data with calculated xP per gameweek,\n    formatted for the FPLOptimizer.\n    \"\"\"\n    return self.all_players_xp_calculated_data\n</code></pre>"},{"location":"autoapi/build/lib/build/lib/fpl_solver/fpl_xp_predictor/#build.lib.build.lib.fpl_solver.fpl_xp_predictor.FPLPredictor.get_upcoming_fixtures","title":"<code>get_upcoming_fixtures(limit=None)</code>","text":"<p>Returns a list of upcoming fixtures, sorted by gameweek and kickoff time. Optionally limits the number of fixtures returned.</p> Source code in <code>build/lib/build/lib/fpl_solver/fpl_xp_predictor.py</code> <pre><code>def get_upcoming_fixtures(self, limit=None):\n    \"\"\"\n    Returns a list of upcoming fixtures, sorted by gameweek and kickoff time.\n    Optionally limits the number of fixtures returned.\n    \"\"\"\n    upcoming = []\n    now = datetime.now()\n\n    # Sort all fixtures by gameweek and then by kickoff time\n    sorted_fixtures = sorted(\n        self.fixtures_data.values(),\n        key=lambda x: (\n            x.get(\"event\", 0),\n            x.get(\"kickoff_time\", \"9999-12-31T00:00:00Z\"),\n        ),\n    )\n\n    current_gameweek = None\n    for fixture_data in sorted_fixtures:\n        # Determine current gameweek from the earliest upcoming fixture\n        if not fixture_data[\"finished\"] and current_gameweek is None:\n            current_gameweek = fixture_data.get(\"event\", 0)\n\n        # Filter for upcoming fixtures within the prediction horizon\n        if (\n            fixture_data.get(\"event\", 0) &lt; current_gameweek  # Skip past gameweeks\n            or fixture_data.get(\"event\", 0)\n            &gt;= current_gameweek + self.gameweeks_to_predict\n        ):\n            continue  # Skip fixtures outside the prediction horizon\n\n        home_team_name = self.teams_data.get(\n            fixture_data[\"team_h\"], {}\n        ).get(  # Use 'team_h'\n            \"name\", \"Unknown\"\n        )\n        away_team_name = self.teams_data.get(\n            fixture_data[\"team_a\"], {}\n        ).get(  # Use 'team_a'\n            \"name\", \"Unknown\"\n        )\n\n        # Only add fixtures that are not finished\n        if not fixture_data[\"finished\"]:\n            upcoming.append(\n                {\n                    \"fixture_id\": fixture_data[\"id\"],\n                    \"gameweek\": fixture_data.get(\"event\"),\n                    \"home_team_id\": fixture_data[\"team_h\"],  # Use 'team_h'\n                    \"away_team_id\": fixture_data[\"team_a\"],  # Use 'team_a'\n                    \"match\": f\"{home_team_name} vs {away_team_name}\",\n                    \"kickoff_time\": fixture_data.get(\"kickoff_time\"),\n                    \"home_team_difficulty\": fixture_data[\"team_h_difficulty\"],\n                    \"away_team_difficulty\": fixture_data[\"team_a_difficulty\"],\n                }\n            )\n        if limit is not None and len(upcoming) &gt;= limit:\n            break\n    return upcoming\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/","title":"fpl_solver","text":""},{"location":"autoapi/build/lib/fpl_solver/#build.lib.fpl_solver.fpl_config","title":"<code>fpl_config</code>","text":"<p>fpl_config.py</p> <p>Configuration settings for the FPL Expected Points Predictor and Solver. This file centralizes all constants related to FPL scoring, thresholds, and optimization parameters.</p>"},{"location":"autoapi/build/lib/fpl_solver/#build.lib.fpl_solver.fpl_solver","title":"<code>fpl_solver</code>","text":""},{"location":"autoapi/build/lib/fpl_solver/#build.lib.fpl_solver.fpl_solver.FPLOptimizer","title":"<code>FPLOptimizer</code>","text":"<p>A class to optimize Fantasy Premier League (FPL) squad selection using Integer Linear Programming (ILP).</p> <p>The optimizer aims to select a 15-player squad (2 GKs, 5 DEFs, 5 MIDs, 3 FWDs) within a budget, with a maximum number of players from any single team, to maximize the total expected points.</p> Source code in <code>build/lib/fpl_solver/fpl_solver.py</code> <pre><code>class FPLOptimizer:\n    \"\"\"\n    A class to optimize Fantasy Premier League (FPL) squad selection\n    using Integer Linear Programming (ILP).\n\n    The optimizer aims to select a 15-player squad (2 GKs, 5 DEFs, 5 MIDs, 3 FWDs)\n    within a budget, with a maximum number of players from any single team,\n    to maximize the total expected points.\n    \"\"\"\n\n    def __init__(self, player_data: pd.DataFrame):\n        \"\"\"\n        Initializes the FPLOptimizer with player data.\n\n        Args:\n            player_data (pd.DataFrame): A DataFrame containing player information\n                                        with columns: 'name', 'team', 'position',\n                                        'cost', 'expected_points_by_gw' (a dict of xP per GW).\n        \"\"\"\n        required_columns = [\"name\", \"team\", \"position\", \"cost\", \"expected_points_by_gw\"]\n        if not all(col in player_data.columns for col in required_columns):\n            missing_cols = [\n                col for col in required_columns if col not in player_data.columns\n            ]\n            raise ValueError(\n                f\"player_data DataFrame must contain {required_columns} columns. Missing: {missing_cols}\"\n            )\n\n        self.player_data = player_data\n        self.problem = None\n        self.selected_squad_history = {}  # To store squad for each gameweek\n        self.total_cost = 0\n        self.total_expected_points = 0\n        self.total_transfer_hits = 0\n\n        # --- Process Enforced Players ---\n        self.enforced_player_indices = set()\n        self.enforced_team_pos_requirements = []\n\n        print(\"\\n--- Processing Enforced Players ---\")\n\n        # Enforce by Player ID\n        for player_id in ENFORCED_PLAYERS_BY_ID:\n            found_player = self.player_data[self.player_data[\"id\"] == player_id]\n            if not found_player.empty:\n                player_idx = found_player.index[0]\n                self.enforced_player_indices.add(player_idx)\n                print(\n                    f\"Enforcing player by ID: {found_player.loc[player_idx, 'name']} (ID: {player_id})\"\n                )\n            else:\n                print(\n                    f\"Warning: Enforced player with ID {player_id} not found in data.\"\n                )\n\n        # Enforce by Player Name\n        for player_name in ENFORCED_PLAYERS_BY_NAME:\n            found_player = self.player_data[self.player_data[\"name\"] == player_name]\n            if not found_player.empty:\n                player_idx = found_player.index[0]\n                self.enforced_player_indices.add(player_idx)\n                print(f\"Enforcing player by name: {player_name}\")\n            else:\n                print(f\"Warning: Enforced player '{player_name}' not found in data.\")\n\n        # Enforce by Team and Position\n        for requirement in ENFORCED_PLAYERS_BY_TEAM_AND_POSITION:\n            team = requirement.get(\"team\")\n            position = requirement.get(\"position\")\n            if team and position:\n                # Validate team and position exist in data\n                if team not in self.player_data[\"team\"].unique():\n                    print(\n                        f\"Warning: Enforced team '{team}' for position '{position}' not found in data.\"\n                    )\n                    continue\n                if position not in self.player_data[\"position\"].unique():\n                    print(\n                        f\"Warning: Enforced position '{position}' for team '{team}' not found in data.\"\n                    )\n                    continue\n\n                self.enforced_team_pos_requirements.append((team, position))\n                print(f\"Enforcing at least one {position} from {team}.\")\n            else:\n                print(\n                    f\"Warning: Invalid enforced team/position requirement: {requirement}\"\n                )\n\n        if not (\n            self.enforced_player_indices\n            or self.enforced_team_pos_requirements\n            or ENFORCED_PLAYERS_BY_ID\n            or ENFORCED_PLAYERS_BY_NAME\n            or ENFORCED_PLAYERS_BY_TEAM_AND_POSITION\n        ):\n            print(\"No players or team/position combinations are enforced.\")\n        print(\"-----------------------------------\\n\")\n\n    def solve(\n        self,\n        budget: float,\n        max_players_per_team: int,\n        chip_allowances: dict,\n        num_gameweeks: int,\n    ) -&gt; bool:\n        \"\"\"\n        Solves the FPL optimization problem using PuLP.\n\n        Args:\n            budget (float): The maximum budget in millions of pounds.\n            max_players_per_team (int): The maximum number of players allowed from\n                                        any single Premier League team.\n            chip_allowances (dict): A dictionary specifying the maximum usage for each chip.\n            num_gameweeks (int): The number of gameweeks to optimize over.\n\n        Returns:\n            bool: True if a solution was found, False otherwise.\n        \"\"\"\n        self.problem = LpProblem(\"FPL Squad Multi-Week Optimization\", LpMaximize)\n\n        # Decision variables for player selection, indexed by player and gameweek\n        player_vars = LpVariable.dicts(\n            \"Player\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n        )\n        starting_xi_vars = LpVariable.dicts(\n            \"StartingXI\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n        )\n        captain_var = LpVariable.dicts(\n            \"Captain\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n        )\n\n        # Binary variables for chip usage, indexed by gameweek\n        use_bench_boost = LpVariable.dicts(\n            \"Use_Bench_Boost\", range(num_gameweeks), 0, 1, LpBinary\n        )\n        use_triple_captain = LpVariable.dicts(\n            \"Use_Triple_Captain\", range(num_gameweeks), 0, 1, LpBinary\n        )\n\n        # Transfer variables\n        transfer_in_vars = LpVariable.dicts(\n            \"Transfer_In\",\n            (self.player_data.index, range(1, num_gameweeks)),\n            0,\n            1,\n            LpBinary,\n        )\n        transfer_out_vars = LpVariable.dicts(\n            \"Transfer_Out\",\n            (self.player_data.index, range(1, num_gameweeks)),\n            0,\n            1,\n            LpBinary,\n        )\n\n        # Total transfers made in a gameweek (absolute count)\n        transfers_made = LpVariable.dicts(\n            \"Transfers_Made\", range(1, num_gameweeks), 0, None, LpInteger\n        )\n        # Free transfers available at the start of a gameweek\n        free_transfers_available = LpVariable.dicts(\n            \"Free_Transfers_Available\",\n            range(num_gameweeks),\n            0,\n            MAX_FREE_TRANSFERS_SAVED + 1,\n            LpInteger,\n        )\n        # Number of transfer hits taken in a gameweek\n        transfer_hits = LpVariable.dicts(\n            \"Transfer_Hits\", range(1, num_gameweeks), 0, None, LpInteger\n        )\n\n        # Auxiliary variables for linearizing chip effects\n        is_bench_player = LpVariable.dicts(\n            \"Is_Bench_Player\",\n            (self.player_data.index, range(num_gameweeks)),\n            0,\n            1,\n            LpBinary,\n        )\n        actual_bench_boost_points = LpVariable.dicts(\n            \"Actual_Bench_Boost_Points\",\n            (self.player_data.index, range(num_gameweeks)),\n            0,\n            None,\n            LpContinuous,\n        )\n        actual_triple_captain_bonus = LpVariable.dicts(\n            \"Actual_Triple_Captain_Bonus\",\n            (self.player_data.index, range(num_gameweeks)),\n            0,\n            None,\n            LpContinuous,\n        )\n\n        # --- Objective Function ---\n        total_objective_points = []\n\n        # Get the first gameweek number from the player data to correctly index expected_points_by_gw\n        first_gw_key = next(\n            iter(\n                self.player_data.loc[\n                    self.player_data.index[0], \"expected_points_by_gw\"\n                ].keys()\n            )\n        )\n        current_gameweek_number_start = int(first_gw_key)\n\n        for w in range(num_gameweeks):\n            # The actual gameweek number (1-indexed)\n            gw_actual = current_gameweek_number_start + w\n\n            # Base expected points from the selected starting 11 for this gameweek\n            base_points_expression_gw = lpSum(\n                self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n                * starting_xi_vars[i][w]\n                for i in self.player_data.index\n            )\n            total_objective_points.append(base_points_expression_gw)\n\n            # Regular Captaincy points (additional 1x for captain)\n            captain_points_bonus_gw = lpSum(\n                self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n                * captain_var[i][w]\n                for i in self.player_data.index\n            )\n            total_objective_points.append(captain_points_bonus_gw)\n\n            # Define auxiliary variables and constraints for chips for each gameweek\n            for i in self.player_data.index:\n                # Use gameweek-specific player xP for chip calculations\n                player_xp = self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n\n                # Bench Boost auxiliary variables and constraints\n                self.problem += (\n                    is_bench_player[i][w] &lt;= player_vars[i][w],\n                    f\"IsBench_Squad_{i}_{w}\",\n                )\n                self.problem += (\n                    is_bench_player[i][w] &lt;= 1 - starting_xi_vars[i][w],\n                    f\"IsBench_NotStarter_{i}_{w}\",\n                )\n                self.problem += (\n                    is_bench_player[i][w]\n                    &gt;= player_vars[i][w] + (1 - starting_xi_vars[i][w]) - 1,\n                    f\"IsBench_Logical_{i}_{w}\",\n                )\n\n                self.problem += (\n                    actual_bench_boost_points[i][w]\n                    &lt;= player_xp * is_bench_player[i][w],\n                    f\"BenchBoost_Contr_1_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_bench_boost_points[i][w] &lt;= player_xp * use_bench_boost[w],\n                    f\"BenchBoost_Contr_2_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_bench_boost_points[i][w]\n                    &gt;= player_xp * (is_bench_player[i][w] + use_bench_boost[w] - 1),\n                    f\"BenchBoost_Contr_3_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_bench_boost_points[i][w] &gt;= 0,\n                    f\"BenchBoost_Contr_4_{i}_{w}\",\n                )\n\n                # Triple Captain auxiliary variables and constraints\n                # Changed player_xp * 2 to player_xp to reflect additional 1x bonus\n                self.problem += (\n                    actual_triple_captain_bonus[i][w] &lt;= player_xp * captain_var[i][w],\n                    f\"TripleCaptain_Contr_1_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_triple_captain_bonus[i][w]\n                    &lt;= player_xp * use_triple_captain[w],\n                    f\"TripleCaptain_Contr_2_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_triple_captain_bonus[i][w]\n                    &gt;= player_xp * (captain_var[i][w] + use_triple_captain[w] - 1),\n                    f\"TripleCaptain_Contr_3_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_triple_captain_bonus[i][w] &gt;= 0,\n                    f\"TripleCaptain_Contr_4_{i}_{w}\",\n                )\n\n            # Add points from bench boost and triple captain bonus for this gameweek\n            total_bench_boost_points_gw = lpSum(\n                actual_bench_boost_points[i][w] for i in self.player_data.index\n            )\n            total_triple_captain_bonus_points_gw = lpSum(\n                actual_triple_captain_bonus[i][w] for i in self.player_data.index\n            )\n\n            total_objective_points.append(total_bench_boost_points_gw)\n            total_objective_points.append(total_triple_captain_bonus_points_gw)\n\n        # Subtract transfer hits from the total objective\n        total_objective_points.append(\n            -POINTS_PER_HIT * lpSum(transfer_hits[w] for w in range(1, num_gameweeks))\n        )\n\n        self.problem += (\n            lpSum(total_objective_points),\n            \"Total Expected Points Over Gameweeks\",\n        )\n\n        # --- Constraints ---\n\n        # Apply constraints for each gameweek\n        for w in range(num_gameweeks):\n            # 1. Select exactly 15 players for the squad\n            self.problem += (\n                lpSum(player_vars[i][w] for i in self.player_data.index) == 15,\n                f\"Total_Players_GW{w}\",\n            )\n\n            # 2. Squad position constraints (2 GKs, 5 DEFs, 5 MIDs, 3 FWDs)\n            gks = self.player_data[self.player_data[\"position\"] == \"GK\"].index\n            defs = self.player_data[self.player_data[\"position\"] == \"DEF\"].index\n            mids = self.player_data[self.player_data[\"position\"] == \"MID\"].index\n            fwds = self.player_data[self.player_data[\"position\"] == \"FWD\"].index\n\n            self.problem += (\n                lpSum(player_vars[i][w] for i in gks) == 2,\n                f\"Goalkeepers_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(player_vars[i][w] for i in defs) == 5,\n                f\"Defenders_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(player_vars[i][w] for i in mids) == 5,\n                f\"Midfielders_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(player_vars[i][w] for i in fwds) == 3,\n                f\"Forwards_Count_GW{w}\",\n            )\n\n            # 3. Budget constraint\n            # This applies to the cost of the squad for the current gameweek.\n            self.problem += (\n                lpSum(\n                    self.player_data.loc[i, \"cost\"] * player_vars[i][w]\n                    for i in self.player_data.index\n                )\n                &lt;= budget,\n                f\"Total_Budget_GW{w}\",\n            )\n\n            # 4. Maximum players per team constraint\n            for team in self.player_data[\"team\"].unique():\n                team_players = self.player_data[self.player_data[\"team\"] == team].index\n                self.problem += (\n                    lpSum(player_vars[i][w] for i in team_players)\n                    &lt;= max_players_per_team,\n                    f\"Max_Players_from_{team}_GW{w}\",\n                )\n\n            # 5. Starting XI constraints\n            # 5.1 Select exactly 11 players for the starting XI\n            self.problem += (\n                lpSum(starting_xi_vars[i][w] for i in self.player_data.index) == 11,\n                f\"Total_Starting_XI_Players_GW{w}\",\n            )\n\n            # 5.2 A player can only be in the starting XI if they are in the squad\n            for i in self.player_data.index:\n                self.problem += (\n                    starting_xi_vars[i][w] &lt;= player_vars[i][w],\n                    f\"StartingXI_in_Squad_{i}_{w}\",\n                )\n\n            # 5.3 Starting XI position constraints (FPL allows flexible formations, so use minimums)\n            self.problem += (\n                lpSum(starting_xi_vars[i][w] for i in gks) == 1,\n                f\"Starting_Goalkeepers_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(starting_xi_vars[i][w] for i in defs) &gt;= 3,\n                f\"Min_Starting_Defenders_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(starting_xi_vars[i][w] for i in mids) &gt;= 2,\n                f\"Min_Starting_Midfielders_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(starting_xi_vars[i][w] for i in fwds) &gt;= 1,\n                f\"Min_Starting_Forwards_Count_GW{w}\",\n            )\n\n            # 6. Captain Constraints\n            # 6.1 Select exactly one captain from the starting XI\n            self.problem += (\n                lpSum(captain_var[i][w] for i in self.player_data.index) == 1,\n                f\"One_Captain_GW{w}\",\n            )\n\n            # 6.2 A player can only be captain if they are in the starting XI\n            for i in self.player_data.index:\n                self.problem += (\n                    captain_var[i][w] &lt;= starting_xi_vars[i][w],\n                    f\"Captain_in_StartingXI_{i}_{w}\",\n                )\n\n            # --- Enforced Player Constraints---\n            for player_idx in self.enforced_player_indices:\n                self.problem += (\n                    player_vars[player_idx][w] == 1,\n                    f\"Enforce_Player_{self.player_data.loc[player_idx, 'name']}_GW{w}\",\n                )\n\n            for team, position in self.enforced_team_pos_requirements:\n                # Filter players for the current team and position\n                team_pos_players = self.player_data[\n                    (self.player_data[\"team\"] == team)\n                    &amp; (self.player_data[\"position\"] == position)\n                ].index\n                if not team_pos_players.empty:\n                    self.problem += (\n                        lpSum(player_vars[i][w] for i in team_pos_players) &gt;= 1,\n                        f\"Enforce_One_{position}_from_{team}_GW{w}\",\n                    )\n                else:\n                    print(\n                        f\"Warning: No players found for enforced requirement: at least one {position} from {team} for GW{gw_actual}.\"\n                    )\n\n        # --- Chip Usage Constraints (TOTAL usage over all gameweeks) ---\n        # These constraints should be outside the per-gameweek loop to avoid duplicates.\n        self.problem += (\n            lpSum(use_bench_boost[j] for j in range(num_gameweeks))\n            &lt;= chip_allowances.get(\"bench_boost\", 0),\n            f\"Max_Bench_Boost_Usage_Total\",\n        )\n        self.problem += (\n            lpSum(use_triple_captain[j] for j in range(num_gameweeks))\n            &lt;= chip_allowances.get(\"triple_captain\", 0),\n            f\"Max_Triple_Captain_Usage_Total\",\n        )\n\n        # --- Inter-Gameweek Constraints (Transfers and Transfer Rules) ---\n        # Initialize free transfers for GW0 (first gameweek of optimization horizon)\n        # This assumes the optimization starts at GW0, and it has INITIAL_FREE_TRANSFERS.\n        # If the model starts at an arbitrary GW, this would need to be an input.\n        self.problem += (\n            free_transfers_available[0] == INITIAL_FREE_TRANSFERS,\n            f\"Initial_Free_Transfers_GW0\",\n        )\n\n        for w in range(1, num_gameweeks):\n            # Calculate total transfers made in this gameweek\n            self.problem += (\n                transfers_made[w]\n                == lpSum(transfer_in_vars[i][w] for i in self.player_data.index),\n                f\"Transfers_Made_GW{w}\",\n            )\n            # Total transfers in must equal total transfers out for each gameweek after the first\n            self.problem += (\n                lpSum(transfer_in_vars[i][w] for i in self.player_data.index)\n                == lpSum(transfer_out_vars[i][w] for i in self.player_data.index),\n                f\"Transfers_In_Equals_Out_GW{w}\",\n            )\n\n            # Calculate free transfers available for the current gameweek (w)\n            # Free transfers for GW_w = min(free transfers from GW_w-1 - transfers made in GW_w + 1, MAX_FREE_TRANSFERS_SAVED + 1)\n            # The + 1 in MAX_FREE_TRANSFERS_SAVED + 1 is because MAX_FREE_TRANSFERS_SAVED implies how many can be *saved*,\n            # so if you save 1, you have 1 (current) + 1 (saved) = 2.\n            self.problem += (\n                free_transfers_available[w]\n                &lt;= free_transfers_available[w - 1] - transfers_made[w] + 1,\n                f\"Free_Transfers_Calc_1_GW{w}\",\n            )\n            self.problem += (\n                free_transfers_available[w] &lt;= MAX_FREE_TRANSFERS_SAVED + 1,\n                f\"Free_Transfers_Calc_2_GW{w}\",\n            )\n            self.problem += (\n                free_transfers_available[w] &gt;= 0,  # Cannot have negative free transfers\n                f\"Free_Transfers_Non_Negative_GW{w}\",\n            )\n\n            # Calculate transfer hits\n            # transfer_hits[w] = max(0, transfers_made[w] - free_transfers_available_at_start_of_gw_w)\n            # This needs to be linearized. If transfers_made[w] &gt; free_transfers_available[w-1], then hit.\n            # free_transfers_available[w-1] represents transfers available *before* making transfers for GW_w\n            self.problem += (\n                transfer_hits[w] &gt;= transfers_made[w] - free_transfers_available[w - 1],\n                f\"Transfer_Hits_Calc_1_GW{w}\",\n            )\n            self.problem += (\n                transfer_hits[w] &gt;= 0,\n                f\"Transfer_Hits_Calc_2_GW{w}\",\n            )\n\n            for i in self.player_data.index:\n                # Squad continuity: player_vars[i][w] (in squad at start of GW w)\n                #                 = player_vars[i][w-1] (in squad at start of GW w-1)\n                #                 - transfer_out_vars[i][w] (transferred out for GW w)\n                #                 + transfer_in_vars[i][w] (transferred in for GW w)\n                self.problem += (\n                    player_vars[i][w]\n                    == player_vars[i][w - 1]\n                    - transfer_out_vars[i][w]\n                    + transfer_in_vars[i][w],\n                    f\"Squad_Continuity_{i}_GW{w}\",\n                )\n                # A player cannot be transferred in and out in the same gameweek\n                self.problem += (\n                    transfer_in_vars[i][w] + transfer_out_vars[i][w] &lt;= 1,\n                    f\"No_Simultaneous_Transfer_{i}_{w}\",\n                )\n\n        try:\n            # The solver is called with the GLPK_CMD solver\n            self.problem.solve(PULP_CBC_CMD(msg=0))  # msg=0 suppresses verbose output\n        except Exception as e:\n            print(f\"Error solving the problem: {e}\")\n            return False\n\n        if LpStatus[self.problem.status] == \"Optimal\":\n            print(\"Optimization successful! Optimal solution found.\")\n\n            self.selected_squad_history = {}\n            self.total_transfer_hits = 0\n            for w in range(num_gameweeks):\n                # The actual gameweek number (1-indexed)\n                gw_actual = current_gameweek_number_start + w\n\n                # Get selected players for the current gameweek\n                selected_squad_gw = self.player_data[\n                    [player_vars[i][w].varValue == 1 for i in self.player_data.index]\n                ].copy()\n\n                # Get starter and captain info for this gameweek\n                is_starter_series_gw = pd.Series(\n                    [\n                        starting_xi_vars[i][w].varValue == 1\n                        for i in self.player_data.index\n                    ],\n                    index=self.player_data.index,\n                )\n                is_captain_series_gw = pd.Series(\n                    [captain_var[i][w].varValue == 1 for i in self.player_data.index],\n                    index=self.player_data.index,\n                )\n\n                selected_squad_gw[\"is_starter\"] = is_starter_series_gw.loc[\n                    selected_squad_gw.index\n                ]\n                selected_squad_gw[\"is_captain\"] = is_captain_series_gw.loc[\n                    selected_squad_gw.index\n                ]\n\n                transfers_in_gw = 0\n                transfers_out_gw = 0\n                hits_gw = 0\n\n                # Store transfer details for gameweeks &gt; 0\n                if (\n                    w &gt; 0\n                ):  # Check for transfers only from GW1 onwards (index 1 in 0-indexed loop)\n                    transfer_in_flags = pd.Series(\n                        [\n                            transfer_in_vars[i][w].varValue == 1\n                            for i in self.player_data.index\n                        ],\n                        index=self.player_data.index,\n                    )\n                    transfer_out_flags = pd.Series(\n                        [\n                            transfer_out_vars[i][w].varValue == 1\n                            for i in self.player_data.index\n                        ],\n                        index=self.player_data.index,\n                    )\n\n                    selected_squad_gw[\"transfer_in\"] = transfer_in_flags.loc[\n                        selected_squad_gw.index\n                    ]\n                    selected_squad_gw[\"transfer_out\"] = transfer_out_flags.loc[\n                        selected_squad_gw.index\n                    ]\n\n                    transfers_in_gw = int(round(transfer_in_flags.sum()))\n                    transfers_out_gw = int(round(transfer_out_flags.sum()))\n                    hits_gw = int(round(transfer_hits[w].varValue))\n                    self.total_transfer_hits += hits_gw\n                else:\n                    selected_squad_gw[\"transfer_in\"] = False  # No transfers in for GW0\n                    selected_squad_gw[\"transfer_out\"] = (\n                        False  # No transfers out for GW0\n                    )\n\n                self.selected_squad_history[f\"GW{gw_actual}\"] = {\n                    \"squad\": selected_squad_gw,\n                    \"total_cost\": selected_squad_gw[\"cost\"].sum(),\n                    \"expected_points_from_xi\": sum(\n                        self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n                        * starting_xi_vars[i][w].varValue\n                        for i in self.player_data.index\n                    ),\n                    \"bench_boost_used\": bool(use_bench_boost[w].varValue),\n                    \"triple_captain_used\": bool(use_triple_captain[w].varValue),\n                    \"total_bench_boost_points\": value(\n                        lpSum(\n                            actual_bench_boost_points[i][w]\n                            for i in self.player_data.index\n                        )\n                    ),\n                    \"total_triple_captain_bonus\": value(\n                        lpSum(\n                            actual_triple_captain_bonus[i][w]\n                            for i in self.player_data.index\n                        )\n                    ),\n                    \"transfers_in_count\": transfers_in_gw,\n                    \"transfers_out_count\": transfers_out_gw,\n                    \"transfer_hits\": hits_gw,  # New\n                    \"free_transfers_available_next_gw\": (\n                        int(round(free_transfers_available[w].varValue))\n                        if w &lt; num_gameweeks - 1\n                        else 0\n                    ),  # Free transfers available *after* this GW's transfers are made\n                }\n\n            # Overall totals\n            self.total_cost = self.selected_squad_history[\n                f\"GW{current_gameweek_number_start + num_gameweeks - 1}\"\n            ][\n                \"total_cost\"\n            ]  # Cost of final squad\n            self.total_expected_points = value(\n                self.problem.objective\n            )  # Total objective value from solver\n            self.used_chips = {\n                f\"GW{current_gameweek_number_start + w}\": {\n                    \"bench_boost\": bool(use_bench_boost[w].varValue),\n                    \"triple_captain\": bool(use_triple_captain[w].varValue),\n                }\n                for w in range(num_gameweeks)\n            }\n\n            return True\n        else:\n            print(f\"No optimal solution found. Status: {LpStatus[self.problem.status]}\")\n            self.selected_squad_history = {}\n            self.total_cost = 0\n            self.total_expected_points = 0\n            self.used_chips = {}\n            self.total_transfer_hits = 0\n            return False\n\n    def get_selected_squad(self, gameweek: int = None) -&gt; pd.DataFrame | None:\n        \"\"\"\n        Returns the selected squad for a specific gameweek (1-indexed).\n        If no gameweek is specified, returns the squad for the last optimized gameweek.\n        \"\"\"\n        if not self.selected_squad_history:\n            return None\n\n        # Get the first GW key to determine the range of available GWs\n        first_gw_in_history = min(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n        last_gw_in_history = max(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n\n        if gameweek is None:\n            return self.selected_squad_history[f\"GW{last_gw_in_history}\"][\"squad\"]\n\n        if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n            print(\n                f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n            )\n            return None\n\n        return self.selected_squad_history.get(f\"GW{gameweek}\", {}).get(\"squad\")\n\n    def get_total_cost(self, gameweek: int = None) -&gt; float:\n        \"\"\"\n        Returns the total cost for a specific gameweek (1-indexed).\n        If no gameweek is specified, returns the cost of the squad in the last optimized gameweek.\n        \"\"\"\n        if not self.selected_squad_history:\n            return 0\n        first_gw_in_history = min(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n        last_gw_in_history = max(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n\n        if gameweek is None:\n            return self.selected_squad_history[f\"GW{last_gw_in_history}\"][\"total_cost\"]\n\n        if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n            print(\n                f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n            )\n            return 0  # Or raise an error\n\n        return self.selected_squad_history.get(f\"GW{gameweek}\", {}).get(\"total_cost\", 0)\n\n    def get_total_expected_points(self) -&gt; float:\n        \"\"\"\n        Returns the overall total expected points across all optimized gameweeks.\n        \"\"\"\n        return self.total_expected_points\n\n    def get_gameweek_summary(self, gameweek: int):\n        \"\"\"\n        Returns a dictionary summary for a specific gameweek.\n        \"\"\"\n        if not self.selected_squad_history:\n            return None\n        first_gw_in_history = min(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n        last_gw_in_history = max(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n\n        if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n            print(\n                f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n            )\n            return None\n\n        return self.selected_squad_history.get(f\"GW{gameweek}\")\n\n    def print_squad_summary(self, gameweek: int):\n        \"\"\"\n        Prints a formatted summary of the selected squad for a specific gameweek.\n        \"\"\"\n        if not self.selected_squad_history:\n            print(\"No squad has been selected yet. Run the 'solve' method first.\")\n            return\n\n        gw_data = self.get_gameweek_summary(gameweek)\n        if not gw_data:\n            return  # get_gameweek_summary already prints error message\n\n        selected_squad = gw_data[\"squad\"]\n        total_cost = gw_data[\"total_cost\"]\n        expected_points_from_xi = gw_data[\"expected_points_from_xi\"]\n        bench_boost_used = gw_data[\"bench_boost_used\"]\n        triple_captain_used = gw_data[\"triple_captain_used\"]\n        total_bench_boost_points = gw_data[\"total_bench_boost_points\"]\n        total_triple_captain_bonus = gw_data[\"total_triple_captain_bonus\"]\n        transfers_in_count = gw_data[\"transfers_in_count\"]  # New\n        transfers_out_count = gw_data[\"transfers_out_count\"]  # New\n        transfer_hits_taken = gw_data[\"transfer_hits\"]  # New\n        free_transfers_available_next_gw = gw_data[\n            \"free_transfers_available_next_gw\"\n        ]  # New\n\n        print(f\"\\n--- FPL Optimized Squad for Gameweek {gameweek} ---\")\n        print(f\"Squad Cost: \u00a3{total_cost:.1f}m\")\n        print(f\"Expected Points (Starting XI): {expected_points_from_xi:.2f}\")\n        print(\n            f\"Total Expected Points for GW{gameweek} (including chips): {expected_points_from_xi + total_bench_boost_points + total_triple_captain_bonus:.2f}\"\n        )\n        print(\"\\n--- Chips Used This Gameweek ---\")\n        if bench_boost_used:\n            print(f\"- Bench Boost (Added {total_bench_boost_points:.2f} points)\")\n        if triple_captain_used:\n            print(\n                f\"- Triple Captain (Added {total_triple_captain_bonus:.2f} bonus points)\"\n            )\n        if not (bench_boost_used or triple_captain_used):\n            print(\"No chips used this gameweek.\")\n\n        print(\"\\n--- Goalkeepers (Starting XI marked with *) ---\")\n        for index, row in selected_squad[selected_squad[\"position\"] == \"GK\"].iterrows():\n            starter_str = \"*\" if row[\"is_starter\"] else \"\"\n            captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n            transfer_status = \"\"\n            if row[\"transfer_in\"]:\n                transfer_status = \"(IN)\"\n            elif row[\"transfer_out\"]:\n                transfer_status = \"(OUT)\"\n\n            # Access gameweek-specific xP correctly\n            player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n            print(\n                f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n            )\n        print(\"\\n--- Defenders (Starting XI marked with *) ---\")\n        for index, row in selected_squad[\n            selected_squad[\"position\"] == \"DEF\"\n        ].iterrows():\n            starter_str = \"*\" if row[\"is_starter\"] else \"\"\n            captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n            transfer_status = \"\"\n            if row[\"transfer_in\"]:\n                transfer_status = \"(IN)\"\n            elif row[\"transfer_out\"]:\n                transfer_status = \"(OUT)\"\n\n            player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n            print(\n                f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n            )\n        print(\"\\n--- Midfielders (Starting XI marked with *) ---\")\n        for index, row in selected_squad[\n            selected_squad[\"position\"] == \"MID\"\n        ].iterrows():\n            starter_str = \"*\" if row[\"is_starter\"] else \"\"\n            captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n            transfer_status = \"\"\n            if row[\"transfer_in\"]:\n                transfer_status = \"(IN)\"\n            elif row[\"transfer_out\"]:\n                transfer_status = \"(OUT)\"\n\n            player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n            print(\n                f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n            )\n        print(\"\\n--- Forwards (Starting XI marked with *) ---\")\n        for index, row in selected_squad[\n            selected_squad[\"position\"] == \"FWD\"\n        ].iterrows():\n            starter_str = \"*\" if row[\"is_starter\"] else \"\"\n            captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n            transfer_status = \"\"\n            if row[\"transfer_in\"]:\n                transfer_status = \"(IN)\"\n            elif row[\"transfer_out\"]:\n                transfer_status = \"(OUT)\"\n\n            player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n            print(\n                f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n            )\n\n        print(f\"\\n--- Team Breakdown for GW{gameweek} ---\")\n        print(selected_squad[\"team\"].value_counts())\n\n        # Transfers are relevant from Gameweek 2 (index 1) onwards in the optimization horizon\n        # For display, if the current GW is the initial one (GW1 in the current context), no transfers are made\n        # If it's a subsequent GW, check if transfers occurred.\n        first_gw_in_history = min(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n        if (\n            gameweek &gt;= first_gw_in_history\n        ):  # Changed from &gt; to &gt;=, to show initial free transfers\n            # Display transfer info for this gameweek\n            print(\n                f\"  Transfers In: {transfers_in_count}, Transfers Out: {transfers_out_count}\"\n            )\n            print(\n                f\"  Transfer Hits: {transfer_hits_taken} (-{transfer_hits_taken * POINTS_PER_HIT} points)\"\n            )\n            # Only show free transfers for the *next* gameweek if it's not the last gameweek in the horizon\n            if gameweek &lt; max(\n                int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n            ):\n                print(\n                    f\"  Free Transfers Available for Next GW: {free_transfers_available_next_gw}\"\n                )\n        print(\"---------------------------\\n\")\n\n    def print_overall_summary(self):\n        \"\"\"\n        Prints an overall summary of the multi-week optimization results.\n        \"\"\"\n        if not self.selected_squad_history:\n            print(\"No optimization results to summarize.\")\n            return\n\n        print(\"\\n=== Overall Multi-Week FPL Optimization Summary ===\")\n        print(\n            f\"Total Expected Points Across All Gameweeks: {self.total_expected_points:.2f}\"\n        )\n\n        # Get the latest gameweek's cost\n        last_gw_key = max(\n            self.selected_squad_history.keys(), key=lambda k: int(k.replace(\"GW\", \"\"))\n        )\n        print(\n            f\"Squad Cost ({last_gw_key}): \u00a3{self.selected_squad_history[last_gw_key]['total_cost']:.1f}m\"\n        )\n        print(\n            f\"Total Transfer Hits Taken: {self.total_transfer_hits} (-{self.total_transfer_hits * POINTS_PER_HIT} points)\"\n        )\n\n        print(\"\\n--- Chip Usage Across Gameweeks ---\")\n        # Ensure consistent order by sorting gameweek keys\n        sorted_gw_keys = sorted(\n            self.used_chips.keys(), key=lambda k: int(k.replace(\"GW\", \"\"))\n        )\n        for gw_str in sorted_gw_keys:\n            chips = self.used_chips[gw_str]\n            chip_summary = []\n            if chips[\"bench_boost\"]:\n                chip_summary.append(\"Bench Boost\")\n            if chips[\"triple_captain\"]:\n                chip_summary.append(\"Triple Captain\")\n\n            if chip_summary:\n                print(f\"{gw_str}: {', '.join(chip_summary)}\")\n            else:\n                print(f\"{gw_str}: No chips used\")\n\n        print(\"\\n--- Gameweek-by-Gameweek Summary ---\")\n        # Iterate and print basic summary for each gameweek\n        for gw_str in sorted_gw_keys:\n            gw_data = self.selected_squad_history[gw_str]\n            print(f\"\\n--- {gw_str} ---\")\n            print(f\"  Squad Cost: \u00a3{gw_data['total_cost']:.1f}m\")\n            print(\n                f\"  Expected Points (Starting XI): {gw_data['expected_points_from_xi']:.2f}\"\n            )\n            print(\n                f\"  Total GW Points (incl. chips): {gw_data['expected_points_from_xi'] + gw_data['total_bench_boost_points'] + gw_data['total_triple_captain_bonus']:.2f}\"\n            )\n\n            # Display transfer info for this gameweek\n            transfers_in_count = gw_data[\"transfers_in_count\"]\n            transfers_out_count = gw_data[\"transfers_out_count\"]\n            transfer_hits_taken = gw_data[\"transfer_hits\"]\n            free_transfers_available_next_gw = gw_data[\n                \"free_transfers_available_next_gw\"\n            ]\n\n            print(\n                f\"  Transfers In: {transfers_in_count}, Transfers Out: {transfers_out_count}\"\n            )\n            print(\n                f\"  Transfer Hits: {transfer_hits_taken} (-{transfer_hits_taken * POINTS_PER_HIT} points)\"\n            )\n            # Only show free transfers for the *next* gameweek if it's not the last gameweek in the horizon\n            if int(gw_str.replace(\"GW\", \"\")) &lt; max(\n                int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n            ):\n                print(\n                    f\"  Free Transfers Available for Next GW: {free_transfers_available_next_gw}\"\n                )\n            print(\"-----------------------------------\")\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/#build.lib.fpl_solver.fpl_solver.FPLOptimizer.__init__","title":"<code>__init__(player_data)</code>","text":"<p>Initializes the FPLOptimizer with player data.</p> <p>Parameters:</p> Name Type Description Default <code>player_data</code> <code>DataFrame</code> <p>A DataFrame containing player information                         with columns: 'name', 'team', 'position',                         'cost', 'expected_points_by_gw' (a dict of xP per GW).</p> required Source code in <code>build/lib/fpl_solver/fpl_solver.py</code> <pre><code>def __init__(self, player_data: pd.DataFrame):\n    \"\"\"\n    Initializes the FPLOptimizer with player data.\n\n    Args:\n        player_data (pd.DataFrame): A DataFrame containing player information\n                                    with columns: 'name', 'team', 'position',\n                                    'cost', 'expected_points_by_gw' (a dict of xP per GW).\n    \"\"\"\n    required_columns = [\"name\", \"team\", \"position\", \"cost\", \"expected_points_by_gw\"]\n    if not all(col in player_data.columns for col in required_columns):\n        missing_cols = [\n            col for col in required_columns if col not in player_data.columns\n        ]\n        raise ValueError(\n            f\"player_data DataFrame must contain {required_columns} columns. Missing: {missing_cols}\"\n        )\n\n    self.player_data = player_data\n    self.problem = None\n    self.selected_squad_history = {}  # To store squad for each gameweek\n    self.total_cost = 0\n    self.total_expected_points = 0\n    self.total_transfer_hits = 0\n\n    # --- Process Enforced Players ---\n    self.enforced_player_indices = set()\n    self.enforced_team_pos_requirements = []\n\n    print(\"\\n--- Processing Enforced Players ---\")\n\n    # Enforce by Player ID\n    for player_id in ENFORCED_PLAYERS_BY_ID:\n        found_player = self.player_data[self.player_data[\"id\"] == player_id]\n        if not found_player.empty:\n            player_idx = found_player.index[0]\n            self.enforced_player_indices.add(player_idx)\n            print(\n                f\"Enforcing player by ID: {found_player.loc[player_idx, 'name']} (ID: {player_id})\"\n            )\n        else:\n            print(\n                f\"Warning: Enforced player with ID {player_id} not found in data.\"\n            )\n\n    # Enforce by Player Name\n    for player_name in ENFORCED_PLAYERS_BY_NAME:\n        found_player = self.player_data[self.player_data[\"name\"] == player_name]\n        if not found_player.empty:\n            player_idx = found_player.index[0]\n            self.enforced_player_indices.add(player_idx)\n            print(f\"Enforcing player by name: {player_name}\")\n        else:\n            print(f\"Warning: Enforced player '{player_name}' not found in data.\")\n\n    # Enforce by Team and Position\n    for requirement in ENFORCED_PLAYERS_BY_TEAM_AND_POSITION:\n        team = requirement.get(\"team\")\n        position = requirement.get(\"position\")\n        if team and position:\n            # Validate team and position exist in data\n            if team not in self.player_data[\"team\"].unique():\n                print(\n                    f\"Warning: Enforced team '{team}' for position '{position}' not found in data.\"\n                )\n                continue\n            if position not in self.player_data[\"position\"].unique():\n                print(\n                    f\"Warning: Enforced position '{position}' for team '{team}' not found in data.\"\n                )\n                continue\n\n            self.enforced_team_pos_requirements.append((team, position))\n            print(f\"Enforcing at least one {position} from {team}.\")\n        else:\n            print(\n                f\"Warning: Invalid enforced team/position requirement: {requirement}\"\n            )\n\n    if not (\n        self.enforced_player_indices\n        or self.enforced_team_pos_requirements\n        or ENFORCED_PLAYERS_BY_ID\n        or ENFORCED_PLAYERS_BY_NAME\n        or ENFORCED_PLAYERS_BY_TEAM_AND_POSITION\n    ):\n        print(\"No players or team/position combinations are enforced.\")\n    print(\"-----------------------------------\\n\")\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/#build.lib.fpl_solver.fpl_solver.FPLOptimizer.get_gameweek_summary","title":"<code>get_gameweek_summary(gameweek)</code>","text":"<p>Returns a dictionary summary for a specific gameweek.</p> Source code in <code>build/lib/fpl_solver/fpl_solver.py</code> <pre><code>def get_gameweek_summary(self, gameweek: int):\n    \"\"\"\n    Returns a dictionary summary for a specific gameweek.\n    \"\"\"\n    if not self.selected_squad_history:\n        return None\n    first_gw_in_history = min(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n    last_gw_in_history = max(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n\n    if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n        print(\n            f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n        )\n        return None\n\n    return self.selected_squad_history.get(f\"GW{gameweek}\")\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/#build.lib.fpl_solver.fpl_solver.FPLOptimizer.get_selected_squad","title":"<code>get_selected_squad(gameweek=None)</code>","text":"<p>Returns the selected squad for a specific gameweek (1-indexed). If no gameweek is specified, returns the squad for the last optimized gameweek.</p> Source code in <code>build/lib/fpl_solver/fpl_solver.py</code> <pre><code>def get_selected_squad(self, gameweek: int = None) -&gt; pd.DataFrame | None:\n    \"\"\"\n    Returns the selected squad for a specific gameweek (1-indexed).\n    If no gameweek is specified, returns the squad for the last optimized gameweek.\n    \"\"\"\n    if not self.selected_squad_history:\n        return None\n\n    # Get the first GW key to determine the range of available GWs\n    first_gw_in_history = min(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n    last_gw_in_history = max(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n\n    if gameweek is None:\n        return self.selected_squad_history[f\"GW{last_gw_in_history}\"][\"squad\"]\n\n    if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n        print(\n            f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n        )\n        return None\n\n    return self.selected_squad_history.get(f\"GW{gameweek}\", {}).get(\"squad\")\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/#build.lib.fpl_solver.fpl_solver.FPLOptimizer.get_total_cost","title":"<code>get_total_cost(gameweek=None)</code>","text":"<p>Returns the total cost for a specific gameweek (1-indexed). If no gameweek is specified, returns the cost of the squad in the last optimized gameweek.</p> Source code in <code>build/lib/fpl_solver/fpl_solver.py</code> <pre><code>def get_total_cost(self, gameweek: int = None) -&gt; float:\n    \"\"\"\n    Returns the total cost for a specific gameweek (1-indexed).\n    If no gameweek is specified, returns the cost of the squad in the last optimized gameweek.\n    \"\"\"\n    if not self.selected_squad_history:\n        return 0\n    first_gw_in_history = min(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n    last_gw_in_history = max(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n\n    if gameweek is None:\n        return self.selected_squad_history[f\"GW{last_gw_in_history}\"][\"total_cost\"]\n\n    if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n        print(\n            f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n        )\n        return 0  # Or raise an error\n\n    return self.selected_squad_history.get(f\"GW{gameweek}\", {}).get(\"total_cost\", 0)\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/#build.lib.fpl_solver.fpl_solver.FPLOptimizer.get_total_expected_points","title":"<code>get_total_expected_points()</code>","text":"<p>Returns the overall total expected points across all optimized gameweeks.</p> Source code in <code>build/lib/fpl_solver/fpl_solver.py</code> <pre><code>def get_total_expected_points(self) -&gt; float:\n    \"\"\"\n    Returns the overall total expected points across all optimized gameweeks.\n    \"\"\"\n    return self.total_expected_points\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/#build.lib.fpl_solver.fpl_solver.FPLOptimizer.print_overall_summary","title":"<code>print_overall_summary()</code>","text":"<p>Prints an overall summary of the multi-week optimization results.</p> Source code in <code>build/lib/fpl_solver/fpl_solver.py</code> <pre><code>def print_overall_summary(self):\n    \"\"\"\n    Prints an overall summary of the multi-week optimization results.\n    \"\"\"\n    if not self.selected_squad_history:\n        print(\"No optimization results to summarize.\")\n        return\n\n    print(\"\\n=== Overall Multi-Week FPL Optimization Summary ===\")\n    print(\n        f\"Total Expected Points Across All Gameweeks: {self.total_expected_points:.2f}\"\n    )\n\n    # Get the latest gameweek's cost\n    last_gw_key = max(\n        self.selected_squad_history.keys(), key=lambda k: int(k.replace(\"GW\", \"\"))\n    )\n    print(\n        f\"Squad Cost ({last_gw_key}): \u00a3{self.selected_squad_history[last_gw_key]['total_cost']:.1f}m\"\n    )\n    print(\n        f\"Total Transfer Hits Taken: {self.total_transfer_hits} (-{self.total_transfer_hits * POINTS_PER_HIT} points)\"\n    )\n\n    print(\"\\n--- Chip Usage Across Gameweeks ---\")\n    # Ensure consistent order by sorting gameweek keys\n    sorted_gw_keys = sorted(\n        self.used_chips.keys(), key=lambda k: int(k.replace(\"GW\", \"\"))\n    )\n    for gw_str in sorted_gw_keys:\n        chips = self.used_chips[gw_str]\n        chip_summary = []\n        if chips[\"bench_boost\"]:\n            chip_summary.append(\"Bench Boost\")\n        if chips[\"triple_captain\"]:\n            chip_summary.append(\"Triple Captain\")\n\n        if chip_summary:\n            print(f\"{gw_str}: {', '.join(chip_summary)}\")\n        else:\n            print(f\"{gw_str}: No chips used\")\n\n    print(\"\\n--- Gameweek-by-Gameweek Summary ---\")\n    # Iterate and print basic summary for each gameweek\n    for gw_str in sorted_gw_keys:\n        gw_data = self.selected_squad_history[gw_str]\n        print(f\"\\n--- {gw_str} ---\")\n        print(f\"  Squad Cost: \u00a3{gw_data['total_cost']:.1f}m\")\n        print(\n            f\"  Expected Points (Starting XI): {gw_data['expected_points_from_xi']:.2f}\"\n        )\n        print(\n            f\"  Total GW Points (incl. chips): {gw_data['expected_points_from_xi'] + gw_data['total_bench_boost_points'] + gw_data['total_triple_captain_bonus']:.2f}\"\n        )\n\n        # Display transfer info for this gameweek\n        transfers_in_count = gw_data[\"transfers_in_count\"]\n        transfers_out_count = gw_data[\"transfers_out_count\"]\n        transfer_hits_taken = gw_data[\"transfer_hits\"]\n        free_transfers_available_next_gw = gw_data[\n            \"free_transfers_available_next_gw\"\n        ]\n\n        print(\n            f\"  Transfers In: {transfers_in_count}, Transfers Out: {transfers_out_count}\"\n        )\n        print(\n            f\"  Transfer Hits: {transfer_hits_taken} (-{transfer_hits_taken * POINTS_PER_HIT} points)\"\n        )\n        # Only show free transfers for the *next* gameweek if it's not the last gameweek in the horizon\n        if int(gw_str.replace(\"GW\", \"\")) &lt; max(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        ):\n            print(\n                f\"  Free Transfers Available for Next GW: {free_transfers_available_next_gw}\"\n            )\n        print(\"-----------------------------------\")\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/#build.lib.fpl_solver.fpl_solver.FPLOptimizer.print_squad_summary","title":"<code>print_squad_summary(gameweek)</code>","text":"<p>Prints a formatted summary of the selected squad for a specific gameweek.</p> Source code in <code>build/lib/fpl_solver/fpl_solver.py</code> <pre><code>def print_squad_summary(self, gameweek: int):\n    \"\"\"\n    Prints a formatted summary of the selected squad for a specific gameweek.\n    \"\"\"\n    if not self.selected_squad_history:\n        print(\"No squad has been selected yet. Run the 'solve' method first.\")\n        return\n\n    gw_data = self.get_gameweek_summary(gameweek)\n    if not gw_data:\n        return  # get_gameweek_summary already prints error message\n\n    selected_squad = gw_data[\"squad\"]\n    total_cost = gw_data[\"total_cost\"]\n    expected_points_from_xi = gw_data[\"expected_points_from_xi\"]\n    bench_boost_used = gw_data[\"bench_boost_used\"]\n    triple_captain_used = gw_data[\"triple_captain_used\"]\n    total_bench_boost_points = gw_data[\"total_bench_boost_points\"]\n    total_triple_captain_bonus = gw_data[\"total_triple_captain_bonus\"]\n    transfers_in_count = gw_data[\"transfers_in_count\"]  # New\n    transfers_out_count = gw_data[\"transfers_out_count\"]  # New\n    transfer_hits_taken = gw_data[\"transfer_hits\"]  # New\n    free_transfers_available_next_gw = gw_data[\n        \"free_transfers_available_next_gw\"\n    ]  # New\n\n    print(f\"\\n--- FPL Optimized Squad for Gameweek {gameweek} ---\")\n    print(f\"Squad Cost: \u00a3{total_cost:.1f}m\")\n    print(f\"Expected Points (Starting XI): {expected_points_from_xi:.2f}\")\n    print(\n        f\"Total Expected Points for GW{gameweek} (including chips): {expected_points_from_xi + total_bench_boost_points + total_triple_captain_bonus:.2f}\"\n    )\n    print(\"\\n--- Chips Used This Gameweek ---\")\n    if bench_boost_used:\n        print(f\"- Bench Boost (Added {total_bench_boost_points:.2f} points)\")\n    if triple_captain_used:\n        print(\n            f\"- Triple Captain (Added {total_triple_captain_bonus:.2f} bonus points)\"\n        )\n    if not (bench_boost_used or triple_captain_used):\n        print(\"No chips used this gameweek.\")\n\n    print(\"\\n--- Goalkeepers (Starting XI marked with *) ---\")\n    for index, row in selected_squad[selected_squad[\"position\"] == \"GK\"].iterrows():\n        starter_str = \"*\" if row[\"is_starter\"] else \"\"\n        captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n        transfer_status = \"\"\n        if row[\"transfer_in\"]:\n            transfer_status = \"(IN)\"\n        elif row[\"transfer_out\"]:\n            transfer_status = \"(OUT)\"\n\n        # Access gameweek-specific xP correctly\n        player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n        print(\n            f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n        )\n    print(\"\\n--- Defenders (Starting XI marked with *) ---\")\n    for index, row in selected_squad[\n        selected_squad[\"position\"] == \"DEF\"\n    ].iterrows():\n        starter_str = \"*\" if row[\"is_starter\"] else \"\"\n        captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n        transfer_status = \"\"\n        if row[\"transfer_in\"]:\n            transfer_status = \"(IN)\"\n        elif row[\"transfer_out\"]:\n            transfer_status = \"(OUT)\"\n\n        player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n        print(\n            f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n        )\n    print(\"\\n--- Midfielders (Starting XI marked with *) ---\")\n    for index, row in selected_squad[\n        selected_squad[\"position\"] == \"MID\"\n    ].iterrows():\n        starter_str = \"*\" if row[\"is_starter\"] else \"\"\n        captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n        transfer_status = \"\"\n        if row[\"transfer_in\"]:\n            transfer_status = \"(IN)\"\n        elif row[\"transfer_out\"]:\n            transfer_status = \"(OUT)\"\n\n        player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n        print(\n            f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n        )\n    print(\"\\n--- Forwards (Starting XI marked with *) ---\")\n    for index, row in selected_squad[\n        selected_squad[\"position\"] == \"FWD\"\n    ].iterrows():\n        starter_str = \"*\" if row[\"is_starter\"] else \"\"\n        captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n        transfer_status = \"\"\n        if row[\"transfer_in\"]:\n            transfer_status = \"(IN)\"\n        elif row[\"transfer_out\"]:\n            transfer_status = \"(OUT)\"\n\n        player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n        print(\n            f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n        )\n\n    print(f\"\\n--- Team Breakdown for GW{gameweek} ---\")\n    print(selected_squad[\"team\"].value_counts())\n\n    # Transfers are relevant from Gameweek 2 (index 1) onwards in the optimization horizon\n    # For display, if the current GW is the initial one (GW1 in the current context), no transfers are made\n    # If it's a subsequent GW, check if transfers occurred.\n    first_gw_in_history = min(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n    if (\n        gameweek &gt;= first_gw_in_history\n    ):  # Changed from &gt; to &gt;=, to show initial free transfers\n        # Display transfer info for this gameweek\n        print(\n            f\"  Transfers In: {transfers_in_count}, Transfers Out: {transfers_out_count}\"\n        )\n        print(\n            f\"  Transfer Hits: {transfer_hits_taken} (-{transfer_hits_taken * POINTS_PER_HIT} points)\"\n        )\n        # Only show free transfers for the *next* gameweek if it's not the last gameweek in the horizon\n        if gameweek &lt; max(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        ):\n            print(\n                f\"  Free Transfers Available for Next GW: {free_transfers_available_next_gw}\"\n            )\n    print(\"---------------------------\\n\")\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/#build.lib.fpl_solver.fpl_solver.FPLOptimizer.solve","title":"<code>solve(budget, max_players_per_team, chip_allowances, num_gameweeks)</code>","text":"<p>Solves the FPL optimization problem using PuLP.</p> <p>Parameters:</p> Name Type Description Default <code>budget</code> <code>float</code> <p>The maximum budget in millions of pounds.</p> required <code>max_players_per_team</code> <code>int</code> <p>The maximum number of players allowed from                         any single Premier League team.</p> required <code>chip_allowances</code> <code>dict</code> <p>A dictionary specifying the maximum usage for each chip.</p> required <code>num_gameweeks</code> <code>int</code> <p>The number of gameweeks to optimize over.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if a solution was found, False otherwise.</p> Source code in <code>build/lib/fpl_solver/fpl_solver.py</code> <pre><code>def solve(\n    self,\n    budget: float,\n    max_players_per_team: int,\n    chip_allowances: dict,\n    num_gameweeks: int,\n) -&gt; bool:\n    \"\"\"\n    Solves the FPL optimization problem using PuLP.\n\n    Args:\n        budget (float): The maximum budget in millions of pounds.\n        max_players_per_team (int): The maximum number of players allowed from\n                                    any single Premier League team.\n        chip_allowances (dict): A dictionary specifying the maximum usage for each chip.\n        num_gameweeks (int): The number of gameweeks to optimize over.\n\n    Returns:\n        bool: True if a solution was found, False otherwise.\n    \"\"\"\n    self.problem = LpProblem(\"FPL Squad Multi-Week Optimization\", LpMaximize)\n\n    # Decision variables for player selection, indexed by player and gameweek\n    player_vars = LpVariable.dicts(\n        \"Player\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n    )\n    starting_xi_vars = LpVariable.dicts(\n        \"StartingXI\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n    )\n    captain_var = LpVariable.dicts(\n        \"Captain\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n    )\n\n    # Binary variables for chip usage, indexed by gameweek\n    use_bench_boost = LpVariable.dicts(\n        \"Use_Bench_Boost\", range(num_gameweeks), 0, 1, LpBinary\n    )\n    use_triple_captain = LpVariable.dicts(\n        \"Use_Triple_Captain\", range(num_gameweeks), 0, 1, LpBinary\n    )\n\n    # Transfer variables\n    transfer_in_vars = LpVariable.dicts(\n        \"Transfer_In\",\n        (self.player_data.index, range(1, num_gameweeks)),\n        0,\n        1,\n        LpBinary,\n    )\n    transfer_out_vars = LpVariable.dicts(\n        \"Transfer_Out\",\n        (self.player_data.index, range(1, num_gameweeks)),\n        0,\n        1,\n        LpBinary,\n    )\n\n    # Total transfers made in a gameweek (absolute count)\n    transfers_made = LpVariable.dicts(\n        \"Transfers_Made\", range(1, num_gameweeks), 0, None, LpInteger\n    )\n    # Free transfers available at the start of a gameweek\n    free_transfers_available = LpVariable.dicts(\n        \"Free_Transfers_Available\",\n        range(num_gameweeks),\n        0,\n        MAX_FREE_TRANSFERS_SAVED + 1,\n        LpInteger,\n    )\n    # Number of transfer hits taken in a gameweek\n    transfer_hits = LpVariable.dicts(\n        \"Transfer_Hits\", range(1, num_gameweeks), 0, None, LpInteger\n    )\n\n    # Auxiliary variables for linearizing chip effects\n    is_bench_player = LpVariable.dicts(\n        \"Is_Bench_Player\",\n        (self.player_data.index, range(num_gameweeks)),\n        0,\n        1,\n        LpBinary,\n    )\n    actual_bench_boost_points = LpVariable.dicts(\n        \"Actual_Bench_Boost_Points\",\n        (self.player_data.index, range(num_gameweeks)),\n        0,\n        None,\n        LpContinuous,\n    )\n    actual_triple_captain_bonus = LpVariable.dicts(\n        \"Actual_Triple_Captain_Bonus\",\n        (self.player_data.index, range(num_gameweeks)),\n        0,\n        None,\n        LpContinuous,\n    )\n\n    # --- Objective Function ---\n    total_objective_points = []\n\n    # Get the first gameweek number from the player data to correctly index expected_points_by_gw\n    first_gw_key = next(\n        iter(\n            self.player_data.loc[\n                self.player_data.index[0], \"expected_points_by_gw\"\n            ].keys()\n        )\n    )\n    current_gameweek_number_start = int(first_gw_key)\n\n    for w in range(num_gameweeks):\n        # The actual gameweek number (1-indexed)\n        gw_actual = current_gameweek_number_start + w\n\n        # Base expected points from the selected starting 11 for this gameweek\n        base_points_expression_gw = lpSum(\n            self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n            * starting_xi_vars[i][w]\n            for i in self.player_data.index\n        )\n        total_objective_points.append(base_points_expression_gw)\n\n        # Regular Captaincy points (additional 1x for captain)\n        captain_points_bonus_gw = lpSum(\n            self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n            * captain_var[i][w]\n            for i in self.player_data.index\n        )\n        total_objective_points.append(captain_points_bonus_gw)\n\n        # Define auxiliary variables and constraints for chips for each gameweek\n        for i in self.player_data.index:\n            # Use gameweek-specific player xP for chip calculations\n            player_xp = self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n\n            # Bench Boost auxiliary variables and constraints\n            self.problem += (\n                is_bench_player[i][w] &lt;= player_vars[i][w],\n                f\"IsBench_Squad_{i}_{w}\",\n            )\n            self.problem += (\n                is_bench_player[i][w] &lt;= 1 - starting_xi_vars[i][w],\n                f\"IsBench_NotStarter_{i}_{w}\",\n            )\n            self.problem += (\n                is_bench_player[i][w]\n                &gt;= player_vars[i][w] + (1 - starting_xi_vars[i][w]) - 1,\n                f\"IsBench_Logical_{i}_{w}\",\n            )\n\n            self.problem += (\n                actual_bench_boost_points[i][w]\n                &lt;= player_xp * is_bench_player[i][w],\n                f\"BenchBoost_Contr_1_{i}_{w}\",\n            )\n            self.problem += (\n                actual_bench_boost_points[i][w] &lt;= player_xp * use_bench_boost[w],\n                f\"BenchBoost_Contr_2_{i}_{w}\",\n            )\n            self.problem += (\n                actual_bench_boost_points[i][w]\n                &gt;= player_xp * (is_bench_player[i][w] + use_bench_boost[w] - 1),\n                f\"BenchBoost_Contr_3_{i}_{w}\",\n            )\n            self.problem += (\n                actual_bench_boost_points[i][w] &gt;= 0,\n                f\"BenchBoost_Contr_4_{i}_{w}\",\n            )\n\n            # Triple Captain auxiliary variables and constraints\n            # Changed player_xp * 2 to player_xp to reflect additional 1x bonus\n            self.problem += (\n                actual_triple_captain_bonus[i][w] &lt;= player_xp * captain_var[i][w],\n                f\"TripleCaptain_Contr_1_{i}_{w}\",\n            )\n            self.problem += (\n                actual_triple_captain_bonus[i][w]\n                &lt;= player_xp * use_triple_captain[w],\n                f\"TripleCaptain_Contr_2_{i}_{w}\",\n            )\n            self.problem += (\n                actual_triple_captain_bonus[i][w]\n                &gt;= player_xp * (captain_var[i][w] + use_triple_captain[w] - 1),\n                f\"TripleCaptain_Contr_3_{i}_{w}\",\n            )\n            self.problem += (\n                actual_triple_captain_bonus[i][w] &gt;= 0,\n                f\"TripleCaptain_Contr_4_{i}_{w}\",\n            )\n\n        # Add points from bench boost and triple captain bonus for this gameweek\n        total_bench_boost_points_gw = lpSum(\n            actual_bench_boost_points[i][w] for i in self.player_data.index\n        )\n        total_triple_captain_bonus_points_gw = lpSum(\n            actual_triple_captain_bonus[i][w] for i in self.player_data.index\n        )\n\n        total_objective_points.append(total_bench_boost_points_gw)\n        total_objective_points.append(total_triple_captain_bonus_points_gw)\n\n    # Subtract transfer hits from the total objective\n    total_objective_points.append(\n        -POINTS_PER_HIT * lpSum(transfer_hits[w] for w in range(1, num_gameweeks))\n    )\n\n    self.problem += (\n        lpSum(total_objective_points),\n        \"Total Expected Points Over Gameweeks\",\n    )\n\n    # --- Constraints ---\n\n    # Apply constraints for each gameweek\n    for w in range(num_gameweeks):\n        # 1. Select exactly 15 players for the squad\n        self.problem += (\n            lpSum(player_vars[i][w] for i in self.player_data.index) == 15,\n            f\"Total_Players_GW{w}\",\n        )\n\n        # 2. Squad position constraints (2 GKs, 5 DEFs, 5 MIDs, 3 FWDs)\n        gks = self.player_data[self.player_data[\"position\"] == \"GK\"].index\n        defs = self.player_data[self.player_data[\"position\"] == \"DEF\"].index\n        mids = self.player_data[self.player_data[\"position\"] == \"MID\"].index\n        fwds = self.player_data[self.player_data[\"position\"] == \"FWD\"].index\n\n        self.problem += (\n            lpSum(player_vars[i][w] for i in gks) == 2,\n            f\"Goalkeepers_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(player_vars[i][w] for i in defs) == 5,\n            f\"Defenders_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(player_vars[i][w] for i in mids) == 5,\n            f\"Midfielders_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(player_vars[i][w] for i in fwds) == 3,\n            f\"Forwards_Count_GW{w}\",\n        )\n\n        # 3. Budget constraint\n        # This applies to the cost of the squad for the current gameweek.\n        self.problem += (\n            lpSum(\n                self.player_data.loc[i, \"cost\"] * player_vars[i][w]\n                for i in self.player_data.index\n            )\n            &lt;= budget,\n            f\"Total_Budget_GW{w}\",\n        )\n\n        # 4. Maximum players per team constraint\n        for team in self.player_data[\"team\"].unique():\n            team_players = self.player_data[self.player_data[\"team\"] == team].index\n            self.problem += (\n                lpSum(player_vars[i][w] for i in team_players)\n                &lt;= max_players_per_team,\n                f\"Max_Players_from_{team}_GW{w}\",\n            )\n\n        # 5. Starting XI constraints\n        # 5.1 Select exactly 11 players for the starting XI\n        self.problem += (\n            lpSum(starting_xi_vars[i][w] for i in self.player_data.index) == 11,\n            f\"Total_Starting_XI_Players_GW{w}\",\n        )\n\n        # 5.2 A player can only be in the starting XI if they are in the squad\n        for i in self.player_data.index:\n            self.problem += (\n                starting_xi_vars[i][w] &lt;= player_vars[i][w],\n                f\"StartingXI_in_Squad_{i}_{w}\",\n            )\n\n        # 5.3 Starting XI position constraints (FPL allows flexible formations, so use minimums)\n        self.problem += (\n            lpSum(starting_xi_vars[i][w] for i in gks) == 1,\n            f\"Starting_Goalkeepers_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(starting_xi_vars[i][w] for i in defs) &gt;= 3,\n            f\"Min_Starting_Defenders_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(starting_xi_vars[i][w] for i in mids) &gt;= 2,\n            f\"Min_Starting_Midfielders_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(starting_xi_vars[i][w] for i in fwds) &gt;= 1,\n            f\"Min_Starting_Forwards_Count_GW{w}\",\n        )\n\n        # 6. Captain Constraints\n        # 6.1 Select exactly one captain from the starting XI\n        self.problem += (\n            lpSum(captain_var[i][w] for i in self.player_data.index) == 1,\n            f\"One_Captain_GW{w}\",\n        )\n\n        # 6.2 A player can only be captain if they are in the starting XI\n        for i in self.player_data.index:\n            self.problem += (\n                captain_var[i][w] &lt;= starting_xi_vars[i][w],\n                f\"Captain_in_StartingXI_{i}_{w}\",\n            )\n\n        # --- Enforced Player Constraints---\n        for player_idx in self.enforced_player_indices:\n            self.problem += (\n                player_vars[player_idx][w] == 1,\n                f\"Enforce_Player_{self.player_data.loc[player_idx, 'name']}_GW{w}\",\n            )\n\n        for team, position in self.enforced_team_pos_requirements:\n            # Filter players for the current team and position\n            team_pos_players = self.player_data[\n                (self.player_data[\"team\"] == team)\n                &amp; (self.player_data[\"position\"] == position)\n            ].index\n            if not team_pos_players.empty:\n                self.problem += (\n                    lpSum(player_vars[i][w] for i in team_pos_players) &gt;= 1,\n                    f\"Enforce_One_{position}_from_{team}_GW{w}\",\n                )\n            else:\n                print(\n                    f\"Warning: No players found for enforced requirement: at least one {position} from {team} for GW{gw_actual}.\"\n                )\n\n    # --- Chip Usage Constraints (TOTAL usage over all gameweeks) ---\n    # These constraints should be outside the per-gameweek loop to avoid duplicates.\n    self.problem += (\n        lpSum(use_bench_boost[j] for j in range(num_gameweeks))\n        &lt;= chip_allowances.get(\"bench_boost\", 0),\n        f\"Max_Bench_Boost_Usage_Total\",\n    )\n    self.problem += (\n        lpSum(use_triple_captain[j] for j in range(num_gameweeks))\n        &lt;= chip_allowances.get(\"triple_captain\", 0),\n        f\"Max_Triple_Captain_Usage_Total\",\n    )\n\n    # --- Inter-Gameweek Constraints (Transfers and Transfer Rules) ---\n    # Initialize free transfers for GW0 (first gameweek of optimization horizon)\n    # This assumes the optimization starts at GW0, and it has INITIAL_FREE_TRANSFERS.\n    # If the model starts at an arbitrary GW, this would need to be an input.\n    self.problem += (\n        free_transfers_available[0] == INITIAL_FREE_TRANSFERS,\n        f\"Initial_Free_Transfers_GW0\",\n    )\n\n    for w in range(1, num_gameweeks):\n        # Calculate total transfers made in this gameweek\n        self.problem += (\n            transfers_made[w]\n            == lpSum(transfer_in_vars[i][w] for i in self.player_data.index),\n            f\"Transfers_Made_GW{w}\",\n        )\n        # Total transfers in must equal total transfers out for each gameweek after the first\n        self.problem += (\n            lpSum(transfer_in_vars[i][w] for i in self.player_data.index)\n            == lpSum(transfer_out_vars[i][w] for i in self.player_data.index),\n            f\"Transfers_In_Equals_Out_GW{w}\",\n        )\n\n        # Calculate free transfers available for the current gameweek (w)\n        # Free transfers for GW_w = min(free transfers from GW_w-1 - transfers made in GW_w + 1, MAX_FREE_TRANSFERS_SAVED + 1)\n        # The + 1 in MAX_FREE_TRANSFERS_SAVED + 1 is because MAX_FREE_TRANSFERS_SAVED implies how many can be *saved*,\n        # so if you save 1, you have 1 (current) + 1 (saved) = 2.\n        self.problem += (\n            free_transfers_available[w]\n            &lt;= free_transfers_available[w - 1] - transfers_made[w] + 1,\n            f\"Free_Transfers_Calc_1_GW{w}\",\n        )\n        self.problem += (\n            free_transfers_available[w] &lt;= MAX_FREE_TRANSFERS_SAVED + 1,\n            f\"Free_Transfers_Calc_2_GW{w}\",\n        )\n        self.problem += (\n            free_transfers_available[w] &gt;= 0,  # Cannot have negative free transfers\n            f\"Free_Transfers_Non_Negative_GW{w}\",\n        )\n\n        # Calculate transfer hits\n        # transfer_hits[w] = max(0, transfers_made[w] - free_transfers_available_at_start_of_gw_w)\n        # This needs to be linearized. If transfers_made[w] &gt; free_transfers_available[w-1], then hit.\n        # free_transfers_available[w-1] represents transfers available *before* making transfers for GW_w\n        self.problem += (\n            transfer_hits[w] &gt;= transfers_made[w] - free_transfers_available[w - 1],\n            f\"Transfer_Hits_Calc_1_GW{w}\",\n        )\n        self.problem += (\n            transfer_hits[w] &gt;= 0,\n            f\"Transfer_Hits_Calc_2_GW{w}\",\n        )\n\n        for i in self.player_data.index:\n            # Squad continuity: player_vars[i][w] (in squad at start of GW w)\n            #                 = player_vars[i][w-1] (in squad at start of GW w-1)\n            #                 - transfer_out_vars[i][w] (transferred out for GW w)\n            #                 + transfer_in_vars[i][w] (transferred in for GW w)\n            self.problem += (\n                player_vars[i][w]\n                == player_vars[i][w - 1]\n                - transfer_out_vars[i][w]\n                + transfer_in_vars[i][w],\n                f\"Squad_Continuity_{i}_GW{w}\",\n            )\n            # A player cannot be transferred in and out in the same gameweek\n            self.problem += (\n                transfer_in_vars[i][w] + transfer_out_vars[i][w] &lt;= 1,\n                f\"No_Simultaneous_Transfer_{i}_{w}\",\n            )\n\n    try:\n        # The solver is called with the GLPK_CMD solver\n        self.problem.solve(PULP_CBC_CMD(msg=0))  # msg=0 suppresses verbose output\n    except Exception as e:\n        print(f\"Error solving the problem: {e}\")\n        return False\n\n    if LpStatus[self.problem.status] == \"Optimal\":\n        print(\"Optimization successful! Optimal solution found.\")\n\n        self.selected_squad_history = {}\n        self.total_transfer_hits = 0\n        for w in range(num_gameweeks):\n            # The actual gameweek number (1-indexed)\n            gw_actual = current_gameweek_number_start + w\n\n            # Get selected players for the current gameweek\n            selected_squad_gw = self.player_data[\n                [player_vars[i][w].varValue == 1 for i in self.player_data.index]\n            ].copy()\n\n            # Get starter and captain info for this gameweek\n            is_starter_series_gw = pd.Series(\n                [\n                    starting_xi_vars[i][w].varValue == 1\n                    for i in self.player_data.index\n                ],\n                index=self.player_data.index,\n            )\n            is_captain_series_gw = pd.Series(\n                [captain_var[i][w].varValue == 1 for i in self.player_data.index],\n                index=self.player_data.index,\n            )\n\n            selected_squad_gw[\"is_starter\"] = is_starter_series_gw.loc[\n                selected_squad_gw.index\n            ]\n            selected_squad_gw[\"is_captain\"] = is_captain_series_gw.loc[\n                selected_squad_gw.index\n            ]\n\n            transfers_in_gw = 0\n            transfers_out_gw = 0\n            hits_gw = 0\n\n            # Store transfer details for gameweeks &gt; 0\n            if (\n                w &gt; 0\n            ):  # Check for transfers only from GW1 onwards (index 1 in 0-indexed loop)\n                transfer_in_flags = pd.Series(\n                    [\n                        transfer_in_vars[i][w].varValue == 1\n                        for i in self.player_data.index\n                    ],\n                    index=self.player_data.index,\n                )\n                transfer_out_flags = pd.Series(\n                    [\n                        transfer_out_vars[i][w].varValue == 1\n                        for i in self.player_data.index\n                    ],\n                    index=self.player_data.index,\n                )\n\n                selected_squad_gw[\"transfer_in\"] = transfer_in_flags.loc[\n                    selected_squad_gw.index\n                ]\n                selected_squad_gw[\"transfer_out\"] = transfer_out_flags.loc[\n                    selected_squad_gw.index\n                ]\n\n                transfers_in_gw = int(round(transfer_in_flags.sum()))\n                transfers_out_gw = int(round(transfer_out_flags.sum()))\n                hits_gw = int(round(transfer_hits[w].varValue))\n                self.total_transfer_hits += hits_gw\n            else:\n                selected_squad_gw[\"transfer_in\"] = False  # No transfers in for GW0\n                selected_squad_gw[\"transfer_out\"] = (\n                    False  # No transfers out for GW0\n                )\n\n            self.selected_squad_history[f\"GW{gw_actual}\"] = {\n                \"squad\": selected_squad_gw,\n                \"total_cost\": selected_squad_gw[\"cost\"].sum(),\n                \"expected_points_from_xi\": sum(\n                    self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n                    * starting_xi_vars[i][w].varValue\n                    for i in self.player_data.index\n                ),\n                \"bench_boost_used\": bool(use_bench_boost[w].varValue),\n                \"triple_captain_used\": bool(use_triple_captain[w].varValue),\n                \"total_bench_boost_points\": value(\n                    lpSum(\n                        actual_bench_boost_points[i][w]\n                        for i in self.player_data.index\n                    )\n                ),\n                \"total_triple_captain_bonus\": value(\n                    lpSum(\n                        actual_triple_captain_bonus[i][w]\n                        for i in self.player_data.index\n                    )\n                ),\n                \"transfers_in_count\": transfers_in_gw,\n                \"transfers_out_count\": transfers_out_gw,\n                \"transfer_hits\": hits_gw,  # New\n                \"free_transfers_available_next_gw\": (\n                    int(round(free_transfers_available[w].varValue))\n                    if w &lt; num_gameweeks - 1\n                    else 0\n                ),  # Free transfers available *after* this GW's transfers are made\n            }\n\n        # Overall totals\n        self.total_cost = self.selected_squad_history[\n            f\"GW{current_gameweek_number_start + num_gameweeks - 1}\"\n        ][\n            \"total_cost\"\n        ]  # Cost of final squad\n        self.total_expected_points = value(\n            self.problem.objective\n        )  # Total objective value from solver\n        self.used_chips = {\n            f\"GW{current_gameweek_number_start + w}\": {\n                \"bench_boost\": bool(use_bench_boost[w].varValue),\n                \"triple_captain\": bool(use_triple_captain[w].varValue),\n            }\n            for w in range(num_gameweeks)\n        }\n\n        return True\n    else:\n        print(f\"No optimal solution found. Status: {LpStatus[self.problem.status]}\")\n        self.selected_squad_history = {}\n        self.total_cost = 0\n        self.total_expected_points = 0\n        self.used_chips = {}\n        self.total_transfer_hits = 0\n        return False\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/#build.lib.fpl_solver.fpl_xp_predictor","title":"<code>fpl_xp_predictor</code>","text":""},{"location":"autoapi/build/lib/fpl_solver/#build.lib.fpl_solver.fpl_xp_predictor.FPLPredictor","title":"<code>FPLPredictor</code>","text":"<p>Predictive algorithm for Expected Points (xP) in Fantasy Premier League, using real data from the FPL API.</p> Source code in <code>build/lib/fpl_solver/fpl_xp_predictor.py</code> <pre><code>class FPLPredictor:\n    \"\"\"\n    Predictive algorithm for Expected Points (xP) in Fantasy Premier League,\n    using real data from the FPL API.\n    \"\"\"\n\n    def __init__(self, gameweeks_to_predict: int = 1):\n        \"\"\"\n        Initializes the FPLPredictor with default FPL point rules and\n        data structures, then fetches real data and calculates xP for all players.\n\n        Args:\n            gameweeks_to_predict (int): The number of upcoming gameweeks to calculate\n                                        expected points for. Default is 1 (next gameweek).\n        \"\"\"\n        if not isinstance(gameweeks_to_predict, int) or gameweeks_to_predict &lt; 1:\n            raise ValueError(\"gameweeks_to_predict must be a positive integer.\")\n        self.gameweeks_to_predict = gameweeks_to_predict\n\n        self.fpl_points = FPL_POINTS\n\n        self.players_data = {}\n        self.teams_data = {}\n        self.fixtures_data = {}\n        self.position_definitions = {\n            1: \"GK\",\n            2: \"DEF\",\n            3: \"MID\",\n            4: \"FWD\",\n        }\n        self.all_players_xp_calculated_data = (\n            []\n        )  # To store xP for all players for the optimizer\n\n        self._fetch_fpl_data()\n        self._calculate_all_players_xp()  # Calculate xP for all players after data is loaded\n\n    def _fetch_fpl_data(self):\n        \"\"\"Fetches initial data from the FPL API.\"\"\"\n        print(\"Fetching FPL data...\")\n        try:\n            # Fetch general data\n            static_data = requests.get(\n                \"https://fantasy.premierleague.com/api/bootstrap-static/\"\n            ).json()\n            # Fetch fixtures data\n            fixtures_data = requests.get(\n                \"https://fantasy.premierleague.com/api/fixtures/\"\n            ).json()\n\n            # Process players data\n            for element in static_data[\"elements\"]:\n                player_id = element[\"id\"]\n                self.players_data[player_id] = {\n                    \"name\": element[\"first_name\"] + \" \" + element[\"second_name\"],\n                    \"web_name\": element[\"web_name\"],\n                    \"team_id\": element[\"team\"],\n                    \"element_type\": element[\"element_type\"],\n                    \"position\": self.position_definitions.get(\n                        element[\"element_type\"], \"Unknown\"\n                    ),\n                    \"cost_pence\": element[\"now_cost\"],\n                    \"status\": element[\"status\"],\n                    \"news\": element[\"news\"],\n                    \"total_points\": element[\"total_points\"],\n                    \"minutes\": element[\"minutes\"],\n                    \"goals_scored\": element[\"goals_scored\"],\n                    \"assists\": element[\"assists\"],\n                    \"clean_sheets\": element[\"clean_sheets\"],\n                    \"goals_conceded\": element[\"goals_conceded\"],\n                    \"penalties_saved\": element[\"penalties_saved\"],\n                    \"penalties_missed\": element[\"penalties_missed\"],\n                    \"yellow_cards\": element[\"yellow_cards\"],\n                    \"red_cards\": element[\"red_cards\"],\n                    \"own_goals\": element[\"own_goals\"],\n                    \"saves\": element[\"saves\"],\n                    \"bonus\": element[\"bonus\"],\n                    \"bps\": element[\"bps\"],\n                    \"threat\": element[\"threat\"],\n                    \"creativity\": element[\"creativity\"],\n                    \"influence\": element[\"influence\"],\n                    \"form\": float(element[\"form\"]),\n                    \"points_per_game\": float(element[\"points_per_game\"]),\n                    \"value_season\": float(element[\"value_season\"]),\n                    \"value_form\": float(element[\"value_form\"]),\n                    \"ict_index\": float(element[\"ict_index\"]),\n                }\n\n            # --- Apply Player Exclusions ---\n            initial_player_count = len(self.players_data)\n            players_to_keep = {}\n            for player_id, player_info in self.players_data.items():\n                # Exclude by ID\n                if player_id in EXCLUDED_PLAYERS_BY_ID:\n                    print(\n                        f\"Excluding player by ID: {player_info['name']} (ID: {player_id})\"\n                    )\n                    continue\n\n                # Exclude by Name\n                if player_info[\"name\"] in EXCLUDED_PLAYERS_BY_NAME:\n                    print(\n                        f\"Excluding player by Name: {player_info['name']} (ID: {player_id})\"\n                    )\n                    continue\n\n                # Exclude by Team and Position\n                excluded_by_team_pos = False\n                for exclusion_rule in EXCLUDED_PLAYERS_BY_TEAM_AND_POSITION:\n                    team_name = self.teams_data.get(player_info[\"team_id\"], {}).get(\n                        \"name\"\n                    )\n                    if team_name == exclusion_rule.get(\"team\") and player_info[\n                        \"position\"\n                    ] == exclusion_rule.get(\"position\"):\n                        print(\n                            f\"Excluding player by Team/Position: {player_info['name']} ({team_name}, {player_info['position']})\"\n                        )\n                        excluded_by_team_pos = True\n                        break\n                if excluded_by_team_pos:\n                    continue\n\n                players_to_keep[player_id] = player_info\n\n            self.players_data = players_to_keep\n            print(\n                f\"Filtered {initial_player_count - len(self.players_data)} players. Remaining: {len(self.players_data)}\"\n            )\n\n            # Process teams data\n            for team in static_data[\"teams\"]:\n                self.teams_data[team[\"id\"]] = {\n                    \"name\": team[\"name\"],\n                    \"short_name\": team[\"short_name\"],\n                    \"strength\": team[\"strength\"],\n                    \"strength_overall_home\": team[\"strength_overall_home\"],\n                    \"strength_overall_away\": team[\"strength_overall_away\"],\n                    \"strength_attack_home\": team[\"strength_attack_home\"],\n                    \"strength_attack_away\": team[\"strength_attack_away\"],\n                    \"strength_defence_home\": team[\"strength_defence_home\"],\n                    \"strength_defence_away\": team[\"strength_defence_away\"],\n                }\n\n            # Process fixtures data\n            for fixture in fixtures_data:\n                self.fixtures_data[fixture[\"id\"]] = fixture\n\n            print(\"FPL data fetched successfully.\")\n\n        except requests.exceptions.RequestException as e:\n            print(f\"Error fetching FPL data: {e}\")\n            self.players_data = {}\n            self.teams_data = {}\n            self.fixtures_data = {}\n            print(\"Initialization failed due to data fetching error. Exiting.\")\n            sys.exit(1)\n        except Exception as e:\n            print(f\"An unexpected error occurred during data fetching: {e}\")\n            self.players_data = {}\n            self.teams_data = {}\n            self.fixtures_data = {}\n            print(\"Initialization failed due to unexpected error. Exiting.\")\n            sys.exit(1)\n\n    def _get_team_strength(self, team_id, is_home):\n        \"\"\"Get team strength based on home/away status.\"\"\"\n        team = self.teams_data.get(team_id, {})\n        if is_home:\n            return team.get(\"strength_overall_home\", 1000)  # Default if not found\n        return team.get(\"strength_overall_away\", 1000)  # Default if not found\n\n    def _predict_minutes(self, player_id):\n        \"\"\"\n        Predicts expected minutes for a player based on historical data.\n        More sophisticated logic for handling very low minute players.\n        \"\"\"\n        player = self.players_data.get(player_id)\n        if not player:\n            return 0.0\n\n        status = player[\"status\"]\n        news = player[\"news\"].lower()\n        minutes_played = player[\"minutes\"]\n\n        # 1. Unavailable players (injured, suspended, doubtful)\n        if status != \"a\" or any(\n            x in news\n            for x in [\n                \"injured\",\n                \"doubtful\",\n                \"suspension\",\n                \"red card\",\n                \"expected back\",\n            ]\n        ):\n            return 0.0\n\n        # 2. Players with significant minutes (starters/key rotation)\n        if minutes_played &gt;= MIN_MINUTES_THRESHOLD:\n            # Average minutes per game started (assuming most minutes come from starts)\n            # This is a heuristic; real FPL API doesn't give starts directly.\n            # We assume a player with &gt; MIN_MINUTES_THRESHOLD plays ~80-90 minutes when on pitch.\n            # So, (minutes_played / number_of_appearances) is a rough proxy.\n            # For simplicity, let's use a cap of 90 minutes.\n            if player[\"total_points\"] &gt; 0:  # Player has played at least one game\n                avg_minutes_per_appearance = minutes_played / (\n                    player[\"total_points\"] / player[\"points_per_game\"]\n                )\n                return min(avg_minutes_per_appearance, 90.0)\n            return 70.0  # Reasonable default for established player with points but no clear avg\n\n        # 3. Players with very low minutes (rarely play, new, youth)\n        if minutes_played &lt; VERY_LOW_MINUTES_THRESHOLD:\n            # If news suggests they might get a chance, assign default sub minutes.\n            # Otherwise, very low expected minutes or zero.\n            if any(x in news for x in [\"return imminent\", \"close to return\"]):\n                return DEFAULT_SUB_MINUTES  # Might get some minutes\n            return DEFAULT_UNKNOWN_PLAYER_MINUTES  # Very unlikely to play significant minutes\n\n        # 4. Players with some minutes but below significant threshold (regular subs)\n        return DEFAULT_SUB_MINUTES\n\n    def _calculate_expected_goals(self, team_attack_strength, opp_defence_strength):\n        \"\"\"\n        Calculates expected goals for a team based on its attack strength and\n        opponent's defensive strength. This is a simplified heuristic.\n        \"\"\"\n        # A simple ratio model: Higher attack strength and lower opponent defense means more goals\n        # Normalization factor can be adjusted based on average league goals\n        expected_goals = (\n            team_attack_strength / opp_defence_strength\n        ) * 1.5  # 1.5 is an arbitrary scaling factor\n        return max(0.0, expected_goals)\n\n    def _calculate_expected_conceded_goals(\n        self, team_defence_strength, opp_attack_strength\n    ):\n        \"\"\"\n        Calculates expected goals conceded by a team based on its defense strength\n        and opponent's attacking strength.\n        \"\"\"\n        # A simple ratio model: Higher opponent attack and lower team defense means more conceded goals\n        expected_conceded_goals = (\n            opp_attack_strength / team_defence_strength\n        ) * 1.5  # 1.5 is an arbitrary scaling factor\n        return max(0.0, expected_conceded_goals)\n\n    def calculate_xp_for_player(self, player_id, fixture_id):\n        \"\"\"\n        Calculates Expected Points (xP) for a single player in a given fixture.\n        Considers various factors: minutes, goals, assists, clean sheets, saves,\n        bonus points, and negative events, adjusted for fixture difficulty.\n        \"\"\"\n        player = self.players_data.get(player_id)\n        fixture = self.fixtures_data.get(fixture_id)\n\n        if not player or not fixture:\n            return {\"xp\": 0.0, \"reason\": \"Player or fixture data missing.\"}\n\n        # Handle unavailable players\n        if (\n            player[\"status\"] != \"a\"\n        ):  # 'd' for doubtful, 'i' for injured, 's' for suspended\n            return {\"xp\": 0.0, \"reason\": f\"Player status: {player['status']}\"}\n        if any(\n            x in player[\"news\"].lower()\n            for x in [\"injured\", \"doubtful\", \"suspension\", \"red card\"]\n        ):\n            return {\"xp\": 0.0, \"reason\": f\"Player news: {player['news']}\"}\n\n        # Predict minutes\n        expected_minutes = self._predict_minutes(player_id)\n        if expected_minutes &lt; 1.0:  # If expected to play very little or none\n            return {\"xp\": 0.0, \"reason\": \"Expected minutes too low.\"}\n\n        xp = 0.0\n        position = player[\"position\"]\n        # Use 'team_h' for home team ID\n        is_home_fixture = player[\"team_id\"] == fixture[\"team_h\"]\n\n        # Determine attacking and defensive strengths for the fixture\n        player_team_strength_attack = (\n            self.teams_data.get(fixture[\"team_h\"], {}).get(\n                \"strength_attack_home\"\n            )  # Use 'team_h'\n            if is_home_fixture\n            else self.teams_data.get(fixture[\"team_a\"], {}).get(\n                \"strength_attack_away\"\n            )  # Use 'team_a'\n        )\n        player_team_strength_defence = (\n            self.teams_data.get(fixture[\"team_h\"], {}).get(\n                \"strength_defence_home\"\n            )  # Use 'team_h'\n            if is_home_fixture\n            else self.teams_data.get(fixture[\"team_a\"], {}).get(\n                \"strength_defence_away\"\n            )  # Use 'team_a'\n        )\n        opponent_team_strength_attack = (\n            self.teams_data.get(fixture[\"team_a\"], {}).get(\n                \"strength_attack_away\"\n            )  # Use 'team_a'\n            if is_home_fixture\n            else self.teams_data.get(fixture[\"team_h\"], {}).get(\n                \"strength_attack_home\"\n            )  # Use 'team_h'\n        )\n        opponent_team_strength_defence = (\n            self.teams_data.get(fixture[\"team_a\"], {}).get(\n                \"strength_defence_away\"\n            )  # Use 'team_a'\n            if is_home_fixture\n            else self.teams_data.get(fixture[\"team_h\"], {}).get(\n                \"strength_defence_home\"\n            )  # Use 'team_h'\n        )\n\n        if None in [\n            player_team_strength_attack,\n            player_team_strength_defence,\n            opponent_team_strength_attack,\n            opponent_team_strength_defence,\n        ]:\n            # Fallback if strength data is missing (shouldn't happen with robust data fetch)\n            return {\"xp\": 0.0, \"reason\": \"Team strength data missing for fixture.\"}\n\n        # 1. Appearance points\n        if expected_minutes &gt;= 60:\n            xp += self.fpl_points[\"appearance_points_gte_60\"]\n        elif expected_minutes &gt; 0:\n            xp += self.fpl_points[\"appearance_points_lt_60\"]\n\n        # 2. Expected Goals (scaled by historical goals per 90 and opponent difficulty)\n        # Use player's form and total goals as a basis\n        goals_per_90_hist = (\n            (player[\"goals_scored\"] / player[\"minutes\"] * 90)\n            if player[\"minutes\"] &gt; 0\n            else 0.0\n        )\n        expected_team_goals = self._calculate_expected_goals(\n            player_team_strength_attack, opponent_team_strength_defence\n        )\n\n        expected_goals_player_contribution = (\n            (goals_per_90_hist / 90.0) * expected_minutes * (expected_team_goals / 1.5)\n        )  # Scale player's goal contribution by team's expected goals\n\n        if position == \"GK\":\n            xp += expected_goals_player_contribution * self.fpl_points[\"goal_gk\"]\n        elif position == \"DEF\":\n            xp += expected_goals_player_contribution * self.fpl_points[\"goal_def\"]\n        elif position == \"MID\":\n            xp += expected_goals_player_contribution * self.fpl_points[\"goal_mid\"]\n        elif position == \"FWD\":\n            xp += expected_goals_player_contribution * self.fpl_points[\"goal_fwd\"]\n\n        # 3. Expected Assists (scaled by historical assists per 90 and opponent difficulty)\n        assists_per_90_hist = (\n            (player[\"assists\"] / player[\"minutes\"] * 90)\n            if player[\"minutes\"] &gt; 0\n            else 0.0\n        )\n        # Assuming team's attacking strength correlates with assist opportunities\n        expected_assists_player_contribution = (\n            (assists_per_90_hist / 90.0)\n            * expected_minutes\n            * (expected_team_goals / 1.5)\n        )  # Similarly scale by team's expected goals\n        xp += expected_assists_player_contribution * self.fpl_points[\"assist_points\"]\n\n        # 4. Expected Clean Sheets (for GKs/DEFs/MIDs) and Conceded Goals deduction\n        expected_conceded = self._calculate_expected_conceded_goals(\n            player_team_strength_defence, opponent_team_strength_attack\n        )\n\n        # Probability of clean sheet\n        # Simplified: higher team defense / lower opponent attack -&gt; higher CS prob\n        # Use logistic or sigmoid for probability\n        cs_prob = 1.0 / (\n            1.0 + math.exp(expected_conceded - 1.0)\n        )  # Sigmoid centered at 1 goal\n\n        if position in [\"GK\", \"DEF\"]:\n            xp += cs_prob * self.fpl_points[\"clean_sheet_gk_def\"]\n\n            # Conceded goals deduction: Apply penalty for every 2 goals conceded *probability*\n            # For simplicity, calculate expected deduction: (expected_conceded / 2) * deduction\n            xp += (expected_conceded / 2.0) * self.fpl_points[\n                \"conceded_2_goals_deduction\"\n            ]\n        elif position == \"MID\":\n            xp += cs_prob * self.fpl_points[\"clean_sheet_mid\"]\n\n        # 5. Expected Saves (for GKs)\n        if position == \"GK\":\n            saves_per_90_hist = (\n                (player[\"saves\"] / player[\"minutes\"] * 90)\n                if player[\"minutes\"] &gt; 0\n                else 0.0\n            )\n            # Expected saves scaled by opponent's attacking strength (more attacking -&gt; more shots -&gt; more saves)\n            expected_saves_player_contribution = (\n                (saves_per_90_hist / 90.0)\n                * expected_minutes\n                * (opponent_team_strength_attack / player_team_strength_defence)\n            )\n            xp += (expected_saves_player_contribution / 3.0) * self.fpl_points[\n                \"saves_3_points\"\n            ]  # Using the new config point value\n\n            # Penalty saves (low probability, use historical rate)\n            penalty_saves_hist_per_game = (\n                player[\"penalties_saved\"] / (player[\"minutes\"] / 90.0)\n                if player[\"minutes\"] &gt; 0\n                else 0.0\n            )\n            xp += (\n                penalty_saves_hist_per_game\n                * (expected_minutes / 90.0)\n                * self.fpl_points[\"penalty_save_points\"]\n            )\n\n        # 6. Expected Bonus Points\n        # Use BPS (Bonus Points System) as a proxy. Scale player's average BPS by form and expected minutes.\n        bps_per_90_hist = (\n            (player[\"bps\"] / player[\"minutes\"] * 90) if player[\"minutes\"] &gt; 0 else 0.0\n        )\n        expected_bps = (bps_per_90_hist / 90.0) * expected_minutes * player[\"form\"]\n        xp += expected_bps * self.fpl_points[\"bonus_points_scaling_factor\"]\n\n        # 7. Minor Negative Events (Probabilistic)\n        # These are rare, so a simple probability based on expected minutes.\n        xp += (expected_minutes / 90.0) * (\n            self.fpl_points[\"yellow_card_deduction\"] * YELLOW_CARD_PROB\n            + self.fpl_points[\"red_card_deduction\"] * RED_CARD_PROB\n            + self.fpl_points[\"own_goal_deduction\"] * OWN_GOAL_PROB\n            + self.fpl_points[\"penalty_miss_deduction\"] * PENALTY_MISS_PROB\n        )\n\n        # 8. Defensive Contribution Points (for 2025/26 season heuristic)\n        # Assuming CBIT/CBIRT tracking\n        if position in [\"GK\", \"DEF\"]:\n            xp += CBIT_DEF_PROB * self.fpl_points[\"cbit_def_points\"]\n        elif position in [\"MID\", \"FWD\"]:\n            xp += CBIRT_MID_FWD_PROB * self.fpl_points[\"cbirt_mid_fwd_points\"]\n\n        return {\"xp\": round(xp, 2), \"reason\": \"Success\"}\n\n    def _calculate_all_players_xp(self):\n        \"\"\"\n        Calculates the Expected Points (xP) for all players over multiple upcoming gameweeks\n        and populates self.all_players_xp_calculated_data with xP per gameweek.\n        \"\"\"\n        print(\n            f\"Calculating xP for all players over {self.gameweeks_to_predict} gameweek(s)...\"\n        )\n\n        # Get all upcoming fixtures and sort them by gameweek\n        all_upcoming_fixtures_items = sorted(\n            [\n                (fid, fdict)\n                for fid, fdict in self.fixtures_data.items()\n                if not fdict[\"finished\"]\n            ],\n            key=lambda item: item[1][\"event\"],\n        )\n\n        if not all_upcoming_fixtures_items:\n            print(\"No upcoming fixtures found. Cannot calculate xP.\")\n            return\n\n        # Determine the current gameweek (the gameweek of the earliest upcoming fixture)\n        current_gameweek = all_upcoming_fixtures_items[0][1][\"event\"]\n        target_gameweeks = range(\n            current_gameweek, current_gameweek + self.gameweeks_to_predict\n        )\n\n        # Create a mapping of team_id_code to a list of their fixtures within the target gameweeks\n        team_fixtures_in_range = {team_code: [] for team_code in self.teams_data.keys()}\n        for fixture_id, fixture_data in all_upcoming_fixtures_items:\n            if fixture_data[\"event\"] in target_gameweeks:\n                home_team_code = fixture_data[\"team_h\"]\n                away_team_code = fixture_data[\"team_a\"]\n\n                team_fixtures_in_range[home_team_code].append(fixture_id)\n                team_fixtures_in_range[away_team_code].append(fixture_id)\n\n        # Calculate total xP for each player across the specified gameweeks\n        for player_id, player_data in self.players_data.items():\n            player_team_code = player_data[\"team_id\"]\n            player_position = player_data[\"position\"]\n\n            # Calculate xP for each relevant fixture and store by gameweek\n            expected_points_by_gw = {}\n            for fixture_id in team_fixtures_in_range.get(player_team_code, []):\n                fixture_gameweek = self.fixtures_data[fixture_id][\"event\"]\n                xp_result_single_gw = self.calculate_xp_for_player(\n                    player_id, fixture_id\n                )\n                if xp_result_single_gw and xp_result_single_gw[\"xp\"] is not None:\n                    if fixture_gameweek not in expected_points_by_gw:\n                        expected_points_by_gw[fixture_gameweek] = 0.0\n                    expected_points_by_gw[fixture_gameweek] += xp_result_single_gw[\"xp\"]\n\n            # Ensure all target gameweeks are present, even if xP is 0 for a given GW\n            for gw in target_gameweeks:\n                if gw not in expected_points_by_gw:\n                    expected_points_by_gw[gw] = 0.0\n\n            # Sort the dictionary by gameweek for consistent output\n            expected_points_by_gw = dict(sorted(expected_points_by_gw.items()))\n\n            # Prepare data for the optimizer\n            player_cost_m = player_data[\"cost_pence\"] / 10.0\n            team_name_full = self.teams_data.get(player_team_code, {}).get(\n                \"name\", \"Unknown Team\"\n            )\n\n            self.all_players_xp_calculated_data.append(\n                {\n                    \"name\": player_data[\"name\"],\n                    \"web_name\": player_data[\"web_name\"],\n                    \"team\": team_name_full,\n                    \"position\": player_position,\n                    \"cost\": player_cost_m,\n                    \"expected_points_by_gw\": expected_points_by_gw,  # Changed key and format\n                }\n            )\n        print(\"xP calculation for all players complete.\")\n\n    def get_upcoming_fixtures(self, limit=None):\n        \"\"\"\n        Returns a list of upcoming fixtures, sorted by gameweek and kickoff time.\n        Optionally limits the number of fixtures returned.\n        \"\"\"\n        upcoming = []\n        now = datetime.now()\n\n        # Sort all fixtures by gameweek and then by kickoff time\n        sorted_fixtures = sorted(\n            self.fixtures_data.values(),\n            key=lambda x: (\n                x.get(\"event\", 0),\n                x.get(\"kickoff_time\", \"9999-12-31T00:00:00Z\"),\n            ),\n        )\n\n        current_gameweek = None\n        for fixture_data in sorted_fixtures:\n            # Determine current gameweek from the earliest upcoming fixture\n            if not fixture_data[\"finished\"] and current_gameweek is None:\n                current_gameweek = fixture_data.get(\"event\", 0)\n\n            # Filter for upcoming fixtures within the prediction horizon\n            if (\n                fixture_data.get(\"event\", 0) &lt; current_gameweek  # Skip past gameweeks\n                or fixture_data.get(\"event\", 0)\n                &gt;= current_gameweek + self.gameweeks_to_predict\n            ):\n                continue  # Skip fixtures outside the prediction horizon\n\n            home_team_name = self.teams_data.get(\n                fixture_data[\"team_h\"], {}\n            ).get(  # Use 'team_h'\n                \"name\", \"Unknown\"\n            )\n            away_team_name = self.teams_data.get(\n                fixture_data[\"team_a\"], {}\n            ).get(  # Use 'team_a'\n                \"name\", \"Unknown\"\n            )\n\n            # Only add fixtures that are not finished\n            if not fixture_data[\"finished\"]:\n                upcoming.append(\n                    {\n                        \"fixture_id\": fixture_data[\"id\"],\n                        \"gameweek\": fixture_data.get(\"event\"),\n                        \"home_team_id\": fixture_data[\"team_h\"],  # Use 'team_h'\n                        \"away_team_id\": fixture_data[\"team_a\"],  # Use 'team_a'\n                        \"match\": f\"{home_team_name} vs {away_team_name}\",\n                        \"kickoff_time\": fixture_data.get(\"kickoff_time\"),\n                        \"home_team_difficulty\": fixture_data[\"team_h_difficulty\"],\n                        \"away_team_difficulty\": fixture_data[\"team_a_difficulty\"],\n                    }\n                )\n            if limit is not None and len(upcoming) &gt;= limit:\n                break\n        return upcoming\n\n    def get_players_for_optimizer(self):\n        \"\"\"\n        Returns the list of player data with calculated xP per gameweek,\n        formatted for the FPLOptimizer.\n        \"\"\"\n        return self.all_players_xp_calculated_data\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/#build.lib.fpl_solver.fpl_xp_predictor.FPLPredictor.__init__","title":"<code>__init__(gameweeks_to_predict=1)</code>","text":"<p>Initializes the FPLPredictor with default FPL point rules and data structures, then fetches real data and calculates xP for all players.</p> <p>Parameters:</p> Name Type Description Default <code>gameweeks_to_predict</code> <code>int</code> <p>The number of upcoming gameweeks to calculate                         expected points for. Default is 1 (next gameweek).</p> <code>1</code> Source code in <code>build/lib/fpl_solver/fpl_xp_predictor.py</code> <pre><code>def __init__(self, gameweeks_to_predict: int = 1):\n    \"\"\"\n    Initializes the FPLPredictor with default FPL point rules and\n    data structures, then fetches real data and calculates xP for all players.\n\n    Args:\n        gameweeks_to_predict (int): The number of upcoming gameweeks to calculate\n                                    expected points for. Default is 1 (next gameweek).\n    \"\"\"\n    if not isinstance(gameweeks_to_predict, int) or gameweeks_to_predict &lt; 1:\n        raise ValueError(\"gameweeks_to_predict must be a positive integer.\")\n    self.gameweeks_to_predict = gameweeks_to_predict\n\n    self.fpl_points = FPL_POINTS\n\n    self.players_data = {}\n    self.teams_data = {}\n    self.fixtures_data = {}\n    self.position_definitions = {\n        1: \"GK\",\n        2: \"DEF\",\n        3: \"MID\",\n        4: \"FWD\",\n    }\n    self.all_players_xp_calculated_data = (\n        []\n    )  # To store xP for all players for the optimizer\n\n    self._fetch_fpl_data()\n    self._calculate_all_players_xp()  # Calculate xP for all players after data is loaded\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/#build.lib.fpl_solver.fpl_xp_predictor.FPLPredictor.calculate_xp_for_player","title":"<code>calculate_xp_for_player(player_id, fixture_id)</code>","text":"<p>Calculates Expected Points (xP) for a single player in a given fixture. Considers various factors: minutes, goals, assists, clean sheets, saves, bonus points, and negative events, adjusted for fixture difficulty.</p> Source code in <code>build/lib/fpl_solver/fpl_xp_predictor.py</code> <pre><code>def calculate_xp_for_player(self, player_id, fixture_id):\n    \"\"\"\n    Calculates Expected Points (xP) for a single player in a given fixture.\n    Considers various factors: minutes, goals, assists, clean sheets, saves,\n    bonus points, and negative events, adjusted for fixture difficulty.\n    \"\"\"\n    player = self.players_data.get(player_id)\n    fixture = self.fixtures_data.get(fixture_id)\n\n    if not player or not fixture:\n        return {\"xp\": 0.0, \"reason\": \"Player or fixture data missing.\"}\n\n    # Handle unavailable players\n    if (\n        player[\"status\"] != \"a\"\n    ):  # 'd' for doubtful, 'i' for injured, 's' for suspended\n        return {\"xp\": 0.0, \"reason\": f\"Player status: {player['status']}\"}\n    if any(\n        x in player[\"news\"].lower()\n        for x in [\"injured\", \"doubtful\", \"suspension\", \"red card\"]\n    ):\n        return {\"xp\": 0.0, \"reason\": f\"Player news: {player['news']}\"}\n\n    # Predict minutes\n    expected_minutes = self._predict_minutes(player_id)\n    if expected_minutes &lt; 1.0:  # If expected to play very little or none\n        return {\"xp\": 0.0, \"reason\": \"Expected minutes too low.\"}\n\n    xp = 0.0\n    position = player[\"position\"]\n    # Use 'team_h' for home team ID\n    is_home_fixture = player[\"team_id\"] == fixture[\"team_h\"]\n\n    # Determine attacking and defensive strengths for the fixture\n    player_team_strength_attack = (\n        self.teams_data.get(fixture[\"team_h\"], {}).get(\n            \"strength_attack_home\"\n        )  # Use 'team_h'\n        if is_home_fixture\n        else self.teams_data.get(fixture[\"team_a\"], {}).get(\n            \"strength_attack_away\"\n        )  # Use 'team_a'\n    )\n    player_team_strength_defence = (\n        self.teams_data.get(fixture[\"team_h\"], {}).get(\n            \"strength_defence_home\"\n        )  # Use 'team_h'\n        if is_home_fixture\n        else self.teams_data.get(fixture[\"team_a\"], {}).get(\n            \"strength_defence_away\"\n        )  # Use 'team_a'\n    )\n    opponent_team_strength_attack = (\n        self.teams_data.get(fixture[\"team_a\"], {}).get(\n            \"strength_attack_away\"\n        )  # Use 'team_a'\n        if is_home_fixture\n        else self.teams_data.get(fixture[\"team_h\"], {}).get(\n            \"strength_attack_home\"\n        )  # Use 'team_h'\n    )\n    opponent_team_strength_defence = (\n        self.teams_data.get(fixture[\"team_a\"], {}).get(\n            \"strength_defence_away\"\n        )  # Use 'team_a'\n        if is_home_fixture\n        else self.teams_data.get(fixture[\"team_h\"], {}).get(\n            \"strength_defence_home\"\n        )  # Use 'team_h'\n    )\n\n    if None in [\n        player_team_strength_attack,\n        player_team_strength_defence,\n        opponent_team_strength_attack,\n        opponent_team_strength_defence,\n    ]:\n        # Fallback if strength data is missing (shouldn't happen with robust data fetch)\n        return {\"xp\": 0.0, \"reason\": \"Team strength data missing for fixture.\"}\n\n    # 1. Appearance points\n    if expected_minutes &gt;= 60:\n        xp += self.fpl_points[\"appearance_points_gte_60\"]\n    elif expected_minutes &gt; 0:\n        xp += self.fpl_points[\"appearance_points_lt_60\"]\n\n    # 2. Expected Goals (scaled by historical goals per 90 and opponent difficulty)\n    # Use player's form and total goals as a basis\n    goals_per_90_hist = (\n        (player[\"goals_scored\"] / player[\"minutes\"] * 90)\n        if player[\"minutes\"] &gt; 0\n        else 0.0\n    )\n    expected_team_goals = self._calculate_expected_goals(\n        player_team_strength_attack, opponent_team_strength_defence\n    )\n\n    expected_goals_player_contribution = (\n        (goals_per_90_hist / 90.0) * expected_minutes * (expected_team_goals / 1.5)\n    )  # Scale player's goal contribution by team's expected goals\n\n    if position == \"GK\":\n        xp += expected_goals_player_contribution * self.fpl_points[\"goal_gk\"]\n    elif position == \"DEF\":\n        xp += expected_goals_player_contribution * self.fpl_points[\"goal_def\"]\n    elif position == \"MID\":\n        xp += expected_goals_player_contribution * self.fpl_points[\"goal_mid\"]\n    elif position == \"FWD\":\n        xp += expected_goals_player_contribution * self.fpl_points[\"goal_fwd\"]\n\n    # 3. Expected Assists (scaled by historical assists per 90 and opponent difficulty)\n    assists_per_90_hist = (\n        (player[\"assists\"] / player[\"minutes\"] * 90)\n        if player[\"minutes\"] &gt; 0\n        else 0.0\n    )\n    # Assuming team's attacking strength correlates with assist opportunities\n    expected_assists_player_contribution = (\n        (assists_per_90_hist / 90.0)\n        * expected_minutes\n        * (expected_team_goals / 1.5)\n    )  # Similarly scale by team's expected goals\n    xp += expected_assists_player_contribution * self.fpl_points[\"assist_points\"]\n\n    # 4. Expected Clean Sheets (for GKs/DEFs/MIDs) and Conceded Goals deduction\n    expected_conceded = self._calculate_expected_conceded_goals(\n        player_team_strength_defence, opponent_team_strength_attack\n    )\n\n    # Probability of clean sheet\n    # Simplified: higher team defense / lower opponent attack -&gt; higher CS prob\n    # Use logistic or sigmoid for probability\n    cs_prob = 1.0 / (\n        1.0 + math.exp(expected_conceded - 1.0)\n    )  # Sigmoid centered at 1 goal\n\n    if position in [\"GK\", \"DEF\"]:\n        xp += cs_prob * self.fpl_points[\"clean_sheet_gk_def\"]\n\n        # Conceded goals deduction: Apply penalty for every 2 goals conceded *probability*\n        # For simplicity, calculate expected deduction: (expected_conceded / 2) * deduction\n        xp += (expected_conceded / 2.0) * self.fpl_points[\n            \"conceded_2_goals_deduction\"\n        ]\n    elif position == \"MID\":\n        xp += cs_prob * self.fpl_points[\"clean_sheet_mid\"]\n\n    # 5. Expected Saves (for GKs)\n    if position == \"GK\":\n        saves_per_90_hist = (\n            (player[\"saves\"] / player[\"minutes\"] * 90)\n            if player[\"minutes\"] &gt; 0\n            else 0.0\n        )\n        # Expected saves scaled by opponent's attacking strength (more attacking -&gt; more shots -&gt; more saves)\n        expected_saves_player_contribution = (\n            (saves_per_90_hist / 90.0)\n            * expected_minutes\n            * (opponent_team_strength_attack / player_team_strength_defence)\n        )\n        xp += (expected_saves_player_contribution / 3.0) * self.fpl_points[\n            \"saves_3_points\"\n        ]  # Using the new config point value\n\n        # Penalty saves (low probability, use historical rate)\n        penalty_saves_hist_per_game = (\n            player[\"penalties_saved\"] / (player[\"minutes\"] / 90.0)\n            if player[\"minutes\"] &gt; 0\n            else 0.0\n        )\n        xp += (\n            penalty_saves_hist_per_game\n            * (expected_minutes / 90.0)\n            * self.fpl_points[\"penalty_save_points\"]\n        )\n\n    # 6. Expected Bonus Points\n    # Use BPS (Bonus Points System) as a proxy. Scale player's average BPS by form and expected minutes.\n    bps_per_90_hist = (\n        (player[\"bps\"] / player[\"minutes\"] * 90) if player[\"minutes\"] &gt; 0 else 0.0\n    )\n    expected_bps = (bps_per_90_hist / 90.0) * expected_minutes * player[\"form\"]\n    xp += expected_bps * self.fpl_points[\"bonus_points_scaling_factor\"]\n\n    # 7. Minor Negative Events (Probabilistic)\n    # These are rare, so a simple probability based on expected minutes.\n    xp += (expected_minutes / 90.0) * (\n        self.fpl_points[\"yellow_card_deduction\"] * YELLOW_CARD_PROB\n        + self.fpl_points[\"red_card_deduction\"] * RED_CARD_PROB\n        + self.fpl_points[\"own_goal_deduction\"] * OWN_GOAL_PROB\n        + self.fpl_points[\"penalty_miss_deduction\"] * PENALTY_MISS_PROB\n    )\n\n    # 8. Defensive Contribution Points (for 2025/26 season heuristic)\n    # Assuming CBIT/CBIRT tracking\n    if position in [\"GK\", \"DEF\"]:\n        xp += CBIT_DEF_PROB * self.fpl_points[\"cbit_def_points\"]\n    elif position in [\"MID\", \"FWD\"]:\n        xp += CBIRT_MID_FWD_PROB * self.fpl_points[\"cbirt_mid_fwd_points\"]\n\n    return {\"xp\": round(xp, 2), \"reason\": \"Success\"}\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/#build.lib.fpl_solver.fpl_xp_predictor.FPLPredictor.get_players_for_optimizer","title":"<code>get_players_for_optimizer()</code>","text":"<p>Returns the list of player data with calculated xP per gameweek, formatted for the FPLOptimizer.</p> Source code in <code>build/lib/fpl_solver/fpl_xp_predictor.py</code> <pre><code>def get_players_for_optimizer(self):\n    \"\"\"\n    Returns the list of player data with calculated xP per gameweek,\n    formatted for the FPLOptimizer.\n    \"\"\"\n    return self.all_players_xp_calculated_data\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/#build.lib.fpl_solver.fpl_xp_predictor.FPLPredictor.get_upcoming_fixtures","title":"<code>get_upcoming_fixtures(limit=None)</code>","text":"<p>Returns a list of upcoming fixtures, sorted by gameweek and kickoff time. Optionally limits the number of fixtures returned.</p> Source code in <code>build/lib/fpl_solver/fpl_xp_predictor.py</code> <pre><code>def get_upcoming_fixtures(self, limit=None):\n    \"\"\"\n    Returns a list of upcoming fixtures, sorted by gameweek and kickoff time.\n    Optionally limits the number of fixtures returned.\n    \"\"\"\n    upcoming = []\n    now = datetime.now()\n\n    # Sort all fixtures by gameweek and then by kickoff time\n    sorted_fixtures = sorted(\n        self.fixtures_data.values(),\n        key=lambda x: (\n            x.get(\"event\", 0),\n            x.get(\"kickoff_time\", \"9999-12-31T00:00:00Z\"),\n        ),\n    )\n\n    current_gameweek = None\n    for fixture_data in sorted_fixtures:\n        # Determine current gameweek from the earliest upcoming fixture\n        if not fixture_data[\"finished\"] and current_gameweek is None:\n            current_gameweek = fixture_data.get(\"event\", 0)\n\n        # Filter for upcoming fixtures within the prediction horizon\n        if (\n            fixture_data.get(\"event\", 0) &lt; current_gameweek  # Skip past gameweeks\n            or fixture_data.get(\"event\", 0)\n            &gt;= current_gameweek + self.gameweeks_to_predict\n        ):\n            continue  # Skip fixtures outside the prediction horizon\n\n        home_team_name = self.teams_data.get(\n            fixture_data[\"team_h\"], {}\n        ).get(  # Use 'team_h'\n            \"name\", \"Unknown\"\n        )\n        away_team_name = self.teams_data.get(\n            fixture_data[\"team_a\"], {}\n        ).get(  # Use 'team_a'\n            \"name\", \"Unknown\"\n        )\n\n        # Only add fixtures that are not finished\n        if not fixture_data[\"finished\"]:\n            upcoming.append(\n                {\n                    \"fixture_id\": fixture_data[\"id\"],\n                    \"gameweek\": fixture_data.get(\"event\"),\n                    \"home_team_id\": fixture_data[\"team_h\"],  # Use 'team_h'\n                    \"away_team_id\": fixture_data[\"team_a\"],  # Use 'team_a'\n                    \"match\": f\"{home_team_name} vs {away_team_name}\",\n                    \"kickoff_time\": fixture_data.get(\"kickoff_time\"),\n                    \"home_team_difficulty\": fixture_data[\"team_h_difficulty\"],\n                    \"away_team_difficulty\": fixture_data[\"team_a_difficulty\"],\n                }\n            )\n        if limit is not None and len(upcoming) &gt;= limit:\n            break\n    return upcoming\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/fpl_config/","title":"fpl_config","text":"<p>fpl_config.py</p> <p>Configuration settings for the FPL Expected Points Predictor and Solver. This file centralizes all constants related to FPL scoring, thresholds, and optimization parameters.</p>"},{"location":"autoapi/build/lib/fpl_solver/fpl_solver/","title":"fpl_solver","text":""},{"location":"autoapi/build/lib/fpl_solver/fpl_solver/#build.lib.fpl_solver.fpl_solver.FPLOptimizer","title":"<code>FPLOptimizer</code>","text":"<p>A class to optimize Fantasy Premier League (FPL) squad selection using Integer Linear Programming (ILP).</p> <p>The optimizer aims to select a 15-player squad (2 GKs, 5 DEFs, 5 MIDs, 3 FWDs) within a budget, with a maximum number of players from any single team, to maximize the total expected points.</p> Source code in <code>build/lib/fpl_solver/fpl_solver.py</code> <pre><code>class FPLOptimizer:\n    \"\"\"\n    A class to optimize Fantasy Premier League (FPL) squad selection\n    using Integer Linear Programming (ILP).\n\n    The optimizer aims to select a 15-player squad (2 GKs, 5 DEFs, 5 MIDs, 3 FWDs)\n    within a budget, with a maximum number of players from any single team,\n    to maximize the total expected points.\n    \"\"\"\n\n    def __init__(self, player_data: pd.DataFrame):\n        \"\"\"\n        Initializes the FPLOptimizer with player data.\n\n        Args:\n            player_data (pd.DataFrame): A DataFrame containing player information\n                                        with columns: 'name', 'team', 'position',\n                                        'cost', 'expected_points_by_gw' (a dict of xP per GW).\n        \"\"\"\n        required_columns = [\"name\", \"team\", \"position\", \"cost\", \"expected_points_by_gw\"]\n        if not all(col in player_data.columns for col in required_columns):\n            missing_cols = [\n                col for col in required_columns if col not in player_data.columns\n            ]\n            raise ValueError(\n                f\"player_data DataFrame must contain {required_columns} columns. Missing: {missing_cols}\"\n            )\n\n        self.player_data = player_data\n        self.problem = None\n        self.selected_squad_history = {}  # To store squad for each gameweek\n        self.total_cost = 0\n        self.total_expected_points = 0\n        self.total_transfer_hits = 0\n\n        # --- Process Enforced Players ---\n        self.enforced_player_indices = set()\n        self.enforced_team_pos_requirements = []\n\n        print(\"\\n--- Processing Enforced Players ---\")\n\n        # Enforce by Player ID\n        for player_id in ENFORCED_PLAYERS_BY_ID:\n            found_player = self.player_data[self.player_data[\"id\"] == player_id]\n            if not found_player.empty:\n                player_idx = found_player.index[0]\n                self.enforced_player_indices.add(player_idx)\n                print(\n                    f\"Enforcing player by ID: {found_player.loc[player_idx, 'name']} (ID: {player_id})\"\n                )\n            else:\n                print(\n                    f\"Warning: Enforced player with ID {player_id} not found in data.\"\n                )\n\n        # Enforce by Player Name\n        for player_name in ENFORCED_PLAYERS_BY_NAME:\n            found_player = self.player_data[self.player_data[\"name\"] == player_name]\n            if not found_player.empty:\n                player_idx = found_player.index[0]\n                self.enforced_player_indices.add(player_idx)\n                print(f\"Enforcing player by name: {player_name}\")\n            else:\n                print(f\"Warning: Enforced player '{player_name}' not found in data.\")\n\n        # Enforce by Team and Position\n        for requirement in ENFORCED_PLAYERS_BY_TEAM_AND_POSITION:\n            team = requirement.get(\"team\")\n            position = requirement.get(\"position\")\n            if team and position:\n                # Validate team and position exist in data\n                if team not in self.player_data[\"team\"].unique():\n                    print(\n                        f\"Warning: Enforced team '{team}' for position '{position}' not found in data.\"\n                    )\n                    continue\n                if position not in self.player_data[\"position\"].unique():\n                    print(\n                        f\"Warning: Enforced position '{position}' for team '{team}' not found in data.\"\n                    )\n                    continue\n\n                self.enforced_team_pos_requirements.append((team, position))\n                print(f\"Enforcing at least one {position} from {team}.\")\n            else:\n                print(\n                    f\"Warning: Invalid enforced team/position requirement: {requirement}\"\n                )\n\n        if not (\n            self.enforced_player_indices\n            or self.enforced_team_pos_requirements\n            or ENFORCED_PLAYERS_BY_ID\n            or ENFORCED_PLAYERS_BY_NAME\n            or ENFORCED_PLAYERS_BY_TEAM_AND_POSITION\n        ):\n            print(\"No players or team/position combinations are enforced.\")\n        print(\"-----------------------------------\\n\")\n\n    def solve(\n        self,\n        budget: float,\n        max_players_per_team: int,\n        chip_allowances: dict,\n        num_gameweeks: int,\n    ) -&gt; bool:\n        \"\"\"\n        Solves the FPL optimization problem using PuLP.\n\n        Args:\n            budget (float): The maximum budget in millions of pounds.\n            max_players_per_team (int): The maximum number of players allowed from\n                                        any single Premier League team.\n            chip_allowances (dict): A dictionary specifying the maximum usage for each chip.\n            num_gameweeks (int): The number of gameweeks to optimize over.\n\n        Returns:\n            bool: True if a solution was found, False otherwise.\n        \"\"\"\n        self.problem = LpProblem(\"FPL Squad Multi-Week Optimization\", LpMaximize)\n\n        # Decision variables for player selection, indexed by player and gameweek\n        player_vars = LpVariable.dicts(\n            \"Player\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n        )\n        starting_xi_vars = LpVariable.dicts(\n            \"StartingXI\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n        )\n        captain_var = LpVariable.dicts(\n            \"Captain\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n        )\n\n        # Binary variables for chip usage, indexed by gameweek\n        use_bench_boost = LpVariable.dicts(\n            \"Use_Bench_Boost\", range(num_gameweeks), 0, 1, LpBinary\n        )\n        use_triple_captain = LpVariable.dicts(\n            \"Use_Triple_Captain\", range(num_gameweeks), 0, 1, LpBinary\n        )\n\n        # Transfer variables\n        transfer_in_vars = LpVariable.dicts(\n            \"Transfer_In\",\n            (self.player_data.index, range(1, num_gameweeks)),\n            0,\n            1,\n            LpBinary,\n        )\n        transfer_out_vars = LpVariable.dicts(\n            \"Transfer_Out\",\n            (self.player_data.index, range(1, num_gameweeks)),\n            0,\n            1,\n            LpBinary,\n        )\n\n        # Total transfers made in a gameweek (absolute count)\n        transfers_made = LpVariable.dicts(\n            \"Transfers_Made\", range(1, num_gameweeks), 0, None, LpInteger\n        )\n        # Free transfers available at the start of a gameweek\n        free_transfers_available = LpVariable.dicts(\n            \"Free_Transfers_Available\",\n            range(num_gameweeks),\n            0,\n            MAX_FREE_TRANSFERS_SAVED + 1,\n            LpInteger,\n        )\n        # Number of transfer hits taken in a gameweek\n        transfer_hits = LpVariable.dicts(\n            \"Transfer_Hits\", range(1, num_gameweeks), 0, None, LpInteger\n        )\n\n        # Auxiliary variables for linearizing chip effects\n        is_bench_player = LpVariable.dicts(\n            \"Is_Bench_Player\",\n            (self.player_data.index, range(num_gameweeks)),\n            0,\n            1,\n            LpBinary,\n        )\n        actual_bench_boost_points = LpVariable.dicts(\n            \"Actual_Bench_Boost_Points\",\n            (self.player_data.index, range(num_gameweeks)),\n            0,\n            None,\n            LpContinuous,\n        )\n        actual_triple_captain_bonus = LpVariable.dicts(\n            \"Actual_Triple_Captain_Bonus\",\n            (self.player_data.index, range(num_gameweeks)),\n            0,\n            None,\n            LpContinuous,\n        )\n\n        # --- Objective Function ---\n        total_objective_points = []\n\n        # Get the first gameweek number from the player data to correctly index expected_points_by_gw\n        first_gw_key = next(\n            iter(\n                self.player_data.loc[\n                    self.player_data.index[0], \"expected_points_by_gw\"\n                ].keys()\n            )\n        )\n        current_gameweek_number_start = int(first_gw_key)\n\n        for w in range(num_gameweeks):\n            # The actual gameweek number (1-indexed)\n            gw_actual = current_gameweek_number_start + w\n\n            # Base expected points from the selected starting 11 for this gameweek\n            base_points_expression_gw = lpSum(\n                self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n                * starting_xi_vars[i][w]\n                for i in self.player_data.index\n            )\n            total_objective_points.append(base_points_expression_gw)\n\n            # Regular Captaincy points (additional 1x for captain)\n            captain_points_bonus_gw = lpSum(\n                self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n                * captain_var[i][w]\n                for i in self.player_data.index\n            )\n            total_objective_points.append(captain_points_bonus_gw)\n\n            # Define auxiliary variables and constraints for chips for each gameweek\n            for i in self.player_data.index:\n                # Use gameweek-specific player xP for chip calculations\n                player_xp = self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n\n                # Bench Boost auxiliary variables and constraints\n                self.problem += (\n                    is_bench_player[i][w] &lt;= player_vars[i][w],\n                    f\"IsBench_Squad_{i}_{w}\",\n                )\n                self.problem += (\n                    is_bench_player[i][w] &lt;= 1 - starting_xi_vars[i][w],\n                    f\"IsBench_NotStarter_{i}_{w}\",\n                )\n                self.problem += (\n                    is_bench_player[i][w]\n                    &gt;= player_vars[i][w] + (1 - starting_xi_vars[i][w]) - 1,\n                    f\"IsBench_Logical_{i}_{w}\",\n                )\n\n                self.problem += (\n                    actual_bench_boost_points[i][w]\n                    &lt;= player_xp * is_bench_player[i][w],\n                    f\"BenchBoost_Contr_1_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_bench_boost_points[i][w] &lt;= player_xp * use_bench_boost[w],\n                    f\"BenchBoost_Contr_2_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_bench_boost_points[i][w]\n                    &gt;= player_xp * (is_bench_player[i][w] + use_bench_boost[w] - 1),\n                    f\"BenchBoost_Contr_3_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_bench_boost_points[i][w] &gt;= 0,\n                    f\"BenchBoost_Contr_4_{i}_{w}\",\n                )\n\n                # Triple Captain auxiliary variables and constraints\n                # Changed player_xp * 2 to player_xp to reflect additional 1x bonus\n                self.problem += (\n                    actual_triple_captain_bonus[i][w] &lt;= player_xp * captain_var[i][w],\n                    f\"TripleCaptain_Contr_1_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_triple_captain_bonus[i][w]\n                    &lt;= player_xp * use_triple_captain[w],\n                    f\"TripleCaptain_Contr_2_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_triple_captain_bonus[i][w]\n                    &gt;= player_xp * (captain_var[i][w] + use_triple_captain[w] - 1),\n                    f\"TripleCaptain_Contr_3_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_triple_captain_bonus[i][w] &gt;= 0,\n                    f\"TripleCaptain_Contr_4_{i}_{w}\",\n                )\n\n            # Add points from bench boost and triple captain bonus for this gameweek\n            total_bench_boost_points_gw = lpSum(\n                actual_bench_boost_points[i][w] for i in self.player_data.index\n            )\n            total_triple_captain_bonus_points_gw = lpSum(\n                actual_triple_captain_bonus[i][w] for i in self.player_data.index\n            )\n\n            total_objective_points.append(total_bench_boost_points_gw)\n            total_objective_points.append(total_triple_captain_bonus_points_gw)\n\n        # Subtract transfer hits from the total objective\n        total_objective_points.append(\n            -POINTS_PER_HIT * lpSum(transfer_hits[w] for w in range(1, num_gameweeks))\n        )\n\n        self.problem += (\n            lpSum(total_objective_points),\n            \"Total Expected Points Over Gameweeks\",\n        )\n\n        # --- Constraints ---\n\n        # Apply constraints for each gameweek\n        for w in range(num_gameweeks):\n            # 1. Select exactly 15 players for the squad\n            self.problem += (\n                lpSum(player_vars[i][w] for i in self.player_data.index) == 15,\n                f\"Total_Players_GW{w}\",\n            )\n\n            # 2. Squad position constraints (2 GKs, 5 DEFs, 5 MIDs, 3 FWDs)\n            gks = self.player_data[self.player_data[\"position\"] == \"GK\"].index\n            defs = self.player_data[self.player_data[\"position\"] == \"DEF\"].index\n            mids = self.player_data[self.player_data[\"position\"] == \"MID\"].index\n            fwds = self.player_data[self.player_data[\"position\"] == \"FWD\"].index\n\n            self.problem += (\n                lpSum(player_vars[i][w] for i in gks) == 2,\n                f\"Goalkeepers_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(player_vars[i][w] for i in defs) == 5,\n                f\"Defenders_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(player_vars[i][w] for i in mids) == 5,\n                f\"Midfielders_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(player_vars[i][w] for i in fwds) == 3,\n                f\"Forwards_Count_GW{w}\",\n            )\n\n            # 3. Budget constraint\n            # This applies to the cost of the squad for the current gameweek.\n            self.problem += (\n                lpSum(\n                    self.player_data.loc[i, \"cost\"] * player_vars[i][w]\n                    for i in self.player_data.index\n                )\n                &lt;= budget,\n                f\"Total_Budget_GW{w}\",\n            )\n\n            # 4. Maximum players per team constraint\n            for team in self.player_data[\"team\"].unique():\n                team_players = self.player_data[self.player_data[\"team\"] == team].index\n                self.problem += (\n                    lpSum(player_vars[i][w] for i in team_players)\n                    &lt;= max_players_per_team,\n                    f\"Max_Players_from_{team}_GW{w}\",\n                )\n\n            # 5. Starting XI constraints\n            # 5.1 Select exactly 11 players for the starting XI\n            self.problem += (\n                lpSum(starting_xi_vars[i][w] for i in self.player_data.index) == 11,\n                f\"Total_Starting_XI_Players_GW{w}\",\n            )\n\n            # 5.2 A player can only be in the starting XI if they are in the squad\n            for i in self.player_data.index:\n                self.problem += (\n                    starting_xi_vars[i][w] &lt;= player_vars[i][w],\n                    f\"StartingXI_in_Squad_{i}_{w}\",\n                )\n\n            # 5.3 Starting XI position constraints (FPL allows flexible formations, so use minimums)\n            self.problem += (\n                lpSum(starting_xi_vars[i][w] for i in gks) == 1,\n                f\"Starting_Goalkeepers_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(starting_xi_vars[i][w] for i in defs) &gt;= 3,\n                f\"Min_Starting_Defenders_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(starting_xi_vars[i][w] for i in mids) &gt;= 2,\n                f\"Min_Starting_Midfielders_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(starting_xi_vars[i][w] for i in fwds) &gt;= 1,\n                f\"Min_Starting_Forwards_Count_GW{w}\",\n            )\n\n            # 6. Captain Constraints\n            # 6.1 Select exactly one captain from the starting XI\n            self.problem += (\n                lpSum(captain_var[i][w] for i in self.player_data.index) == 1,\n                f\"One_Captain_GW{w}\",\n            )\n\n            # 6.2 A player can only be captain if they are in the starting XI\n            for i in self.player_data.index:\n                self.problem += (\n                    captain_var[i][w] &lt;= starting_xi_vars[i][w],\n                    f\"Captain_in_StartingXI_{i}_{w}\",\n                )\n\n            # --- Enforced Player Constraints---\n            for player_idx in self.enforced_player_indices:\n                self.problem += (\n                    player_vars[player_idx][w] == 1,\n                    f\"Enforce_Player_{self.player_data.loc[player_idx, 'name']}_GW{w}\",\n                )\n\n            for team, position in self.enforced_team_pos_requirements:\n                # Filter players for the current team and position\n                team_pos_players = self.player_data[\n                    (self.player_data[\"team\"] == team)\n                    &amp; (self.player_data[\"position\"] == position)\n                ].index\n                if not team_pos_players.empty:\n                    self.problem += (\n                        lpSum(player_vars[i][w] for i in team_pos_players) &gt;= 1,\n                        f\"Enforce_One_{position}_from_{team}_GW{w}\",\n                    )\n                else:\n                    print(\n                        f\"Warning: No players found for enforced requirement: at least one {position} from {team} for GW{gw_actual}.\"\n                    )\n\n        # --- Chip Usage Constraints (TOTAL usage over all gameweeks) ---\n        # These constraints should be outside the per-gameweek loop to avoid duplicates.\n        self.problem += (\n            lpSum(use_bench_boost[j] for j in range(num_gameweeks))\n            &lt;= chip_allowances.get(\"bench_boost\", 0),\n            f\"Max_Bench_Boost_Usage_Total\",\n        )\n        self.problem += (\n            lpSum(use_triple_captain[j] for j in range(num_gameweeks))\n            &lt;= chip_allowances.get(\"triple_captain\", 0),\n            f\"Max_Triple_Captain_Usage_Total\",\n        )\n\n        # --- Inter-Gameweek Constraints (Transfers and Transfer Rules) ---\n        # Initialize free transfers for GW0 (first gameweek of optimization horizon)\n        # This assumes the optimization starts at GW0, and it has INITIAL_FREE_TRANSFERS.\n        # If the model starts at an arbitrary GW, this would need to be an input.\n        self.problem += (\n            free_transfers_available[0] == INITIAL_FREE_TRANSFERS,\n            f\"Initial_Free_Transfers_GW0\",\n        )\n\n        for w in range(1, num_gameweeks):\n            # Calculate total transfers made in this gameweek\n            self.problem += (\n                transfers_made[w]\n                == lpSum(transfer_in_vars[i][w] for i in self.player_data.index),\n                f\"Transfers_Made_GW{w}\",\n            )\n            # Total transfers in must equal total transfers out for each gameweek after the first\n            self.problem += (\n                lpSum(transfer_in_vars[i][w] for i in self.player_data.index)\n                == lpSum(transfer_out_vars[i][w] for i in self.player_data.index),\n                f\"Transfers_In_Equals_Out_GW{w}\",\n            )\n\n            # Calculate free transfers available for the current gameweek (w)\n            # Free transfers for GW_w = min(free transfers from GW_w-1 - transfers made in GW_w + 1, MAX_FREE_TRANSFERS_SAVED + 1)\n            # The + 1 in MAX_FREE_TRANSFERS_SAVED + 1 is because MAX_FREE_TRANSFERS_SAVED implies how many can be *saved*,\n            # so if you save 1, you have 1 (current) + 1 (saved) = 2.\n            self.problem += (\n                free_transfers_available[w]\n                &lt;= free_transfers_available[w - 1] - transfers_made[w] + 1,\n                f\"Free_Transfers_Calc_1_GW{w}\",\n            )\n            self.problem += (\n                free_transfers_available[w] &lt;= MAX_FREE_TRANSFERS_SAVED + 1,\n                f\"Free_Transfers_Calc_2_GW{w}\",\n            )\n            self.problem += (\n                free_transfers_available[w] &gt;= 0,  # Cannot have negative free transfers\n                f\"Free_Transfers_Non_Negative_GW{w}\",\n            )\n\n            # Calculate transfer hits\n            # transfer_hits[w] = max(0, transfers_made[w] - free_transfers_available_at_start_of_gw_w)\n            # This needs to be linearized. If transfers_made[w] &gt; free_transfers_available[w-1], then hit.\n            # free_transfers_available[w-1] represents transfers available *before* making transfers for GW_w\n            self.problem += (\n                transfer_hits[w] &gt;= transfers_made[w] - free_transfers_available[w - 1],\n                f\"Transfer_Hits_Calc_1_GW{w}\",\n            )\n            self.problem += (\n                transfer_hits[w] &gt;= 0,\n                f\"Transfer_Hits_Calc_2_GW{w}\",\n            )\n\n            for i in self.player_data.index:\n                # Squad continuity: player_vars[i][w] (in squad at start of GW w)\n                #                 = player_vars[i][w-1] (in squad at start of GW w-1)\n                #                 - transfer_out_vars[i][w] (transferred out for GW w)\n                #                 + transfer_in_vars[i][w] (transferred in for GW w)\n                self.problem += (\n                    player_vars[i][w]\n                    == player_vars[i][w - 1]\n                    - transfer_out_vars[i][w]\n                    + transfer_in_vars[i][w],\n                    f\"Squad_Continuity_{i}_GW{w}\",\n                )\n                # A player cannot be transferred in and out in the same gameweek\n                self.problem += (\n                    transfer_in_vars[i][w] + transfer_out_vars[i][w] &lt;= 1,\n                    f\"No_Simultaneous_Transfer_{i}_{w}\",\n                )\n\n        try:\n            # The solver is called with the GLPK_CMD solver\n            self.problem.solve(PULP_CBC_CMD(msg=0))  # msg=0 suppresses verbose output\n        except Exception as e:\n            print(f\"Error solving the problem: {e}\")\n            return False\n\n        if LpStatus[self.problem.status] == \"Optimal\":\n            print(\"Optimization successful! Optimal solution found.\")\n\n            self.selected_squad_history = {}\n            self.total_transfer_hits = 0\n            for w in range(num_gameweeks):\n                # The actual gameweek number (1-indexed)\n                gw_actual = current_gameweek_number_start + w\n\n                # Get selected players for the current gameweek\n                selected_squad_gw = self.player_data[\n                    [player_vars[i][w].varValue == 1 for i in self.player_data.index]\n                ].copy()\n\n                # Get starter and captain info for this gameweek\n                is_starter_series_gw = pd.Series(\n                    [\n                        starting_xi_vars[i][w].varValue == 1\n                        for i in self.player_data.index\n                    ],\n                    index=self.player_data.index,\n                )\n                is_captain_series_gw = pd.Series(\n                    [captain_var[i][w].varValue == 1 for i in self.player_data.index],\n                    index=self.player_data.index,\n                )\n\n                selected_squad_gw[\"is_starter\"] = is_starter_series_gw.loc[\n                    selected_squad_gw.index\n                ]\n                selected_squad_gw[\"is_captain\"] = is_captain_series_gw.loc[\n                    selected_squad_gw.index\n                ]\n\n                transfers_in_gw = 0\n                transfers_out_gw = 0\n                hits_gw = 0\n\n                # Store transfer details for gameweeks &gt; 0\n                if (\n                    w &gt; 0\n                ):  # Check for transfers only from GW1 onwards (index 1 in 0-indexed loop)\n                    transfer_in_flags = pd.Series(\n                        [\n                            transfer_in_vars[i][w].varValue == 1\n                            for i in self.player_data.index\n                        ],\n                        index=self.player_data.index,\n                    )\n                    transfer_out_flags = pd.Series(\n                        [\n                            transfer_out_vars[i][w].varValue == 1\n                            for i in self.player_data.index\n                        ],\n                        index=self.player_data.index,\n                    )\n\n                    selected_squad_gw[\"transfer_in\"] = transfer_in_flags.loc[\n                        selected_squad_gw.index\n                    ]\n                    selected_squad_gw[\"transfer_out\"] = transfer_out_flags.loc[\n                        selected_squad_gw.index\n                    ]\n\n                    transfers_in_gw = int(round(transfer_in_flags.sum()))\n                    transfers_out_gw = int(round(transfer_out_flags.sum()))\n                    hits_gw = int(round(transfer_hits[w].varValue))\n                    self.total_transfer_hits += hits_gw\n                else:\n                    selected_squad_gw[\"transfer_in\"] = False  # No transfers in for GW0\n                    selected_squad_gw[\"transfer_out\"] = (\n                        False  # No transfers out for GW0\n                    )\n\n                self.selected_squad_history[f\"GW{gw_actual}\"] = {\n                    \"squad\": selected_squad_gw,\n                    \"total_cost\": selected_squad_gw[\"cost\"].sum(),\n                    \"expected_points_from_xi\": sum(\n                        self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n                        * starting_xi_vars[i][w].varValue\n                        for i in self.player_data.index\n                    ),\n                    \"bench_boost_used\": bool(use_bench_boost[w].varValue),\n                    \"triple_captain_used\": bool(use_triple_captain[w].varValue),\n                    \"total_bench_boost_points\": value(\n                        lpSum(\n                            actual_bench_boost_points[i][w]\n                            for i in self.player_data.index\n                        )\n                    ),\n                    \"total_triple_captain_bonus\": value(\n                        lpSum(\n                            actual_triple_captain_bonus[i][w]\n                            for i in self.player_data.index\n                        )\n                    ),\n                    \"transfers_in_count\": transfers_in_gw,\n                    \"transfers_out_count\": transfers_out_gw,\n                    \"transfer_hits\": hits_gw,  # New\n                    \"free_transfers_available_next_gw\": (\n                        int(round(free_transfers_available[w].varValue))\n                        if w &lt; num_gameweeks - 1\n                        else 0\n                    ),  # Free transfers available *after* this GW's transfers are made\n                }\n\n            # Overall totals\n            self.total_cost = self.selected_squad_history[\n                f\"GW{current_gameweek_number_start + num_gameweeks - 1}\"\n            ][\n                \"total_cost\"\n            ]  # Cost of final squad\n            self.total_expected_points = value(\n                self.problem.objective\n            )  # Total objective value from solver\n            self.used_chips = {\n                f\"GW{current_gameweek_number_start + w}\": {\n                    \"bench_boost\": bool(use_bench_boost[w].varValue),\n                    \"triple_captain\": bool(use_triple_captain[w].varValue),\n                }\n                for w in range(num_gameweeks)\n            }\n\n            return True\n        else:\n            print(f\"No optimal solution found. Status: {LpStatus[self.problem.status]}\")\n            self.selected_squad_history = {}\n            self.total_cost = 0\n            self.total_expected_points = 0\n            self.used_chips = {}\n            self.total_transfer_hits = 0\n            return False\n\n    def get_selected_squad(self, gameweek: int = None) -&gt; pd.DataFrame | None:\n        \"\"\"\n        Returns the selected squad for a specific gameweek (1-indexed).\n        If no gameweek is specified, returns the squad for the last optimized gameweek.\n        \"\"\"\n        if not self.selected_squad_history:\n            return None\n\n        # Get the first GW key to determine the range of available GWs\n        first_gw_in_history = min(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n        last_gw_in_history = max(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n\n        if gameweek is None:\n            return self.selected_squad_history[f\"GW{last_gw_in_history}\"][\"squad\"]\n\n        if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n            print(\n                f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n            )\n            return None\n\n        return self.selected_squad_history.get(f\"GW{gameweek}\", {}).get(\"squad\")\n\n    def get_total_cost(self, gameweek: int = None) -&gt; float:\n        \"\"\"\n        Returns the total cost for a specific gameweek (1-indexed).\n        If no gameweek is specified, returns the cost of the squad in the last optimized gameweek.\n        \"\"\"\n        if not self.selected_squad_history:\n            return 0\n        first_gw_in_history = min(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n        last_gw_in_history = max(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n\n        if gameweek is None:\n            return self.selected_squad_history[f\"GW{last_gw_in_history}\"][\"total_cost\"]\n\n        if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n            print(\n                f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n            )\n            return 0  # Or raise an error\n\n        return self.selected_squad_history.get(f\"GW{gameweek}\", {}).get(\"total_cost\", 0)\n\n    def get_total_expected_points(self) -&gt; float:\n        \"\"\"\n        Returns the overall total expected points across all optimized gameweeks.\n        \"\"\"\n        return self.total_expected_points\n\n    def get_gameweek_summary(self, gameweek: int):\n        \"\"\"\n        Returns a dictionary summary for a specific gameweek.\n        \"\"\"\n        if not self.selected_squad_history:\n            return None\n        first_gw_in_history = min(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n        last_gw_in_history = max(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n\n        if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n            print(\n                f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n            )\n            return None\n\n        return self.selected_squad_history.get(f\"GW{gameweek}\")\n\n    def print_squad_summary(self, gameweek: int):\n        \"\"\"\n        Prints a formatted summary of the selected squad for a specific gameweek.\n        \"\"\"\n        if not self.selected_squad_history:\n            print(\"No squad has been selected yet. Run the 'solve' method first.\")\n            return\n\n        gw_data = self.get_gameweek_summary(gameweek)\n        if not gw_data:\n            return  # get_gameweek_summary already prints error message\n\n        selected_squad = gw_data[\"squad\"]\n        total_cost = gw_data[\"total_cost\"]\n        expected_points_from_xi = gw_data[\"expected_points_from_xi\"]\n        bench_boost_used = gw_data[\"bench_boost_used\"]\n        triple_captain_used = gw_data[\"triple_captain_used\"]\n        total_bench_boost_points = gw_data[\"total_bench_boost_points\"]\n        total_triple_captain_bonus = gw_data[\"total_triple_captain_bonus\"]\n        transfers_in_count = gw_data[\"transfers_in_count\"]  # New\n        transfers_out_count = gw_data[\"transfers_out_count\"]  # New\n        transfer_hits_taken = gw_data[\"transfer_hits\"]  # New\n        free_transfers_available_next_gw = gw_data[\n            \"free_transfers_available_next_gw\"\n        ]  # New\n\n        print(f\"\\n--- FPL Optimized Squad for Gameweek {gameweek} ---\")\n        print(f\"Squad Cost: \u00a3{total_cost:.1f}m\")\n        print(f\"Expected Points (Starting XI): {expected_points_from_xi:.2f}\")\n        print(\n            f\"Total Expected Points for GW{gameweek} (including chips): {expected_points_from_xi + total_bench_boost_points + total_triple_captain_bonus:.2f}\"\n        )\n        print(\"\\n--- Chips Used This Gameweek ---\")\n        if bench_boost_used:\n            print(f\"- Bench Boost (Added {total_bench_boost_points:.2f} points)\")\n        if triple_captain_used:\n            print(\n                f\"- Triple Captain (Added {total_triple_captain_bonus:.2f} bonus points)\"\n            )\n        if not (bench_boost_used or triple_captain_used):\n            print(\"No chips used this gameweek.\")\n\n        print(\"\\n--- Goalkeepers (Starting XI marked with *) ---\")\n        for index, row in selected_squad[selected_squad[\"position\"] == \"GK\"].iterrows():\n            starter_str = \"*\" if row[\"is_starter\"] else \"\"\n            captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n            transfer_status = \"\"\n            if row[\"transfer_in\"]:\n                transfer_status = \"(IN)\"\n            elif row[\"transfer_out\"]:\n                transfer_status = \"(OUT)\"\n\n            # Access gameweek-specific xP correctly\n            player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n            print(\n                f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n            )\n        print(\"\\n--- Defenders (Starting XI marked with *) ---\")\n        for index, row in selected_squad[\n            selected_squad[\"position\"] == \"DEF\"\n        ].iterrows():\n            starter_str = \"*\" if row[\"is_starter\"] else \"\"\n            captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n            transfer_status = \"\"\n            if row[\"transfer_in\"]:\n                transfer_status = \"(IN)\"\n            elif row[\"transfer_out\"]:\n                transfer_status = \"(OUT)\"\n\n            player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n            print(\n                f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n            )\n        print(\"\\n--- Midfielders (Starting XI marked with *) ---\")\n        for index, row in selected_squad[\n            selected_squad[\"position\"] == \"MID\"\n        ].iterrows():\n            starter_str = \"*\" if row[\"is_starter\"] else \"\"\n            captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n            transfer_status = \"\"\n            if row[\"transfer_in\"]:\n                transfer_status = \"(IN)\"\n            elif row[\"transfer_out\"]:\n                transfer_status = \"(OUT)\"\n\n            player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n            print(\n                f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n            )\n        print(\"\\n--- Forwards (Starting XI marked with *) ---\")\n        for index, row in selected_squad[\n            selected_squad[\"position\"] == \"FWD\"\n        ].iterrows():\n            starter_str = \"*\" if row[\"is_starter\"] else \"\"\n            captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n            transfer_status = \"\"\n            if row[\"transfer_in\"]:\n                transfer_status = \"(IN)\"\n            elif row[\"transfer_out\"]:\n                transfer_status = \"(OUT)\"\n\n            player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n            print(\n                f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n            )\n\n        print(f\"\\n--- Team Breakdown for GW{gameweek} ---\")\n        print(selected_squad[\"team\"].value_counts())\n\n        # Transfers are relevant from Gameweek 2 (index 1) onwards in the optimization horizon\n        # For display, if the current GW is the initial one (GW1 in the current context), no transfers are made\n        # If it's a subsequent GW, check if transfers occurred.\n        first_gw_in_history = min(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n        if (\n            gameweek &gt;= first_gw_in_history\n        ):  # Changed from &gt; to &gt;=, to show initial free transfers\n            # Display transfer info for this gameweek\n            print(\n                f\"  Transfers In: {transfers_in_count}, Transfers Out: {transfers_out_count}\"\n            )\n            print(\n                f\"  Transfer Hits: {transfer_hits_taken} (-{transfer_hits_taken * POINTS_PER_HIT} points)\"\n            )\n            # Only show free transfers for the *next* gameweek if it's not the last gameweek in the horizon\n            if gameweek &lt; max(\n                int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n            ):\n                print(\n                    f\"  Free Transfers Available for Next GW: {free_transfers_available_next_gw}\"\n                )\n        print(\"---------------------------\\n\")\n\n    def print_overall_summary(self):\n        \"\"\"\n        Prints an overall summary of the multi-week optimization results.\n        \"\"\"\n        if not self.selected_squad_history:\n            print(\"No optimization results to summarize.\")\n            return\n\n        print(\"\\n=== Overall Multi-Week FPL Optimization Summary ===\")\n        print(\n            f\"Total Expected Points Across All Gameweeks: {self.total_expected_points:.2f}\"\n        )\n\n        # Get the latest gameweek's cost\n        last_gw_key = max(\n            self.selected_squad_history.keys(), key=lambda k: int(k.replace(\"GW\", \"\"))\n        )\n        print(\n            f\"Squad Cost ({last_gw_key}): \u00a3{self.selected_squad_history[last_gw_key]['total_cost']:.1f}m\"\n        )\n        print(\n            f\"Total Transfer Hits Taken: {self.total_transfer_hits} (-{self.total_transfer_hits * POINTS_PER_HIT} points)\"\n        )\n\n        print(\"\\n--- Chip Usage Across Gameweeks ---\")\n        # Ensure consistent order by sorting gameweek keys\n        sorted_gw_keys = sorted(\n            self.used_chips.keys(), key=lambda k: int(k.replace(\"GW\", \"\"))\n        )\n        for gw_str in sorted_gw_keys:\n            chips = self.used_chips[gw_str]\n            chip_summary = []\n            if chips[\"bench_boost\"]:\n                chip_summary.append(\"Bench Boost\")\n            if chips[\"triple_captain\"]:\n                chip_summary.append(\"Triple Captain\")\n\n            if chip_summary:\n                print(f\"{gw_str}: {', '.join(chip_summary)}\")\n            else:\n                print(f\"{gw_str}: No chips used\")\n\n        print(\"\\n--- Gameweek-by-Gameweek Summary ---\")\n        # Iterate and print basic summary for each gameweek\n        for gw_str in sorted_gw_keys:\n            gw_data = self.selected_squad_history[gw_str]\n            print(f\"\\n--- {gw_str} ---\")\n            print(f\"  Squad Cost: \u00a3{gw_data['total_cost']:.1f}m\")\n            print(\n                f\"  Expected Points (Starting XI): {gw_data['expected_points_from_xi']:.2f}\"\n            )\n            print(\n                f\"  Total GW Points (incl. chips): {gw_data['expected_points_from_xi'] + gw_data['total_bench_boost_points'] + gw_data['total_triple_captain_bonus']:.2f}\"\n            )\n\n            # Display transfer info for this gameweek\n            transfers_in_count = gw_data[\"transfers_in_count\"]\n            transfers_out_count = gw_data[\"transfers_out_count\"]\n            transfer_hits_taken = gw_data[\"transfer_hits\"]\n            free_transfers_available_next_gw = gw_data[\n                \"free_transfers_available_next_gw\"\n            ]\n\n            print(\n                f\"  Transfers In: {transfers_in_count}, Transfers Out: {transfers_out_count}\"\n            )\n            print(\n                f\"  Transfer Hits: {transfer_hits_taken} (-{transfer_hits_taken * POINTS_PER_HIT} points)\"\n            )\n            # Only show free transfers for the *next* gameweek if it's not the last gameweek in the horizon\n            if int(gw_str.replace(\"GW\", \"\")) &lt; max(\n                int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n            ):\n                print(\n                    f\"  Free Transfers Available for Next GW: {free_transfers_available_next_gw}\"\n                )\n            print(\"-----------------------------------\")\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/fpl_solver/#build.lib.fpl_solver.fpl_solver.FPLOptimizer.__init__","title":"<code>__init__(player_data)</code>","text":"<p>Initializes the FPLOptimizer with player data.</p> <p>Parameters:</p> Name Type Description Default <code>player_data</code> <code>DataFrame</code> <p>A DataFrame containing player information                         with columns: 'name', 'team', 'position',                         'cost', 'expected_points_by_gw' (a dict of xP per GW).</p> required Source code in <code>build/lib/fpl_solver/fpl_solver.py</code> <pre><code>def __init__(self, player_data: pd.DataFrame):\n    \"\"\"\n    Initializes the FPLOptimizer with player data.\n\n    Args:\n        player_data (pd.DataFrame): A DataFrame containing player information\n                                    with columns: 'name', 'team', 'position',\n                                    'cost', 'expected_points_by_gw' (a dict of xP per GW).\n    \"\"\"\n    required_columns = [\"name\", \"team\", \"position\", \"cost\", \"expected_points_by_gw\"]\n    if not all(col in player_data.columns for col in required_columns):\n        missing_cols = [\n            col for col in required_columns if col not in player_data.columns\n        ]\n        raise ValueError(\n            f\"player_data DataFrame must contain {required_columns} columns. Missing: {missing_cols}\"\n        )\n\n    self.player_data = player_data\n    self.problem = None\n    self.selected_squad_history = {}  # To store squad for each gameweek\n    self.total_cost = 0\n    self.total_expected_points = 0\n    self.total_transfer_hits = 0\n\n    # --- Process Enforced Players ---\n    self.enforced_player_indices = set()\n    self.enforced_team_pos_requirements = []\n\n    print(\"\\n--- Processing Enforced Players ---\")\n\n    # Enforce by Player ID\n    for player_id in ENFORCED_PLAYERS_BY_ID:\n        found_player = self.player_data[self.player_data[\"id\"] == player_id]\n        if not found_player.empty:\n            player_idx = found_player.index[0]\n            self.enforced_player_indices.add(player_idx)\n            print(\n                f\"Enforcing player by ID: {found_player.loc[player_idx, 'name']} (ID: {player_id})\"\n            )\n        else:\n            print(\n                f\"Warning: Enforced player with ID {player_id} not found in data.\"\n            )\n\n    # Enforce by Player Name\n    for player_name in ENFORCED_PLAYERS_BY_NAME:\n        found_player = self.player_data[self.player_data[\"name\"] == player_name]\n        if not found_player.empty:\n            player_idx = found_player.index[0]\n            self.enforced_player_indices.add(player_idx)\n            print(f\"Enforcing player by name: {player_name}\")\n        else:\n            print(f\"Warning: Enforced player '{player_name}' not found in data.\")\n\n    # Enforce by Team and Position\n    for requirement in ENFORCED_PLAYERS_BY_TEAM_AND_POSITION:\n        team = requirement.get(\"team\")\n        position = requirement.get(\"position\")\n        if team and position:\n            # Validate team and position exist in data\n            if team not in self.player_data[\"team\"].unique():\n                print(\n                    f\"Warning: Enforced team '{team}' for position '{position}' not found in data.\"\n                )\n                continue\n            if position not in self.player_data[\"position\"].unique():\n                print(\n                    f\"Warning: Enforced position '{position}' for team '{team}' not found in data.\"\n                )\n                continue\n\n            self.enforced_team_pos_requirements.append((team, position))\n            print(f\"Enforcing at least one {position} from {team}.\")\n        else:\n            print(\n                f\"Warning: Invalid enforced team/position requirement: {requirement}\"\n            )\n\n    if not (\n        self.enforced_player_indices\n        or self.enforced_team_pos_requirements\n        or ENFORCED_PLAYERS_BY_ID\n        or ENFORCED_PLAYERS_BY_NAME\n        or ENFORCED_PLAYERS_BY_TEAM_AND_POSITION\n    ):\n        print(\"No players or team/position combinations are enforced.\")\n    print(\"-----------------------------------\\n\")\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/fpl_solver/#build.lib.fpl_solver.fpl_solver.FPLOptimizer.get_gameweek_summary","title":"<code>get_gameweek_summary(gameweek)</code>","text":"<p>Returns a dictionary summary for a specific gameweek.</p> Source code in <code>build/lib/fpl_solver/fpl_solver.py</code> <pre><code>def get_gameweek_summary(self, gameweek: int):\n    \"\"\"\n    Returns a dictionary summary for a specific gameweek.\n    \"\"\"\n    if not self.selected_squad_history:\n        return None\n    first_gw_in_history = min(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n    last_gw_in_history = max(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n\n    if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n        print(\n            f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n        )\n        return None\n\n    return self.selected_squad_history.get(f\"GW{gameweek}\")\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/fpl_solver/#build.lib.fpl_solver.fpl_solver.FPLOptimizer.get_selected_squad","title":"<code>get_selected_squad(gameweek=None)</code>","text":"<p>Returns the selected squad for a specific gameweek (1-indexed). If no gameweek is specified, returns the squad for the last optimized gameweek.</p> Source code in <code>build/lib/fpl_solver/fpl_solver.py</code> <pre><code>def get_selected_squad(self, gameweek: int = None) -&gt; pd.DataFrame | None:\n    \"\"\"\n    Returns the selected squad for a specific gameweek (1-indexed).\n    If no gameweek is specified, returns the squad for the last optimized gameweek.\n    \"\"\"\n    if not self.selected_squad_history:\n        return None\n\n    # Get the first GW key to determine the range of available GWs\n    first_gw_in_history = min(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n    last_gw_in_history = max(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n\n    if gameweek is None:\n        return self.selected_squad_history[f\"GW{last_gw_in_history}\"][\"squad\"]\n\n    if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n        print(\n            f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n        )\n        return None\n\n    return self.selected_squad_history.get(f\"GW{gameweek}\", {}).get(\"squad\")\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/fpl_solver/#build.lib.fpl_solver.fpl_solver.FPLOptimizer.get_total_cost","title":"<code>get_total_cost(gameweek=None)</code>","text":"<p>Returns the total cost for a specific gameweek (1-indexed). If no gameweek is specified, returns the cost of the squad in the last optimized gameweek.</p> Source code in <code>build/lib/fpl_solver/fpl_solver.py</code> <pre><code>def get_total_cost(self, gameweek: int = None) -&gt; float:\n    \"\"\"\n    Returns the total cost for a specific gameweek (1-indexed).\n    If no gameweek is specified, returns the cost of the squad in the last optimized gameweek.\n    \"\"\"\n    if not self.selected_squad_history:\n        return 0\n    first_gw_in_history = min(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n    last_gw_in_history = max(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n\n    if gameweek is None:\n        return self.selected_squad_history[f\"GW{last_gw_in_history}\"][\"total_cost\"]\n\n    if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n        print(\n            f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n        )\n        return 0  # Or raise an error\n\n    return self.selected_squad_history.get(f\"GW{gameweek}\", {}).get(\"total_cost\", 0)\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/fpl_solver/#build.lib.fpl_solver.fpl_solver.FPLOptimizer.get_total_expected_points","title":"<code>get_total_expected_points()</code>","text":"<p>Returns the overall total expected points across all optimized gameweeks.</p> Source code in <code>build/lib/fpl_solver/fpl_solver.py</code> <pre><code>def get_total_expected_points(self) -&gt; float:\n    \"\"\"\n    Returns the overall total expected points across all optimized gameweeks.\n    \"\"\"\n    return self.total_expected_points\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/fpl_solver/#build.lib.fpl_solver.fpl_solver.FPLOptimizer.print_overall_summary","title":"<code>print_overall_summary()</code>","text":"<p>Prints an overall summary of the multi-week optimization results.</p> Source code in <code>build/lib/fpl_solver/fpl_solver.py</code> <pre><code>def print_overall_summary(self):\n    \"\"\"\n    Prints an overall summary of the multi-week optimization results.\n    \"\"\"\n    if not self.selected_squad_history:\n        print(\"No optimization results to summarize.\")\n        return\n\n    print(\"\\n=== Overall Multi-Week FPL Optimization Summary ===\")\n    print(\n        f\"Total Expected Points Across All Gameweeks: {self.total_expected_points:.2f}\"\n    )\n\n    # Get the latest gameweek's cost\n    last_gw_key = max(\n        self.selected_squad_history.keys(), key=lambda k: int(k.replace(\"GW\", \"\"))\n    )\n    print(\n        f\"Squad Cost ({last_gw_key}): \u00a3{self.selected_squad_history[last_gw_key]['total_cost']:.1f}m\"\n    )\n    print(\n        f\"Total Transfer Hits Taken: {self.total_transfer_hits} (-{self.total_transfer_hits * POINTS_PER_HIT} points)\"\n    )\n\n    print(\"\\n--- Chip Usage Across Gameweeks ---\")\n    # Ensure consistent order by sorting gameweek keys\n    sorted_gw_keys = sorted(\n        self.used_chips.keys(), key=lambda k: int(k.replace(\"GW\", \"\"))\n    )\n    for gw_str in sorted_gw_keys:\n        chips = self.used_chips[gw_str]\n        chip_summary = []\n        if chips[\"bench_boost\"]:\n            chip_summary.append(\"Bench Boost\")\n        if chips[\"triple_captain\"]:\n            chip_summary.append(\"Triple Captain\")\n\n        if chip_summary:\n            print(f\"{gw_str}: {', '.join(chip_summary)}\")\n        else:\n            print(f\"{gw_str}: No chips used\")\n\n    print(\"\\n--- Gameweek-by-Gameweek Summary ---\")\n    # Iterate and print basic summary for each gameweek\n    for gw_str in sorted_gw_keys:\n        gw_data = self.selected_squad_history[gw_str]\n        print(f\"\\n--- {gw_str} ---\")\n        print(f\"  Squad Cost: \u00a3{gw_data['total_cost']:.1f}m\")\n        print(\n            f\"  Expected Points (Starting XI): {gw_data['expected_points_from_xi']:.2f}\"\n        )\n        print(\n            f\"  Total GW Points (incl. chips): {gw_data['expected_points_from_xi'] + gw_data['total_bench_boost_points'] + gw_data['total_triple_captain_bonus']:.2f}\"\n        )\n\n        # Display transfer info for this gameweek\n        transfers_in_count = gw_data[\"transfers_in_count\"]\n        transfers_out_count = gw_data[\"transfers_out_count\"]\n        transfer_hits_taken = gw_data[\"transfer_hits\"]\n        free_transfers_available_next_gw = gw_data[\n            \"free_transfers_available_next_gw\"\n        ]\n\n        print(\n            f\"  Transfers In: {transfers_in_count}, Transfers Out: {transfers_out_count}\"\n        )\n        print(\n            f\"  Transfer Hits: {transfer_hits_taken} (-{transfer_hits_taken * POINTS_PER_HIT} points)\"\n        )\n        # Only show free transfers for the *next* gameweek if it's not the last gameweek in the horizon\n        if int(gw_str.replace(\"GW\", \"\")) &lt; max(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        ):\n            print(\n                f\"  Free Transfers Available for Next GW: {free_transfers_available_next_gw}\"\n            )\n        print(\"-----------------------------------\")\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/fpl_solver/#build.lib.fpl_solver.fpl_solver.FPLOptimizer.print_squad_summary","title":"<code>print_squad_summary(gameweek)</code>","text":"<p>Prints a formatted summary of the selected squad for a specific gameweek.</p> Source code in <code>build/lib/fpl_solver/fpl_solver.py</code> <pre><code>def print_squad_summary(self, gameweek: int):\n    \"\"\"\n    Prints a formatted summary of the selected squad for a specific gameweek.\n    \"\"\"\n    if not self.selected_squad_history:\n        print(\"No squad has been selected yet. Run the 'solve' method first.\")\n        return\n\n    gw_data = self.get_gameweek_summary(gameweek)\n    if not gw_data:\n        return  # get_gameweek_summary already prints error message\n\n    selected_squad = gw_data[\"squad\"]\n    total_cost = gw_data[\"total_cost\"]\n    expected_points_from_xi = gw_data[\"expected_points_from_xi\"]\n    bench_boost_used = gw_data[\"bench_boost_used\"]\n    triple_captain_used = gw_data[\"triple_captain_used\"]\n    total_bench_boost_points = gw_data[\"total_bench_boost_points\"]\n    total_triple_captain_bonus = gw_data[\"total_triple_captain_bonus\"]\n    transfers_in_count = gw_data[\"transfers_in_count\"]  # New\n    transfers_out_count = gw_data[\"transfers_out_count\"]  # New\n    transfer_hits_taken = gw_data[\"transfer_hits\"]  # New\n    free_transfers_available_next_gw = gw_data[\n        \"free_transfers_available_next_gw\"\n    ]  # New\n\n    print(f\"\\n--- FPL Optimized Squad for Gameweek {gameweek} ---\")\n    print(f\"Squad Cost: \u00a3{total_cost:.1f}m\")\n    print(f\"Expected Points (Starting XI): {expected_points_from_xi:.2f}\")\n    print(\n        f\"Total Expected Points for GW{gameweek} (including chips): {expected_points_from_xi + total_bench_boost_points + total_triple_captain_bonus:.2f}\"\n    )\n    print(\"\\n--- Chips Used This Gameweek ---\")\n    if bench_boost_used:\n        print(f\"- Bench Boost (Added {total_bench_boost_points:.2f} points)\")\n    if triple_captain_used:\n        print(\n            f\"- Triple Captain (Added {total_triple_captain_bonus:.2f} bonus points)\"\n        )\n    if not (bench_boost_used or triple_captain_used):\n        print(\"No chips used this gameweek.\")\n\n    print(\"\\n--- Goalkeepers (Starting XI marked with *) ---\")\n    for index, row in selected_squad[selected_squad[\"position\"] == \"GK\"].iterrows():\n        starter_str = \"*\" if row[\"is_starter\"] else \"\"\n        captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n        transfer_status = \"\"\n        if row[\"transfer_in\"]:\n            transfer_status = \"(IN)\"\n        elif row[\"transfer_out\"]:\n            transfer_status = \"(OUT)\"\n\n        # Access gameweek-specific xP correctly\n        player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n        print(\n            f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n        )\n    print(\"\\n--- Defenders (Starting XI marked with *) ---\")\n    for index, row in selected_squad[\n        selected_squad[\"position\"] == \"DEF\"\n    ].iterrows():\n        starter_str = \"*\" if row[\"is_starter\"] else \"\"\n        captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n        transfer_status = \"\"\n        if row[\"transfer_in\"]:\n            transfer_status = \"(IN)\"\n        elif row[\"transfer_out\"]:\n            transfer_status = \"(OUT)\"\n\n        player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n        print(\n            f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n        )\n    print(\"\\n--- Midfielders (Starting XI marked with *) ---\")\n    for index, row in selected_squad[\n        selected_squad[\"position\"] == \"MID\"\n    ].iterrows():\n        starter_str = \"*\" if row[\"is_starter\"] else \"\"\n        captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n        transfer_status = \"\"\n        if row[\"transfer_in\"]:\n            transfer_status = \"(IN)\"\n        elif row[\"transfer_out\"]:\n            transfer_status = \"(OUT)\"\n\n        player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n        print(\n            f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n        )\n    print(\"\\n--- Forwards (Starting XI marked with *) ---\")\n    for index, row in selected_squad[\n        selected_squad[\"position\"] == \"FWD\"\n    ].iterrows():\n        starter_str = \"*\" if row[\"is_starter\"] else \"\"\n        captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n        transfer_status = \"\"\n        if row[\"transfer_in\"]:\n            transfer_status = \"(IN)\"\n        elif row[\"transfer_out\"]:\n            transfer_status = \"(OUT)\"\n\n        player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n        print(\n            f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n        )\n\n    print(f\"\\n--- Team Breakdown for GW{gameweek} ---\")\n    print(selected_squad[\"team\"].value_counts())\n\n    # Transfers are relevant from Gameweek 2 (index 1) onwards in the optimization horizon\n    # For display, if the current GW is the initial one (GW1 in the current context), no transfers are made\n    # If it's a subsequent GW, check if transfers occurred.\n    first_gw_in_history = min(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n    if (\n        gameweek &gt;= first_gw_in_history\n    ):  # Changed from &gt; to &gt;=, to show initial free transfers\n        # Display transfer info for this gameweek\n        print(\n            f\"  Transfers In: {transfers_in_count}, Transfers Out: {transfers_out_count}\"\n        )\n        print(\n            f\"  Transfer Hits: {transfer_hits_taken} (-{transfer_hits_taken * POINTS_PER_HIT} points)\"\n        )\n        # Only show free transfers for the *next* gameweek if it's not the last gameweek in the horizon\n        if gameweek &lt; max(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        ):\n            print(\n                f\"  Free Transfers Available for Next GW: {free_transfers_available_next_gw}\"\n            )\n    print(\"---------------------------\\n\")\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/fpl_solver/#build.lib.fpl_solver.fpl_solver.FPLOptimizer.solve","title":"<code>solve(budget, max_players_per_team, chip_allowances, num_gameweeks)</code>","text":"<p>Solves the FPL optimization problem using PuLP.</p> <p>Parameters:</p> Name Type Description Default <code>budget</code> <code>float</code> <p>The maximum budget in millions of pounds.</p> required <code>max_players_per_team</code> <code>int</code> <p>The maximum number of players allowed from                         any single Premier League team.</p> required <code>chip_allowances</code> <code>dict</code> <p>A dictionary specifying the maximum usage for each chip.</p> required <code>num_gameweeks</code> <code>int</code> <p>The number of gameweeks to optimize over.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if a solution was found, False otherwise.</p> Source code in <code>build/lib/fpl_solver/fpl_solver.py</code> <pre><code>def solve(\n    self,\n    budget: float,\n    max_players_per_team: int,\n    chip_allowances: dict,\n    num_gameweeks: int,\n) -&gt; bool:\n    \"\"\"\n    Solves the FPL optimization problem using PuLP.\n\n    Args:\n        budget (float): The maximum budget in millions of pounds.\n        max_players_per_team (int): The maximum number of players allowed from\n                                    any single Premier League team.\n        chip_allowances (dict): A dictionary specifying the maximum usage for each chip.\n        num_gameweeks (int): The number of gameweeks to optimize over.\n\n    Returns:\n        bool: True if a solution was found, False otherwise.\n    \"\"\"\n    self.problem = LpProblem(\"FPL Squad Multi-Week Optimization\", LpMaximize)\n\n    # Decision variables for player selection, indexed by player and gameweek\n    player_vars = LpVariable.dicts(\n        \"Player\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n    )\n    starting_xi_vars = LpVariable.dicts(\n        \"StartingXI\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n    )\n    captain_var = LpVariable.dicts(\n        \"Captain\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n    )\n\n    # Binary variables for chip usage, indexed by gameweek\n    use_bench_boost = LpVariable.dicts(\n        \"Use_Bench_Boost\", range(num_gameweeks), 0, 1, LpBinary\n    )\n    use_triple_captain = LpVariable.dicts(\n        \"Use_Triple_Captain\", range(num_gameweeks), 0, 1, LpBinary\n    )\n\n    # Transfer variables\n    transfer_in_vars = LpVariable.dicts(\n        \"Transfer_In\",\n        (self.player_data.index, range(1, num_gameweeks)),\n        0,\n        1,\n        LpBinary,\n    )\n    transfer_out_vars = LpVariable.dicts(\n        \"Transfer_Out\",\n        (self.player_data.index, range(1, num_gameweeks)),\n        0,\n        1,\n        LpBinary,\n    )\n\n    # Total transfers made in a gameweek (absolute count)\n    transfers_made = LpVariable.dicts(\n        \"Transfers_Made\", range(1, num_gameweeks), 0, None, LpInteger\n    )\n    # Free transfers available at the start of a gameweek\n    free_transfers_available = LpVariable.dicts(\n        \"Free_Transfers_Available\",\n        range(num_gameweeks),\n        0,\n        MAX_FREE_TRANSFERS_SAVED + 1,\n        LpInteger,\n    )\n    # Number of transfer hits taken in a gameweek\n    transfer_hits = LpVariable.dicts(\n        \"Transfer_Hits\", range(1, num_gameweeks), 0, None, LpInteger\n    )\n\n    # Auxiliary variables for linearizing chip effects\n    is_bench_player = LpVariable.dicts(\n        \"Is_Bench_Player\",\n        (self.player_data.index, range(num_gameweeks)),\n        0,\n        1,\n        LpBinary,\n    )\n    actual_bench_boost_points = LpVariable.dicts(\n        \"Actual_Bench_Boost_Points\",\n        (self.player_data.index, range(num_gameweeks)),\n        0,\n        None,\n        LpContinuous,\n    )\n    actual_triple_captain_bonus = LpVariable.dicts(\n        \"Actual_Triple_Captain_Bonus\",\n        (self.player_data.index, range(num_gameweeks)),\n        0,\n        None,\n        LpContinuous,\n    )\n\n    # --- Objective Function ---\n    total_objective_points = []\n\n    # Get the first gameweek number from the player data to correctly index expected_points_by_gw\n    first_gw_key = next(\n        iter(\n            self.player_data.loc[\n                self.player_data.index[0], \"expected_points_by_gw\"\n            ].keys()\n        )\n    )\n    current_gameweek_number_start = int(first_gw_key)\n\n    for w in range(num_gameweeks):\n        # The actual gameweek number (1-indexed)\n        gw_actual = current_gameweek_number_start + w\n\n        # Base expected points from the selected starting 11 for this gameweek\n        base_points_expression_gw = lpSum(\n            self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n            * starting_xi_vars[i][w]\n            for i in self.player_data.index\n        )\n        total_objective_points.append(base_points_expression_gw)\n\n        # Regular Captaincy points (additional 1x for captain)\n        captain_points_bonus_gw = lpSum(\n            self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n            * captain_var[i][w]\n            for i in self.player_data.index\n        )\n        total_objective_points.append(captain_points_bonus_gw)\n\n        # Define auxiliary variables and constraints for chips for each gameweek\n        for i in self.player_data.index:\n            # Use gameweek-specific player xP for chip calculations\n            player_xp = self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n\n            # Bench Boost auxiliary variables and constraints\n            self.problem += (\n                is_bench_player[i][w] &lt;= player_vars[i][w],\n                f\"IsBench_Squad_{i}_{w}\",\n            )\n            self.problem += (\n                is_bench_player[i][w] &lt;= 1 - starting_xi_vars[i][w],\n                f\"IsBench_NotStarter_{i}_{w}\",\n            )\n            self.problem += (\n                is_bench_player[i][w]\n                &gt;= player_vars[i][w] + (1 - starting_xi_vars[i][w]) - 1,\n                f\"IsBench_Logical_{i}_{w}\",\n            )\n\n            self.problem += (\n                actual_bench_boost_points[i][w]\n                &lt;= player_xp * is_bench_player[i][w],\n                f\"BenchBoost_Contr_1_{i}_{w}\",\n            )\n            self.problem += (\n                actual_bench_boost_points[i][w] &lt;= player_xp * use_bench_boost[w],\n                f\"BenchBoost_Contr_2_{i}_{w}\",\n            )\n            self.problem += (\n                actual_bench_boost_points[i][w]\n                &gt;= player_xp * (is_bench_player[i][w] + use_bench_boost[w] - 1),\n                f\"BenchBoost_Contr_3_{i}_{w}\",\n            )\n            self.problem += (\n                actual_bench_boost_points[i][w] &gt;= 0,\n                f\"BenchBoost_Contr_4_{i}_{w}\",\n            )\n\n            # Triple Captain auxiliary variables and constraints\n            # Changed player_xp * 2 to player_xp to reflect additional 1x bonus\n            self.problem += (\n                actual_triple_captain_bonus[i][w] &lt;= player_xp * captain_var[i][w],\n                f\"TripleCaptain_Contr_1_{i}_{w}\",\n            )\n            self.problem += (\n                actual_triple_captain_bonus[i][w]\n                &lt;= player_xp * use_triple_captain[w],\n                f\"TripleCaptain_Contr_2_{i}_{w}\",\n            )\n            self.problem += (\n                actual_triple_captain_bonus[i][w]\n                &gt;= player_xp * (captain_var[i][w] + use_triple_captain[w] - 1),\n                f\"TripleCaptain_Contr_3_{i}_{w}\",\n            )\n            self.problem += (\n                actual_triple_captain_bonus[i][w] &gt;= 0,\n                f\"TripleCaptain_Contr_4_{i}_{w}\",\n            )\n\n        # Add points from bench boost and triple captain bonus for this gameweek\n        total_bench_boost_points_gw = lpSum(\n            actual_bench_boost_points[i][w] for i in self.player_data.index\n        )\n        total_triple_captain_bonus_points_gw = lpSum(\n            actual_triple_captain_bonus[i][w] for i in self.player_data.index\n        )\n\n        total_objective_points.append(total_bench_boost_points_gw)\n        total_objective_points.append(total_triple_captain_bonus_points_gw)\n\n    # Subtract transfer hits from the total objective\n    total_objective_points.append(\n        -POINTS_PER_HIT * lpSum(transfer_hits[w] for w in range(1, num_gameweeks))\n    )\n\n    self.problem += (\n        lpSum(total_objective_points),\n        \"Total Expected Points Over Gameweeks\",\n    )\n\n    # --- Constraints ---\n\n    # Apply constraints for each gameweek\n    for w in range(num_gameweeks):\n        # 1. Select exactly 15 players for the squad\n        self.problem += (\n            lpSum(player_vars[i][w] for i in self.player_data.index) == 15,\n            f\"Total_Players_GW{w}\",\n        )\n\n        # 2. Squad position constraints (2 GKs, 5 DEFs, 5 MIDs, 3 FWDs)\n        gks = self.player_data[self.player_data[\"position\"] == \"GK\"].index\n        defs = self.player_data[self.player_data[\"position\"] == \"DEF\"].index\n        mids = self.player_data[self.player_data[\"position\"] == \"MID\"].index\n        fwds = self.player_data[self.player_data[\"position\"] == \"FWD\"].index\n\n        self.problem += (\n            lpSum(player_vars[i][w] for i in gks) == 2,\n            f\"Goalkeepers_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(player_vars[i][w] for i in defs) == 5,\n            f\"Defenders_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(player_vars[i][w] for i in mids) == 5,\n            f\"Midfielders_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(player_vars[i][w] for i in fwds) == 3,\n            f\"Forwards_Count_GW{w}\",\n        )\n\n        # 3. Budget constraint\n        # This applies to the cost of the squad for the current gameweek.\n        self.problem += (\n            lpSum(\n                self.player_data.loc[i, \"cost\"] * player_vars[i][w]\n                for i in self.player_data.index\n            )\n            &lt;= budget,\n            f\"Total_Budget_GW{w}\",\n        )\n\n        # 4. Maximum players per team constraint\n        for team in self.player_data[\"team\"].unique():\n            team_players = self.player_data[self.player_data[\"team\"] == team].index\n            self.problem += (\n                lpSum(player_vars[i][w] for i in team_players)\n                &lt;= max_players_per_team,\n                f\"Max_Players_from_{team}_GW{w}\",\n            )\n\n        # 5. Starting XI constraints\n        # 5.1 Select exactly 11 players for the starting XI\n        self.problem += (\n            lpSum(starting_xi_vars[i][w] for i in self.player_data.index) == 11,\n            f\"Total_Starting_XI_Players_GW{w}\",\n        )\n\n        # 5.2 A player can only be in the starting XI if they are in the squad\n        for i in self.player_data.index:\n            self.problem += (\n                starting_xi_vars[i][w] &lt;= player_vars[i][w],\n                f\"StartingXI_in_Squad_{i}_{w}\",\n            )\n\n        # 5.3 Starting XI position constraints (FPL allows flexible formations, so use minimums)\n        self.problem += (\n            lpSum(starting_xi_vars[i][w] for i in gks) == 1,\n            f\"Starting_Goalkeepers_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(starting_xi_vars[i][w] for i in defs) &gt;= 3,\n            f\"Min_Starting_Defenders_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(starting_xi_vars[i][w] for i in mids) &gt;= 2,\n            f\"Min_Starting_Midfielders_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(starting_xi_vars[i][w] for i in fwds) &gt;= 1,\n            f\"Min_Starting_Forwards_Count_GW{w}\",\n        )\n\n        # 6. Captain Constraints\n        # 6.1 Select exactly one captain from the starting XI\n        self.problem += (\n            lpSum(captain_var[i][w] for i in self.player_data.index) == 1,\n            f\"One_Captain_GW{w}\",\n        )\n\n        # 6.2 A player can only be captain if they are in the starting XI\n        for i in self.player_data.index:\n            self.problem += (\n                captain_var[i][w] &lt;= starting_xi_vars[i][w],\n                f\"Captain_in_StartingXI_{i}_{w}\",\n            )\n\n        # --- Enforced Player Constraints---\n        for player_idx in self.enforced_player_indices:\n            self.problem += (\n                player_vars[player_idx][w] == 1,\n                f\"Enforce_Player_{self.player_data.loc[player_idx, 'name']}_GW{w}\",\n            )\n\n        for team, position in self.enforced_team_pos_requirements:\n            # Filter players for the current team and position\n            team_pos_players = self.player_data[\n                (self.player_data[\"team\"] == team)\n                &amp; (self.player_data[\"position\"] == position)\n            ].index\n            if not team_pos_players.empty:\n                self.problem += (\n                    lpSum(player_vars[i][w] for i in team_pos_players) &gt;= 1,\n                    f\"Enforce_One_{position}_from_{team}_GW{w}\",\n                )\n            else:\n                print(\n                    f\"Warning: No players found for enforced requirement: at least one {position} from {team} for GW{gw_actual}.\"\n                )\n\n    # --- Chip Usage Constraints (TOTAL usage over all gameweeks) ---\n    # These constraints should be outside the per-gameweek loop to avoid duplicates.\n    self.problem += (\n        lpSum(use_bench_boost[j] for j in range(num_gameweeks))\n        &lt;= chip_allowances.get(\"bench_boost\", 0),\n        f\"Max_Bench_Boost_Usage_Total\",\n    )\n    self.problem += (\n        lpSum(use_triple_captain[j] for j in range(num_gameweeks))\n        &lt;= chip_allowances.get(\"triple_captain\", 0),\n        f\"Max_Triple_Captain_Usage_Total\",\n    )\n\n    # --- Inter-Gameweek Constraints (Transfers and Transfer Rules) ---\n    # Initialize free transfers for GW0 (first gameweek of optimization horizon)\n    # This assumes the optimization starts at GW0, and it has INITIAL_FREE_TRANSFERS.\n    # If the model starts at an arbitrary GW, this would need to be an input.\n    self.problem += (\n        free_transfers_available[0] == INITIAL_FREE_TRANSFERS,\n        f\"Initial_Free_Transfers_GW0\",\n    )\n\n    for w in range(1, num_gameweeks):\n        # Calculate total transfers made in this gameweek\n        self.problem += (\n            transfers_made[w]\n            == lpSum(transfer_in_vars[i][w] for i in self.player_data.index),\n            f\"Transfers_Made_GW{w}\",\n        )\n        # Total transfers in must equal total transfers out for each gameweek after the first\n        self.problem += (\n            lpSum(transfer_in_vars[i][w] for i in self.player_data.index)\n            == lpSum(transfer_out_vars[i][w] for i in self.player_data.index),\n            f\"Transfers_In_Equals_Out_GW{w}\",\n        )\n\n        # Calculate free transfers available for the current gameweek (w)\n        # Free transfers for GW_w = min(free transfers from GW_w-1 - transfers made in GW_w + 1, MAX_FREE_TRANSFERS_SAVED + 1)\n        # The + 1 in MAX_FREE_TRANSFERS_SAVED + 1 is because MAX_FREE_TRANSFERS_SAVED implies how many can be *saved*,\n        # so if you save 1, you have 1 (current) + 1 (saved) = 2.\n        self.problem += (\n            free_transfers_available[w]\n            &lt;= free_transfers_available[w - 1] - transfers_made[w] + 1,\n            f\"Free_Transfers_Calc_1_GW{w}\",\n        )\n        self.problem += (\n            free_transfers_available[w] &lt;= MAX_FREE_TRANSFERS_SAVED + 1,\n            f\"Free_Transfers_Calc_2_GW{w}\",\n        )\n        self.problem += (\n            free_transfers_available[w] &gt;= 0,  # Cannot have negative free transfers\n            f\"Free_Transfers_Non_Negative_GW{w}\",\n        )\n\n        # Calculate transfer hits\n        # transfer_hits[w] = max(0, transfers_made[w] - free_transfers_available_at_start_of_gw_w)\n        # This needs to be linearized. If transfers_made[w] &gt; free_transfers_available[w-1], then hit.\n        # free_transfers_available[w-1] represents transfers available *before* making transfers for GW_w\n        self.problem += (\n            transfer_hits[w] &gt;= transfers_made[w] - free_transfers_available[w - 1],\n            f\"Transfer_Hits_Calc_1_GW{w}\",\n        )\n        self.problem += (\n            transfer_hits[w] &gt;= 0,\n            f\"Transfer_Hits_Calc_2_GW{w}\",\n        )\n\n        for i in self.player_data.index:\n            # Squad continuity: player_vars[i][w] (in squad at start of GW w)\n            #                 = player_vars[i][w-1] (in squad at start of GW w-1)\n            #                 - transfer_out_vars[i][w] (transferred out for GW w)\n            #                 + transfer_in_vars[i][w] (transferred in for GW w)\n            self.problem += (\n                player_vars[i][w]\n                == player_vars[i][w - 1]\n                - transfer_out_vars[i][w]\n                + transfer_in_vars[i][w],\n                f\"Squad_Continuity_{i}_GW{w}\",\n            )\n            # A player cannot be transferred in and out in the same gameweek\n            self.problem += (\n                transfer_in_vars[i][w] + transfer_out_vars[i][w] &lt;= 1,\n                f\"No_Simultaneous_Transfer_{i}_{w}\",\n            )\n\n    try:\n        # The solver is called with the GLPK_CMD solver\n        self.problem.solve(PULP_CBC_CMD(msg=0))  # msg=0 suppresses verbose output\n    except Exception as e:\n        print(f\"Error solving the problem: {e}\")\n        return False\n\n    if LpStatus[self.problem.status] == \"Optimal\":\n        print(\"Optimization successful! Optimal solution found.\")\n\n        self.selected_squad_history = {}\n        self.total_transfer_hits = 0\n        for w in range(num_gameweeks):\n            # The actual gameweek number (1-indexed)\n            gw_actual = current_gameweek_number_start + w\n\n            # Get selected players for the current gameweek\n            selected_squad_gw = self.player_data[\n                [player_vars[i][w].varValue == 1 for i in self.player_data.index]\n            ].copy()\n\n            # Get starter and captain info for this gameweek\n            is_starter_series_gw = pd.Series(\n                [\n                    starting_xi_vars[i][w].varValue == 1\n                    for i in self.player_data.index\n                ],\n                index=self.player_data.index,\n            )\n            is_captain_series_gw = pd.Series(\n                [captain_var[i][w].varValue == 1 for i in self.player_data.index],\n                index=self.player_data.index,\n            )\n\n            selected_squad_gw[\"is_starter\"] = is_starter_series_gw.loc[\n                selected_squad_gw.index\n            ]\n            selected_squad_gw[\"is_captain\"] = is_captain_series_gw.loc[\n                selected_squad_gw.index\n            ]\n\n            transfers_in_gw = 0\n            transfers_out_gw = 0\n            hits_gw = 0\n\n            # Store transfer details for gameweeks &gt; 0\n            if (\n                w &gt; 0\n            ):  # Check for transfers only from GW1 onwards (index 1 in 0-indexed loop)\n                transfer_in_flags = pd.Series(\n                    [\n                        transfer_in_vars[i][w].varValue == 1\n                        for i in self.player_data.index\n                    ],\n                    index=self.player_data.index,\n                )\n                transfer_out_flags = pd.Series(\n                    [\n                        transfer_out_vars[i][w].varValue == 1\n                        for i in self.player_data.index\n                    ],\n                    index=self.player_data.index,\n                )\n\n                selected_squad_gw[\"transfer_in\"] = transfer_in_flags.loc[\n                    selected_squad_gw.index\n                ]\n                selected_squad_gw[\"transfer_out\"] = transfer_out_flags.loc[\n                    selected_squad_gw.index\n                ]\n\n                transfers_in_gw = int(round(transfer_in_flags.sum()))\n                transfers_out_gw = int(round(transfer_out_flags.sum()))\n                hits_gw = int(round(transfer_hits[w].varValue))\n                self.total_transfer_hits += hits_gw\n            else:\n                selected_squad_gw[\"transfer_in\"] = False  # No transfers in for GW0\n                selected_squad_gw[\"transfer_out\"] = (\n                    False  # No transfers out for GW0\n                )\n\n            self.selected_squad_history[f\"GW{gw_actual}\"] = {\n                \"squad\": selected_squad_gw,\n                \"total_cost\": selected_squad_gw[\"cost\"].sum(),\n                \"expected_points_from_xi\": sum(\n                    self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n                    * starting_xi_vars[i][w].varValue\n                    for i in self.player_data.index\n                ),\n                \"bench_boost_used\": bool(use_bench_boost[w].varValue),\n                \"triple_captain_used\": bool(use_triple_captain[w].varValue),\n                \"total_bench_boost_points\": value(\n                    lpSum(\n                        actual_bench_boost_points[i][w]\n                        for i in self.player_data.index\n                    )\n                ),\n                \"total_triple_captain_bonus\": value(\n                    lpSum(\n                        actual_triple_captain_bonus[i][w]\n                        for i in self.player_data.index\n                    )\n                ),\n                \"transfers_in_count\": transfers_in_gw,\n                \"transfers_out_count\": transfers_out_gw,\n                \"transfer_hits\": hits_gw,  # New\n                \"free_transfers_available_next_gw\": (\n                    int(round(free_transfers_available[w].varValue))\n                    if w &lt; num_gameweeks - 1\n                    else 0\n                ),  # Free transfers available *after* this GW's transfers are made\n            }\n\n        # Overall totals\n        self.total_cost = self.selected_squad_history[\n            f\"GW{current_gameweek_number_start + num_gameweeks - 1}\"\n        ][\n            \"total_cost\"\n        ]  # Cost of final squad\n        self.total_expected_points = value(\n            self.problem.objective\n        )  # Total objective value from solver\n        self.used_chips = {\n            f\"GW{current_gameweek_number_start + w}\": {\n                \"bench_boost\": bool(use_bench_boost[w].varValue),\n                \"triple_captain\": bool(use_triple_captain[w].varValue),\n            }\n            for w in range(num_gameweeks)\n        }\n\n        return True\n    else:\n        print(f\"No optimal solution found. Status: {LpStatus[self.problem.status]}\")\n        self.selected_squad_history = {}\n        self.total_cost = 0\n        self.total_expected_points = 0\n        self.used_chips = {}\n        self.total_transfer_hits = 0\n        return False\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/fpl_xp_predictor/","title":"fpl_xp_predictor","text":""},{"location":"autoapi/build/lib/fpl_solver/fpl_xp_predictor/#build.lib.fpl_solver.fpl_xp_predictor.FPLPredictor","title":"<code>FPLPredictor</code>","text":"<p>Predictive algorithm for Expected Points (xP) in Fantasy Premier League, using real data from the FPL API.</p> Source code in <code>build/lib/fpl_solver/fpl_xp_predictor.py</code> <pre><code>class FPLPredictor:\n    \"\"\"\n    Predictive algorithm for Expected Points (xP) in Fantasy Premier League,\n    using real data from the FPL API.\n    \"\"\"\n\n    def __init__(self, gameweeks_to_predict: int = 1):\n        \"\"\"\n        Initializes the FPLPredictor with default FPL point rules and\n        data structures, then fetches real data and calculates xP for all players.\n\n        Args:\n            gameweeks_to_predict (int): The number of upcoming gameweeks to calculate\n                                        expected points for. Default is 1 (next gameweek).\n        \"\"\"\n        if not isinstance(gameweeks_to_predict, int) or gameweeks_to_predict &lt; 1:\n            raise ValueError(\"gameweeks_to_predict must be a positive integer.\")\n        self.gameweeks_to_predict = gameweeks_to_predict\n\n        self.fpl_points = FPL_POINTS\n\n        self.players_data = {}\n        self.teams_data = {}\n        self.fixtures_data = {}\n        self.position_definitions = {\n            1: \"GK\",\n            2: \"DEF\",\n            3: \"MID\",\n            4: \"FWD\",\n        }\n        self.all_players_xp_calculated_data = (\n            []\n        )  # To store xP for all players for the optimizer\n\n        self._fetch_fpl_data()\n        self._calculate_all_players_xp()  # Calculate xP for all players after data is loaded\n\n    def _fetch_fpl_data(self):\n        \"\"\"Fetches initial data from the FPL API.\"\"\"\n        print(\"Fetching FPL data...\")\n        try:\n            # Fetch general data\n            static_data = requests.get(\n                \"https://fantasy.premierleague.com/api/bootstrap-static/\"\n            ).json()\n            # Fetch fixtures data\n            fixtures_data = requests.get(\n                \"https://fantasy.premierleague.com/api/fixtures/\"\n            ).json()\n\n            # Process players data\n            for element in static_data[\"elements\"]:\n                player_id = element[\"id\"]\n                self.players_data[player_id] = {\n                    \"name\": element[\"first_name\"] + \" \" + element[\"second_name\"],\n                    \"web_name\": element[\"web_name\"],\n                    \"team_id\": element[\"team\"],\n                    \"element_type\": element[\"element_type\"],\n                    \"position\": self.position_definitions.get(\n                        element[\"element_type\"], \"Unknown\"\n                    ),\n                    \"cost_pence\": element[\"now_cost\"],\n                    \"status\": element[\"status\"],\n                    \"news\": element[\"news\"],\n                    \"total_points\": element[\"total_points\"],\n                    \"minutes\": element[\"minutes\"],\n                    \"goals_scored\": element[\"goals_scored\"],\n                    \"assists\": element[\"assists\"],\n                    \"clean_sheets\": element[\"clean_sheets\"],\n                    \"goals_conceded\": element[\"goals_conceded\"],\n                    \"penalties_saved\": element[\"penalties_saved\"],\n                    \"penalties_missed\": element[\"penalties_missed\"],\n                    \"yellow_cards\": element[\"yellow_cards\"],\n                    \"red_cards\": element[\"red_cards\"],\n                    \"own_goals\": element[\"own_goals\"],\n                    \"saves\": element[\"saves\"],\n                    \"bonus\": element[\"bonus\"],\n                    \"bps\": element[\"bps\"],\n                    \"threat\": element[\"threat\"],\n                    \"creativity\": element[\"creativity\"],\n                    \"influence\": element[\"influence\"],\n                    \"form\": float(element[\"form\"]),\n                    \"points_per_game\": float(element[\"points_per_game\"]),\n                    \"value_season\": float(element[\"value_season\"]),\n                    \"value_form\": float(element[\"value_form\"]),\n                    \"ict_index\": float(element[\"ict_index\"]),\n                }\n\n            # --- Apply Player Exclusions ---\n            initial_player_count = len(self.players_data)\n            players_to_keep = {}\n            for player_id, player_info in self.players_data.items():\n                # Exclude by ID\n                if player_id in EXCLUDED_PLAYERS_BY_ID:\n                    print(\n                        f\"Excluding player by ID: {player_info['name']} (ID: {player_id})\"\n                    )\n                    continue\n\n                # Exclude by Name\n                if player_info[\"name\"] in EXCLUDED_PLAYERS_BY_NAME:\n                    print(\n                        f\"Excluding player by Name: {player_info['name']} (ID: {player_id})\"\n                    )\n                    continue\n\n                # Exclude by Team and Position\n                excluded_by_team_pos = False\n                for exclusion_rule in EXCLUDED_PLAYERS_BY_TEAM_AND_POSITION:\n                    team_name = self.teams_data.get(player_info[\"team_id\"], {}).get(\n                        \"name\"\n                    )\n                    if team_name == exclusion_rule.get(\"team\") and player_info[\n                        \"position\"\n                    ] == exclusion_rule.get(\"position\"):\n                        print(\n                            f\"Excluding player by Team/Position: {player_info['name']} ({team_name}, {player_info['position']})\"\n                        )\n                        excluded_by_team_pos = True\n                        break\n                if excluded_by_team_pos:\n                    continue\n\n                players_to_keep[player_id] = player_info\n\n            self.players_data = players_to_keep\n            print(\n                f\"Filtered {initial_player_count - len(self.players_data)} players. Remaining: {len(self.players_data)}\"\n            )\n\n            # Process teams data\n            for team in static_data[\"teams\"]:\n                self.teams_data[team[\"id\"]] = {\n                    \"name\": team[\"name\"],\n                    \"short_name\": team[\"short_name\"],\n                    \"strength\": team[\"strength\"],\n                    \"strength_overall_home\": team[\"strength_overall_home\"],\n                    \"strength_overall_away\": team[\"strength_overall_away\"],\n                    \"strength_attack_home\": team[\"strength_attack_home\"],\n                    \"strength_attack_away\": team[\"strength_attack_away\"],\n                    \"strength_defence_home\": team[\"strength_defence_home\"],\n                    \"strength_defence_away\": team[\"strength_defence_away\"],\n                }\n\n            # Process fixtures data\n            for fixture in fixtures_data:\n                self.fixtures_data[fixture[\"id\"]] = fixture\n\n            print(\"FPL data fetched successfully.\")\n\n        except requests.exceptions.RequestException as e:\n            print(f\"Error fetching FPL data: {e}\")\n            self.players_data = {}\n            self.teams_data = {}\n            self.fixtures_data = {}\n            print(\"Initialization failed due to data fetching error. Exiting.\")\n            sys.exit(1)\n        except Exception as e:\n            print(f\"An unexpected error occurred during data fetching: {e}\")\n            self.players_data = {}\n            self.teams_data = {}\n            self.fixtures_data = {}\n            print(\"Initialization failed due to unexpected error. Exiting.\")\n            sys.exit(1)\n\n    def _get_team_strength(self, team_id, is_home):\n        \"\"\"Get team strength based on home/away status.\"\"\"\n        team = self.teams_data.get(team_id, {})\n        if is_home:\n            return team.get(\"strength_overall_home\", 1000)  # Default if not found\n        return team.get(\"strength_overall_away\", 1000)  # Default if not found\n\n    def _predict_minutes(self, player_id):\n        \"\"\"\n        Predicts expected minutes for a player based on historical data.\n        More sophisticated logic for handling very low minute players.\n        \"\"\"\n        player = self.players_data.get(player_id)\n        if not player:\n            return 0.0\n\n        status = player[\"status\"]\n        news = player[\"news\"].lower()\n        minutes_played = player[\"minutes\"]\n\n        # 1. Unavailable players (injured, suspended, doubtful)\n        if status != \"a\" or any(\n            x in news\n            for x in [\n                \"injured\",\n                \"doubtful\",\n                \"suspension\",\n                \"red card\",\n                \"expected back\",\n            ]\n        ):\n            return 0.0\n\n        # 2. Players with significant minutes (starters/key rotation)\n        if minutes_played &gt;= MIN_MINUTES_THRESHOLD:\n            # Average minutes per game started (assuming most minutes come from starts)\n            # This is a heuristic; real FPL API doesn't give starts directly.\n            # We assume a player with &gt; MIN_MINUTES_THRESHOLD plays ~80-90 minutes when on pitch.\n            # So, (minutes_played / number_of_appearances) is a rough proxy.\n            # For simplicity, let's use a cap of 90 minutes.\n            if player[\"total_points\"] &gt; 0:  # Player has played at least one game\n                avg_minutes_per_appearance = minutes_played / (\n                    player[\"total_points\"] / player[\"points_per_game\"]\n                )\n                return min(avg_minutes_per_appearance, 90.0)\n            return 70.0  # Reasonable default for established player with points but no clear avg\n\n        # 3. Players with very low minutes (rarely play, new, youth)\n        if minutes_played &lt; VERY_LOW_MINUTES_THRESHOLD:\n            # If news suggests they might get a chance, assign default sub minutes.\n            # Otherwise, very low expected minutes or zero.\n            if any(x in news for x in [\"return imminent\", \"close to return\"]):\n                return DEFAULT_SUB_MINUTES  # Might get some minutes\n            return DEFAULT_UNKNOWN_PLAYER_MINUTES  # Very unlikely to play significant minutes\n\n        # 4. Players with some minutes but below significant threshold (regular subs)\n        return DEFAULT_SUB_MINUTES\n\n    def _calculate_expected_goals(self, team_attack_strength, opp_defence_strength):\n        \"\"\"\n        Calculates expected goals for a team based on its attack strength and\n        opponent's defensive strength. This is a simplified heuristic.\n        \"\"\"\n        # A simple ratio model: Higher attack strength and lower opponent defense means more goals\n        # Normalization factor can be adjusted based on average league goals\n        expected_goals = (\n            team_attack_strength / opp_defence_strength\n        ) * 1.5  # 1.5 is an arbitrary scaling factor\n        return max(0.0, expected_goals)\n\n    def _calculate_expected_conceded_goals(\n        self, team_defence_strength, opp_attack_strength\n    ):\n        \"\"\"\n        Calculates expected goals conceded by a team based on its defense strength\n        and opponent's attacking strength.\n        \"\"\"\n        # A simple ratio model: Higher opponent attack and lower team defense means more conceded goals\n        expected_conceded_goals = (\n            opp_attack_strength / team_defence_strength\n        ) * 1.5  # 1.5 is an arbitrary scaling factor\n        return max(0.0, expected_conceded_goals)\n\n    def calculate_xp_for_player(self, player_id, fixture_id):\n        \"\"\"\n        Calculates Expected Points (xP) for a single player in a given fixture.\n        Considers various factors: minutes, goals, assists, clean sheets, saves,\n        bonus points, and negative events, adjusted for fixture difficulty.\n        \"\"\"\n        player = self.players_data.get(player_id)\n        fixture = self.fixtures_data.get(fixture_id)\n\n        if not player or not fixture:\n            return {\"xp\": 0.0, \"reason\": \"Player or fixture data missing.\"}\n\n        # Handle unavailable players\n        if (\n            player[\"status\"] != \"a\"\n        ):  # 'd' for doubtful, 'i' for injured, 's' for suspended\n            return {\"xp\": 0.0, \"reason\": f\"Player status: {player['status']}\"}\n        if any(\n            x in player[\"news\"].lower()\n            for x in [\"injured\", \"doubtful\", \"suspension\", \"red card\"]\n        ):\n            return {\"xp\": 0.0, \"reason\": f\"Player news: {player['news']}\"}\n\n        # Predict minutes\n        expected_minutes = self._predict_minutes(player_id)\n        if expected_minutes &lt; 1.0:  # If expected to play very little or none\n            return {\"xp\": 0.0, \"reason\": \"Expected minutes too low.\"}\n\n        xp = 0.0\n        position = player[\"position\"]\n        # Use 'team_h' for home team ID\n        is_home_fixture = player[\"team_id\"] == fixture[\"team_h\"]\n\n        # Determine attacking and defensive strengths for the fixture\n        player_team_strength_attack = (\n            self.teams_data.get(fixture[\"team_h\"], {}).get(\n                \"strength_attack_home\"\n            )  # Use 'team_h'\n            if is_home_fixture\n            else self.teams_data.get(fixture[\"team_a\"], {}).get(\n                \"strength_attack_away\"\n            )  # Use 'team_a'\n        )\n        player_team_strength_defence = (\n            self.teams_data.get(fixture[\"team_h\"], {}).get(\n                \"strength_defence_home\"\n            )  # Use 'team_h'\n            if is_home_fixture\n            else self.teams_data.get(fixture[\"team_a\"], {}).get(\n                \"strength_defence_away\"\n            )  # Use 'team_a'\n        )\n        opponent_team_strength_attack = (\n            self.teams_data.get(fixture[\"team_a\"], {}).get(\n                \"strength_attack_away\"\n            )  # Use 'team_a'\n            if is_home_fixture\n            else self.teams_data.get(fixture[\"team_h\"], {}).get(\n                \"strength_attack_home\"\n            )  # Use 'team_h'\n        )\n        opponent_team_strength_defence = (\n            self.teams_data.get(fixture[\"team_a\"], {}).get(\n                \"strength_defence_away\"\n            )  # Use 'team_a'\n            if is_home_fixture\n            else self.teams_data.get(fixture[\"team_h\"], {}).get(\n                \"strength_defence_home\"\n            )  # Use 'team_h'\n        )\n\n        if None in [\n            player_team_strength_attack,\n            player_team_strength_defence,\n            opponent_team_strength_attack,\n            opponent_team_strength_defence,\n        ]:\n            # Fallback if strength data is missing (shouldn't happen with robust data fetch)\n            return {\"xp\": 0.0, \"reason\": \"Team strength data missing for fixture.\"}\n\n        # 1. Appearance points\n        if expected_minutes &gt;= 60:\n            xp += self.fpl_points[\"appearance_points_gte_60\"]\n        elif expected_minutes &gt; 0:\n            xp += self.fpl_points[\"appearance_points_lt_60\"]\n\n        # 2. Expected Goals (scaled by historical goals per 90 and opponent difficulty)\n        # Use player's form and total goals as a basis\n        goals_per_90_hist = (\n            (player[\"goals_scored\"] / player[\"minutes\"] * 90)\n            if player[\"minutes\"] &gt; 0\n            else 0.0\n        )\n        expected_team_goals = self._calculate_expected_goals(\n            player_team_strength_attack, opponent_team_strength_defence\n        )\n\n        expected_goals_player_contribution = (\n            (goals_per_90_hist / 90.0) * expected_minutes * (expected_team_goals / 1.5)\n        )  # Scale player's goal contribution by team's expected goals\n\n        if position == \"GK\":\n            xp += expected_goals_player_contribution * self.fpl_points[\"goal_gk\"]\n        elif position == \"DEF\":\n            xp += expected_goals_player_contribution * self.fpl_points[\"goal_def\"]\n        elif position == \"MID\":\n            xp += expected_goals_player_contribution * self.fpl_points[\"goal_mid\"]\n        elif position == \"FWD\":\n            xp += expected_goals_player_contribution * self.fpl_points[\"goal_fwd\"]\n\n        # 3. Expected Assists (scaled by historical assists per 90 and opponent difficulty)\n        assists_per_90_hist = (\n            (player[\"assists\"] / player[\"minutes\"] * 90)\n            if player[\"minutes\"] &gt; 0\n            else 0.0\n        )\n        # Assuming team's attacking strength correlates with assist opportunities\n        expected_assists_player_contribution = (\n            (assists_per_90_hist / 90.0)\n            * expected_minutes\n            * (expected_team_goals / 1.5)\n        )  # Similarly scale by team's expected goals\n        xp += expected_assists_player_contribution * self.fpl_points[\"assist_points\"]\n\n        # 4. Expected Clean Sheets (for GKs/DEFs/MIDs) and Conceded Goals deduction\n        expected_conceded = self._calculate_expected_conceded_goals(\n            player_team_strength_defence, opponent_team_strength_attack\n        )\n\n        # Probability of clean sheet\n        # Simplified: higher team defense / lower opponent attack -&gt; higher CS prob\n        # Use logistic or sigmoid for probability\n        cs_prob = 1.0 / (\n            1.0 + math.exp(expected_conceded - 1.0)\n        )  # Sigmoid centered at 1 goal\n\n        if position in [\"GK\", \"DEF\"]:\n            xp += cs_prob * self.fpl_points[\"clean_sheet_gk_def\"]\n\n            # Conceded goals deduction: Apply penalty for every 2 goals conceded *probability*\n            # For simplicity, calculate expected deduction: (expected_conceded / 2) * deduction\n            xp += (expected_conceded / 2.0) * self.fpl_points[\n                \"conceded_2_goals_deduction\"\n            ]\n        elif position == \"MID\":\n            xp += cs_prob * self.fpl_points[\"clean_sheet_mid\"]\n\n        # 5. Expected Saves (for GKs)\n        if position == \"GK\":\n            saves_per_90_hist = (\n                (player[\"saves\"] / player[\"minutes\"] * 90)\n                if player[\"minutes\"] &gt; 0\n                else 0.0\n            )\n            # Expected saves scaled by opponent's attacking strength (more attacking -&gt; more shots -&gt; more saves)\n            expected_saves_player_contribution = (\n                (saves_per_90_hist / 90.0)\n                * expected_minutes\n                * (opponent_team_strength_attack / player_team_strength_defence)\n            )\n            xp += (expected_saves_player_contribution / 3.0) * self.fpl_points[\n                \"saves_3_points\"\n            ]  # Using the new config point value\n\n            # Penalty saves (low probability, use historical rate)\n            penalty_saves_hist_per_game = (\n                player[\"penalties_saved\"] / (player[\"minutes\"] / 90.0)\n                if player[\"minutes\"] &gt; 0\n                else 0.0\n            )\n            xp += (\n                penalty_saves_hist_per_game\n                * (expected_minutes / 90.0)\n                * self.fpl_points[\"penalty_save_points\"]\n            )\n\n        # 6. Expected Bonus Points\n        # Use BPS (Bonus Points System) as a proxy. Scale player's average BPS by form and expected minutes.\n        bps_per_90_hist = (\n            (player[\"bps\"] / player[\"minutes\"] * 90) if player[\"minutes\"] &gt; 0 else 0.0\n        )\n        expected_bps = (bps_per_90_hist / 90.0) * expected_minutes * player[\"form\"]\n        xp += expected_bps * self.fpl_points[\"bonus_points_scaling_factor\"]\n\n        # 7. Minor Negative Events (Probabilistic)\n        # These are rare, so a simple probability based on expected minutes.\n        xp += (expected_minutes / 90.0) * (\n            self.fpl_points[\"yellow_card_deduction\"] * YELLOW_CARD_PROB\n            + self.fpl_points[\"red_card_deduction\"] * RED_CARD_PROB\n            + self.fpl_points[\"own_goal_deduction\"] * OWN_GOAL_PROB\n            + self.fpl_points[\"penalty_miss_deduction\"] * PENALTY_MISS_PROB\n        )\n\n        # 8. Defensive Contribution Points (for 2025/26 season heuristic)\n        # Assuming CBIT/CBIRT tracking\n        if position in [\"GK\", \"DEF\"]:\n            xp += CBIT_DEF_PROB * self.fpl_points[\"cbit_def_points\"]\n        elif position in [\"MID\", \"FWD\"]:\n            xp += CBIRT_MID_FWD_PROB * self.fpl_points[\"cbirt_mid_fwd_points\"]\n\n        return {\"xp\": round(xp, 2), \"reason\": \"Success\"}\n\n    def _calculate_all_players_xp(self):\n        \"\"\"\n        Calculates the Expected Points (xP) for all players over multiple upcoming gameweeks\n        and populates self.all_players_xp_calculated_data with xP per gameweek.\n        \"\"\"\n        print(\n            f\"Calculating xP for all players over {self.gameweeks_to_predict} gameweek(s)...\"\n        )\n\n        # Get all upcoming fixtures and sort them by gameweek\n        all_upcoming_fixtures_items = sorted(\n            [\n                (fid, fdict)\n                for fid, fdict in self.fixtures_data.items()\n                if not fdict[\"finished\"]\n            ],\n            key=lambda item: item[1][\"event\"],\n        )\n\n        if not all_upcoming_fixtures_items:\n            print(\"No upcoming fixtures found. Cannot calculate xP.\")\n            return\n\n        # Determine the current gameweek (the gameweek of the earliest upcoming fixture)\n        current_gameweek = all_upcoming_fixtures_items[0][1][\"event\"]\n        target_gameweeks = range(\n            current_gameweek, current_gameweek + self.gameweeks_to_predict\n        )\n\n        # Create a mapping of team_id_code to a list of their fixtures within the target gameweeks\n        team_fixtures_in_range = {team_code: [] for team_code in self.teams_data.keys()}\n        for fixture_id, fixture_data in all_upcoming_fixtures_items:\n            if fixture_data[\"event\"] in target_gameweeks:\n                home_team_code = fixture_data[\"team_h\"]\n                away_team_code = fixture_data[\"team_a\"]\n\n                team_fixtures_in_range[home_team_code].append(fixture_id)\n                team_fixtures_in_range[away_team_code].append(fixture_id)\n\n        # Calculate total xP for each player across the specified gameweeks\n        for player_id, player_data in self.players_data.items():\n            player_team_code = player_data[\"team_id\"]\n            player_position = player_data[\"position\"]\n\n            # Calculate xP for each relevant fixture and store by gameweek\n            expected_points_by_gw = {}\n            for fixture_id in team_fixtures_in_range.get(player_team_code, []):\n                fixture_gameweek = self.fixtures_data[fixture_id][\"event\"]\n                xp_result_single_gw = self.calculate_xp_for_player(\n                    player_id, fixture_id\n                )\n                if xp_result_single_gw and xp_result_single_gw[\"xp\"] is not None:\n                    if fixture_gameweek not in expected_points_by_gw:\n                        expected_points_by_gw[fixture_gameweek] = 0.0\n                    expected_points_by_gw[fixture_gameweek] += xp_result_single_gw[\"xp\"]\n\n            # Ensure all target gameweeks are present, even if xP is 0 for a given GW\n            for gw in target_gameweeks:\n                if gw not in expected_points_by_gw:\n                    expected_points_by_gw[gw] = 0.0\n\n            # Sort the dictionary by gameweek for consistent output\n            expected_points_by_gw = dict(sorted(expected_points_by_gw.items()))\n\n            # Prepare data for the optimizer\n            player_cost_m = player_data[\"cost_pence\"] / 10.0\n            team_name_full = self.teams_data.get(player_team_code, {}).get(\n                \"name\", \"Unknown Team\"\n            )\n\n            self.all_players_xp_calculated_data.append(\n                {\n                    \"name\": player_data[\"name\"],\n                    \"web_name\": player_data[\"web_name\"],\n                    \"team\": team_name_full,\n                    \"position\": player_position,\n                    \"cost\": player_cost_m,\n                    \"expected_points_by_gw\": expected_points_by_gw,  # Changed key and format\n                }\n            )\n        print(\"xP calculation for all players complete.\")\n\n    def get_upcoming_fixtures(self, limit=None):\n        \"\"\"\n        Returns a list of upcoming fixtures, sorted by gameweek and kickoff time.\n        Optionally limits the number of fixtures returned.\n        \"\"\"\n        upcoming = []\n        now = datetime.now()\n\n        # Sort all fixtures by gameweek and then by kickoff time\n        sorted_fixtures = sorted(\n            self.fixtures_data.values(),\n            key=lambda x: (\n                x.get(\"event\", 0),\n                x.get(\"kickoff_time\", \"9999-12-31T00:00:00Z\"),\n            ),\n        )\n\n        current_gameweek = None\n        for fixture_data in sorted_fixtures:\n            # Determine current gameweek from the earliest upcoming fixture\n            if not fixture_data[\"finished\"] and current_gameweek is None:\n                current_gameweek = fixture_data.get(\"event\", 0)\n\n            # Filter for upcoming fixtures within the prediction horizon\n            if (\n                fixture_data.get(\"event\", 0) &lt; current_gameweek  # Skip past gameweeks\n                or fixture_data.get(\"event\", 0)\n                &gt;= current_gameweek + self.gameweeks_to_predict\n            ):\n                continue  # Skip fixtures outside the prediction horizon\n\n            home_team_name = self.teams_data.get(\n                fixture_data[\"team_h\"], {}\n            ).get(  # Use 'team_h'\n                \"name\", \"Unknown\"\n            )\n            away_team_name = self.teams_data.get(\n                fixture_data[\"team_a\"], {}\n            ).get(  # Use 'team_a'\n                \"name\", \"Unknown\"\n            )\n\n            # Only add fixtures that are not finished\n            if not fixture_data[\"finished\"]:\n                upcoming.append(\n                    {\n                        \"fixture_id\": fixture_data[\"id\"],\n                        \"gameweek\": fixture_data.get(\"event\"),\n                        \"home_team_id\": fixture_data[\"team_h\"],  # Use 'team_h'\n                        \"away_team_id\": fixture_data[\"team_a\"],  # Use 'team_a'\n                        \"match\": f\"{home_team_name} vs {away_team_name}\",\n                        \"kickoff_time\": fixture_data.get(\"kickoff_time\"),\n                        \"home_team_difficulty\": fixture_data[\"team_h_difficulty\"],\n                        \"away_team_difficulty\": fixture_data[\"team_a_difficulty\"],\n                    }\n                )\n            if limit is not None and len(upcoming) &gt;= limit:\n                break\n        return upcoming\n\n    def get_players_for_optimizer(self):\n        \"\"\"\n        Returns the list of player data with calculated xP per gameweek,\n        formatted for the FPLOptimizer.\n        \"\"\"\n        return self.all_players_xp_calculated_data\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/fpl_xp_predictor/#build.lib.fpl_solver.fpl_xp_predictor.FPLPredictor.__init__","title":"<code>__init__(gameweeks_to_predict=1)</code>","text":"<p>Initializes the FPLPredictor with default FPL point rules and data structures, then fetches real data and calculates xP for all players.</p> <p>Parameters:</p> Name Type Description Default <code>gameweeks_to_predict</code> <code>int</code> <p>The number of upcoming gameweeks to calculate                         expected points for. Default is 1 (next gameweek).</p> <code>1</code> Source code in <code>build/lib/fpl_solver/fpl_xp_predictor.py</code> <pre><code>def __init__(self, gameweeks_to_predict: int = 1):\n    \"\"\"\n    Initializes the FPLPredictor with default FPL point rules and\n    data structures, then fetches real data and calculates xP for all players.\n\n    Args:\n        gameweeks_to_predict (int): The number of upcoming gameweeks to calculate\n                                    expected points for. Default is 1 (next gameweek).\n    \"\"\"\n    if not isinstance(gameweeks_to_predict, int) or gameweeks_to_predict &lt; 1:\n        raise ValueError(\"gameweeks_to_predict must be a positive integer.\")\n    self.gameweeks_to_predict = gameweeks_to_predict\n\n    self.fpl_points = FPL_POINTS\n\n    self.players_data = {}\n    self.teams_data = {}\n    self.fixtures_data = {}\n    self.position_definitions = {\n        1: \"GK\",\n        2: \"DEF\",\n        3: \"MID\",\n        4: \"FWD\",\n    }\n    self.all_players_xp_calculated_data = (\n        []\n    )  # To store xP for all players for the optimizer\n\n    self._fetch_fpl_data()\n    self._calculate_all_players_xp()  # Calculate xP for all players after data is loaded\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/fpl_xp_predictor/#build.lib.fpl_solver.fpl_xp_predictor.FPLPredictor.calculate_xp_for_player","title":"<code>calculate_xp_for_player(player_id, fixture_id)</code>","text":"<p>Calculates Expected Points (xP) for a single player in a given fixture. Considers various factors: minutes, goals, assists, clean sheets, saves, bonus points, and negative events, adjusted for fixture difficulty.</p> Source code in <code>build/lib/fpl_solver/fpl_xp_predictor.py</code> <pre><code>def calculate_xp_for_player(self, player_id, fixture_id):\n    \"\"\"\n    Calculates Expected Points (xP) for a single player in a given fixture.\n    Considers various factors: minutes, goals, assists, clean sheets, saves,\n    bonus points, and negative events, adjusted for fixture difficulty.\n    \"\"\"\n    player = self.players_data.get(player_id)\n    fixture = self.fixtures_data.get(fixture_id)\n\n    if not player or not fixture:\n        return {\"xp\": 0.0, \"reason\": \"Player or fixture data missing.\"}\n\n    # Handle unavailable players\n    if (\n        player[\"status\"] != \"a\"\n    ):  # 'd' for doubtful, 'i' for injured, 's' for suspended\n        return {\"xp\": 0.0, \"reason\": f\"Player status: {player['status']}\"}\n    if any(\n        x in player[\"news\"].lower()\n        for x in [\"injured\", \"doubtful\", \"suspension\", \"red card\"]\n    ):\n        return {\"xp\": 0.0, \"reason\": f\"Player news: {player['news']}\"}\n\n    # Predict minutes\n    expected_minutes = self._predict_minutes(player_id)\n    if expected_minutes &lt; 1.0:  # If expected to play very little or none\n        return {\"xp\": 0.0, \"reason\": \"Expected minutes too low.\"}\n\n    xp = 0.0\n    position = player[\"position\"]\n    # Use 'team_h' for home team ID\n    is_home_fixture = player[\"team_id\"] == fixture[\"team_h\"]\n\n    # Determine attacking and defensive strengths for the fixture\n    player_team_strength_attack = (\n        self.teams_data.get(fixture[\"team_h\"], {}).get(\n            \"strength_attack_home\"\n        )  # Use 'team_h'\n        if is_home_fixture\n        else self.teams_data.get(fixture[\"team_a\"], {}).get(\n            \"strength_attack_away\"\n        )  # Use 'team_a'\n    )\n    player_team_strength_defence = (\n        self.teams_data.get(fixture[\"team_h\"], {}).get(\n            \"strength_defence_home\"\n        )  # Use 'team_h'\n        if is_home_fixture\n        else self.teams_data.get(fixture[\"team_a\"], {}).get(\n            \"strength_defence_away\"\n        )  # Use 'team_a'\n    )\n    opponent_team_strength_attack = (\n        self.teams_data.get(fixture[\"team_a\"], {}).get(\n            \"strength_attack_away\"\n        )  # Use 'team_a'\n        if is_home_fixture\n        else self.teams_data.get(fixture[\"team_h\"], {}).get(\n            \"strength_attack_home\"\n        )  # Use 'team_h'\n    )\n    opponent_team_strength_defence = (\n        self.teams_data.get(fixture[\"team_a\"], {}).get(\n            \"strength_defence_away\"\n        )  # Use 'team_a'\n        if is_home_fixture\n        else self.teams_data.get(fixture[\"team_h\"], {}).get(\n            \"strength_defence_home\"\n        )  # Use 'team_h'\n    )\n\n    if None in [\n        player_team_strength_attack,\n        player_team_strength_defence,\n        opponent_team_strength_attack,\n        opponent_team_strength_defence,\n    ]:\n        # Fallback if strength data is missing (shouldn't happen with robust data fetch)\n        return {\"xp\": 0.0, \"reason\": \"Team strength data missing for fixture.\"}\n\n    # 1. Appearance points\n    if expected_minutes &gt;= 60:\n        xp += self.fpl_points[\"appearance_points_gte_60\"]\n    elif expected_minutes &gt; 0:\n        xp += self.fpl_points[\"appearance_points_lt_60\"]\n\n    # 2. Expected Goals (scaled by historical goals per 90 and opponent difficulty)\n    # Use player's form and total goals as a basis\n    goals_per_90_hist = (\n        (player[\"goals_scored\"] / player[\"minutes\"] * 90)\n        if player[\"minutes\"] &gt; 0\n        else 0.0\n    )\n    expected_team_goals = self._calculate_expected_goals(\n        player_team_strength_attack, opponent_team_strength_defence\n    )\n\n    expected_goals_player_contribution = (\n        (goals_per_90_hist / 90.0) * expected_minutes * (expected_team_goals / 1.5)\n    )  # Scale player's goal contribution by team's expected goals\n\n    if position == \"GK\":\n        xp += expected_goals_player_contribution * self.fpl_points[\"goal_gk\"]\n    elif position == \"DEF\":\n        xp += expected_goals_player_contribution * self.fpl_points[\"goal_def\"]\n    elif position == \"MID\":\n        xp += expected_goals_player_contribution * self.fpl_points[\"goal_mid\"]\n    elif position == \"FWD\":\n        xp += expected_goals_player_contribution * self.fpl_points[\"goal_fwd\"]\n\n    # 3. Expected Assists (scaled by historical assists per 90 and opponent difficulty)\n    assists_per_90_hist = (\n        (player[\"assists\"] / player[\"minutes\"] * 90)\n        if player[\"minutes\"] &gt; 0\n        else 0.0\n    )\n    # Assuming team's attacking strength correlates with assist opportunities\n    expected_assists_player_contribution = (\n        (assists_per_90_hist / 90.0)\n        * expected_minutes\n        * (expected_team_goals / 1.5)\n    )  # Similarly scale by team's expected goals\n    xp += expected_assists_player_contribution * self.fpl_points[\"assist_points\"]\n\n    # 4. Expected Clean Sheets (for GKs/DEFs/MIDs) and Conceded Goals deduction\n    expected_conceded = self._calculate_expected_conceded_goals(\n        player_team_strength_defence, opponent_team_strength_attack\n    )\n\n    # Probability of clean sheet\n    # Simplified: higher team defense / lower opponent attack -&gt; higher CS prob\n    # Use logistic or sigmoid for probability\n    cs_prob = 1.0 / (\n        1.0 + math.exp(expected_conceded - 1.0)\n    )  # Sigmoid centered at 1 goal\n\n    if position in [\"GK\", \"DEF\"]:\n        xp += cs_prob * self.fpl_points[\"clean_sheet_gk_def\"]\n\n        # Conceded goals deduction: Apply penalty for every 2 goals conceded *probability*\n        # For simplicity, calculate expected deduction: (expected_conceded / 2) * deduction\n        xp += (expected_conceded / 2.0) * self.fpl_points[\n            \"conceded_2_goals_deduction\"\n        ]\n    elif position == \"MID\":\n        xp += cs_prob * self.fpl_points[\"clean_sheet_mid\"]\n\n    # 5. Expected Saves (for GKs)\n    if position == \"GK\":\n        saves_per_90_hist = (\n            (player[\"saves\"] / player[\"minutes\"] * 90)\n            if player[\"minutes\"] &gt; 0\n            else 0.0\n        )\n        # Expected saves scaled by opponent's attacking strength (more attacking -&gt; more shots -&gt; more saves)\n        expected_saves_player_contribution = (\n            (saves_per_90_hist / 90.0)\n            * expected_minutes\n            * (opponent_team_strength_attack / player_team_strength_defence)\n        )\n        xp += (expected_saves_player_contribution / 3.0) * self.fpl_points[\n            \"saves_3_points\"\n        ]  # Using the new config point value\n\n        # Penalty saves (low probability, use historical rate)\n        penalty_saves_hist_per_game = (\n            player[\"penalties_saved\"] / (player[\"minutes\"] / 90.0)\n            if player[\"minutes\"] &gt; 0\n            else 0.0\n        )\n        xp += (\n            penalty_saves_hist_per_game\n            * (expected_minutes / 90.0)\n            * self.fpl_points[\"penalty_save_points\"]\n        )\n\n    # 6. Expected Bonus Points\n    # Use BPS (Bonus Points System) as a proxy. Scale player's average BPS by form and expected minutes.\n    bps_per_90_hist = (\n        (player[\"bps\"] / player[\"minutes\"] * 90) if player[\"minutes\"] &gt; 0 else 0.0\n    )\n    expected_bps = (bps_per_90_hist / 90.0) * expected_minutes * player[\"form\"]\n    xp += expected_bps * self.fpl_points[\"bonus_points_scaling_factor\"]\n\n    # 7. Minor Negative Events (Probabilistic)\n    # These are rare, so a simple probability based on expected minutes.\n    xp += (expected_minutes / 90.0) * (\n        self.fpl_points[\"yellow_card_deduction\"] * YELLOW_CARD_PROB\n        + self.fpl_points[\"red_card_deduction\"] * RED_CARD_PROB\n        + self.fpl_points[\"own_goal_deduction\"] * OWN_GOAL_PROB\n        + self.fpl_points[\"penalty_miss_deduction\"] * PENALTY_MISS_PROB\n    )\n\n    # 8. Defensive Contribution Points (for 2025/26 season heuristic)\n    # Assuming CBIT/CBIRT tracking\n    if position in [\"GK\", \"DEF\"]:\n        xp += CBIT_DEF_PROB * self.fpl_points[\"cbit_def_points\"]\n    elif position in [\"MID\", \"FWD\"]:\n        xp += CBIRT_MID_FWD_PROB * self.fpl_points[\"cbirt_mid_fwd_points\"]\n\n    return {\"xp\": round(xp, 2), \"reason\": \"Success\"}\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/fpl_xp_predictor/#build.lib.fpl_solver.fpl_xp_predictor.FPLPredictor.get_players_for_optimizer","title":"<code>get_players_for_optimizer()</code>","text":"<p>Returns the list of player data with calculated xP per gameweek, formatted for the FPLOptimizer.</p> Source code in <code>build/lib/fpl_solver/fpl_xp_predictor.py</code> <pre><code>def get_players_for_optimizer(self):\n    \"\"\"\n    Returns the list of player data with calculated xP per gameweek,\n    formatted for the FPLOptimizer.\n    \"\"\"\n    return self.all_players_xp_calculated_data\n</code></pre>"},{"location":"autoapi/build/lib/fpl_solver/fpl_xp_predictor/#build.lib.fpl_solver.fpl_xp_predictor.FPLPredictor.get_upcoming_fixtures","title":"<code>get_upcoming_fixtures(limit=None)</code>","text":"<p>Returns a list of upcoming fixtures, sorted by gameweek and kickoff time. Optionally limits the number of fixtures returned.</p> Source code in <code>build/lib/fpl_solver/fpl_xp_predictor.py</code> <pre><code>def get_upcoming_fixtures(self, limit=None):\n    \"\"\"\n    Returns a list of upcoming fixtures, sorted by gameweek and kickoff time.\n    Optionally limits the number of fixtures returned.\n    \"\"\"\n    upcoming = []\n    now = datetime.now()\n\n    # Sort all fixtures by gameweek and then by kickoff time\n    sorted_fixtures = sorted(\n        self.fixtures_data.values(),\n        key=lambda x: (\n            x.get(\"event\", 0),\n            x.get(\"kickoff_time\", \"9999-12-31T00:00:00Z\"),\n        ),\n    )\n\n    current_gameweek = None\n    for fixture_data in sorted_fixtures:\n        # Determine current gameweek from the earliest upcoming fixture\n        if not fixture_data[\"finished\"] and current_gameweek is None:\n            current_gameweek = fixture_data.get(\"event\", 0)\n\n        # Filter for upcoming fixtures within the prediction horizon\n        if (\n            fixture_data.get(\"event\", 0) &lt; current_gameweek  # Skip past gameweeks\n            or fixture_data.get(\"event\", 0)\n            &gt;= current_gameweek + self.gameweeks_to_predict\n        ):\n            continue  # Skip fixtures outside the prediction horizon\n\n        home_team_name = self.teams_data.get(\n            fixture_data[\"team_h\"], {}\n        ).get(  # Use 'team_h'\n            \"name\", \"Unknown\"\n        )\n        away_team_name = self.teams_data.get(\n            fixture_data[\"team_a\"], {}\n        ).get(  # Use 'team_a'\n            \"name\", \"Unknown\"\n        )\n\n        # Only add fixtures that are not finished\n        if not fixture_data[\"finished\"]:\n            upcoming.append(\n                {\n                    \"fixture_id\": fixture_data[\"id\"],\n                    \"gameweek\": fixture_data.get(\"event\"),\n                    \"home_team_id\": fixture_data[\"team_h\"],  # Use 'team_h'\n                    \"away_team_id\": fixture_data[\"team_a\"],  # Use 'team_a'\n                    \"match\": f\"{home_team_name} vs {away_team_name}\",\n                    \"kickoff_time\": fixture_data.get(\"kickoff_time\"),\n                    \"home_team_difficulty\": fixture_data[\"team_h_difficulty\"],\n                    \"away_team_difficulty\": fixture_data[\"team_a_difficulty\"],\n                }\n            )\n        if limit is not None and len(upcoming) &gt;= limit:\n            break\n    return upcoming\n</code></pre>"},{"location":"autoapi/fpl_solver/","title":"fpl_solver","text":""},{"location":"autoapi/fpl_solver/#fpl_solver.fpl_config","title":"<code>fpl_config</code>","text":"<p>fpl_config.py</p> <p>Configuration settings for the FPL Expected Points Predictor and Solver. This file centralizes all constants related to FPL scoring, thresholds, and optimization parameters.</p>"},{"location":"autoapi/fpl_solver/#fpl_solver.fpl_solver","title":"<code>fpl_solver</code>","text":""},{"location":"autoapi/fpl_solver/#fpl_solver.fpl_solver.FPLOptimizer","title":"<code>FPLOptimizer</code>","text":"<p>A class to optimize Fantasy Premier League (FPL) squad selection using Integer Linear Programming (ILP).</p> <p>The optimizer aims to select a 15-player squad (2 GKs, 5 DEFs, 5 MIDs, 3 FWDs) within a budget, with a maximum number of players from any single team, to maximize the total expected points.</p> Source code in <code>fpl_solver/fpl_solver.py</code> <pre><code>class FPLOptimizer:\n    \"\"\"\n    A class to optimize Fantasy Premier League (FPL) squad selection\n    using Integer Linear Programming (ILP).\n\n    The optimizer aims to select a 15-player squad (2 GKs, 5 DEFs, 5 MIDs, 3 FWDs)\n    within a budget, with a maximum number of players from any single team,\n    to maximize the total expected points.\n    \"\"\"\n\n    def __init__(self, player_data: pd.DataFrame):\n        \"\"\"\n        Initializes the FPLOptimizer with player data.\n\n        Args:\n            player_data (pd.DataFrame): A DataFrame containing player information\n                                        with columns: 'name', 'team', 'position',\n                                        'cost', 'expected_points_by_gw' (a dict of xP per GW).\n        \"\"\"\n        required_columns = [\"name\", \"team\", \"position\", \"cost\", \"expected_points_by_gw\"]\n        if not all(col in player_data.columns for col in required_columns):\n            missing_cols = [\n                col for col in required_columns if col not in player_data.columns\n            ]\n            raise ValueError(\n                f\"player_data DataFrame must contain {required_columns} columns. Missing: {missing_cols}\"\n            )\n\n        self.player_data = player_data\n        self.problem = None\n        self.selected_squad_history = {}  # To store squad for each gameweek\n        self.total_cost = 0\n        self.total_expected_points = 0\n        self.total_transfer_hits = 0\n\n        # --- Process Enforced Players ---\n        self.enforced_player_indices = set()\n        self.enforced_team_pos_requirements = []\n\n        print(\"\\n--- Processing Enforced Players ---\")\n\n        # Enforce by Player ID\n        for player_id in ENFORCED_PLAYERS_BY_ID:\n            found_player = self.player_data[self.player_data[\"id\"] == player_id]\n            if not found_player.empty:\n                player_idx = found_player.index[0]\n                self.enforced_player_indices.add(player_idx)\n                print(\n                    f\"Enforcing player by ID: {found_player.loc[player_idx, 'name']} (ID: {player_id})\"\n                )\n            else:\n                print(\n                    f\"Warning: Enforced player with ID {player_id} not found in data.\"\n                )\n\n        # Enforce by Player Name\n        for player_name in ENFORCED_PLAYERS_BY_NAME:\n            found_player = self.player_data[self.player_data[\"name\"] == player_name]\n            if not found_player.empty:\n                player_idx = found_player.index[0]\n                self.enforced_player_indices.add(player_idx)\n                print(f\"Enforcing player by name: {player_name}\")\n            else:\n                print(f\"Warning: Enforced player '{player_name}' not found in data.\")\n\n        # Enforce by Team and Position\n        for requirement in ENFORCED_PLAYERS_BY_TEAM_AND_POSITION:\n            team = requirement.get(\"team\")\n            position = requirement.get(\"position\")\n            if team and position:\n                # Validate team and position exist in data\n                if team not in self.player_data[\"team\"].unique():\n                    print(\n                        f\"Warning: Enforced team '{team}' for position '{position}' not found in data.\"\n                    )\n                    continue\n                if position not in self.player_data[\"position\"].unique():\n                    print(\n                        f\"Warning: Enforced position '{position}' for team '{team}' not found in data.\"\n                    )\n                    continue\n\n                self.enforced_team_pos_requirements.append((team, position))\n                print(f\"Enforcing at least one {position} from {team}.\")\n            else:\n                print(\n                    f\"Warning: Invalid enforced team/position requirement: {requirement}\"\n                )\n\n        if not (\n            self.enforced_player_indices\n            or self.enforced_team_pos_requirements\n            or ENFORCED_PLAYERS_BY_ID\n            or ENFORCED_PLAYERS_BY_NAME\n            or ENFORCED_PLAYERS_BY_TEAM_AND_POSITION\n        ):\n            print(\"No players or team/position combinations are enforced.\")\n        print(\"-----------------------------------\\n\")\n\n    def solve(\n        self,\n        budget: float,\n        max_players_per_team: int,\n        chip_allowances: dict,\n        num_gameweeks: int,\n    ) -&gt; bool:\n        \"\"\"\n        Solves the FPL optimization problem using PuLP.\n\n        Args:\n            budget (float): The maximum budget in millions of pounds.\n            max_players_per_team (int): The maximum number of players allowed from\n                                        any single Premier League team.\n            chip_allowances (dict): A dictionary specifying the maximum usage for each chip.\n            num_gameweeks (int): The number of gameweeks to optimize over.\n\n        Returns:\n            bool: True if a solution was found, False otherwise.\n        \"\"\"\n        self.problem = LpProblem(\"FPL Squad Multi-Week Optimization\", LpMaximize)\n\n        # Decision variables for player selection, indexed by player and gameweek\n        player_vars = LpVariable.dicts(\n            \"Player\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n        )\n        starting_xi_vars = LpVariable.dicts(\n            \"StartingXI\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n        )\n        captain_var = LpVariable.dicts(\n            \"Captain\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n        )\n\n        # Binary variables for chip usage, indexed by gameweek\n        use_bench_boost = LpVariable.dicts(\n            \"Use_Bench_Boost\", range(num_gameweeks), 0, 1, LpBinary\n        )\n        use_triple_captain = LpVariable.dicts(\n            \"Use_Triple_Captain\", range(num_gameweeks), 0, 1, LpBinary\n        )\n\n        # Transfer variables\n        transfer_in_vars = LpVariable.dicts(\n            \"Transfer_In\",\n            (self.player_data.index, range(1, num_gameweeks)),\n            0,\n            1,\n            LpBinary,\n        )\n        transfer_out_vars = LpVariable.dicts(\n            \"Transfer_Out\",\n            (self.player_data.index, range(1, num_gameweeks)),\n            0,\n            1,\n            LpBinary,\n        )\n\n        # Total transfers made in a gameweek (absolute count)\n        transfers_made = LpVariable.dicts(\n            \"Transfers_Made\", range(1, num_gameweeks), 0, None, LpInteger\n        )\n        # Free transfers available at the start of a gameweek\n        free_transfers_available = LpVariable.dicts(\n            \"Free_Transfers_Available\",\n            range(num_gameweeks),\n            0,\n            MAX_FREE_TRANSFERS_SAVED + 1,\n            LpInteger,\n        )\n        # Number of transfer hits taken in a gameweek\n        transfer_hits = LpVariable.dicts(\n            \"Transfer_Hits\", range(1, num_gameweeks), 0, None, LpInteger\n        )\n\n        # Auxiliary variables for linearizing chip effects\n        is_bench_player = LpVariable.dicts(\n            \"Is_Bench_Player\",\n            (self.player_data.index, range(num_gameweeks)),\n            0,\n            1,\n            LpBinary,\n        )\n        actual_bench_boost_points = LpVariable.dicts(\n            \"Actual_Bench_Boost_Points\",\n            (self.player_data.index, range(num_gameweeks)),\n            0,\n            None,\n            LpContinuous,\n        )\n        actual_triple_captain_bonus = LpVariable.dicts(\n            \"Actual_Triple_Captain_Bonus\",\n            (self.player_data.index, range(num_gameweeks)),\n            0,\n            None,\n            LpContinuous,\n        )\n\n        # --- Objective Function ---\n        total_objective_points = []\n\n        # Get the first gameweek number from the player data to correctly index expected_points_by_gw\n        first_gw_key = next(\n            iter(\n                self.player_data.loc[\n                    self.player_data.index[0], \"expected_points_by_gw\"\n                ].keys()\n            )\n        )\n        current_gameweek_number_start = int(first_gw_key)\n\n        for w in range(num_gameweeks):\n            # The actual gameweek number (1-indexed)\n            gw_actual = current_gameweek_number_start + w\n\n            # Base expected points from the selected starting 11 for this gameweek\n            base_points_expression_gw = lpSum(\n                self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n                * starting_xi_vars[i][w]\n                for i in self.player_data.index\n            )\n            total_objective_points.append(base_points_expression_gw)\n\n            # Regular Captaincy points (additional 1x for captain)\n            captain_points_bonus_gw = lpSum(\n                self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n                * captain_var[i][w]\n                for i in self.player_data.index\n            )\n            total_objective_points.append(captain_points_bonus_gw)\n\n            # Define auxiliary variables and constraints for chips for each gameweek\n            for i in self.player_data.index:\n                # Use gameweek-specific player xP for chip calculations\n                player_xp = self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n\n                # Bench Boost auxiliary variables and constraints\n                self.problem += (\n                    is_bench_player[i][w] &lt;= player_vars[i][w],\n                    f\"IsBench_Squad_{i}_{w}\",\n                )\n                self.problem += (\n                    is_bench_player[i][w] &lt;= 1 - starting_xi_vars[i][w],\n                    f\"IsBench_NotStarter_{i}_{w}\",\n                )\n                self.problem += (\n                    is_bench_player[i][w]\n                    &gt;= player_vars[i][w] + (1 - starting_xi_vars[i][w]) - 1,\n                    f\"IsBench_Logical_{i}_{w}\",\n                )\n\n                self.problem += (\n                    actual_bench_boost_points[i][w]\n                    &lt;= player_xp * is_bench_player[i][w],\n                    f\"BenchBoost_Contr_1_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_bench_boost_points[i][w] &lt;= player_xp * use_bench_boost[w],\n                    f\"BenchBoost_Contr_2_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_bench_boost_points[i][w]\n                    &gt;= player_xp * (is_bench_player[i][w] + use_bench_boost[w] - 1),\n                    f\"BenchBoost_Contr_3_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_bench_boost_points[i][w] &gt;= 0,\n                    f\"BenchBoost_Contr_4_{i}_{w}\",\n                )\n\n                # Triple Captain auxiliary variables and constraints\n                # Changed player_xp * 2 to player_xp to reflect additional 1x bonus\n                self.problem += (\n                    actual_triple_captain_bonus[i][w] &lt;= player_xp * captain_var[i][w],\n                    f\"TripleCaptain_Contr_1_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_triple_captain_bonus[i][w]\n                    &lt;= player_xp * use_triple_captain[w],\n                    f\"TripleCaptain_Contr_2_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_triple_captain_bonus[i][w]\n                    &gt;= player_xp * (captain_var[i][w] + use_triple_captain[w] - 1),\n                    f\"TripleCaptain_Contr_3_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_triple_captain_bonus[i][w] &gt;= 0,\n                    f\"TripleCaptain_Contr_4_{i}_{w}\",\n                )\n\n            # Add points from bench boost and triple captain bonus for this gameweek\n            total_bench_boost_points_gw = lpSum(\n                actual_bench_boost_points[i][w] for i in self.player_data.index\n            )\n            total_triple_captain_bonus_points_gw = lpSum(\n                actual_triple_captain_bonus[i][w] for i in self.player_data.index\n            )\n\n            total_objective_points.append(total_bench_boost_points_gw)\n            total_objective_points.append(total_triple_captain_bonus_points_gw)\n\n        # Subtract transfer hits from the total objective\n        total_objective_points.append(\n            -POINTS_PER_HIT * lpSum(transfer_hits[w] for w in range(1, num_gameweeks))\n        )\n\n        self.problem += (\n            lpSum(total_objective_points),\n            \"Total Expected Points Over Gameweeks\",\n        )\n\n        # --- Constraints ---\n\n        # Apply constraints for each gameweek\n        for w in range(num_gameweeks):\n            # 1. Select exactly 15 players for the squad\n            self.problem += (\n                lpSum(player_vars[i][w] for i in self.player_data.index) == 15,\n                f\"Total_Players_GW{w}\",\n            )\n\n            # 2. Squad position constraints (2 GKs, 5 DEFs, 5 MIDs, 3 FWDs)\n            gks = self.player_data[self.player_data[\"position\"] == \"GK\"].index\n            defs = self.player_data[self.player_data[\"position\"] == \"DEF\"].index\n            mids = self.player_data[self.player_data[\"position\"] == \"MID\"].index\n            fwds = self.player_data[self.player_data[\"position\"] == \"FWD\"].index\n\n            self.problem += (\n                lpSum(player_vars[i][w] for i in gks) == 2,\n                f\"Goalkeepers_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(player_vars[i][w] for i in defs) == 5,\n                f\"Defenders_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(player_vars[i][w] for i in mids) == 5,\n                f\"Midfielders_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(player_vars[i][w] for i in fwds) == 3,\n                f\"Forwards_Count_GW{w}\",\n            )\n\n            # 3. Budget constraint\n            # This applies to the cost of the squad for the current gameweek.\n            self.problem += (\n                lpSum(\n                    self.player_data.loc[i, \"cost\"] * player_vars[i][w]\n                    for i in self.player_data.index\n                )\n                &lt;= budget,\n                f\"Total_Budget_GW{w}\",\n            )\n\n            # 4. Maximum players per team constraint\n            for team in self.player_data[\"team\"].unique():\n                team_players = self.player_data[self.player_data[\"team\"] == team].index\n                self.problem += (\n                    lpSum(player_vars[i][w] for i in team_players)\n                    &lt;= max_players_per_team,\n                    f\"Max_Players_from_{team}_GW{w}\",\n                )\n\n            # 5. Starting XI constraints\n            # 5.1 Select exactly 11 players for the starting XI\n            self.problem += (\n                lpSum(starting_xi_vars[i][w] for i in self.player_data.index) == 11,\n                f\"Total_Starting_XI_Players_GW{w}\",\n            )\n\n            # 5.2 A player can only be in the starting XI if they are in the squad\n            for i in self.player_data.index:\n                self.problem += (\n                    starting_xi_vars[i][w] &lt;= player_vars[i][w],\n                    f\"StartingXI_in_Squad_{i}_{w}\",\n                )\n\n            # 5.3 Starting XI position constraints (FPL allows flexible formations, so use minimums)\n            self.problem += (\n                lpSum(starting_xi_vars[i][w] for i in gks) == 1,\n                f\"Starting_Goalkeepers_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(starting_xi_vars[i][w] for i in defs) &gt;= 3,\n                f\"Min_Starting_Defenders_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(starting_xi_vars[i][w] for i in mids) &gt;= 2,\n                f\"Min_Starting_Midfielders_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(starting_xi_vars[i][w] for i in fwds) &gt;= 1,\n                f\"Min_Starting_Forwards_Count_GW{w}\",\n            )\n\n            # 6. Captain Constraints\n            # 6.1 Select exactly one captain from the starting XI\n            self.problem += (\n                lpSum(captain_var[i][w] for i in self.player_data.index) == 1,\n                f\"One_Captain_GW{w}\",\n            )\n\n            # 6.2 A player can only be captain if they are in the starting XI\n            for i in self.player_data.index:\n                self.problem += (\n                    captain_var[i][w] &lt;= starting_xi_vars[i][w],\n                    f\"Captain_in_StartingXI_{i}_{w}\",\n                )\n\n            # --- Enforced Player Constraints---\n            for player_idx in self.enforced_player_indices:\n                self.problem += (\n                    player_vars[player_idx][w] == 1,\n                    f\"Enforce_Player_{self.player_data.loc[player_idx, 'name']}_GW{w}\",\n                )\n\n            for team, position in self.enforced_team_pos_requirements:\n                # Filter players for the current team and position\n                team_pos_players = self.player_data[\n                    (self.player_data[\"team\"] == team)\n                    &amp; (self.player_data[\"position\"] == position)\n                ].index\n                if not team_pos_players.empty:\n                    self.problem += (\n                        lpSum(player_vars[i][w] for i in team_pos_players) &gt;= 1,\n                        f\"Enforce_One_{position}_from_{team}_GW{w}\",\n                    )\n                else:\n                    print(\n                        f\"Warning: No players found for enforced requirement: at least one {position} from {team} for GW{gw_actual}.\"\n                    )\n\n        # --- Chip Usage Constraints (TOTAL usage over all gameweeks) ---\n        # These constraints should be outside the per-gameweek loop to avoid duplicates.\n        self.problem += (\n            lpSum(use_bench_boost[j] for j in range(num_gameweeks))\n            &lt;= chip_allowances.get(\"bench_boost\", 0),\n            f\"Max_Bench_Boost_Usage_Total\",\n        )\n        self.problem += (\n            lpSum(use_triple_captain[j] for j in range(num_gameweeks))\n            &lt;= chip_allowances.get(\"triple_captain\", 0),\n            f\"Max_Triple_Captain_Usage_Total\",\n        )\n\n        # --- Inter-Gameweek Constraints (Transfers and Transfer Rules) ---\n        # Initialize free transfers for GW0 (first gameweek of optimization horizon)\n        # This assumes the optimization starts at GW0, and it has INITIAL_FREE_TRANSFERS.\n        # If the model starts at an arbitrary GW, this would need to be an input.\n        self.problem += (\n            free_transfers_available[0] == INITIAL_FREE_TRANSFERS,\n            f\"Initial_Free_Transfers_GW0\",\n        )\n\n        for w in range(1, num_gameweeks):\n            # Calculate total transfers made in this gameweek\n            self.problem += (\n                transfers_made[w]\n                == lpSum(transfer_in_vars[i][w] for i in self.player_data.index),\n                f\"Transfers_Made_GW{w}\",\n            )\n            # Total transfers in must equal total transfers out for each gameweek after the first\n            self.problem += (\n                lpSum(transfer_in_vars[i][w] for i in self.player_data.index)\n                == lpSum(transfer_out_vars[i][w] for i in self.player_data.index),\n                f\"Transfers_In_Equals_Out_GW{w}\",\n            )\n\n            # Calculate free transfers available for the current gameweek (w)\n            # Free transfers for GW_w = min(free transfers from GW_w-1 - transfers made in GW_w + 1, MAX_FREE_TRANSFERS_SAVED + 1)\n            # The + 1 in MAX_FREE_TRANSFERS_SAVED + 1 is because MAX_FREE_TRANSFERS_SAVED implies how many can be *saved*,\n            # so if you save 1, you have 1 (current) + 1 (saved) = 2.\n            self.problem += (\n                free_transfers_available[w]\n                &lt;= free_transfers_available[w - 1] - transfers_made[w] + 1,\n                f\"Free_Transfers_Calc_1_GW{w}\",\n            )\n            self.problem += (\n                free_transfers_available[w] &lt;= MAX_FREE_TRANSFERS_SAVED + 1,\n                f\"Free_Transfers_Calc_2_GW{w}\",\n            )\n            self.problem += (\n                free_transfers_available[w] &gt;= 0,  # Cannot have negative free transfers\n                f\"Free_Transfers_Non_Negative_GW{w}\",\n            )\n\n            # Calculate transfer hits\n            # transfer_hits[w] = max(0, transfers_made[w] - free_transfers_available_at_start_of_gw_w)\n            # This needs to be linearized. If transfers_made[w] &gt; free_transfers_available[w-1], then hit.\n            # free_transfers_available[w-1] represents transfers available *before* making transfers for GW_w\n            self.problem += (\n                transfer_hits[w] &gt;= transfers_made[w] - free_transfers_available[w - 1],\n                f\"Transfer_Hits_Calc_1_GW{w}\",\n            )\n            self.problem += (\n                transfer_hits[w] &gt;= 0,\n                f\"Transfer_Hits_Calc_2_GW{w}\",\n            )\n\n            for i in self.player_data.index:\n                # Squad continuity: player_vars[i][w] (in squad at start of GW w)\n                #                 = player_vars[i][w-1] (in squad at start of GW w-1)\n                #                 - transfer_out_vars[i][w] (transferred out for GW w)\n                #                 + transfer_in_vars[i][w] (transferred in for GW w)\n                self.problem += (\n                    player_vars[i][w]\n                    == player_vars[i][w - 1]\n                    - transfer_out_vars[i][w]\n                    + transfer_in_vars[i][w],\n                    f\"Squad_Continuity_{i}_GW{w}\",\n                )\n                # A player cannot be transferred in and out in the same gameweek\n                self.problem += (\n                    transfer_in_vars[i][w] + transfer_out_vars[i][w] &lt;= 1,\n                    f\"No_Simultaneous_Transfer_{i}_{w}\",\n                )\n\n        try:\n            # The solver is called with the GLPK_CMD solver\n            self.problem.solve(PULP_CBC_CMD(msg=0))  # msg=0 suppresses verbose output\n        except Exception as e:\n            print(f\"Error solving the problem: {e}\")\n            return False\n\n        if LpStatus[self.problem.status] == \"Optimal\":\n            print(\"Optimization successful! Optimal solution found.\")\n\n            self.selected_squad_history = {}\n            self.total_transfer_hits = 0\n            for w in range(num_gameweeks):\n                # The actual gameweek number (1-indexed)\n                gw_actual = current_gameweek_number_start + w\n\n                # Get selected players for the current gameweek\n                selected_squad_gw = self.player_data[\n                    [player_vars[i][w].varValue == 1 for i in self.player_data.index]\n                ].copy()\n\n                # Get starter and captain info for this gameweek\n                is_starter_series_gw = pd.Series(\n                    [\n                        starting_xi_vars[i][w].varValue == 1\n                        for i in self.player_data.index\n                    ],\n                    index=self.player_data.index,\n                )\n                is_captain_series_gw = pd.Series(\n                    [captain_var[i][w].varValue == 1 for i in self.player_data.index],\n                    index=self.player_data.index,\n                )\n\n                selected_squad_gw[\"is_starter\"] = is_starter_series_gw.loc[\n                    selected_squad_gw.index\n                ]\n                selected_squad_gw[\"is_captain\"] = is_captain_series_gw.loc[\n                    selected_squad_gw.index\n                ]\n\n                transfers_in_gw = 0\n                transfers_out_gw = 0\n                hits_gw = 0\n\n                # Store transfer details for gameweeks &gt; 0\n                if (\n                    w &gt; 0\n                ):  # Check for transfers only from GW1 onwards (index 1 in 0-indexed loop)\n                    transfer_in_flags = pd.Series(\n                        [\n                            transfer_in_vars[i][w].varValue == 1\n                            for i in self.player_data.index\n                        ],\n                        index=self.player_data.index,\n                    )\n                    transfer_out_flags = pd.Series(\n                        [\n                            transfer_out_vars[i][w].varValue == 1\n                            for i in self.player_data.index\n                        ],\n                        index=self.player_data.index,\n                    )\n\n                    selected_squad_gw[\"transfer_in\"] = transfer_in_flags.loc[\n                        selected_squad_gw.index\n                    ]\n                    selected_squad_gw[\"transfer_out\"] = transfer_out_flags.loc[\n                        selected_squad_gw.index\n                    ]\n\n                    transfers_in_gw = int(round(transfer_in_flags.sum()))\n                    transfers_out_gw = int(round(transfer_out_flags.sum()))\n                    hits_gw = int(round(transfer_hits[w].varValue))\n                    self.total_transfer_hits += hits_gw\n                else:\n                    selected_squad_gw[\"transfer_in\"] = False  # No transfers in for GW0\n                    selected_squad_gw[\"transfer_out\"] = (\n                        False  # No transfers out for GW0\n                    )\n\n                self.selected_squad_history[f\"GW{gw_actual}\"] = {\n                    \"squad\": selected_squad_gw,\n                    \"total_cost\": selected_squad_gw[\"cost\"].sum(),\n                    \"expected_points_from_xi\": sum(\n                        self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n                        * starting_xi_vars[i][w].varValue\n                        for i in self.player_data.index\n                    ),\n                    \"bench_boost_used\": bool(use_bench_boost[w].varValue),\n                    \"triple_captain_used\": bool(use_triple_captain[w].varValue),\n                    \"total_bench_boost_points\": value(\n                        lpSum(\n                            actual_bench_boost_points[i][w]\n                            for i in self.player_data.index\n                        )\n                    ),\n                    \"total_triple_captain_bonus\": value(\n                        lpSum(\n                            actual_triple_captain_bonus[i][w]\n                            for i in self.player_data.index\n                        )\n                    ),\n                    \"transfers_in_count\": transfers_in_gw,\n                    \"transfers_out_count\": transfers_out_gw,\n                    \"transfer_hits\": hits_gw,  # New\n                    \"free_transfers_available_next_gw\": (\n                        int(round(free_transfers_available[w].varValue))\n                        if w &lt; num_gameweeks - 1\n                        else 0\n                    ),  # Free transfers available *after* this GW's transfers are made\n                }\n\n            # Overall totals\n            self.total_cost = self.selected_squad_history[\n                f\"GW{current_gameweek_number_start + num_gameweeks - 1}\"\n            ][\n                \"total_cost\"\n            ]  # Cost of final squad\n            self.total_expected_points = value(\n                self.problem.objective\n            )  # Total objective value from solver\n            self.used_chips = {\n                f\"GW{current_gameweek_number_start + w}\": {\n                    \"bench_boost\": bool(use_bench_boost[w].varValue),\n                    \"triple_captain\": bool(use_triple_captain[w].varValue),\n                }\n                for w in range(num_gameweeks)\n            }\n\n            return True\n        else:\n            print(f\"No optimal solution found. Status: {LpStatus[self.problem.status]}\")\n            self.selected_squad_history = {}\n            self.total_cost = 0\n            self.total_expected_points = 0\n            self.used_chips = {}\n            self.total_transfer_hits = 0\n            return False\n\n    def get_selected_squad(self, gameweek: int = None) -&gt; pd.DataFrame | None:\n        \"\"\"\n        Returns the selected squad for a specific gameweek (1-indexed).\n        If no gameweek is specified, returns the squad for the last optimized gameweek.\n        \"\"\"\n        if not self.selected_squad_history:\n            return None\n\n        # Get the first GW key to determine the range of available GWs\n        first_gw_in_history = min(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n        last_gw_in_history = max(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n\n        if gameweek is None:\n            return self.selected_squad_history[f\"GW{last_gw_in_history}\"][\"squad\"]\n\n        if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n            print(\n                f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n            )\n            return None\n\n        return self.selected_squad_history.get(f\"GW{gameweek}\", {}).get(\"squad\")\n\n    def get_total_cost(self, gameweek: int = None) -&gt; float:\n        \"\"\"\n        Returns the total cost for a specific gameweek (1-indexed).\n        If no gameweek is specified, returns the cost of the squad in the last optimized gameweek.\n        \"\"\"\n        if not self.selected_squad_history:\n            return 0\n        first_gw_in_history = min(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n        last_gw_in_history = max(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n\n        if gameweek is None:\n            return self.selected_squad_history[f\"GW{last_gw_in_history}\"][\"total_cost\"]\n\n        if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n            print(\n                f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n            )\n            return 0  # Or raise an error\n\n        return self.selected_squad_history.get(f\"GW{gameweek}\", {}).get(\"total_cost\", 0)\n\n    def get_total_expected_points(self) -&gt; float:\n        \"\"\"\n        Returns the overall total expected points across all optimized gameweeks.\n        \"\"\"\n        return self.total_expected_points\n\n    def get_gameweek_summary(self, gameweek: int):\n        \"\"\"\n        Returns a dictionary summary for a specific gameweek.\n        \"\"\"\n        if not self.selected_squad_history:\n            return None\n        first_gw_in_history = min(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n        last_gw_in_history = max(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n\n        if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n            print(\n                f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n            )\n            return None\n\n        return self.selected_squad_history.get(f\"GW{gameweek}\")\n\n    def print_squad_summary(self, gameweek: int):\n        \"\"\"\n        Prints a formatted summary of the selected squad for a specific gameweek.\n        \"\"\"\n        if not self.selected_squad_history:\n            print(\"No squad has been selected yet. Run the 'solve' method first.\")\n            return\n\n        gw_data = self.get_gameweek_summary(gameweek)\n        if not gw_data:\n            return  # get_gameweek_summary already prints error message\n\n        selected_squad = gw_data[\"squad\"]\n        total_cost = gw_data[\"total_cost\"]\n        expected_points_from_xi = gw_data[\"expected_points_from_xi\"]\n        bench_boost_used = gw_data[\"bench_boost_used\"]\n        triple_captain_used = gw_data[\"triple_captain_used\"]\n        total_bench_boost_points = gw_data[\"total_bench_boost_points\"]\n        total_triple_captain_bonus = gw_data[\"total_triple_captain_bonus\"]\n        transfers_in_count = gw_data[\"transfers_in_count\"]  # New\n        transfers_out_count = gw_data[\"transfers_out_count\"]  # New\n        transfer_hits_taken = gw_data[\"transfer_hits\"]  # New\n        free_transfers_available_next_gw = gw_data[\n            \"free_transfers_available_next_gw\"\n        ]  # New\n\n        print(f\"\\n--- FPL Optimized Squad for Gameweek {gameweek} ---\")\n        print(f\"Squad Cost: \u00a3{total_cost:.1f}m\")\n        print(f\"Expected Points (Starting XI): {expected_points_from_xi:.2f}\")\n        print(\n            f\"Total Expected Points for GW{gameweek} (including chips): {expected_points_from_xi + total_bench_boost_points + total_triple_captain_bonus:.2f}\"\n        )\n        print(\"\\n--- Chips Used This Gameweek ---\")\n        if bench_boost_used:\n            print(f\"- Bench Boost (Added {total_bench_boost_points:.2f} points)\")\n        if triple_captain_used:\n            print(\n                f\"- Triple Captain (Added {total_triple_captain_bonus:.2f} bonus points)\"\n            )\n        if not (bench_boost_used or triple_captain_used):\n            print(\"No chips used this gameweek.\")\n\n        print(\"\\n--- Goalkeepers (Starting XI marked with *) ---\")\n        for index, row in selected_squad[selected_squad[\"position\"] == \"GK\"].iterrows():\n            starter_str = \"*\" if row[\"is_starter\"] else \"\"\n            captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n            transfer_status = \"\"\n            if row[\"transfer_in\"]:\n                transfer_status = \"(IN)\"\n            elif row[\"transfer_out\"]:\n                transfer_status = \"(OUT)\"\n\n            # Access gameweek-specific xP correctly\n            player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n            print(\n                f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n            )\n        print(\"\\n--- Defenders (Starting XI marked with *) ---\")\n        for index, row in selected_squad[\n            selected_squad[\"position\"] == \"DEF\"\n        ].iterrows():\n            starter_str = \"*\" if row[\"is_starter\"] else \"\"\n            captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n            transfer_status = \"\"\n            if row[\"transfer_in\"]:\n                transfer_status = \"(IN)\"\n            elif row[\"transfer_out\"]:\n                transfer_status = \"(OUT)\"\n\n            player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n            print(\n                f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n            )\n        print(\"\\n--- Midfielders (Starting XI marked with *) ---\")\n        for index, row in selected_squad[\n            selected_squad[\"position\"] == \"MID\"\n        ].iterrows():\n            starter_str = \"*\" if row[\"is_starter\"] else \"\"\n            captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n            transfer_status = \"\"\n            if row[\"transfer_in\"]:\n                transfer_status = \"(IN)\"\n            elif row[\"transfer_out\"]:\n                transfer_status = \"(OUT)\"\n\n            player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n            print(\n                f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n            )\n        print(\"\\n--- Forwards (Starting XI marked with *) ---\")\n        for index, row in selected_squad[\n            selected_squad[\"position\"] == \"FWD\"\n        ].iterrows():\n            starter_str = \"*\" if row[\"is_starter\"] else \"\"\n            captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n            transfer_status = \"\"\n            if row[\"transfer_in\"]:\n                transfer_status = \"(IN)\"\n            elif row[\"transfer_out\"]:\n                transfer_status = \"(OUT)\"\n\n            player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n            print(\n                f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n            )\n\n        print(f\"\\n--- Team Breakdown for GW{gameweek} ---\")\n        print(selected_squad[\"team\"].value_counts())\n\n        # Transfers are relevant from Gameweek 2 (index 1) onwards in the optimization horizon\n        # For display, if the current GW is the initial one (GW1 in the current context), no transfers are made\n        # If it's a subsequent GW, check if transfers occurred.\n        first_gw_in_history = min(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n        if (\n            gameweek &gt;= first_gw_in_history\n        ):  # Changed from &gt; to &gt;=, to show initial free transfers\n            # Display transfer info for this gameweek\n            print(\n                f\"  Transfers In: {transfers_in_count}, Transfers Out: {transfers_out_count}\"\n            )\n            print(\n                f\"  Transfer Hits: {transfer_hits_taken} (-{transfer_hits_taken * POINTS_PER_HIT} points)\"\n            )\n            # Only show free transfers for the *next* gameweek if it's not the last gameweek in the horizon\n            if gameweek &lt; max(\n                int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n            ):\n                print(\n                    f\"  Free Transfers Available for Next GW: {free_transfers_available_next_gw}\"\n                )\n        print(\"---------------------------\\n\")\n\n    def print_overall_summary(self):\n        \"\"\"\n        Prints an overall summary of the multi-week optimization results.\n        \"\"\"\n        if not self.selected_squad_history:\n            print(\"No optimization results to summarize.\")\n            return\n\n        print(\"\\n=== Overall Multi-Week FPL Optimization Summary ===\")\n        print(\n            f\"Total Expected Points Across All Gameweeks: {self.total_expected_points:.2f}\"\n        )\n\n        # Get the latest gameweek's cost\n        last_gw_key = max(\n            self.selected_squad_history.keys(), key=lambda k: int(k.replace(\"GW\", \"\"))\n        )\n        print(\n            f\"Squad Cost ({last_gw_key}): \u00a3{self.selected_squad_history[last_gw_key]['total_cost']:.1f}m\"\n        )\n        print(\n            f\"Total Transfer Hits Taken: {self.total_transfer_hits} (-{self.total_transfer_hits * POINTS_PER_HIT} points)\"\n        )\n\n        print(\"\\n--- Chip Usage Across Gameweeks ---\")\n        # Ensure consistent order by sorting gameweek keys\n        sorted_gw_keys = sorted(\n            self.used_chips.keys(), key=lambda k: int(k.replace(\"GW\", \"\"))\n        )\n        for gw_str in sorted_gw_keys:\n            chips = self.used_chips[gw_str]\n            chip_summary = []\n            if chips[\"bench_boost\"]:\n                chip_summary.append(\"Bench Boost\")\n            if chips[\"triple_captain\"]:\n                chip_summary.append(\"Triple Captain\")\n\n            if chip_summary:\n                print(f\"{gw_str}: {', '.join(chip_summary)}\")\n            else:\n                print(f\"{gw_str}: No chips used\")\n\n        print(\"\\n--- Gameweek-by-Gameweek Summary ---\")\n        # Iterate and print basic summary for each gameweek\n        for gw_str in sorted_gw_keys:\n            gw_data = self.selected_squad_history[gw_str]\n            print(f\"\\n--- {gw_str} ---\")\n            print(f\"  Squad Cost: \u00a3{gw_data['total_cost']:.1f}m\")\n            print(\n                f\"  Expected Points (Starting XI): {gw_data['expected_points_from_xi']:.2f}\"\n            )\n            print(\n                f\"  Total GW Points (incl. chips): {gw_data['expected_points_from_xi'] + gw_data['total_bench_boost_points'] + gw_data['total_triple_captain_bonus']:.2f}\"\n            )\n\n            # Display transfer info for this gameweek\n            transfers_in_count = gw_data[\"transfers_in_count\"]\n            transfers_out_count = gw_data[\"transfers_out_count\"]\n            transfer_hits_taken = gw_data[\"transfer_hits\"]\n            free_transfers_available_next_gw = gw_data[\n                \"free_transfers_available_next_gw\"\n            ]\n\n            print(\n                f\"  Transfers In: {transfers_in_count}, Transfers Out: {transfers_out_count}\"\n            )\n            print(\n                f\"  Transfer Hits: {transfer_hits_taken} (-{transfer_hits_taken * POINTS_PER_HIT} points)\"\n            )\n            # Only show free transfers for the *next* gameweek if it's not the last gameweek in the horizon\n            if int(gw_str.replace(\"GW\", \"\")) &lt; max(\n                int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n            ):\n                print(\n                    f\"  Free Transfers Available for Next GW: {free_transfers_available_next_gw}\"\n                )\n            print(\"-----------------------------------\")\n</code></pre>"},{"location":"autoapi/fpl_solver/#fpl_solver.fpl_solver.FPLOptimizer.__init__","title":"<code>__init__(player_data)</code>","text":"<p>Initializes the FPLOptimizer with player data.</p> <p>Parameters:</p> Name Type Description Default <code>player_data</code> <code>DataFrame</code> <p>A DataFrame containing player information                         with columns: 'name', 'team', 'position',                         'cost', 'expected_points_by_gw' (a dict of xP per GW).</p> required Source code in <code>fpl_solver/fpl_solver.py</code> <pre><code>def __init__(self, player_data: pd.DataFrame):\n    \"\"\"\n    Initializes the FPLOptimizer with player data.\n\n    Args:\n        player_data (pd.DataFrame): A DataFrame containing player information\n                                    with columns: 'name', 'team', 'position',\n                                    'cost', 'expected_points_by_gw' (a dict of xP per GW).\n    \"\"\"\n    required_columns = [\"name\", \"team\", \"position\", \"cost\", \"expected_points_by_gw\"]\n    if not all(col in player_data.columns for col in required_columns):\n        missing_cols = [\n            col for col in required_columns if col not in player_data.columns\n        ]\n        raise ValueError(\n            f\"player_data DataFrame must contain {required_columns} columns. Missing: {missing_cols}\"\n        )\n\n    self.player_data = player_data\n    self.problem = None\n    self.selected_squad_history = {}  # To store squad for each gameweek\n    self.total_cost = 0\n    self.total_expected_points = 0\n    self.total_transfer_hits = 0\n\n    # --- Process Enforced Players ---\n    self.enforced_player_indices = set()\n    self.enforced_team_pos_requirements = []\n\n    print(\"\\n--- Processing Enforced Players ---\")\n\n    # Enforce by Player ID\n    for player_id in ENFORCED_PLAYERS_BY_ID:\n        found_player = self.player_data[self.player_data[\"id\"] == player_id]\n        if not found_player.empty:\n            player_idx = found_player.index[0]\n            self.enforced_player_indices.add(player_idx)\n            print(\n                f\"Enforcing player by ID: {found_player.loc[player_idx, 'name']} (ID: {player_id})\"\n            )\n        else:\n            print(\n                f\"Warning: Enforced player with ID {player_id} not found in data.\"\n            )\n\n    # Enforce by Player Name\n    for player_name in ENFORCED_PLAYERS_BY_NAME:\n        found_player = self.player_data[self.player_data[\"name\"] == player_name]\n        if not found_player.empty:\n            player_idx = found_player.index[0]\n            self.enforced_player_indices.add(player_idx)\n            print(f\"Enforcing player by name: {player_name}\")\n        else:\n            print(f\"Warning: Enforced player '{player_name}' not found in data.\")\n\n    # Enforce by Team and Position\n    for requirement in ENFORCED_PLAYERS_BY_TEAM_AND_POSITION:\n        team = requirement.get(\"team\")\n        position = requirement.get(\"position\")\n        if team and position:\n            # Validate team and position exist in data\n            if team not in self.player_data[\"team\"].unique():\n                print(\n                    f\"Warning: Enforced team '{team}' for position '{position}' not found in data.\"\n                )\n                continue\n            if position not in self.player_data[\"position\"].unique():\n                print(\n                    f\"Warning: Enforced position '{position}' for team '{team}' not found in data.\"\n                )\n                continue\n\n            self.enforced_team_pos_requirements.append((team, position))\n            print(f\"Enforcing at least one {position} from {team}.\")\n        else:\n            print(\n                f\"Warning: Invalid enforced team/position requirement: {requirement}\"\n            )\n\n    if not (\n        self.enforced_player_indices\n        or self.enforced_team_pos_requirements\n        or ENFORCED_PLAYERS_BY_ID\n        or ENFORCED_PLAYERS_BY_NAME\n        or ENFORCED_PLAYERS_BY_TEAM_AND_POSITION\n    ):\n        print(\"No players or team/position combinations are enforced.\")\n    print(\"-----------------------------------\\n\")\n</code></pre>"},{"location":"autoapi/fpl_solver/#fpl_solver.fpl_solver.FPLOptimizer.get_gameweek_summary","title":"<code>get_gameweek_summary(gameweek)</code>","text":"<p>Returns a dictionary summary for a specific gameweek.</p> Source code in <code>fpl_solver/fpl_solver.py</code> <pre><code>def get_gameweek_summary(self, gameweek: int):\n    \"\"\"\n    Returns a dictionary summary for a specific gameweek.\n    \"\"\"\n    if not self.selected_squad_history:\n        return None\n    first_gw_in_history = min(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n    last_gw_in_history = max(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n\n    if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n        print(\n            f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n        )\n        return None\n\n    return self.selected_squad_history.get(f\"GW{gameweek}\")\n</code></pre>"},{"location":"autoapi/fpl_solver/#fpl_solver.fpl_solver.FPLOptimizer.get_selected_squad","title":"<code>get_selected_squad(gameweek=None)</code>","text":"<p>Returns the selected squad for a specific gameweek (1-indexed). If no gameweek is specified, returns the squad for the last optimized gameweek.</p> Source code in <code>fpl_solver/fpl_solver.py</code> <pre><code>def get_selected_squad(self, gameweek: int = None) -&gt; pd.DataFrame | None:\n    \"\"\"\n    Returns the selected squad for a specific gameweek (1-indexed).\n    If no gameweek is specified, returns the squad for the last optimized gameweek.\n    \"\"\"\n    if not self.selected_squad_history:\n        return None\n\n    # Get the first GW key to determine the range of available GWs\n    first_gw_in_history = min(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n    last_gw_in_history = max(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n\n    if gameweek is None:\n        return self.selected_squad_history[f\"GW{last_gw_in_history}\"][\"squad\"]\n\n    if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n        print(\n            f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n        )\n        return None\n\n    return self.selected_squad_history.get(f\"GW{gameweek}\", {}).get(\"squad\")\n</code></pre>"},{"location":"autoapi/fpl_solver/#fpl_solver.fpl_solver.FPLOptimizer.get_total_cost","title":"<code>get_total_cost(gameweek=None)</code>","text":"<p>Returns the total cost for a specific gameweek (1-indexed). If no gameweek is specified, returns the cost of the squad in the last optimized gameweek.</p> Source code in <code>fpl_solver/fpl_solver.py</code> <pre><code>def get_total_cost(self, gameweek: int = None) -&gt; float:\n    \"\"\"\n    Returns the total cost for a specific gameweek (1-indexed).\n    If no gameweek is specified, returns the cost of the squad in the last optimized gameweek.\n    \"\"\"\n    if not self.selected_squad_history:\n        return 0\n    first_gw_in_history = min(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n    last_gw_in_history = max(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n\n    if gameweek is None:\n        return self.selected_squad_history[f\"GW{last_gw_in_history}\"][\"total_cost\"]\n\n    if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n        print(\n            f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n        )\n        return 0  # Or raise an error\n\n    return self.selected_squad_history.get(f\"GW{gameweek}\", {}).get(\"total_cost\", 0)\n</code></pre>"},{"location":"autoapi/fpl_solver/#fpl_solver.fpl_solver.FPLOptimizer.get_total_expected_points","title":"<code>get_total_expected_points()</code>","text":"<p>Returns the overall total expected points across all optimized gameweeks.</p> Source code in <code>fpl_solver/fpl_solver.py</code> <pre><code>def get_total_expected_points(self) -&gt; float:\n    \"\"\"\n    Returns the overall total expected points across all optimized gameweeks.\n    \"\"\"\n    return self.total_expected_points\n</code></pre>"},{"location":"autoapi/fpl_solver/#fpl_solver.fpl_solver.FPLOptimizer.print_overall_summary","title":"<code>print_overall_summary()</code>","text":"<p>Prints an overall summary of the multi-week optimization results.</p> Source code in <code>fpl_solver/fpl_solver.py</code> <pre><code>def print_overall_summary(self):\n    \"\"\"\n    Prints an overall summary of the multi-week optimization results.\n    \"\"\"\n    if not self.selected_squad_history:\n        print(\"No optimization results to summarize.\")\n        return\n\n    print(\"\\n=== Overall Multi-Week FPL Optimization Summary ===\")\n    print(\n        f\"Total Expected Points Across All Gameweeks: {self.total_expected_points:.2f}\"\n    )\n\n    # Get the latest gameweek's cost\n    last_gw_key = max(\n        self.selected_squad_history.keys(), key=lambda k: int(k.replace(\"GW\", \"\"))\n    )\n    print(\n        f\"Squad Cost ({last_gw_key}): \u00a3{self.selected_squad_history[last_gw_key]['total_cost']:.1f}m\"\n    )\n    print(\n        f\"Total Transfer Hits Taken: {self.total_transfer_hits} (-{self.total_transfer_hits * POINTS_PER_HIT} points)\"\n    )\n\n    print(\"\\n--- Chip Usage Across Gameweeks ---\")\n    # Ensure consistent order by sorting gameweek keys\n    sorted_gw_keys = sorted(\n        self.used_chips.keys(), key=lambda k: int(k.replace(\"GW\", \"\"))\n    )\n    for gw_str in sorted_gw_keys:\n        chips = self.used_chips[gw_str]\n        chip_summary = []\n        if chips[\"bench_boost\"]:\n            chip_summary.append(\"Bench Boost\")\n        if chips[\"triple_captain\"]:\n            chip_summary.append(\"Triple Captain\")\n\n        if chip_summary:\n            print(f\"{gw_str}: {', '.join(chip_summary)}\")\n        else:\n            print(f\"{gw_str}: No chips used\")\n\n    print(\"\\n--- Gameweek-by-Gameweek Summary ---\")\n    # Iterate and print basic summary for each gameweek\n    for gw_str in sorted_gw_keys:\n        gw_data = self.selected_squad_history[gw_str]\n        print(f\"\\n--- {gw_str} ---\")\n        print(f\"  Squad Cost: \u00a3{gw_data['total_cost']:.1f}m\")\n        print(\n            f\"  Expected Points (Starting XI): {gw_data['expected_points_from_xi']:.2f}\"\n        )\n        print(\n            f\"  Total GW Points (incl. chips): {gw_data['expected_points_from_xi'] + gw_data['total_bench_boost_points'] + gw_data['total_triple_captain_bonus']:.2f}\"\n        )\n\n        # Display transfer info for this gameweek\n        transfers_in_count = gw_data[\"transfers_in_count\"]\n        transfers_out_count = gw_data[\"transfers_out_count\"]\n        transfer_hits_taken = gw_data[\"transfer_hits\"]\n        free_transfers_available_next_gw = gw_data[\n            \"free_transfers_available_next_gw\"\n        ]\n\n        print(\n            f\"  Transfers In: {transfers_in_count}, Transfers Out: {transfers_out_count}\"\n        )\n        print(\n            f\"  Transfer Hits: {transfer_hits_taken} (-{transfer_hits_taken * POINTS_PER_HIT} points)\"\n        )\n        # Only show free transfers for the *next* gameweek if it's not the last gameweek in the horizon\n        if int(gw_str.replace(\"GW\", \"\")) &lt; max(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        ):\n            print(\n                f\"  Free Transfers Available for Next GW: {free_transfers_available_next_gw}\"\n            )\n        print(\"-----------------------------------\")\n</code></pre>"},{"location":"autoapi/fpl_solver/#fpl_solver.fpl_solver.FPLOptimizer.print_squad_summary","title":"<code>print_squad_summary(gameweek)</code>","text":"<p>Prints a formatted summary of the selected squad for a specific gameweek.</p> Source code in <code>fpl_solver/fpl_solver.py</code> <pre><code>def print_squad_summary(self, gameweek: int):\n    \"\"\"\n    Prints a formatted summary of the selected squad for a specific gameweek.\n    \"\"\"\n    if not self.selected_squad_history:\n        print(\"No squad has been selected yet. Run the 'solve' method first.\")\n        return\n\n    gw_data = self.get_gameweek_summary(gameweek)\n    if not gw_data:\n        return  # get_gameweek_summary already prints error message\n\n    selected_squad = gw_data[\"squad\"]\n    total_cost = gw_data[\"total_cost\"]\n    expected_points_from_xi = gw_data[\"expected_points_from_xi\"]\n    bench_boost_used = gw_data[\"bench_boost_used\"]\n    triple_captain_used = gw_data[\"triple_captain_used\"]\n    total_bench_boost_points = gw_data[\"total_bench_boost_points\"]\n    total_triple_captain_bonus = gw_data[\"total_triple_captain_bonus\"]\n    transfers_in_count = gw_data[\"transfers_in_count\"]  # New\n    transfers_out_count = gw_data[\"transfers_out_count\"]  # New\n    transfer_hits_taken = gw_data[\"transfer_hits\"]  # New\n    free_transfers_available_next_gw = gw_data[\n        \"free_transfers_available_next_gw\"\n    ]  # New\n\n    print(f\"\\n--- FPL Optimized Squad for Gameweek {gameweek} ---\")\n    print(f\"Squad Cost: \u00a3{total_cost:.1f}m\")\n    print(f\"Expected Points (Starting XI): {expected_points_from_xi:.2f}\")\n    print(\n        f\"Total Expected Points for GW{gameweek} (including chips): {expected_points_from_xi + total_bench_boost_points + total_triple_captain_bonus:.2f}\"\n    )\n    print(\"\\n--- Chips Used This Gameweek ---\")\n    if bench_boost_used:\n        print(f\"- Bench Boost (Added {total_bench_boost_points:.2f} points)\")\n    if triple_captain_used:\n        print(\n            f\"- Triple Captain (Added {total_triple_captain_bonus:.2f} bonus points)\"\n        )\n    if not (bench_boost_used or triple_captain_used):\n        print(\"No chips used this gameweek.\")\n\n    print(\"\\n--- Goalkeepers (Starting XI marked with *) ---\")\n    for index, row in selected_squad[selected_squad[\"position\"] == \"GK\"].iterrows():\n        starter_str = \"*\" if row[\"is_starter\"] else \"\"\n        captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n        transfer_status = \"\"\n        if row[\"transfer_in\"]:\n            transfer_status = \"(IN)\"\n        elif row[\"transfer_out\"]:\n            transfer_status = \"(OUT)\"\n\n        # Access gameweek-specific xP correctly\n        player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n        print(\n            f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n        )\n    print(\"\\n--- Defenders (Starting XI marked with *) ---\")\n    for index, row in selected_squad[\n        selected_squad[\"position\"] == \"DEF\"\n    ].iterrows():\n        starter_str = \"*\" if row[\"is_starter\"] else \"\"\n        captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n        transfer_status = \"\"\n        if row[\"transfer_in\"]:\n            transfer_status = \"(IN)\"\n        elif row[\"transfer_out\"]:\n            transfer_status = \"(OUT)\"\n\n        player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n        print(\n            f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n        )\n    print(\"\\n--- Midfielders (Starting XI marked with *) ---\")\n    for index, row in selected_squad[\n        selected_squad[\"position\"] == \"MID\"\n    ].iterrows():\n        starter_str = \"*\" if row[\"is_starter\"] else \"\"\n        captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n        transfer_status = \"\"\n        if row[\"transfer_in\"]:\n            transfer_status = \"(IN)\"\n        elif row[\"transfer_out\"]:\n            transfer_status = \"(OUT)\"\n\n        player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n        print(\n            f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n        )\n    print(\"\\n--- Forwards (Starting XI marked with *) ---\")\n    for index, row in selected_squad[\n        selected_squad[\"position\"] == \"FWD\"\n    ].iterrows():\n        starter_str = \"*\" if row[\"is_starter\"] else \"\"\n        captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n        transfer_status = \"\"\n        if row[\"transfer_in\"]:\n            transfer_status = \"(IN)\"\n        elif row[\"transfer_out\"]:\n            transfer_status = \"(OUT)\"\n\n        player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n        print(\n            f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n        )\n\n    print(f\"\\n--- Team Breakdown for GW{gameweek} ---\")\n    print(selected_squad[\"team\"].value_counts())\n\n    # Transfers are relevant from Gameweek 2 (index 1) onwards in the optimization horizon\n    # For display, if the current GW is the initial one (GW1 in the current context), no transfers are made\n    # If it's a subsequent GW, check if transfers occurred.\n    first_gw_in_history = min(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n    if (\n        gameweek &gt;= first_gw_in_history\n    ):  # Changed from &gt; to &gt;=, to show initial free transfers\n        # Display transfer info for this gameweek\n        print(\n            f\"  Transfers In: {transfers_in_count}, Transfers Out: {transfers_out_count}\"\n        )\n        print(\n            f\"  Transfer Hits: {transfer_hits_taken} (-{transfer_hits_taken * POINTS_PER_HIT} points)\"\n        )\n        # Only show free transfers for the *next* gameweek if it's not the last gameweek in the horizon\n        if gameweek &lt; max(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        ):\n            print(\n                f\"  Free Transfers Available for Next GW: {free_transfers_available_next_gw}\"\n            )\n    print(\"---------------------------\\n\")\n</code></pre>"},{"location":"autoapi/fpl_solver/#fpl_solver.fpl_solver.FPLOptimizer.solve","title":"<code>solve(budget, max_players_per_team, chip_allowances, num_gameweeks)</code>","text":"<p>Solves the FPL optimization problem using PuLP.</p> <p>Parameters:</p> Name Type Description Default <code>budget</code> <code>float</code> <p>The maximum budget in millions of pounds.</p> required <code>max_players_per_team</code> <code>int</code> <p>The maximum number of players allowed from                         any single Premier League team.</p> required <code>chip_allowances</code> <code>dict</code> <p>A dictionary specifying the maximum usage for each chip.</p> required <code>num_gameweeks</code> <code>int</code> <p>The number of gameweeks to optimize over.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if a solution was found, False otherwise.</p> Source code in <code>fpl_solver/fpl_solver.py</code> <pre><code>def solve(\n    self,\n    budget: float,\n    max_players_per_team: int,\n    chip_allowances: dict,\n    num_gameweeks: int,\n) -&gt; bool:\n    \"\"\"\n    Solves the FPL optimization problem using PuLP.\n\n    Args:\n        budget (float): The maximum budget in millions of pounds.\n        max_players_per_team (int): The maximum number of players allowed from\n                                    any single Premier League team.\n        chip_allowances (dict): A dictionary specifying the maximum usage for each chip.\n        num_gameweeks (int): The number of gameweeks to optimize over.\n\n    Returns:\n        bool: True if a solution was found, False otherwise.\n    \"\"\"\n    self.problem = LpProblem(\"FPL Squad Multi-Week Optimization\", LpMaximize)\n\n    # Decision variables for player selection, indexed by player and gameweek\n    player_vars = LpVariable.dicts(\n        \"Player\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n    )\n    starting_xi_vars = LpVariable.dicts(\n        \"StartingXI\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n    )\n    captain_var = LpVariable.dicts(\n        \"Captain\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n    )\n\n    # Binary variables for chip usage, indexed by gameweek\n    use_bench_boost = LpVariable.dicts(\n        \"Use_Bench_Boost\", range(num_gameweeks), 0, 1, LpBinary\n    )\n    use_triple_captain = LpVariable.dicts(\n        \"Use_Triple_Captain\", range(num_gameweeks), 0, 1, LpBinary\n    )\n\n    # Transfer variables\n    transfer_in_vars = LpVariable.dicts(\n        \"Transfer_In\",\n        (self.player_data.index, range(1, num_gameweeks)),\n        0,\n        1,\n        LpBinary,\n    )\n    transfer_out_vars = LpVariable.dicts(\n        \"Transfer_Out\",\n        (self.player_data.index, range(1, num_gameweeks)),\n        0,\n        1,\n        LpBinary,\n    )\n\n    # Total transfers made in a gameweek (absolute count)\n    transfers_made = LpVariable.dicts(\n        \"Transfers_Made\", range(1, num_gameweeks), 0, None, LpInteger\n    )\n    # Free transfers available at the start of a gameweek\n    free_transfers_available = LpVariable.dicts(\n        \"Free_Transfers_Available\",\n        range(num_gameweeks),\n        0,\n        MAX_FREE_TRANSFERS_SAVED + 1,\n        LpInteger,\n    )\n    # Number of transfer hits taken in a gameweek\n    transfer_hits = LpVariable.dicts(\n        \"Transfer_Hits\", range(1, num_gameweeks), 0, None, LpInteger\n    )\n\n    # Auxiliary variables for linearizing chip effects\n    is_bench_player = LpVariable.dicts(\n        \"Is_Bench_Player\",\n        (self.player_data.index, range(num_gameweeks)),\n        0,\n        1,\n        LpBinary,\n    )\n    actual_bench_boost_points = LpVariable.dicts(\n        \"Actual_Bench_Boost_Points\",\n        (self.player_data.index, range(num_gameweeks)),\n        0,\n        None,\n        LpContinuous,\n    )\n    actual_triple_captain_bonus = LpVariable.dicts(\n        \"Actual_Triple_Captain_Bonus\",\n        (self.player_data.index, range(num_gameweeks)),\n        0,\n        None,\n        LpContinuous,\n    )\n\n    # --- Objective Function ---\n    total_objective_points = []\n\n    # Get the first gameweek number from the player data to correctly index expected_points_by_gw\n    first_gw_key = next(\n        iter(\n            self.player_data.loc[\n                self.player_data.index[0], \"expected_points_by_gw\"\n            ].keys()\n        )\n    )\n    current_gameweek_number_start = int(first_gw_key)\n\n    for w in range(num_gameweeks):\n        # The actual gameweek number (1-indexed)\n        gw_actual = current_gameweek_number_start + w\n\n        # Base expected points from the selected starting 11 for this gameweek\n        base_points_expression_gw = lpSum(\n            self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n            * starting_xi_vars[i][w]\n            for i in self.player_data.index\n        )\n        total_objective_points.append(base_points_expression_gw)\n\n        # Regular Captaincy points (additional 1x for captain)\n        captain_points_bonus_gw = lpSum(\n            self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n            * captain_var[i][w]\n            for i in self.player_data.index\n        )\n        total_objective_points.append(captain_points_bonus_gw)\n\n        # Define auxiliary variables and constraints for chips for each gameweek\n        for i in self.player_data.index:\n            # Use gameweek-specific player xP for chip calculations\n            player_xp = self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n\n            # Bench Boost auxiliary variables and constraints\n            self.problem += (\n                is_bench_player[i][w] &lt;= player_vars[i][w],\n                f\"IsBench_Squad_{i}_{w}\",\n            )\n            self.problem += (\n                is_bench_player[i][w] &lt;= 1 - starting_xi_vars[i][w],\n                f\"IsBench_NotStarter_{i}_{w}\",\n            )\n            self.problem += (\n                is_bench_player[i][w]\n                &gt;= player_vars[i][w] + (1 - starting_xi_vars[i][w]) - 1,\n                f\"IsBench_Logical_{i}_{w}\",\n            )\n\n            self.problem += (\n                actual_bench_boost_points[i][w]\n                &lt;= player_xp * is_bench_player[i][w],\n                f\"BenchBoost_Contr_1_{i}_{w}\",\n            )\n            self.problem += (\n                actual_bench_boost_points[i][w] &lt;= player_xp * use_bench_boost[w],\n                f\"BenchBoost_Contr_2_{i}_{w}\",\n            )\n            self.problem += (\n                actual_bench_boost_points[i][w]\n                &gt;= player_xp * (is_bench_player[i][w] + use_bench_boost[w] - 1),\n                f\"BenchBoost_Contr_3_{i}_{w}\",\n            )\n            self.problem += (\n                actual_bench_boost_points[i][w] &gt;= 0,\n                f\"BenchBoost_Contr_4_{i}_{w}\",\n            )\n\n            # Triple Captain auxiliary variables and constraints\n            # Changed player_xp * 2 to player_xp to reflect additional 1x bonus\n            self.problem += (\n                actual_triple_captain_bonus[i][w] &lt;= player_xp * captain_var[i][w],\n                f\"TripleCaptain_Contr_1_{i}_{w}\",\n            )\n            self.problem += (\n                actual_triple_captain_bonus[i][w]\n                &lt;= player_xp * use_triple_captain[w],\n                f\"TripleCaptain_Contr_2_{i}_{w}\",\n            )\n            self.problem += (\n                actual_triple_captain_bonus[i][w]\n                &gt;= player_xp * (captain_var[i][w] + use_triple_captain[w] - 1),\n                f\"TripleCaptain_Contr_3_{i}_{w}\",\n            )\n            self.problem += (\n                actual_triple_captain_bonus[i][w] &gt;= 0,\n                f\"TripleCaptain_Contr_4_{i}_{w}\",\n            )\n\n        # Add points from bench boost and triple captain bonus for this gameweek\n        total_bench_boost_points_gw = lpSum(\n            actual_bench_boost_points[i][w] for i in self.player_data.index\n        )\n        total_triple_captain_bonus_points_gw = lpSum(\n            actual_triple_captain_bonus[i][w] for i in self.player_data.index\n        )\n\n        total_objective_points.append(total_bench_boost_points_gw)\n        total_objective_points.append(total_triple_captain_bonus_points_gw)\n\n    # Subtract transfer hits from the total objective\n    total_objective_points.append(\n        -POINTS_PER_HIT * lpSum(transfer_hits[w] for w in range(1, num_gameweeks))\n    )\n\n    self.problem += (\n        lpSum(total_objective_points),\n        \"Total Expected Points Over Gameweeks\",\n    )\n\n    # --- Constraints ---\n\n    # Apply constraints for each gameweek\n    for w in range(num_gameweeks):\n        # 1. Select exactly 15 players for the squad\n        self.problem += (\n            lpSum(player_vars[i][w] for i in self.player_data.index) == 15,\n            f\"Total_Players_GW{w}\",\n        )\n\n        # 2. Squad position constraints (2 GKs, 5 DEFs, 5 MIDs, 3 FWDs)\n        gks = self.player_data[self.player_data[\"position\"] == \"GK\"].index\n        defs = self.player_data[self.player_data[\"position\"] == \"DEF\"].index\n        mids = self.player_data[self.player_data[\"position\"] == \"MID\"].index\n        fwds = self.player_data[self.player_data[\"position\"] == \"FWD\"].index\n\n        self.problem += (\n            lpSum(player_vars[i][w] for i in gks) == 2,\n            f\"Goalkeepers_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(player_vars[i][w] for i in defs) == 5,\n            f\"Defenders_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(player_vars[i][w] for i in mids) == 5,\n            f\"Midfielders_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(player_vars[i][w] for i in fwds) == 3,\n            f\"Forwards_Count_GW{w}\",\n        )\n\n        # 3. Budget constraint\n        # This applies to the cost of the squad for the current gameweek.\n        self.problem += (\n            lpSum(\n                self.player_data.loc[i, \"cost\"] * player_vars[i][w]\n                for i in self.player_data.index\n            )\n            &lt;= budget,\n            f\"Total_Budget_GW{w}\",\n        )\n\n        # 4. Maximum players per team constraint\n        for team in self.player_data[\"team\"].unique():\n            team_players = self.player_data[self.player_data[\"team\"] == team].index\n            self.problem += (\n                lpSum(player_vars[i][w] for i in team_players)\n                &lt;= max_players_per_team,\n                f\"Max_Players_from_{team}_GW{w}\",\n            )\n\n        # 5. Starting XI constraints\n        # 5.1 Select exactly 11 players for the starting XI\n        self.problem += (\n            lpSum(starting_xi_vars[i][w] for i in self.player_data.index) == 11,\n            f\"Total_Starting_XI_Players_GW{w}\",\n        )\n\n        # 5.2 A player can only be in the starting XI if they are in the squad\n        for i in self.player_data.index:\n            self.problem += (\n                starting_xi_vars[i][w] &lt;= player_vars[i][w],\n                f\"StartingXI_in_Squad_{i}_{w}\",\n            )\n\n        # 5.3 Starting XI position constraints (FPL allows flexible formations, so use minimums)\n        self.problem += (\n            lpSum(starting_xi_vars[i][w] for i in gks) == 1,\n            f\"Starting_Goalkeepers_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(starting_xi_vars[i][w] for i in defs) &gt;= 3,\n            f\"Min_Starting_Defenders_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(starting_xi_vars[i][w] for i in mids) &gt;= 2,\n            f\"Min_Starting_Midfielders_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(starting_xi_vars[i][w] for i in fwds) &gt;= 1,\n            f\"Min_Starting_Forwards_Count_GW{w}\",\n        )\n\n        # 6. Captain Constraints\n        # 6.1 Select exactly one captain from the starting XI\n        self.problem += (\n            lpSum(captain_var[i][w] for i in self.player_data.index) == 1,\n            f\"One_Captain_GW{w}\",\n        )\n\n        # 6.2 A player can only be captain if they are in the starting XI\n        for i in self.player_data.index:\n            self.problem += (\n                captain_var[i][w] &lt;= starting_xi_vars[i][w],\n                f\"Captain_in_StartingXI_{i}_{w}\",\n            )\n\n        # --- Enforced Player Constraints---\n        for player_idx in self.enforced_player_indices:\n            self.problem += (\n                player_vars[player_idx][w] == 1,\n                f\"Enforce_Player_{self.player_data.loc[player_idx, 'name']}_GW{w}\",\n            )\n\n        for team, position in self.enforced_team_pos_requirements:\n            # Filter players for the current team and position\n            team_pos_players = self.player_data[\n                (self.player_data[\"team\"] == team)\n                &amp; (self.player_data[\"position\"] == position)\n            ].index\n            if not team_pos_players.empty:\n                self.problem += (\n                    lpSum(player_vars[i][w] for i in team_pos_players) &gt;= 1,\n                    f\"Enforce_One_{position}_from_{team}_GW{w}\",\n                )\n            else:\n                print(\n                    f\"Warning: No players found for enforced requirement: at least one {position} from {team} for GW{gw_actual}.\"\n                )\n\n    # --- Chip Usage Constraints (TOTAL usage over all gameweeks) ---\n    # These constraints should be outside the per-gameweek loop to avoid duplicates.\n    self.problem += (\n        lpSum(use_bench_boost[j] for j in range(num_gameweeks))\n        &lt;= chip_allowances.get(\"bench_boost\", 0),\n        f\"Max_Bench_Boost_Usage_Total\",\n    )\n    self.problem += (\n        lpSum(use_triple_captain[j] for j in range(num_gameweeks))\n        &lt;= chip_allowances.get(\"triple_captain\", 0),\n        f\"Max_Triple_Captain_Usage_Total\",\n    )\n\n    # --- Inter-Gameweek Constraints (Transfers and Transfer Rules) ---\n    # Initialize free transfers for GW0 (first gameweek of optimization horizon)\n    # This assumes the optimization starts at GW0, and it has INITIAL_FREE_TRANSFERS.\n    # If the model starts at an arbitrary GW, this would need to be an input.\n    self.problem += (\n        free_transfers_available[0] == INITIAL_FREE_TRANSFERS,\n        f\"Initial_Free_Transfers_GW0\",\n    )\n\n    for w in range(1, num_gameweeks):\n        # Calculate total transfers made in this gameweek\n        self.problem += (\n            transfers_made[w]\n            == lpSum(transfer_in_vars[i][w] for i in self.player_data.index),\n            f\"Transfers_Made_GW{w}\",\n        )\n        # Total transfers in must equal total transfers out for each gameweek after the first\n        self.problem += (\n            lpSum(transfer_in_vars[i][w] for i in self.player_data.index)\n            == lpSum(transfer_out_vars[i][w] for i in self.player_data.index),\n            f\"Transfers_In_Equals_Out_GW{w}\",\n        )\n\n        # Calculate free transfers available for the current gameweek (w)\n        # Free transfers for GW_w = min(free transfers from GW_w-1 - transfers made in GW_w + 1, MAX_FREE_TRANSFERS_SAVED + 1)\n        # The + 1 in MAX_FREE_TRANSFERS_SAVED + 1 is because MAX_FREE_TRANSFERS_SAVED implies how many can be *saved*,\n        # so if you save 1, you have 1 (current) + 1 (saved) = 2.\n        self.problem += (\n            free_transfers_available[w]\n            &lt;= free_transfers_available[w - 1] - transfers_made[w] + 1,\n            f\"Free_Transfers_Calc_1_GW{w}\",\n        )\n        self.problem += (\n            free_transfers_available[w] &lt;= MAX_FREE_TRANSFERS_SAVED + 1,\n            f\"Free_Transfers_Calc_2_GW{w}\",\n        )\n        self.problem += (\n            free_transfers_available[w] &gt;= 0,  # Cannot have negative free transfers\n            f\"Free_Transfers_Non_Negative_GW{w}\",\n        )\n\n        # Calculate transfer hits\n        # transfer_hits[w] = max(0, transfers_made[w] - free_transfers_available_at_start_of_gw_w)\n        # This needs to be linearized. If transfers_made[w] &gt; free_transfers_available[w-1], then hit.\n        # free_transfers_available[w-1] represents transfers available *before* making transfers for GW_w\n        self.problem += (\n            transfer_hits[w] &gt;= transfers_made[w] - free_transfers_available[w - 1],\n            f\"Transfer_Hits_Calc_1_GW{w}\",\n        )\n        self.problem += (\n            transfer_hits[w] &gt;= 0,\n            f\"Transfer_Hits_Calc_2_GW{w}\",\n        )\n\n        for i in self.player_data.index:\n            # Squad continuity: player_vars[i][w] (in squad at start of GW w)\n            #                 = player_vars[i][w-1] (in squad at start of GW w-1)\n            #                 - transfer_out_vars[i][w] (transferred out for GW w)\n            #                 + transfer_in_vars[i][w] (transferred in for GW w)\n            self.problem += (\n                player_vars[i][w]\n                == player_vars[i][w - 1]\n                - transfer_out_vars[i][w]\n                + transfer_in_vars[i][w],\n                f\"Squad_Continuity_{i}_GW{w}\",\n            )\n            # A player cannot be transferred in and out in the same gameweek\n            self.problem += (\n                transfer_in_vars[i][w] + transfer_out_vars[i][w] &lt;= 1,\n                f\"No_Simultaneous_Transfer_{i}_{w}\",\n            )\n\n    try:\n        # The solver is called with the GLPK_CMD solver\n        self.problem.solve(PULP_CBC_CMD(msg=0))  # msg=0 suppresses verbose output\n    except Exception as e:\n        print(f\"Error solving the problem: {e}\")\n        return False\n\n    if LpStatus[self.problem.status] == \"Optimal\":\n        print(\"Optimization successful! Optimal solution found.\")\n\n        self.selected_squad_history = {}\n        self.total_transfer_hits = 0\n        for w in range(num_gameweeks):\n            # The actual gameweek number (1-indexed)\n            gw_actual = current_gameweek_number_start + w\n\n            # Get selected players for the current gameweek\n            selected_squad_gw = self.player_data[\n                [player_vars[i][w].varValue == 1 for i in self.player_data.index]\n            ].copy()\n\n            # Get starter and captain info for this gameweek\n            is_starter_series_gw = pd.Series(\n                [\n                    starting_xi_vars[i][w].varValue == 1\n                    for i in self.player_data.index\n                ],\n                index=self.player_data.index,\n            )\n            is_captain_series_gw = pd.Series(\n                [captain_var[i][w].varValue == 1 for i in self.player_data.index],\n                index=self.player_data.index,\n            )\n\n            selected_squad_gw[\"is_starter\"] = is_starter_series_gw.loc[\n                selected_squad_gw.index\n            ]\n            selected_squad_gw[\"is_captain\"] = is_captain_series_gw.loc[\n                selected_squad_gw.index\n            ]\n\n            transfers_in_gw = 0\n            transfers_out_gw = 0\n            hits_gw = 0\n\n            # Store transfer details for gameweeks &gt; 0\n            if (\n                w &gt; 0\n            ):  # Check for transfers only from GW1 onwards (index 1 in 0-indexed loop)\n                transfer_in_flags = pd.Series(\n                    [\n                        transfer_in_vars[i][w].varValue == 1\n                        for i in self.player_data.index\n                    ],\n                    index=self.player_data.index,\n                )\n                transfer_out_flags = pd.Series(\n                    [\n                        transfer_out_vars[i][w].varValue == 1\n                        for i in self.player_data.index\n                    ],\n                    index=self.player_data.index,\n                )\n\n                selected_squad_gw[\"transfer_in\"] = transfer_in_flags.loc[\n                    selected_squad_gw.index\n                ]\n                selected_squad_gw[\"transfer_out\"] = transfer_out_flags.loc[\n                    selected_squad_gw.index\n                ]\n\n                transfers_in_gw = int(round(transfer_in_flags.sum()))\n                transfers_out_gw = int(round(transfer_out_flags.sum()))\n                hits_gw = int(round(transfer_hits[w].varValue))\n                self.total_transfer_hits += hits_gw\n            else:\n                selected_squad_gw[\"transfer_in\"] = False  # No transfers in for GW0\n                selected_squad_gw[\"transfer_out\"] = (\n                    False  # No transfers out for GW0\n                )\n\n            self.selected_squad_history[f\"GW{gw_actual}\"] = {\n                \"squad\": selected_squad_gw,\n                \"total_cost\": selected_squad_gw[\"cost\"].sum(),\n                \"expected_points_from_xi\": sum(\n                    self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n                    * starting_xi_vars[i][w].varValue\n                    for i in self.player_data.index\n                ),\n                \"bench_boost_used\": bool(use_bench_boost[w].varValue),\n                \"triple_captain_used\": bool(use_triple_captain[w].varValue),\n                \"total_bench_boost_points\": value(\n                    lpSum(\n                        actual_bench_boost_points[i][w]\n                        for i in self.player_data.index\n                    )\n                ),\n                \"total_triple_captain_bonus\": value(\n                    lpSum(\n                        actual_triple_captain_bonus[i][w]\n                        for i in self.player_data.index\n                    )\n                ),\n                \"transfers_in_count\": transfers_in_gw,\n                \"transfers_out_count\": transfers_out_gw,\n                \"transfer_hits\": hits_gw,  # New\n                \"free_transfers_available_next_gw\": (\n                    int(round(free_transfers_available[w].varValue))\n                    if w &lt; num_gameweeks - 1\n                    else 0\n                ),  # Free transfers available *after* this GW's transfers are made\n            }\n\n        # Overall totals\n        self.total_cost = self.selected_squad_history[\n            f\"GW{current_gameweek_number_start + num_gameweeks - 1}\"\n        ][\n            \"total_cost\"\n        ]  # Cost of final squad\n        self.total_expected_points = value(\n            self.problem.objective\n        )  # Total objective value from solver\n        self.used_chips = {\n            f\"GW{current_gameweek_number_start + w}\": {\n                \"bench_boost\": bool(use_bench_boost[w].varValue),\n                \"triple_captain\": bool(use_triple_captain[w].varValue),\n            }\n            for w in range(num_gameweeks)\n        }\n\n        return True\n    else:\n        print(f\"No optimal solution found. Status: {LpStatus[self.problem.status]}\")\n        self.selected_squad_history = {}\n        self.total_cost = 0\n        self.total_expected_points = 0\n        self.used_chips = {}\n        self.total_transfer_hits = 0\n        return False\n</code></pre>"},{"location":"autoapi/fpl_solver/#fpl_solver.fpl_xp_predictor","title":"<code>fpl_xp_predictor</code>","text":""},{"location":"autoapi/fpl_solver/#fpl_solver.fpl_xp_predictor.FPLPredictor","title":"<code>FPLPredictor</code>","text":"<p>Predictive algorithm for Expected Points (xP) in Fantasy Premier League, using real data from the FPL API.</p> Source code in <code>fpl_solver/fpl_xp_predictor.py</code> <pre><code>class FPLPredictor:\n    \"\"\"\n    Predictive algorithm for Expected Points (xP) in Fantasy Premier League,\n    using real data from the FPL API.\n    \"\"\"\n\n    def __init__(self, gameweeks_to_predict: int = 1):\n        \"\"\"\n        Initializes the FPLPredictor with default FPL point rules and\n        data structures, then fetches real data and calculates xP for all players.\n\n        Args:\n            gameweeks_to_predict (int): The number of upcoming gameweeks to calculate\n                                        expected points for. Default is 1 (next gameweek).\n        \"\"\"\n        if not isinstance(gameweeks_to_predict, int) or gameweeks_to_predict &lt; 1:\n            raise ValueError(\"gameweeks_to_predict must be a positive integer.\")\n        self.gameweeks_to_predict = gameweeks_to_predict\n\n        self.fpl_points = FPL_POINTS\n\n        self.players_data = {}\n        self.teams_data = {}\n        self.fixtures_data = {}\n        self.position_definitions = {\n            1: \"GK\",\n            2: \"DEF\",\n            3: \"MID\",\n            4: \"FWD\",\n        }\n        self.all_players_xp_calculated_data = (\n            []\n        )  # To store xP for all players for the optimizer\n\n        self._fetch_fpl_data()\n        self._calculate_all_players_xp()  # Calculate xP for all players after data is loaded\n\n    def _fetch_fpl_data(self):\n        \"\"\"Fetches initial data from the FPL API.\"\"\"\n        print(\"Fetching FPL data...\")\n        try:\n            # Fetch general data\n            static_data = requests.get(\n                \"https://fantasy.premierleague.com/api/bootstrap-static/\"\n            ).json()\n            # Fetch fixtures data\n            fixtures_data = requests.get(\n                \"https://fantasy.premierleague.com/api/fixtures/\"\n            ).json()\n\n            # Process players data\n            for element in static_data[\"elements\"]:\n                player_id = element[\"id\"]\n                self.players_data[player_id] = {\n                    \"name\": element[\"first_name\"] + \" \" + element[\"second_name\"],\n                    \"web_name\": element[\"web_name\"],\n                    \"team_id\": element[\"team\"],\n                    \"element_type\": element[\"element_type\"],\n                    \"position\": self.position_definitions.get(\n                        element[\"element_type\"], \"Unknown\"\n                    ),\n                    \"cost_pence\": element[\"now_cost\"],\n                    \"status\": element[\"status\"],\n                    \"news\": element[\"news\"],\n                    \"total_points\": element[\"total_points\"],\n                    \"minutes\": element[\"minutes\"],\n                    \"goals_scored\": element[\"goals_scored\"],\n                    \"assists\": element[\"assists\"],\n                    \"clean_sheets\": element[\"clean_sheets\"],\n                    \"goals_conceded\": element[\"goals_conceded\"],\n                    \"penalties_saved\": element[\"penalties_saved\"],\n                    \"penalties_missed\": element[\"penalties_missed\"],\n                    \"yellow_cards\": element[\"yellow_cards\"],\n                    \"red_cards\": element[\"red_cards\"],\n                    \"own_goals\": element[\"own_goals\"],\n                    \"saves\": element[\"saves\"],\n                    \"bonus\": element[\"bonus\"],\n                    \"bps\": element[\"bps\"],\n                    \"threat\": element[\"threat\"],\n                    \"creativity\": element[\"creativity\"],\n                    \"influence\": element[\"influence\"],\n                    \"form\": float(element[\"form\"]),\n                    \"points_per_game\": float(element[\"points_per_game\"]),\n                    \"value_season\": float(element[\"value_season\"]),\n                    \"value_form\": float(element[\"value_form\"]),\n                    \"ict_index\": float(element[\"ict_index\"]),\n                }\n\n            # --- Apply Player Exclusions ---\n            initial_player_count = len(self.players_data)\n            players_to_keep = {}\n            for player_id, player_info in self.players_data.items():\n                # Exclude by ID\n                if player_id in EXCLUDED_PLAYERS_BY_ID:\n                    print(\n                        f\"Excluding player by ID: {player_info['name']} (ID: {player_id})\"\n                    )\n                    continue\n\n                # Exclude by Name\n                if player_info[\"name\"] in EXCLUDED_PLAYERS_BY_NAME:\n                    print(\n                        f\"Excluding player by Name: {player_info['name']} (ID: {player_id})\"\n                    )\n                    continue\n\n                # Exclude by Team and Position\n                excluded_by_team_pos = False\n                for exclusion_rule in EXCLUDED_PLAYERS_BY_TEAM_AND_POSITION:\n                    team_name = self.teams_data.get(player_info[\"team_id\"], {}).get(\n                        \"name\"\n                    )\n                    if team_name == exclusion_rule.get(\"team\") and player_info[\n                        \"position\"\n                    ] == exclusion_rule.get(\"position\"):\n                        print(\n                            f\"Excluding player by Team/Position: {player_info['name']} ({team_name}, {player_info['position']})\"\n                        )\n                        excluded_by_team_pos = True\n                        break\n                if excluded_by_team_pos:\n                    continue\n\n                players_to_keep[player_id] = player_info\n\n            self.players_data = players_to_keep\n            print(\n                f\"Filtered {initial_player_count - len(self.players_data)} players. Remaining: {len(self.players_data)}\"\n            )\n\n            # Process teams data\n            for team in static_data[\"teams\"]:\n                self.teams_data[team[\"id\"]] = {\n                    \"name\": team[\"name\"],\n                    \"short_name\": team[\"short_name\"],\n                    \"strength\": team[\"strength\"],\n                    \"strength_overall_home\": team[\"strength_overall_home\"],\n                    \"strength_overall_away\": team[\"strength_overall_away\"],\n                    \"strength_attack_home\": team[\"strength_attack_home\"],\n                    \"strength_attack_away\": team[\"strength_attack_away\"],\n                    \"strength_defence_home\": team[\"strength_defence_home\"],\n                    \"strength_defence_away\": team[\"strength_defence_away\"],\n                }\n\n            # Process fixtures data\n            for fixture in fixtures_data:\n                self.fixtures_data[fixture[\"id\"]] = fixture\n\n            print(\"FPL data fetched successfully.\")\n\n        except requests.exceptions.RequestException as e:\n            print(f\"Error fetching FPL data: {e}\")\n            self.players_data = {}\n            self.teams_data = {}\n            self.fixtures_data = {}\n            print(\"Initialization failed due to data fetching error. Exiting.\")\n            sys.exit(1)\n        except Exception as e:\n            print(f\"An unexpected error occurred during data fetching: {e}\")\n            self.players_data = {}\n            self.teams_data = {}\n            self.fixtures_data = {}\n            print(\"Initialization failed due to unexpected error. Exiting.\")\n            sys.exit(1)\n\n    def _get_team_strength(self, team_id, is_home):\n        \"\"\"Get team strength based on home/away status.\"\"\"\n        team = self.teams_data.get(team_id, {})\n        if is_home:\n            return team.get(\"strength_overall_home\", 1000)  # Default if not found\n        return team.get(\"strength_overall_away\", 1000)  # Default if not found\n\n    def _predict_minutes(self, player_id):\n        \"\"\"\n        Predicts expected minutes for a player based on historical data.\n        More sophisticated logic for handling very low minute players.\n        \"\"\"\n        player = self.players_data.get(player_id)\n        if not player:\n            return 0.0\n\n        status = player[\"status\"]\n        news = player[\"news\"].lower()\n        minutes_played = player[\"minutes\"]\n\n        # 1. Unavailable players (injured, suspended, doubtful)\n        if status != \"a\" or any(\n            x in news\n            for x in [\n                \"injured\",\n                \"doubtful\",\n                \"suspension\",\n                \"red card\",\n                \"expected back\",\n            ]\n        ):\n            return 0.0\n\n        # 2. Players with significant minutes (starters/key rotation)\n        if minutes_played &gt;= MIN_MINUTES_THRESHOLD:\n            # Average minutes per game started (assuming most minutes come from starts)\n            # This is a heuristic; real FPL API doesn't give starts directly.\n            # We assume a player with &gt; MIN_MINUTES_THRESHOLD plays ~80-90 minutes when on pitch.\n            # So, (minutes_played / number_of_appearances) is a rough proxy.\n            # For simplicity, let's use a cap of 90 minutes.\n            if player[\"total_points\"] &gt; 0:  # Player has played at least one game\n                avg_minutes_per_appearance = minutes_played / (\n                    player[\"total_points\"] / player[\"points_per_game\"]\n                )\n                return min(avg_minutes_per_appearance, 90.0)\n            return 70.0  # Reasonable default for established player with points but no clear avg\n\n        # 3. Players with very low minutes (rarely play, new, youth)\n        if minutes_played &lt; VERY_LOW_MINUTES_THRESHOLD:\n            # If news suggests they might get a chance, assign default sub minutes.\n            # Otherwise, very low expected minutes or zero.\n            if any(x in news for x in [\"return imminent\", \"close to return\"]):\n                return DEFAULT_SUB_MINUTES  # Might get some minutes\n            return DEFAULT_UNKNOWN_PLAYER_MINUTES  # Very unlikely to play significant minutes\n\n        # 4. Players with some minutes but below significant threshold (regular subs)\n        return DEFAULT_SUB_MINUTES\n\n    def _calculate_expected_goals(self, team_attack_strength, opp_defence_strength):\n        \"\"\"\n        Calculates expected goals for a team based on its attack strength and\n        opponent's defensive strength. This is a simplified heuristic.\n        \"\"\"\n        # A simple ratio model: Higher attack strength and lower opponent defense means more goals\n        # Normalization factor can be adjusted based on average league goals\n        expected_goals = (\n            team_attack_strength / opp_defence_strength\n        ) * 1.5  # 1.5 is an arbitrary scaling factor\n        return max(0.0, expected_goals)\n\n    def _calculate_expected_conceded_goals(\n        self, team_defence_strength, opp_attack_strength\n    ):\n        \"\"\"\n        Calculates expected goals conceded by a team based on its defense strength\n        and opponent's attacking strength.\n        \"\"\"\n        # A simple ratio model: Higher opponent attack and lower team defense means more conceded goals\n        expected_conceded_goals = (\n            opp_attack_strength / team_defence_strength\n        ) * 1.5  # 1.5 is an arbitrary scaling factor\n        return max(0.0, expected_conceded_goals)\n\n    def calculate_xp_for_player(self, player_id, fixture_id):\n        \"\"\"\n        Calculates Expected Points (xP) for a single player in a given fixture.\n        Considers various factors: minutes, goals, assists, clean sheets, saves,\n        bonus points, and negative events, adjusted for fixture difficulty.\n        \"\"\"\n        player = self.players_data.get(player_id)\n        fixture = self.fixtures_data.get(fixture_id)\n\n        if not player or not fixture:\n            return {\"xp\": 0.0, \"reason\": \"Player or fixture data missing.\"}\n\n        # Handle unavailable players\n        if (\n            player[\"status\"] != \"a\"\n        ):  # 'd' for doubtful, 'i' for injured, 's' for suspended\n            return {\"xp\": 0.0, \"reason\": f\"Player status: {player['status']}\"}\n        if any(\n            x in player[\"news\"].lower()\n            for x in [\"injured\", \"doubtful\", \"suspension\", \"red card\"]\n        ):\n            return {\"xp\": 0.0, \"reason\": f\"Player news: {player['news']}\"}\n\n        # Predict minutes\n        expected_minutes = self._predict_minutes(player_id)\n        if expected_minutes &lt; 1.0:  # If expected to play very little or none\n            return {\"xp\": 0.0, \"reason\": \"Expected minutes too low.\"}\n\n        xp = 0.0\n        position = player[\"position\"]\n        # Use 'team_h' for home team ID\n        is_home_fixture = player[\"team_id\"] == fixture[\"team_h\"]\n\n        # Determine attacking and defensive strengths for the fixture\n        player_team_strength_attack = (\n            self.teams_data.get(fixture[\"team_h\"], {}).get(\n                \"strength_attack_home\"\n            )  # Use 'team_h'\n            if is_home_fixture\n            else self.teams_data.get(fixture[\"team_a\"], {}).get(\n                \"strength_attack_away\"\n            )  # Use 'team_a'\n        )\n        player_team_strength_defence = (\n            self.teams_data.get(fixture[\"team_h\"], {}).get(\n                \"strength_defence_home\"\n            )  # Use 'team_h'\n            if is_home_fixture\n            else self.teams_data.get(fixture[\"team_a\"], {}).get(\n                \"strength_defence_away\"\n            )  # Use 'team_a'\n        )\n        opponent_team_strength_attack = (\n            self.teams_data.get(fixture[\"team_a\"], {}).get(\n                \"strength_attack_away\"\n            )  # Use 'team_a'\n            if is_home_fixture\n            else self.teams_data.get(fixture[\"team_h\"], {}).get(\n                \"strength_attack_home\"\n            )  # Use 'team_h'\n        )\n        opponent_team_strength_defence = (\n            self.teams_data.get(fixture[\"team_a\"], {}).get(\n                \"strength_defence_away\"\n            )  # Use 'team_a'\n            if is_home_fixture\n            else self.teams_data.get(fixture[\"team_h\"], {}).get(\n                \"strength_defence_home\"\n            )  # Use 'team_h'\n        )\n\n        if None in [\n            player_team_strength_attack,\n            player_team_strength_defence,\n            opponent_team_strength_attack,\n            opponent_team_strength_defence,\n        ]:\n            # Fallback if strength data is missing (shouldn't happen with robust data fetch)\n            return {\"xp\": 0.0, \"reason\": \"Team strength data missing for fixture.\"}\n\n        # 1. Appearance points\n        if expected_minutes &gt;= 60:\n            xp += self.fpl_points[\"appearance_points_gte_60\"]\n        elif expected_minutes &gt; 0:\n            xp += self.fpl_points[\"appearance_points_lt_60\"]\n\n        # 2. Expected Goals (scaled by historical goals per 90 and opponent difficulty)\n        # Use player's form and total goals as a basis\n        goals_per_90_hist = (\n            (player[\"goals_scored\"] / player[\"minutes\"] * 90)\n            if player[\"minutes\"] &gt; 0\n            else 0.0\n        )\n        expected_team_goals = self._calculate_expected_goals(\n            player_team_strength_attack, opponent_team_strength_defence\n        )\n\n        expected_goals_player_contribution = (\n            (goals_per_90_hist / 90.0) * expected_minutes * (expected_team_goals / 1.5)\n        )  # Scale player's goal contribution by team's expected goals\n\n        if position == \"GK\":\n            xp += expected_goals_player_contribution * self.fpl_points[\"goal_gk\"]\n        elif position == \"DEF\":\n            xp += expected_goals_player_contribution * self.fpl_points[\"goal_def\"]\n        elif position == \"MID\":\n            xp += expected_goals_player_contribution * self.fpl_points[\"goal_mid\"]\n        elif position == \"FWD\":\n            xp += expected_goals_player_contribution * self.fpl_points[\"goal_fwd\"]\n\n        # 3. Expected Assists (scaled by historical assists per 90 and opponent difficulty)\n        assists_per_90_hist = (\n            (player[\"assists\"] / player[\"minutes\"] * 90)\n            if player[\"minutes\"] &gt; 0\n            else 0.0\n        )\n        # Assuming team's attacking strength correlates with assist opportunities\n        expected_assists_player_contribution = (\n            (assists_per_90_hist / 90.0)\n            * expected_minutes\n            * (expected_team_goals / 1.5)\n        )  # Similarly scale by team's expected goals\n        xp += expected_assists_player_contribution * self.fpl_points[\"assist_points\"]\n\n        # 4. Expected Clean Sheets (for GKs/DEFs/MIDs) and Conceded Goals deduction\n        expected_conceded = self._calculate_expected_conceded_goals(\n            player_team_strength_defence, opponent_team_strength_attack\n        )\n\n        # Probability of clean sheet\n        # Simplified: higher team defense / lower opponent attack -&gt; higher CS prob\n        # Use logistic or sigmoid for probability\n        cs_prob = 1.0 / (\n            1.0 + math.exp(expected_conceded - 1.0)\n        )  # Sigmoid centered at 1 goal\n\n        if position in [\"GK\", \"DEF\"]:\n            xp += cs_prob * self.fpl_points[\"clean_sheet_gk_def\"]\n\n            # Conceded goals deduction: Apply penalty for every 2 goals conceded *probability*\n            # For simplicity, calculate expected deduction: (expected_conceded / 2) * deduction\n            xp += (expected_conceded / 2.0) * self.fpl_points[\n                \"conceded_2_goals_deduction\"\n            ]\n        elif position == \"MID\":\n            xp += cs_prob * self.fpl_points[\"clean_sheet_mid\"]\n\n        # 5. Expected Saves (for GKs)\n        if position == \"GK\":\n            saves_per_90_hist = (\n                (player[\"saves\"] / player[\"minutes\"] * 90)\n                if player[\"minutes\"] &gt; 0\n                else 0.0\n            )\n            # Expected saves scaled by opponent's attacking strength (more attacking -&gt; more shots -&gt; more saves)\n            expected_saves_player_contribution = (\n                (saves_per_90_hist / 90.0)\n                * expected_minutes\n                * (opponent_team_strength_attack / player_team_strength_defence)\n            )\n            xp += (expected_saves_player_contribution / 3.0) * self.fpl_points[\n                \"saves_3_points\"\n            ]  # Using the new config point value\n\n            # Penalty saves (low probability, use historical rate)\n            penalty_saves_hist_per_game = (\n                player[\"penalties_saved\"] / (player[\"minutes\"] / 90.0)\n                if player[\"minutes\"] &gt; 0\n                else 0.0\n            )\n            xp += (\n                penalty_saves_hist_per_game\n                * (expected_minutes / 90.0)\n                * self.fpl_points[\"penalty_save_points\"]\n            )\n\n        # 6. Expected Bonus Points\n        # Use BPS (Bonus Points System) as a proxy. Scale player's average BPS by form and expected minutes.\n        bps_per_90_hist = (\n            (player[\"bps\"] / player[\"minutes\"] * 90) if player[\"minutes\"] &gt; 0 else 0.0\n        )\n        expected_bps = (bps_per_90_hist / 90.0) * expected_minutes * player[\"form\"]\n        xp += expected_bps * self.fpl_points[\"bonus_points_scaling_factor\"]\n\n        # 7. Minor Negative Events (Probabilistic)\n        # These are rare, so a simple probability based on expected minutes.\n        xp += (expected_minutes / 90.0) * (\n            self.fpl_points[\"yellow_card_deduction\"] * YELLOW_CARD_PROB\n            + self.fpl_points[\"red_card_deduction\"] * RED_CARD_PROB\n            + self.fpl_points[\"own_goal_deduction\"] * OWN_GOAL_PROB\n            + self.fpl_points[\"penalty_miss_deduction\"] * PENALTY_MISS_PROB\n        )\n\n        # 8. Defensive Contribution Points (for 2025/26 season heuristic)\n        # Assuming CBIT/CBIRT tracking\n        if position in [\"GK\", \"DEF\"]:\n            xp += CBIT_DEF_PROB * self.fpl_points[\"cbit_def_points\"]\n        elif position in [\"MID\", \"FWD\"]:\n            xp += CBIRT_MID_FWD_PROB * self.fpl_points[\"cbirt_mid_fwd_points\"]\n\n        return {\"xp\": round(xp, 2), \"reason\": \"Success\"}\n\n    def _calculate_all_players_xp(self):\n        \"\"\"\n        Calculates the Expected Points (xP) for all players over multiple upcoming gameweeks\n        and populates self.all_players_xp_calculated_data with xP per gameweek.\n        \"\"\"\n        print(\n            f\"Calculating xP for all players over {self.gameweeks_to_predict} gameweek(s)...\"\n        )\n\n        # Get all upcoming fixtures and sort them by gameweek\n        all_upcoming_fixtures_items = sorted(\n            [\n                (fid, fdict)\n                for fid, fdict in self.fixtures_data.items()\n                if not fdict[\"finished\"]\n            ],\n            key=lambda item: item[1][\"event\"],\n        )\n\n        if not all_upcoming_fixtures_items:\n            print(\"No upcoming fixtures found. Cannot calculate xP.\")\n            return\n\n        # Determine the current gameweek (the gameweek of the earliest upcoming fixture)\n        current_gameweek = all_upcoming_fixtures_items[0][1][\"event\"]\n        target_gameweeks = range(\n            current_gameweek, current_gameweek + self.gameweeks_to_predict\n        )\n\n        # Create a mapping of team_id_code to a list of their fixtures within the target gameweeks\n        team_fixtures_in_range = {team_code: [] for team_code in self.teams_data.keys()}\n        for fixture_id, fixture_data in all_upcoming_fixtures_items:\n            if fixture_data[\"event\"] in target_gameweeks:\n                home_team_code = fixture_data[\"team_h\"]\n                away_team_code = fixture_data[\"team_a\"]\n\n                team_fixtures_in_range[home_team_code].append(fixture_id)\n                team_fixtures_in_range[away_team_code].append(fixture_id)\n\n        # Calculate total xP for each player across the specified gameweeks\n        for player_id, player_data in self.players_data.items():\n            player_team_code = player_data[\"team_id\"]\n            player_position = player_data[\"position\"]\n\n            # Calculate xP for each relevant fixture and store by gameweek\n            expected_points_by_gw = {}\n            for fixture_id in team_fixtures_in_range.get(player_team_code, []):\n                fixture_gameweek = self.fixtures_data[fixture_id][\"event\"]\n                xp_result_single_gw = self.calculate_xp_for_player(\n                    player_id, fixture_id\n                )\n                if xp_result_single_gw and xp_result_single_gw[\"xp\"] is not None:\n                    if fixture_gameweek not in expected_points_by_gw:\n                        expected_points_by_gw[fixture_gameweek] = 0.0\n                    expected_points_by_gw[fixture_gameweek] += xp_result_single_gw[\"xp\"]\n\n            # Ensure all target gameweeks are present, even if xP is 0 for a given GW\n            for gw in target_gameweeks:\n                if gw not in expected_points_by_gw:\n                    expected_points_by_gw[gw] = 0.0\n\n            # Sort the dictionary by gameweek for consistent output\n            expected_points_by_gw = dict(sorted(expected_points_by_gw.items()))\n\n            # Prepare data for the optimizer\n            player_cost_m = player_data[\"cost_pence\"] / 10.0\n            team_name_full = self.teams_data.get(player_team_code, {}).get(\n                \"name\", \"Unknown Team\"\n            )\n\n            self.all_players_xp_calculated_data.append(\n                {\n                    \"name\": player_data[\"name\"],\n                    \"web_name\": player_data[\"web_name\"],\n                    \"team\": team_name_full,\n                    \"position\": player_position,\n                    \"cost\": player_cost_m,\n                    \"expected_points_by_gw\": expected_points_by_gw,  # Changed key and format\n                }\n            )\n        print(\"xP calculation for all players complete.\")\n\n    def get_upcoming_fixtures(self, limit=None):\n        \"\"\"\n        Returns a list of upcoming fixtures, sorted by gameweek and kickoff time.\n        Optionally limits the number of fixtures returned.\n        \"\"\"\n        upcoming = []\n        now = datetime.now()\n\n        # Sort all fixtures by gameweek and then by kickoff time\n        sorted_fixtures = sorted(\n            self.fixtures_data.values(),\n            key=lambda x: (\n                x.get(\"event\", 0),\n                x.get(\"kickoff_time\", \"9999-12-31T00:00:00Z\"),\n            ),\n        )\n\n        current_gameweek = None\n        for fixture_data in sorted_fixtures:\n            # Determine current gameweek from the earliest upcoming fixture\n            if not fixture_data[\"finished\"] and current_gameweek is None:\n                current_gameweek = fixture_data.get(\"event\", 0)\n\n            # Filter for upcoming fixtures within the prediction horizon\n            if (\n                fixture_data.get(\"event\", 0) &lt; current_gameweek  # Skip past gameweeks\n                or fixture_data.get(\"event\", 0)\n                &gt;= current_gameweek + self.gameweeks_to_predict\n            ):\n                continue  # Skip fixtures outside the prediction horizon\n\n            home_team_name = self.teams_data.get(\n                fixture_data[\"team_h\"], {}\n            ).get(  # Use 'team_h'\n                \"name\", \"Unknown\"\n            )\n            away_team_name = self.teams_data.get(\n                fixture_data[\"team_a\"], {}\n            ).get(  # Use 'team_a'\n                \"name\", \"Unknown\"\n            )\n\n            # Only add fixtures that are not finished\n            if not fixture_data[\"finished\"]:\n                upcoming.append(\n                    {\n                        \"fixture_id\": fixture_data[\"id\"],\n                        \"gameweek\": fixture_data.get(\"event\"),\n                        \"home_team_id\": fixture_data[\"team_h\"],  # Use 'team_h'\n                        \"away_team_id\": fixture_data[\"team_a\"],  # Use 'team_a'\n                        \"match\": f\"{home_team_name} vs {away_team_name}\",\n                        \"kickoff_time\": fixture_data.get(\"kickoff_time\"),\n                        \"home_team_difficulty\": fixture_data[\"team_h_difficulty\"],\n                        \"away_team_difficulty\": fixture_data[\"team_a_difficulty\"],\n                    }\n                )\n            if limit is not None and len(upcoming) &gt;= limit:\n                break\n        return upcoming\n\n    def get_players_for_optimizer(self):\n        \"\"\"\n        Returns the list of player data with calculated xP per gameweek,\n        formatted for the FPLOptimizer.\n        \"\"\"\n        return self.all_players_xp_calculated_data\n</code></pre>"},{"location":"autoapi/fpl_solver/#fpl_solver.fpl_xp_predictor.FPLPredictor.__init__","title":"<code>__init__(gameweeks_to_predict=1)</code>","text":"<p>Initializes the FPLPredictor with default FPL point rules and data structures, then fetches real data and calculates xP for all players.</p> <p>Parameters:</p> Name Type Description Default <code>gameweeks_to_predict</code> <code>int</code> <p>The number of upcoming gameweeks to calculate                         expected points for. Default is 1 (next gameweek).</p> <code>1</code> Source code in <code>fpl_solver/fpl_xp_predictor.py</code> <pre><code>def __init__(self, gameweeks_to_predict: int = 1):\n    \"\"\"\n    Initializes the FPLPredictor with default FPL point rules and\n    data structures, then fetches real data and calculates xP for all players.\n\n    Args:\n        gameweeks_to_predict (int): The number of upcoming gameweeks to calculate\n                                    expected points for. Default is 1 (next gameweek).\n    \"\"\"\n    if not isinstance(gameweeks_to_predict, int) or gameweeks_to_predict &lt; 1:\n        raise ValueError(\"gameweeks_to_predict must be a positive integer.\")\n    self.gameweeks_to_predict = gameweeks_to_predict\n\n    self.fpl_points = FPL_POINTS\n\n    self.players_data = {}\n    self.teams_data = {}\n    self.fixtures_data = {}\n    self.position_definitions = {\n        1: \"GK\",\n        2: \"DEF\",\n        3: \"MID\",\n        4: \"FWD\",\n    }\n    self.all_players_xp_calculated_data = (\n        []\n    )  # To store xP for all players for the optimizer\n\n    self._fetch_fpl_data()\n    self._calculate_all_players_xp()  # Calculate xP for all players after data is loaded\n</code></pre>"},{"location":"autoapi/fpl_solver/#fpl_solver.fpl_xp_predictor.FPLPredictor.calculate_xp_for_player","title":"<code>calculate_xp_for_player(player_id, fixture_id)</code>","text":"<p>Calculates Expected Points (xP) for a single player in a given fixture. Considers various factors: minutes, goals, assists, clean sheets, saves, bonus points, and negative events, adjusted for fixture difficulty.</p> Source code in <code>fpl_solver/fpl_xp_predictor.py</code> <pre><code>def calculate_xp_for_player(self, player_id, fixture_id):\n    \"\"\"\n    Calculates Expected Points (xP) for a single player in a given fixture.\n    Considers various factors: minutes, goals, assists, clean sheets, saves,\n    bonus points, and negative events, adjusted for fixture difficulty.\n    \"\"\"\n    player = self.players_data.get(player_id)\n    fixture = self.fixtures_data.get(fixture_id)\n\n    if not player or not fixture:\n        return {\"xp\": 0.0, \"reason\": \"Player or fixture data missing.\"}\n\n    # Handle unavailable players\n    if (\n        player[\"status\"] != \"a\"\n    ):  # 'd' for doubtful, 'i' for injured, 's' for suspended\n        return {\"xp\": 0.0, \"reason\": f\"Player status: {player['status']}\"}\n    if any(\n        x in player[\"news\"].lower()\n        for x in [\"injured\", \"doubtful\", \"suspension\", \"red card\"]\n    ):\n        return {\"xp\": 0.0, \"reason\": f\"Player news: {player['news']}\"}\n\n    # Predict minutes\n    expected_minutes = self._predict_minutes(player_id)\n    if expected_minutes &lt; 1.0:  # If expected to play very little or none\n        return {\"xp\": 0.0, \"reason\": \"Expected minutes too low.\"}\n\n    xp = 0.0\n    position = player[\"position\"]\n    # Use 'team_h' for home team ID\n    is_home_fixture = player[\"team_id\"] == fixture[\"team_h\"]\n\n    # Determine attacking and defensive strengths for the fixture\n    player_team_strength_attack = (\n        self.teams_data.get(fixture[\"team_h\"], {}).get(\n            \"strength_attack_home\"\n        )  # Use 'team_h'\n        if is_home_fixture\n        else self.teams_data.get(fixture[\"team_a\"], {}).get(\n            \"strength_attack_away\"\n        )  # Use 'team_a'\n    )\n    player_team_strength_defence = (\n        self.teams_data.get(fixture[\"team_h\"], {}).get(\n            \"strength_defence_home\"\n        )  # Use 'team_h'\n        if is_home_fixture\n        else self.teams_data.get(fixture[\"team_a\"], {}).get(\n            \"strength_defence_away\"\n        )  # Use 'team_a'\n    )\n    opponent_team_strength_attack = (\n        self.teams_data.get(fixture[\"team_a\"], {}).get(\n            \"strength_attack_away\"\n        )  # Use 'team_a'\n        if is_home_fixture\n        else self.teams_data.get(fixture[\"team_h\"], {}).get(\n            \"strength_attack_home\"\n        )  # Use 'team_h'\n    )\n    opponent_team_strength_defence = (\n        self.teams_data.get(fixture[\"team_a\"], {}).get(\n            \"strength_defence_away\"\n        )  # Use 'team_a'\n        if is_home_fixture\n        else self.teams_data.get(fixture[\"team_h\"], {}).get(\n            \"strength_defence_home\"\n        )  # Use 'team_h'\n    )\n\n    if None in [\n        player_team_strength_attack,\n        player_team_strength_defence,\n        opponent_team_strength_attack,\n        opponent_team_strength_defence,\n    ]:\n        # Fallback if strength data is missing (shouldn't happen with robust data fetch)\n        return {\"xp\": 0.0, \"reason\": \"Team strength data missing for fixture.\"}\n\n    # 1. Appearance points\n    if expected_minutes &gt;= 60:\n        xp += self.fpl_points[\"appearance_points_gte_60\"]\n    elif expected_minutes &gt; 0:\n        xp += self.fpl_points[\"appearance_points_lt_60\"]\n\n    # 2. Expected Goals (scaled by historical goals per 90 and opponent difficulty)\n    # Use player's form and total goals as a basis\n    goals_per_90_hist = (\n        (player[\"goals_scored\"] / player[\"minutes\"] * 90)\n        if player[\"minutes\"] &gt; 0\n        else 0.0\n    )\n    expected_team_goals = self._calculate_expected_goals(\n        player_team_strength_attack, opponent_team_strength_defence\n    )\n\n    expected_goals_player_contribution = (\n        (goals_per_90_hist / 90.0) * expected_minutes * (expected_team_goals / 1.5)\n    )  # Scale player's goal contribution by team's expected goals\n\n    if position == \"GK\":\n        xp += expected_goals_player_contribution * self.fpl_points[\"goal_gk\"]\n    elif position == \"DEF\":\n        xp += expected_goals_player_contribution * self.fpl_points[\"goal_def\"]\n    elif position == \"MID\":\n        xp += expected_goals_player_contribution * self.fpl_points[\"goal_mid\"]\n    elif position == \"FWD\":\n        xp += expected_goals_player_contribution * self.fpl_points[\"goal_fwd\"]\n\n    # 3. Expected Assists (scaled by historical assists per 90 and opponent difficulty)\n    assists_per_90_hist = (\n        (player[\"assists\"] / player[\"minutes\"] * 90)\n        if player[\"minutes\"] &gt; 0\n        else 0.0\n    )\n    # Assuming team's attacking strength correlates with assist opportunities\n    expected_assists_player_contribution = (\n        (assists_per_90_hist / 90.0)\n        * expected_minutes\n        * (expected_team_goals / 1.5)\n    )  # Similarly scale by team's expected goals\n    xp += expected_assists_player_contribution * self.fpl_points[\"assist_points\"]\n\n    # 4. Expected Clean Sheets (for GKs/DEFs/MIDs) and Conceded Goals deduction\n    expected_conceded = self._calculate_expected_conceded_goals(\n        player_team_strength_defence, opponent_team_strength_attack\n    )\n\n    # Probability of clean sheet\n    # Simplified: higher team defense / lower opponent attack -&gt; higher CS prob\n    # Use logistic or sigmoid for probability\n    cs_prob = 1.0 / (\n        1.0 + math.exp(expected_conceded - 1.0)\n    )  # Sigmoid centered at 1 goal\n\n    if position in [\"GK\", \"DEF\"]:\n        xp += cs_prob * self.fpl_points[\"clean_sheet_gk_def\"]\n\n        # Conceded goals deduction: Apply penalty for every 2 goals conceded *probability*\n        # For simplicity, calculate expected deduction: (expected_conceded / 2) * deduction\n        xp += (expected_conceded / 2.0) * self.fpl_points[\n            \"conceded_2_goals_deduction\"\n        ]\n    elif position == \"MID\":\n        xp += cs_prob * self.fpl_points[\"clean_sheet_mid\"]\n\n    # 5. Expected Saves (for GKs)\n    if position == \"GK\":\n        saves_per_90_hist = (\n            (player[\"saves\"] / player[\"minutes\"] * 90)\n            if player[\"minutes\"] &gt; 0\n            else 0.0\n        )\n        # Expected saves scaled by opponent's attacking strength (more attacking -&gt; more shots -&gt; more saves)\n        expected_saves_player_contribution = (\n            (saves_per_90_hist / 90.0)\n            * expected_minutes\n            * (opponent_team_strength_attack / player_team_strength_defence)\n        )\n        xp += (expected_saves_player_contribution / 3.0) * self.fpl_points[\n            \"saves_3_points\"\n        ]  # Using the new config point value\n\n        # Penalty saves (low probability, use historical rate)\n        penalty_saves_hist_per_game = (\n            player[\"penalties_saved\"] / (player[\"minutes\"] / 90.0)\n            if player[\"minutes\"] &gt; 0\n            else 0.0\n        )\n        xp += (\n            penalty_saves_hist_per_game\n            * (expected_minutes / 90.0)\n            * self.fpl_points[\"penalty_save_points\"]\n        )\n\n    # 6. Expected Bonus Points\n    # Use BPS (Bonus Points System) as a proxy. Scale player's average BPS by form and expected minutes.\n    bps_per_90_hist = (\n        (player[\"bps\"] / player[\"minutes\"] * 90) if player[\"minutes\"] &gt; 0 else 0.0\n    )\n    expected_bps = (bps_per_90_hist / 90.0) * expected_minutes * player[\"form\"]\n    xp += expected_bps * self.fpl_points[\"bonus_points_scaling_factor\"]\n\n    # 7. Minor Negative Events (Probabilistic)\n    # These are rare, so a simple probability based on expected minutes.\n    xp += (expected_minutes / 90.0) * (\n        self.fpl_points[\"yellow_card_deduction\"] * YELLOW_CARD_PROB\n        + self.fpl_points[\"red_card_deduction\"] * RED_CARD_PROB\n        + self.fpl_points[\"own_goal_deduction\"] * OWN_GOAL_PROB\n        + self.fpl_points[\"penalty_miss_deduction\"] * PENALTY_MISS_PROB\n    )\n\n    # 8. Defensive Contribution Points (for 2025/26 season heuristic)\n    # Assuming CBIT/CBIRT tracking\n    if position in [\"GK\", \"DEF\"]:\n        xp += CBIT_DEF_PROB * self.fpl_points[\"cbit_def_points\"]\n    elif position in [\"MID\", \"FWD\"]:\n        xp += CBIRT_MID_FWD_PROB * self.fpl_points[\"cbirt_mid_fwd_points\"]\n\n    return {\"xp\": round(xp, 2), \"reason\": \"Success\"}\n</code></pre>"},{"location":"autoapi/fpl_solver/#fpl_solver.fpl_xp_predictor.FPLPredictor.get_players_for_optimizer","title":"<code>get_players_for_optimizer()</code>","text":"<p>Returns the list of player data with calculated xP per gameweek, formatted for the FPLOptimizer.</p> Source code in <code>fpl_solver/fpl_xp_predictor.py</code> <pre><code>def get_players_for_optimizer(self):\n    \"\"\"\n    Returns the list of player data with calculated xP per gameweek,\n    formatted for the FPLOptimizer.\n    \"\"\"\n    return self.all_players_xp_calculated_data\n</code></pre>"},{"location":"autoapi/fpl_solver/#fpl_solver.fpl_xp_predictor.FPLPredictor.get_upcoming_fixtures","title":"<code>get_upcoming_fixtures(limit=None)</code>","text":"<p>Returns a list of upcoming fixtures, sorted by gameweek and kickoff time. Optionally limits the number of fixtures returned.</p> Source code in <code>fpl_solver/fpl_xp_predictor.py</code> <pre><code>def get_upcoming_fixtures(self, limit=None):\n    \"\"\"\n    Returns a list of upcoming fixtures, sorted by gameweek and kickoff time.\n    Optionally limits the number of fixtures returned.\n    \"\"\"\n    upcoming = []\n    now = datetime.now()\n\n    # Sort all fixtures by gameweek and then by kickoff time\n    sorted_fixtures = sorted(\n        self.fixtures_data.values(),\n        key=lambda x: (\n            x.get(\"event\", 0),\n            x.get(\"kickoff_time\", \"9999-12-31T00:00:00Z\"),\n        ),\n    )\n\n    current_gameweek = None\n    for fixture_data in sorted_fixtures:\n        # Determine current gameweek from the earliest upcoming fixture\n        if not fixture_data[\"finished\"] and current_gameweek is None:\n            current_gameweek = fixture_data.get(\"event\", 0)\n\n        # Filter for upcoming fixtures within the prediction horizon\n        if (\n            fixture_data.get(\"event\", 0) &lt; current_gameweek  # Skip past gameweeks\n            or fixture_data.get(\"event\", 0)\n            &gt;= current_gameweek + self.gameweeks_to_predict\n        ):\n            continue  # Skip fixtures outside the prediction horizon\n\n        home_team_name = self.teams_data.get(\n            fixture_data[\"team_h\"], {}\n        ).get(  # Use 'team_h'\n            \"name\", \"Unknown\"\n        )\n        away_team_name = self.teams_data.get(\n            fixture_data[\"team_a\"], {}\n        ).get(  # Use 'team_a'\n            \"name\", \"Unknown\"\n        )\n\n        # Only add fixtures that are not finished\n        if not fixture_data[\"finished\"]:\n            upcoming.append(\n                {\n                    \"fixture_id\": fixture_data[\"id\"],\n                    \"gameweek\": fixture_data.get(\"event\"),\n                    \"home_team_id\": fixture_data[\"team_h\"],  # Use 'team_h'\n                    \"away_team_id\": fixture_data[\"team_a\"],  # Use 'team_a'\n                    \"match\": f\"{home_team_name} vs {away_team_name}\",\n                    \"kickoff_time\": fixture_data.get(\"kickoff_time\"),\n                    \"home_team_difficulty\": fixture_data[\"team_h_difficulty\"],\n                    \"away_team_difficulty\": fixture_data[\"team_a_difficulty\"],\n                }\n            )\n        if limit is not None and len(upcoming) &gt;= limit:\n            break\n    return upcoming\n</code></pre>"},{"location":"autoapi/fpl_solver/fpl_solver/","title":"fpl_solver","text":""},{"location":"autoapi/fpl_solver/fpl_solver/#fpl_solver.fpl_solver.FPLOptimizer","title":"<code>FPLOptimizer</code>","text":"<p>A class to optimize Fantasy Premier League (FPL) squad selection using Integer Linear Programming (ILP).</p> <p>The optimizer aims to select a 15-player squad (2 GKs, 5 DEFs, 5 MIDs, 3 FWDs) within a budget, with a maximum number of players from any single team, to maximize the total expected points.</p> Source code in <code>fpl_solver/fpl_solver.py</code> <pre><code>class FPLOptimizer:\n    \"\"\"\n    A class to optimize Fantasy Premier League (FPL) squad selection\n    using Integer Linear Programming (ILP).\n\n    The optimizer aims to select a 15-player squad (2 GKs, 5 DEFs, 5 MIDs, 3 FWDs)\n    within a budget, with a maximum number of players from any single team,\n    to maximize the total expected points.\n    \"\"\"\n\n    def __init__(self, player_data: pd.DataFrame):\n        \"\"\"\n        Initializes the FPLOptimizer with player data.\n\n        Args:\n            player_data (pd.DataFrame): A DataFrame containing player information\n                                        with columns: 'name', 'team', 'position',\n                                        'cost', 'expected_points_by_gw' (a dict of xP per GW).\n        \"\"\"\n        required_columns = [\"name\", \"team\", \"position\", \"cost\", \"expected_points_by_gw\"]\n        if not all(col in player_data.columns for col in required_columns):\n            missing_cols = [\n                col for col in required_columns if col not in player_data.columns\n            ]\n            raise ValueError(\n                f\"player_data DataFrame must contain {required_columns} columns. Missing: {missing_cols}\"\n            )\n\n        self.player_data = player_data\n        self.problem = None\n        self.selected_squad_history = {}  # To store squad for each gameweek\n        self.total_cost = 0\n        self.total_expected_points = 0\n        self.total_transfer_hits = 0\n\n        # --- Process Enforced Players ---\n        self.enforced_player_indices = set()\n        self.enforced_team_pos_requirements = []\n\n        print(\"\\n--- Processing Enforced Players ---\")\n\n        # Enforce by Player ID\n        for player_id in ENFORCED_PLAYERS_BY_ID:\n            found_player = self.player_data[self.player_data[\"id\"] == player_id]\n            if not found_player.empty:\n                player_idx = found_player.index[0]\n                self.enforced_player_indices.add(player_idx)\n                print(\n                    f\"Enforcing player by ID: {found_player.loc[player_idx, 'name']} (ID: {player_id})\"\n                )\n            else:\n                print(\n                    f\"Warning: Enforced player with ID {player_id} not found in data.\"\n                )\n\n        # Enforce by Player Name\n        for player_name in ENFORCED_PLAYERS_BY_NAME:\n            found_player = self.player_data[self.player_data[\"name\"] == player_name]\n            if not found_player.empty:\n                player_idx = found_player.index[0]\n                self.enforced_player_indices.add(player_idx)\n                print(f\"Enforcing player by name: {player_name}\")\n            else:\n                print(f\"Warning: Enforced player '{player_name}' not found in data.\")\n\n        # Enforce by Team and Position\n        for requirement in ENFORCED_PLAYERS_BY_TEAM_AND_POSITION:\n            team = requirement.get(\"team\")\n            position = requirement.get(\"position\")\n            if team and position:\n                # Validate team and position exist in data\n                if team not in self.player_data[\"team\"].unique():\n                    print(\n                        f\"Warning: Enforced team '{team}' for position '{position}' not found in data.\"\n                    )\n                    continue\n                if position not in self.player_data[\"position\"].unique():\n                    print(\n                        f\"Warning: Enforced position '{position}' for team '{team}' not found in data.\"\n                    )\n                    continue\n\n                self.enforced_team_pos_requirements.append((team, position))\n                print(f\"Enforcing at least one {position} from {team}.\")\n            else:\n                print(\n                    f\"Warning: Invalid enforced team/position requirement: {requirement}\"\n                )\n\n        if not (\n            self.enforced_player_indices\n            or self.enforced_team_pos_requirements\n            or ENFORCED_PLAYERS_BY_ID\n            or ENFORCED_PLAYERS_BY_NAME\n            or ENFORCED_PLAYERS_BY_TEAM_AND_POSITION\n        ):\n            print(\"No players or team/position combinations are enforced.\")\n        print(\"-----------------------------------\\n\")\n\n    def solve(\n        self,\n        budget: float,\n        max_players_per_team: int,\n        chip_allowances: dict,\n        num_gameweeks: int,\n    ) -&gt; bool:\n        \"\"\"\n        Solves the FPL optimization problem using PuLP.\n\n        Args:\n            budget (float): The maximum budget in millions of pounds.\n            max_players_per_team (int): The maximum number of players allowed from\n                                        any single Premier League team.\n            chip_allowances (dict): A dictionary specifying the maximum usage for each chip.\n            num_gameweeks (int): The number of gameweeks to optimize over.\n\n        Returns:\n            bool: True if a solution was found, False otherwise.\n        \"\"\"\n        self.problem = LpProblem(\"FPL Squad Multi-Week Optimization\", LpMaximize)\n\n        # Decision variables for player selection, indexed by player and gameweek\n        player_vars = LpVariable.dicts(\n            \"Player\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n        )\n        starting_xi_vars = LpVariable.dicts(\n            \"StartingXI\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n        )\n        captain_var = LpVariable.dicts(\n            \"Captain\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n        )\n\n        # Binary variables for chip usage, indexed by gameweek\n        use_bench_boost = LpVariable.dicts(\n            \"Use_Bench_Boost\", range(num_gameweeks), 0, 1, LpBinary\n        )\n        use_triple_captain = LpVariable.dicts(\n            \"Use_Triple_Captain\", range(num_gameweeks), 0, 1, LpBinary\n        )\n\n        # Transfer variables\n        transfer_in_vars = LpVariable.dicts(\n            \"Transfer_In\",\n            (self.player_data.index, range(1, num_gameweeks)),\n            0,\n            1,\n            LpBinary,\n        )\n        transfer_out_vars = LpVariable.dicts(\n            \"Transfer_Out\",\n            (self.player_data.index, range(1, num_gameweeks)),\n            0,\n            1,\n            LpBinary,\n        )\n\n        # Total transfers made in a gameweek (absolute count)\n        transfers_made = LpVariable.dicts(\n            \"Transfers_Made\", range(1, num_gameweeks), 0, None, LpInteger\n        )\n        # Free transfers available at the start of a gameweek\n        free_transfers_available = LpVariable.dicts(\n            \"Free_Transfers_Available\",\n            range(num_gameweeks),\n            0,\n            MAX_FREE_TRANSFERS_SAVED + 1,\n            LpInteger,\n        )\n        # Number of transfer hits taken in a gameweek\n        transfer_hits = LpVariable.dicts(\n            \"Transfer_Hits\", range(1, num_gameweeks), 0, None, LpInteger\n        )\n\n        # Auxiliary variables for linearizing chip effects\n        is_bench_player = LpVariable.dicts(\n            \"Is_Bench_Player\",\n            (self.player_data.index, range(num_gameweeks)),\n            0,\n            1,\n            LpBinary,\n        )\n        actual_bench_boost_points = LpVariable.dicts(\n            \"Actual_Bench_Boost_Points\",\n            (self.player_data.index, range(num_gameweeks)),\n            0,\n            None,\n            LpContinuous,\n        )\n        actual_triple_captain_bonus = LpVariable.dicts(\n            \"Actual_Triple_Captain_Bonus\",\n            (self.player_data.index, range(num_gameweeks)),\n            0,\n            None,\n            LpContinuous,\n        )\n\n        # --- Objective Function ---\n        total_objective_points = []\n\n        # Get the first gameweek number from the player data to correctly index expected_points_by_gw\n        first_gw_key = next(\n            iter(\n                self.player_data.loc[\n                    self.player_data.index[0], \"expected_points_by_gw\"\n                ].keys()\n            )\n        )\n        current_gameweek_number_start = int(first_gw_key)\n\n        for w in range(num_gameweeks):\n            # The actual gameweek number (1-indexed)\n            gw_actual = current_gameweek_number_start + w\n\n            # Base expected points from the selected starting 11 for this gameweek\n            base_points_expression_gw = lpSum(\n                self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n                * starting_xi_vars[i][w]\n                for i in self.player_data.index\n            )\n            total_objective_points.append(base_points_expression_gw)\n\n            # Regular Captaincy points (additional 1x for captain)\n            captain_points_bonus_gw = lpSum(\n                self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n                * captain_var[i][w]\n                for i in self.player_data.index\n            )\n            total_objective_points.append(captain_points_bonus_gw)\n\n            # Define auxiliary variables and constraints for chips for each gameweek\n            for i in self.player_data.index:\n                # Use gameweek-specific player xP for chip calculations\n                player_xp = self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n\n                # Bench Boost auxiliary variables and constraints\n                self.problem += (\n                    is_bench_player[i][w] &lt;= player_vars[i][w],\n                    f\"IsBench_Squad_{i}_{w}\",\n                )\n                self.problem += (\n                    is_bench_player[i][w] &lt;= 1 - starting_xi_vars[i][w],\n                    f\"IsBench_NotStarter_{i}_{w}\",\n                )\n                self.problem += (\n                    is_bench_player[i][w]\n                    &gt;= player_vars[i][w] + (1 - starting_xi_vars[i][w]) - 1,\n                    f\"IsBench_Logical_{i}_{w}\",\n                )\n\n                self.problem += (\n                    actual_bench_boost_points[i][w]\n                    &lt;= player_xp * is_bench_player[i][w],\n                    f\"BenchBoost_Contr_1_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_bench_boost_points[i][w] &lt;= player_xp * use_bench_boost[w],\n                    f\"BenchBoost_Contr_2_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_bench_boost_points[i][w]\n                    &gt;= player_xp * (is_bench_player[i][w] + use_bench_boost[w] - 1),\n                    f\"BenchBoost_Contr_3_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_bench_boost_points[i][w] &gt;= 0,\n                    f\"BenchBoost_Contr_4_{i}_{w}\",\n                )\n\n                # Triple Captain auxiliary variables and constraints\n                # Changed player_xp * 2 to player_xp to reflect additional 1x bonus\n                self.problem += (\n                    actual_triple_captain_bonus[i][w] &lt;= player_xp * captain_var[i][w],\n                    f\"TripleCaptain_Contr_1_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_triple_captain_bonus[i][w]\n                    &lt;= player_xp * use_triple_captain[w],\n                    f\"TripleCaptain_Contr_2_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_triple_captain_bonus[i][w]\n                    &gt;= player_xp * (captain_var[i][w] + use_triple_captain[w] - 1),\n                    f\"TripleCaptain_Contr_3_{i}_{w}\",\n                )\n                self.problem += (\n                    actual_triple_captain_bonus[i][w] &gt;= 0,\n                    f\"TripleCaptain_Contr_4_{i}_{w}\",\n                )\n\n            # Add points from bench boost and triple captain bonus for this gameweek\n            total_bench_boost_points_gw = lpSum(\n                actual_bench_boost_points[i][w] for i in self.player_data.index\n            )\n            total_triple_captain_bonus_points_gw = lpSum(\n                actual_triple_captain_bonus[i][w] for i in self.player_data.index\n            )\n\n            total_objective_points.append(total_bench_boost_points_gw)\n            total_objective_points.append(total_triple_captain_bonus_points_gw)\n\n        # Subtract transfer hits from the total objective\n        total_objective_points.append(\n            -POINTS_PER_HIT * lpSum(transfer_hits[w] for w in range(1, num_gameweeks))\n        )\n\n        self.problem += (\n            lpSum(total_objective_points),\n            \"Total Expected Points Over Gameweeks\",\n        )\n\n        # --- Constraints ---\n\n        # Apply constraints for each gameweek\n        for w in range(num_gameweeks):\n            # 1. Select exactly 15 players for the squad\n            self.problem += (\n                lpSum(player_vars[i][w] for i in self.player_data.index) == 15,\n                f\"Total_Players_GW{w}\",\n            )\n\n            # 2. Squad position constraints (2 GKs, 5 DEFs, 5 MIDs, 3 FWDs)\n            gks = self.player_data[self.player_data[\"position\"] == \"GK\"].index\n            defs = self.player_data[self.player_data[\"position\"] == \"DEF\"].index\n            mids = self.player_data[self.player_data[\"position\"] == \"MID\"].index\n            fwds = self.player_data[self.player_data[\"position\"] == \"FWD\"].index\n\n            self.problem += (\n                lpSum(player_vars[i][w] for i in gks) == 2,\n                f\"Goalkeepers_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(player_vars[i][w] for i in defs) == 5,\n                f\"Defenders_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(player_vars[i][w] for i in mids) == 5,\n                f\"Midfielders_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(player_vars[i][w] for i in fwds) == 3,\n                f\"Forwards_Count_GW{w}\",\n            )\n\n            # 3. Budget constraint\n            # This applies to the cost of the squad for the current gameweek.\n            self.problem += (\n                lpSum(\n                    self.player_data.loc[i, \"cost\"] * player_vars[i][w]\n                    for i in self.player_data.index\n                )\n                &lt;= budget,\n                f\"Total_Budget_GW{w}\",\n            )\n\n            # 4. Maximum players per team constraint\n            for team in self.player_data[\"team\"].unique():\n                team_players = self.player_data[self.player_data[\"team\"] == team].index\n                self.problem += (\n                    lpSum(player_vars[i][w] for i in team_players)\n                    &lt;= max_players_per_team,\n                    f\"Max_Players_from_{team}_GW{w}\",\n                )\n\n            # 5. Starting XI constraints\n            # 5.1 Select exactly 11 players for the starting XI\n            self.problem += (\n                lpSum(starting_xi_vars[i][w] for i in self.player_data.index) == 11,\n                f\"Total_Starting_XI_Players_GW{w}\",\n            )\n\n            # 5.2 A player can only be in the starting XI if they are in the squad\n            for i in self.player_data.index:\n                self.problem += (\n                    starting_xi_vars[i][w] &lt;= player_vars[i][w],\n                    f\"StartingXI_in_Squad_{i}_{w}\",\n                )\n\n            # 5.3 Starting XI position constraints (FPL allows flexible formations, so use minimums)\n            self.problem += (\n                lpSum(starting_xi_vars[i][w] for i in gks) == 1,\n                f\"Starting_Goalkeepers_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(starting_xi_vars[i][w] for i in defs) &gt;= 3,\n                f\"Min_Starting_Defenders_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(starting_xi_vars[i][w] for i in mids) &gt;= 2,\n                f\"Min_Starting_Midfielders_Count_GW{w}\",\n            )\n            self.problem += (\n                lpSum(starting_xi_vars[i][w] for i in fwds) &gt;= 1,\n                f\"Min_Starting_Forwards_Count_GW{w}\",\n            )\n\n            # 6. Captain Constraints\n            # 6.1 Select exactly one captain from the starting XI\n            self.problem += (\n                lpSum(captain_var[i][w] for i in self.player_data.index) == 1,\n                f\"One_Captain_GW{w}\",\n            )\n\n            # 6.2 A player can only be captain if they are in the starting XI\n            for i in self.player_data.index:\n                self.problem += (\n                    captain_var[i][w] &lt;= starting_xi_vars[i][w],\n                    f\"Captain_in_StartingXI_{i}_{w}\",\n                )\n\n            # --- Enforced Player Constraints---\n            for player_idx in self.enforced_player_indices:\n                self.problem += (\n                    player_vars[player_idx][w] == 1,\n                    f\"Enforce_Player_{self.player_data.loc[player_idx, 'name']}_GW{w}\",\n                )\n\n            for team, position in self.enforced_team_pos_requirements:\n                # Filter players for the current team and position\n                team_pos_players = self.player_data[\n                    (self.player_data[\"team\"] == team)\n                    &amp; (self.player_data[\"position\"] == position)\n                ].index\n                if not team_pos_players.empty:\n                    self.problem += (\n                        lpSum(player_vars[i][w] for i in team_pos_players) &gt;= 1,\n                        f\"Enforce_One_{position}_from_{team}_GW{w}\",\n                    )\n                else:\n                    print(\n                        f\"Warning: No players found for enforced requirement: at least one {position} from {team} for GW{gw_actual}.\"\n                    )\n\n        # --- Chip Usage Constraints (TOTAL usage over all gameweeks) ---\n        # These constraints should be outside the per-gameweek loop to avoid duplicates.\n        self.problem += (\n            lpSum(use_bench_boost[j] for j in range(num_gameweeks))\n            &lt;= chip_allowances.get(\"bench_boost\", 0),\n            f\"Max_Bench_Boost_Usage_Total\",\n        )\n        self.problem += (\n            lpSum(use_triple_captain[j] for j in range(num_gameweeks))\n            &lt;= chip_allowances.get(\"triple_captain\", 0),\n            f\"Max_Triple_Captain_Usage_Total\",\n        )\n\n        # --- Inter-Gameweek Constraints (Transfers and Transfer Rules) ---\n        # Initialize free transfers for GW0 (first gameweek of optimization horizon)\n        # This assumes the optimization starts at GW0, and it has INITIAL_FREE_TRANSFERS.\n        # If the model starts at an arbitrary GW, this would need to be an input.\n        self.problem += (\n            free_transfers_available[0] == INITIAL_FREE_TRANSFERS,\n            f\"Initial_Free_Transfers_GW0\",\n        )\n\n        for w in range(1, num_gameweeks):\n            # Calculate total transfers made in this gameweek\n            self.problem += (\n                transfers_made[w]\n                == lpSum(transfer_in_vars[i][w] for i in self.player_data.index),\n                f\"Transfers_Made_GW{w}\",\n            )\n            # Total transfers in must equal total transfers out for each gameweek after the first\n            self.problem += (\n                lpSum(transfer_in_vars[i][w] for i in self.player_data.index)\n                == lpSum(transfer_out_vars[i][w] for i in self.player_data.index),\n                f\"Transfers_In_Equals_Out_GW{w}\",\n            )\n\n            # Calculate free transfers available for the current gameweek (w)\n            # Free transfers for GW_w = min(free transfers from GW_w-1 - transfers made in GW_w + 1, MAX_FREE_TRANSFERS_SAVED + 1)\n            # The + 1 in MAX_FREE_TRANSFERS_SAVED + 1 is because MAX_FREE_TRANSFERS_SAVED implies how many can be *saved*,\n            # so if you save 1, you have 1 (current) + 1 (saved) = 2.\n            self.problem += (\n                free_transfers_available[w]\n                &lt;= free_transfers_available[w - 1] - transfers_made[w] + 1,\n                f\"Free_Transfers_Calc_1_GW{w}\",\n            )\n            self.problem += (\n                free_transfers_available[w] &lt;= MAX_FREE_TRANSFERS_SAVED + 1,\n                f\"Free_Transfers_Calc_2_GW{w}\",\n            )\n            self.problem += (\n                free_transfers_available[w] &gt;= 0,  # Cannot have negative free transfers\n                f\"Free_Transfers_Non_Negative_GW{w}\",\n            )\n\n            # Calculate transfer hits\n            # transfer_hits[w] = max(0, transfers_made[w] - free_transfers_available_at_start_of_gw_w)\n            # This needs to be linearized. If transfers_made[w] &gt; free_transfers_available[w-1], then hit.\n            # free_transfers_available[w-1] represents transfers available *before* making transfers for GW_w\n            self.problem += (\n                transfer_hits[w] &gt;= transfers_made[w] - free_transfers_available[w - 1],\n                f\"Transfer_Hits_Calc_1_GW{w}\",\n            )\n            self.problem += (\n                transfer_hits[w] &gt;= 0,\n                f\"Transfer_Hits_Calc_2_GW{w}\",\n            )\n\n            for i in self.player_data.index:\n                # Squad continuity: player_vars[i][w] (in squad at start of GW w)\n                #                 = player_vars[i][w-1] (in squad at start of GW w-1)\n                #                 - transfer_out_vars[i][w] (transferred out for GW w)\n                #                 + transfer_in_vars[i][w] (transferred in for GW w)\n                self.problem += (\n                    player_vars[i][w]\n                    == player_vars[i][w - 1]\n                    - transfer_out_vars[i][w]\n                    + transfer_in_vars[i][w],\n                    f\"Squad_Continuity_{i}_GW{w}\",\n                )\n                # A player cannot be transferred in and out in the same gameweek\n                self.problem += (\n                    transfer_in_vars[i][w] + transfer_out_vars[i][w] &lt;= 1,\n                    f\"No_Simultaneous_Transfer_{i}_{w}\",\n                )\n\n        try:\n            # The solver is called with the GLPK_CMD solver\n            self.problem.solve(PULP_CBC_CMD(msg=0))  # msg=0 suppresses verbose output\n        except Exception as e:\n            print(f\"Error solving the problem: {e}\")\n            return False\n\n        if LpStatus[self.problem.status] == \"Optimal\":\n            print(\"Optimization successful! Optimal solution found.\")\n\n            self.selected_squad_history = {}\n            self.total_transfer_hits = 0\n            for w in range(num_gameweeks):\n                # The actual gameweek number (1-indexed)\n                gw_actual = current_gameweek_number_start + w\n\n                # Get selected players for the current gameweek\n                selected_squad_gw = self.player_data[\n                    [player_vars[i][w].varValue == 1 for i in self.player_data.index]\n                ].copy()\n\n                # Get starter and captain info for this gameweek\n                is_starter_series_gw = pd.Series(\n                    [\n                        starting_xi_vars[i][w].varValue == 1\n                        for i in self.player_data.index\n                    ],\n                    index=self.player_data.index,\n                )\n                is_captain_series_gw = pd.Series(\n                    [captain_var[i][w].varValue == 1 for i in self.player_data.index],\n                    index=self.player_data.index,\n                )\n\n                selected_squad_gw[\"is_starter\"] = is_starter_series_gw.loc[\n                    selected_squad_gw.index\n                ]\n                selected_squad_gw[\"is_captain\"] = is_captain_series_gw.loc[\n                    selected_squad_gw.index\n                ]\n\n                transfers_in_gw = 0\n                transfers_out_gw = 0\n                hits_gw = 0\n\n                # Store transfer details for gameweeks &gt; 0\n                if (\n                    w &gt; 0\n                ):  # Check for transfers only from GW1 onwards (index 1 in 0-indexed loop)\n                    transfer_in_flags = pd.Series(\n                        [\n                            transfer_in_vars[i][w].varValue == 1\n                            for i in self.player_data.index\n                        ],\n                        index=self.player_data.index,\n                    )\n                    transfer_out_flags = pd.Series(\n                        [\n                            transfer_out_vars[i][w].varValue == 1\n                            for i in self.player_data.index\n                        ],\n                        index=self.player_data.index,\n                    )\n\n                    selected_squad_gw[\"transfer_in\"] = transfer_in_flags.loc[\n                        selected_squad_gw.index\n                    ]\n                    selected_squad_gw[\"transfer_out\"] = transfer_out_flags.loc[\n                        selected_squad_gw.index\n                    ]\n\n                    transfers_in_gw = int(round(transfer_in_flags.sum()))\n                    transfers_out_gw = int(round(transfer_out_flags.sum()))\n                    hits_gw = int(round(transfer_hits[w].varValue))\n                    self.total_transfer_hits += hits_gw\n                else:\n                    selected_squad_gw[\"transfer_in\"] = False  # No transfers in for GW0\n                    selected_squad_gw[\"transfer_out\"] = (\n                        False  # No transfers out for GW0\n                    )\n\n                self.selected_squad_history[f\"GW{gw_actual}\"] = {\n                    \"squad\": selected_squad_gw,\n                    \"total_cost\": selected_squad_gw[\"cost\"].sum(),\n                    \"expected_points_from_xi\": sum(\n                        self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n                        * starting_xi_vars[i][w].varValue\n                        for i in self.player_data.index\n                    ),\n                    \"bench_boost_used\": bool(use_bench_boost[w].varValue),\n                    \"triple_captain_used\": bool(use_triple_captain[w].varValue),\n                    \"total_bench_boost_points\": value(\n                        lpSum(\n                            actual_bench_boost_points[i][w]\n                            for i in self.player_data.index\n                        )\n                    ),\n                    \"total_triple_captain_bonus\": value(\n                        lpSum(\n                            actual_triple_captain_bonus[i][w]\n                            for i in self.player_data.index\n                        )\n                    ),\n                    \"transfers_in_count\": transfers_in_gw,\n                    \"transfers_out_count\": transfers_out_gw,\n                    \"transfer_hits\": hits_gw,  # New\n                    \"free_transfers_available_next_gw\": (\n                        int(round(free_transfers_available[w].varValue))\n                        if w &lt; num_gameweeks - 1\n                        else 0\n                    ),  # Free transfers available *after* this GW's transfers are made\n                }\n\n            # Overall totals\n            self.total_cost = self.selected_squad_history[\n                f\"GW{current_gameweek_number_start + num_gameweeks - 1}\"\n            ][\n                \"total_cost\"\n            ]  # Cost of final squad\n            self.total_expected_points = value(\n                self.problem.objective\n            )  # Total objective value from solver\n            self.used_chips = {\n                f\"GW{current_gameweek_number_start + w}\": {\n                    \"bench_boost\": bool(use_bench_boost[w].varValue),\n                    \"triple_captain\": bool(use_triple_captain[w].varValue),\n                }\n                for w in range(num_gameweeks)\n            }\n\n            return True\n        else:\n            print(f\"No optimal solution found. Status: {LpStatus[self.problem.status]}\")\n            self.selected_squad_history = {}\n            self.total_cost = 0\n            self.total_expected_points = 0\n            self.used_chips = {}\n            self.total_transfer_hits = 0\n            return False\n\n    def get_selected_squad(self, gameweek: int = None) -&gt; pd.DataFrame | None:\n        \"\"\"\n        Returns the selected squad for a specific gameweek (1-indexed).\n        If no gameweek is specified, returns the squad for the last optimized gameweek.\n        \"\"\"\n        if not self.selected_squad_history:\n            return None\n\n        # Get the first GW key to determine the range of available GWs\n        first_gw_in_history = min(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n        last_gw_in_history = max(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n\n        if gameweek is None:\n            return self.selected_squad_history[f\"GW{last_gw_in_history}\"][\"squad\"]\n\n        if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n            print(\n                f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n            )\n            return None\n\n        return self.selected_squad_history.get(f\"GW{gameweek}\", {}).get(\"squad\")\n\n    def get_total_cost(self, gameweek: int = None) -&gt; float:\n        \"\"\"\n        Returns the total cost for a specific gameweek (1-indexed).\n        If no gameweek is specified, returns the cost of the squad in the last optimized gameweek.\n        \"\"\"\n        if not self.selected_squad_history:\n            return 0\n        first_gw_in_history = min(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n        last_gw_in_history = max(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n\n        if gameweek is None:\n            return self.selected_squad_history[f\"GW{last_gw_in_history}\"][\"total_cost\"]\n\n        if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n            print(\n                f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n            )\n            return 0  # Or raise an error\n\n        return self.selected_squad_history.get(f\"GW{gameweek}\", {}).get(\"total_cost\", 0)\n\n    def get_total_expected_points(self) -&gt; float:\n        \"\"\"\n        Returns the overall total expected points across all optimized gameweeks.\n        \"\"\"\n        return self.total_expected_points\n\n    def get_gameweek_summary(self, gameweek: int):\n        \"\"\"\n        Returns a dictionary summary for a specific gameweek.\n        \"\"\"\n        if not self.selected_squad_history:\n            return None\n        first_gw_in_history = min(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n        last_gw_in_history = max(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n\n        if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n            print(\n                f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n            )\n            return None\n\n        return self.selected_squad_history.get(f\"GW{gameweek}\")\n\n    def print_squad_summary(self, gameweek: int):\n        \"\"\"\n        Prints a formatted summary of the selected squad for a specific gameweek.\n        \"\"\"\n        if not self.selected_squad_history:\n            print(\"No squad has been selected yet. Run the 'solve' method first.\")\n            return\n\n        gw_data = self.get_gameweek_summary(gameweek)\n        if not gw_data:\n            return  # get_gameweek_summary already prints error message\n\n        selected_squad = gw_data[\"squad\"]\n        total_cost = gw_data[\"total_cost\"]\n        expected_points_from_xi = gw_data[\"expected_points_from_xi\"]\n        bench_boost_used = gw_data[\"bench_boost_used\"]\n        triple_captain_used = gw_data[\"triple_captain_used\"]\n        total_bench_boost_points = gw_data[\"total_bench_boost_points\"]\n        total_triple_captain_bonus = gw_data[\"total_triple_captain_bonus\"]\n        transfers_in_count = gw_data[\"transfers_in_count\"]  # New\n        transfers_out_count = gw_data[\"transfers_out_count\"]  # New\n        transfer_hits_taken = gw_data[\"transfer_hits\"]  # New\n        free_transfers_available_next_gw = gw_data[\n            \"free_transfers_available_next_gw\"\n        ]  # New\n\n        print(f\"\\n--- FPL Optimized Squad for Gameweek {gameweek} ---\")\n        print(f\"Squad Cost: \u00a3{total_cost:.1f}m\")\n        print(f\"Expected Points (Starting XI): {expected_points_from_xi:.2f}\")\n        print(\n            f\"Total Expected Points for GW{gameweek} (including chips): {expected_points_from_xi + total_bench_boost_points + total_triple_captain_bonus:.2f}\"\n        )\n        print(\"\\n--- Chips Used This Gameweek ---\")\n        if bench_boost_used:\n            print(f\"- Bench Boost (Added {total_bench_boost_points:.2f} points)\")\n        if triple_captain_used:\n            print(\n                f\"- Triple Captain (Added {total_triple_captain_bonus:.2f} bonus points)\"\n            )\n        if not (bench_boost_used or triple_captain_used):\n            print(\"No chips used this gameweek.\")\n\n        print(\"\\n--- Goalkeepers (Starting XI marked with *) ---\")\n        for index, row in selected_squad[selected_squad[\"position\"] == \"GK\"].iterrows():\n            starter_str = \"*\" if row[\"is_starter\"] else \"\"\n            captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n            transfer_status = \"\"\n            if row[\"transfer_in\"]:\n                transfer_status = \"(IN)\"\n            elif row[\"transfer_out\"]:\n                transfer_status = \"(OUT)\"\n\n            # Access gameweek-specific xP correctly\n            player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n            print(\n                f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n            )\n        print(\"\\n--- Defenders (Starting XI marked with *) ---\")\n        for index, row in selected_squad[\n            selected_squad[\"position\"] == \"DEF\"\n        ].iterrows():\n            starter_str = \"*\" if row[\"is_starter\"] else \"\"\n            captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n            transfer_status = \"\"\n            if row[\"transfer_in\"]:\n                transfer_status = \"(IN)\"\n            elif row[\"transfer_out\"]:\n                transfer_status = \"(OUT)\"\n\n            player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n            print(\n                f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n            )\n        print(\"\\n--- Midfielders (Starting XI marked with *) ---\")\n        for index, row in selected_squad[\n            selected_squad[\"position\"] == \"MID\"\n        ].iterrows():\n            starter_str = \"*\" if row[\"is_starter\"] else \"\"\n            captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n            transfer_status = \"\"\n            if row[\"transfer_in\"]:\n                transfer_status = \"(IN)\"\n            elif row[\"transfer_out\"]:\n                transfer_status = \"(OUT)\"\n\n            player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n            print(\n                f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n            )\n        print(\"\\n--- Forwards (Starting XI marked with *) ---\")\n        for index, row in selected_squad[\n            selected_squad[\"position\"] == \"FWD\"\n        ].iterrows():\n            starter_str = \"*\" if row[\"is_starter\"] else \"\"\n            captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n            transfer_status = \"\"\n            if row[\"transfer_in\"]:\n                transfer_status = \"(IN)\"\n            elif row[\"transfer_out\"]:\n                transfer_status = \"(OUT)\"\n\n            player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n            print(\n                f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n            )\n\n        print(f\"\\n--- Team Breakdown for GW{gameweek} ---\")\n        print(selected_squad[\"team\"].value_counts())\n\n        # Transfers are relevant from Gameweek 2 (index 1) onwards in the optimization horizon\n        # For display, if the current GW is the initial one (GW1 in the current context), no transfers are made\n        # If it's a subsequent GW, check if transfers occurred.\n        first_gw_in_history = min(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        )\n        if (\n            gameweek &gt;= first_gw_in_history\n        ):  # Changed from &gt; to &gt;=, to show initial free transfers\n            # Display transfer info for this gameweek\n            print(\n                f\"  Transfers In: {transfers_in_count}, Transfers Out: {transfers_out_count}\"\n            )\n            print(\n                f\"  Transfer Hits: {transfer_hits_taken} (-{transfer_hits_taken * POINTS_PER_HIT} points)\"\n            )\n            # Only show free transfers for the *next* gameweek if it's not the last gameweek in the horizon\n            if gameweek &lt; max(\n                int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n            ):\n                print(\n                    f\"  Free Transfers Available for Next GW: {free_transfers_available_next_gw}\"\n                )\n        print(\"---------------------------\\n\")\n\n    def print_overall_summary(self):\n        \"\"\"\n        Prints an overall summary of the multi-week optimization results.\n        \"\"\"\n        if not self.selected_squad_history:\n            print(\"No optimization results to summarize.\")\n            return\n\n        print(\"\\n=== Overall Multi-Week FPL Optimization Summary ===\")\n        print(\n            f\"Total Expected Points Across All Gameweeks: {self.total_expected_points:.2f}\"\n        )\n\n        # Get the latest gameweek's cost\n        last_gw_key = max(\n            self.selected_squad_history.keys(), key=lambda k: int(k.replace(\"GW\", \"\"))\n        )\n        print(\n            f\"Squad Cost ({last_gw_key}): \u00a3{self.selected_squad_history[last_gw_key]['total_cost']:.1f}m\"\n        )\n        print(\n            f\"Total Transfer Hits Taken: {self.total_transfer_hits} (-{self.total_transfer_hits * POINTS_PER_HIT} points)\"\n        )\n\n        print(\"\\n--- Chip Usage Across Gameweeks ---\")\n        # Ensure consistent order by sorting gameweek keys\n        sorted_gw_keys = sorted(\n            self.used_chips.keys(), key=lambda k: int(k.replace(\"GW\", \"\"))\n        )\n        for gw_str in sorted_gw_keys:\n            chips = self.used_chips[gw_str]\n            chip_summary = []\n            if chips[\"bench_boost\"]:\n                chip_summary.append(\"Bench Boost\")\n            if chips[\"triple_captain\"]:\n                chip_summary.append(\"Triple Captain\")\n\n            if chip_summary:\n                print(f\"{gw_str}: {', '.join(chip_summary)}\")\n            else:\n                print(f\"{gw_str}: No chips used\")\n\n        print(\"\\n--- Gameweek-by-Gameweek Summary ---\")\n        # Iterate and print basic summary for each gameweek\n        for gw_str in sorted_gw_keys:\n            gw_data = self.selected_squad_history[gw_str]\n            print(f\"\\n--- {gw_str} ---\")\n            print(f\"  Squad Cost: \u00a3{gw_data['total_cost']:.1f}m\")\n            print(\n                f\"  Expected Points (Starting XI): {gw_data['expected_points_from_xi']:.2f}\"\n            )\n            print(\n                f\"  Total GW Points (incl. chips): {gw_data['expected_points_from_xi'] + gw_data['total_bench_boost_points'] + gw_data['total_triple_captain_bonus']:.2f}\"\n            )\n\n            # Display transfer info for this gameweek\n            transfers_in_count = gw_data[\"transfers_in_count\"]\n            transfers_out_count = gw_data[\"transfers_out_count\"]\n            transfer_hits_taken = gw_data[\"transfer_hits\"]\n            free_transfers_available_next_gw = gw_data[\n                \"free_transfers_available_next_gw\"\n            ]\n\n            print(\n                f\"  Transfers In: {transfers_in_count}, Transfers Out: {transfers_out_count}\"\n            )\n            print(\n                f\"  Transfer Hits: {transfer_hits_taken} (-{transfer_hits_taken * POINTS_PER_HIT} points)\"\n            )\n            # Only show free transfers for the *next* gameweek if it's not the last gameweek in the horizon\n            if int(gw_str.replace(\"GW\", \"\")) &lt; max(\n                int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n            ):\n                print(\n                    f\"  Free Transfers Available for Next GW: {free_transfers_available_next_gw}\"\n                )\n            print(\"-----------------------------------\")\n</code></pre>"},{"location":"autoapi/fpl_solver/fpl_solver/#fpl_solver.fpl_solver.FPLOptimizer.__init__","title":"<code>__init__(player_data)</code>","text":"<p>Initializes the FPLOptimizer with player data.</p> <p>Parameters:</p> Name Type Description Default <code>player_data</code> <code>DataFrame</code> <p>A DataFrame containing player information                         with columns: 'name', 'team', 'position',                         'cost', 'expected_points_by_gw' (a dict of xP per GW).</p> required Source code in <code>fpl_solver/fpl_solver.py</code> <pre><code>def __init__(self, player_data: pd.DataFrame):\n    \"\"\"\n    Initializes the FPLOptimizer with player data.\n\n    Args:\n        player_data (pd.DataFrame): A DataFrame containing player information\n                                    with columns: 'name', 'team', 'position',\n                                    'cost', 'expected_points_by_gw' (a dict of xP per GW).\n    \"\"\"\n    required_columns = [\"name\", \"team\", \"position\", \"cost\", \"expected_points_by_gw\"]\n    if not all(col in player_data.columns for col in required_columns):\n        missing_cols = [\n            col for col in required_columns if col not in player_data.columns\n        ]\n        raise ValueError(\n            f\"player_data DataFrame must contain {required_columns} columns. Missing: {missing_cols}\"\n        )\n\n    self.player_data = player_data\n    self.problem = None\n    self.selected_squad_history = {}  # To store squad for each gameweek\n    self.total_cost = 0\n    self.total_expected_points = 0\n    self.total_transfer_hits = 0\n\n    # --- Process Enforced Players ---\n    self.enforced_player_indices = set()\n    self.enforced_team_pos_requirements = []\n\n    print(\"\\n--- Processing Enforced Players ---\")\n\n    # Enforce by Player ID\n    for player_id in ENFORCED_PLAYERS_BY_ID:\n        found_player = self.player_data[self.player_data[\"id\"] == player_id]\n        if not found_player.empty:\n            player_idx = found_player.index[0]\n            self.enforced_player_indices.add(player_idx)\n            print(\n                f\"Enforcing player by ID: {found_player.loc[player_idx, 'name']} (ID: {player_id})\"\n            )\n        else:\n            print(\n                f\"Warning: Enforced player with ID {player_id} not found in data.\"\n            )\n\n    # Enforce by Player Name\n    for player_name in ENFORCED_PLAYERS_BY_NAME:\n        found_player = self.player_data[self.player_data[\"name\"] == player_name]\n        if not found_player.empty:\n            player_idx = found_player.index[0]\n            self.enforced_player_indices.add(player_idx)\n            print(f\"Enforcing player by name: {player_name}\")\n        else:\n            print(f\"Warning: Enforced player '{player_name}' not found in data.\")\n\n    # Enforce by Team and Position\n    for requirement in ENFORCED_PLAYERS_BY_TEAM_AND_POSITION:\n        team = requirement.get(\"team\")\n        position = requirement.get(\"position\")\n        if team and position:\n            # Validate team and position exist in data\n            if team not in self.player_data[\"team\"].unique():\n                print(\n                    f\"Warning: Enforced team '{team}' for position '{position}' not found in data.\"\n                )\n                continue\n            if position not in self.player_data[\"position\"].unique():\n                print(\n                    f\"Warning: Enforced position '{position}' for team '{team}' not found in data.\"\n                )\n                continue\n\n            self.enforced_team_pos_requirements.append((team, position))\n            print(f\"Enforcing at least one {position} from {team}.\")\n        else:\n            print(\n                f\"Warning: Invalid enforced team/position requirement: {requirement}\"\n            )\n\n    if not (\n        self.enforced_player_indices\n        or self.enforced_team_pos_requirements\n        or ENFORCED_PLAYERS_BY_ID\n        or ENFORCED_PLAYERS_BY_NAME\n        or ENFORCED_PLAYERS_BY_TEAM_AND_POSITION\n    ):\n        print(\"No players or team/position combinations are enforced.\")\n    print(\"-----------------------------------\\n\")\n</code></pre>"},{"location":"autoapi/fpl_solver/fpl_solver/#fpl_solver.fpl_solver.FPLOptimizer.get_gameweek_summary","title":"<code>get_gameweek_summary(gameweek)</code>","text":"<p>Returns a dictionary summary for a specific gameweek.</p> Source code in <code>fpl_solver/fpl_solver.py</code> <pre><code>def get_gameweek_summary(self, gameweek: int):\n    \"\"\"\n    Returns a dictionary summary for a specific gameweek.\n    \"\"\"\n    if not self.selected_squad_history:\n        return None\n    first_gw_in_history = min(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n    last_gw_in_history = max(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n\n    if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n        print(\n            f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n        )\n        return None\n\n    return self.selected_squad_history.get(f\"GW{gameweek}\")\n</code></pre>"},{"location":"autoapi/fpl_solver/fpl_solver/#fpl_solver.fpl_solver.FPLOptimizer.get_selected_squad","title":"<code>get_selected_squad(gameweek=None)</code>","text":"<p>Returns the selected squad for a specific gameweek (1-indexed). If no gameweek is specified, returns the squad for the last optimized gameweek.</p> Source code in <code>fpl_solver/fpl_solver.py</code> <pre><code>def get_selected_squad(self, gameweek: int = None) -&gt; pd.DataFrame | None:\n    \"\"\"\n    Returns the selected squad for a specific gameweek (1-indexed).\n    If no gameweek is specified, returns the squad for the last optimized gameweek.\n    \"\"\"\n    if not self.selected_squad_history:\n        return None\n\n    # Get the first GW key to determine the range of available GWs\n    first_gw_in_history = min(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n    last_gw_in_history = max(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n\n    if gameweek is None:\n        return self.selected_squad_history[f\"GW{last_gw_in_history}\"][\"squad\"]\n\n    if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n        print(\n            f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n        )\n        return None\n\n    return self.selected_squad_history.get(f\"GW{gameweek}\", {}).get(\"squad\")\n</code></pre>"},{"location":"autoapi/fpl_solver/fpl_solver/#fpl_solver.fpl_solver.FPLOptimizer.get_total_cost","title":"<code>get_total_cost(gameweek=None)</code>","text":"<p>Returns the total cost for a specific gameweek (1-indexed). If no gameweek is specified, returns the cost of the squad in the last optimized gameweek.</p> Source code in <code>fpl_solver/fpl_solver.py</code> <pre><code>def get_total_cost(self, gameweek: int = None) -&gt; float:\n    \"\"\"\n    Returns the total cost for a specific gameweek (1-indexed).\n    If no gameweek is specified, returns the cost of the squad in the last optimized gameweek.\n    \"\"\"\n    if not self.selected_squad_history:\n        return 0\n    first_gw_in_history = min(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n    last_gw_in_history = max(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n\n    if gameweek is None:\n        return self.selected_squad_history[f\"GW{last_gw_in_history}\"][\"total_cost\"]\n\n    if gameweek &lt; first_gw_in_history or gameweek &gt; last_gw_in_history:\n        print(\n            f\"Gameweek {gameweek} is outside the optimized range (GW{first_gw_in_history}-GW{last_gw_in_history}).\"\n        )\n        return 0  # Or raise an error\n\n    return self.selected_squad_history.get(f\"GW{gameweek}\", {}).get(\"total_cost\", 0)\n</code></pre>"},{"location":"autoapi/fpl_solver/fpl_solver/#fpl_solver.fpl_solver.FPLOptimizer.get_total_expected_points","title":"<code>get_total_expected_points()</code>","text":"<p>Returns the overall total expected points across all optimized gameweeks.</p> Source code in <code>fpl_solver/fpl_solver.py</code> <pre><code>def get_total_expected_points(self) -&gt; float:\n    \"\"\"\n    Returns the overall total expected points across all optimized gameweeks.\n    \"\"\"\n    return self.total_expected_points\n</code></pre>"},{"location":"autoapi/fpl_solver/fpl_solver/#fpl_solver.fpl_solver.FPLOptimizer.print_overall_summary","title":"<code>print_overall_summary()</code>","text":"<p>Prints an overall summary of the multi-week optimization results.</p> Source code in <code>fpl_solver/fpl_solver.py</code> <pre><code>def print_overall_summary(self):\n    \"\"\"\n    Prints an overall summary of the multi-week optimization results.\n    \"\"\"\n    if not self.selected_squad_history:\n        print(\"No optimization results to summarize.\")\n        return\n\n    print(\"\\n=== Overall Multi-Week FPL Optimization Summary ===\")\n    print(\n        f\"Total Expected Points Across All Gameweeks: {self.total_expected_points:.2f}\"\n    )\n\n    # Get the latest gameweek's cost\n    last_gw_key = max(\n        self.selected_squad_history.keys(), key=lambda k: int(k.replace(\"GW\", \"\"))\n    )\n    print(\n        f\"Squad Cost ({last_gw_key}): \u00a3{self.selected_squad_history[last_gw_key]['total_cost']:.1f}m\"\n    )\n    print(\n        f\"Total Transfer Hits Taken: {self.total_transfer_hits} (-{self.total_transfer_hits * POINTS_PER_HIT} points)\"\n    )\n\n    print(\"\\n--- Chip Usage Across Gameweeks ---\")\n    # Ensure consistent order by sorting gameweek keys\n    sorted_gw_keys = sorted(\n        self.used_chips.keys(), key=lambda k: int(k.replace(\"GW\", \"\"))\n    )\n    for gw_str in sorted_gw_keys:\n        chips = self.used_chips[gw_str]\n        chip_summary = []\n        if chips[\"bench_boost\"]:\n            chip_summary.append(\"Bench Boost\")\n        if chips[\"triple_captain\"]:\n            chip_summary.append(\"Triple Captain\")\n\n        if chip_summary:\n            print(f\"{gw_str}: {', '.join(chip_summary)}\")\n        else:\n            print(f\"{gw_str}: No chips used\")\n\n    print(\"\\n--- Gameweek-by-Gameweek Summary ---\")\n    # Iterate and print basic summary for each gameweek\n    for gw_str in sorted_gw_keys:\n        gw_data = self.selected_squad_history[gw_str]\n        print(f\"\\n--- {gw_str} ---\")\n        print(f\"  Squad Cost: \u00a3{gw_data['total_cost']:.1f}m\")\n        print(\n            f\"  Expected Points (Starting XI): {gw_data['expected_points_from_xi']:.2f}\"\n        )\n        print(\n            f\"  Total GW Points (incl. chips): {gw_data['expected_points_from_xi'] + gw_data['total_bench_boost_points'] + gw_data['total_triple_captain_bonus']:.2f}\"\n        )\n\n        # Display transfer info for this gameweek\n        transfers_in_count = gw_data[\"transfers_in_count\"]\n        transfers_out_count = gw_data[\"transfers_out_count\"]\n        transfer_hits_taken = gw_data[\"transfer_hits\"]\n        free_transfers_available_next_gw = gw_data[\n            \"free_transfers_available_next_gw\"\n        ]\n\n        print(\n            f\"  Transfers In: {transfers_in_count}, Transfers Out: {transfers_out_count}\"\n        )\n        print(\n            f\"  Transfer Hits: {transfer_hits_taken} (-{transfer_hits_taken * POINTS_PER_HIT} points)\"\n        )\n        # Only show free transfers for the *next* gameweek if it's not the last gameweek in the horizon\n        if int(gw_str.replace(\"GW\", \"\")) &lt; max(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        ):\n            print(\n                f\"  Free Transfers Available for Next GW: {free_transfers_available_next_gw}\"\n            )\n        print(\"-----------------------------------\")\n</code></pre>"},{"location":"autoapi/fpl_solver/fpl_solver/#fpl_solver.fpl_solver.FPLOptimizer.print_squad_summary","title":"<code>print_squad_summary(gameweek)</code>","text":"<p>Prints a formatted summary of the selected squad for a specific gameweek.</p> Source code in <code>fpl_solver/fpl_solver.py</code> <pre><code>def print_squad_summary(self, gameweek: int):\n    \"\"\"\n    Prints a formatted summary of the selected squad for a specific gameweek.\n    \"\"\"\n    if not self.selected_squad_history:\n        print(\"No squad has been selected yet. Run the 'solve' method first.\")\n        return\n\n    gw_data = self.get_gameweek_summary(gameweek)\n    if not gw_data:\n        return  # get_gameweek_summary already prints error message\n\n    selected_squad = gw_data[\"squad\"]\n    total_cost = gw_data[\"total_cost\"]\n    expected_points_from_xi = gw_data[\"expected_points_from_xi\"]\n    bench_boost_used = gw_data[\"bench_boost_used\"]\n    triple_captain_used = gw_data[\"triple_captain_used\"]\n    total_bench_boost_points = gw_data[\"total_bench_boost_points\"]\n    total_triple_captain_bonus = gw_data[\"total_triple_captain_bonus\"]\n    transfers_in_count = gw_data[\"transfers_in_count\"]  # New\n    transfers_out_count = gw_data[\"transfers_out_count\"]  # New\n    transfer_hits_taken = gw_data[\"transfer_hits\"]  # New\n    free_transfers_available_next_gw = gw_data[\n        \"free_transfers_available_next_gw\"\n    ]  # New\n\n    print(f\"\\n--- FPL Optimized Squad for Gameweek {gameweek} ---\")\n    print(f\"Squad Cost: \u00a3{total_cost:.1f}m\")\n    print(f\"Expected Points (Starting XI): {expected_points_from_xi:.2f}\")\n    print(\n        f\"Total Expected Points for GW{gameweek} (including chips): {expected_points_from_xi + total_bench_boost_points + total_triple_captain_bonus:.2f}\"\n    )\n    print(\"\\n--- Chips Used This Gameweek ---\")\n    if bench_boost_used:\n        print(f\"- Bench Boost (Added {total_bench_boost_points:.2f} points)\")\n    if triple_captain_used:\n        print(\n            f\"- Triple Captain (Added {total_triple_captain_bonus:.2f} bonus points)\"\n        )\n    if not (bench_boost_used or triple_captain_used):\n        print(\"No chips used this gameweek.\")\n\n    print(\"\\n--- Goalkeepers (Starting XI marked with *) ---\")\n    for index, row in selected_squad[selected_squad[\"position\"] == \"GK\"].iterrows():\n        starter_str = \"*\" if row[\"is_starter\"] else \"\"\n        captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n        transfer_status = \"\"\n        if row[\"transfer_in\"]:\n            transfer_status = \"(IN)\"\n        elif row[\"transfer_out\"]:\n            transfer_status = \"(OUT)\"\n\n        # Access gameweek-specific xP correctly\n        player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n        print(\n            f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n        )\n    print(\"\\n--- Defenders (Starting XI marked with *) ---\")\n    for index, row in selected_squad[\n        selected_squad[\"position\"] == \"DEF\"\n    ].iterrows():\n        starter_str = \"*\" if row[\"is_starter\"] else \"\"\n        captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n        transfer_status = \"\"\n        if row[\"transfer_in\"]:\n            transfer_status = \"(IN)\"\n        elif row[\"transfer_out\"]:\n            transfer_status = \"(OUT)\"\n\n        player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n        print(\n            f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n        )\n    print(\"\\n--- Midfielders (Starting XI marked with *) ---\")\n    for index, row in selected_squad[\n        selected_squad[\"position\"] == \"MID\"\n    ].iterrows():\n        starter_str = \"*\" if row[\"is_starter\"] else \"\"\n        captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n        transfer_status = \"\"\n        if row[\"transfer_in\"]:\n            transfer_status = \"(IN)\"\n        elif row[\"transfer_out\"]:\n            transfer_status = \"(OUT)\"\n\n        player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n        print(\n            f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n        )\n    print(\"\\n--- Forwards (Starting XI marked with *) ---\")\n    for index, row in selected_squad[\n        selected_squad[\"position\"] == \"FWD\"\n    ].iterrows():\n        starter_str = \"*\" if row[\"is_starter\"] else \"\"\n        captain_str = \"(C)\" if row[\"is_captain\"] else \"\"\n        transfer_status = \"\"\n        if row[\"transfer_in\"]:\n            transfer_status = \"(IN)\"\n        elif row[\"transfer_out\"]:\n            transfer_status = \"(OUT)\"\n\n        player_gw_xp = row[\"expected_points_by_gw\"].get(gameweek, 0.0)\n        print(\n            f\"{starter_str} {row['name']} {captain_str} {transfer_status} ({row['team']}): \u00a3{row['cost']:.1f}m, {player_gw_xp} xP\"\n        )\n\n    print(f\"\\n--- Team Breakdown for GW{gameweek} ---\")\n    print(selected_squad[\"team\"].value_counts())\n\n    # Transfers are relevant from Gameweek 2 (index 1) onwards in the optimization horizon\n    # For display, if the current GW is the initial one (GW1 in the current context), no transfers are made\n    # If it's a subsequent GW, check if transfers occurred.\n    first_gw_in_history = min(\n        int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n    )\n    if (\n        gameweek &gt;= first_gw_in_history\n    ):  # Changed from &gt; to &gt;=, to show initial free transfers\n        # Display transfer info for this gameweek\n        print(\n            f\"  Transfers In: {transfers_in_count}, Transfers Out: {transfers_out_count}\"\n        )\n        print(\n            f\"  Transfer Hits: {transfer_hits_taken} (-{transfer_hits_taken * POINTS_PER_HIT} points)\"\n        )\n        # Only show free transfers for the *next* gameweek if it's not the last gameweek in the horizon\n        if gameweek &lt; max(\n            int(k.replace(\"GW\", \"\")) for k in self.selected_squad_history.keys()\n        ):\n            print(\n                f\"  Free Transfers Available for Next GW: {free_transfers_available_next_gw}\"\n            )\n    print(\"---------------------------\\n\")\n</code></pre>"},{"location":"autoapi/fpl_solver/fpl_solver/#fpl_solver.fpl_solver.FPLOptimizer.solve","title":"<code>solve(budget, max_players_per_team, chip_allowances, num_gameweeks)</code>","text":"<p>Solves the FPL optimization problem using PuLP.</p> <p>Parameters:</p> Name Type Description Default <code>budget</code> <code>float</code> <p>The maximum budget in millions of pounds.</p> required <code>max_players_per_team</code> <code>int</code> <p>The maximum number of players allowed from                         any single Premier League team.</p> required <code>chip_allowances</code> <code>dict</code> <p>A dictionary specifying the maximum usage for each chip.</p> required <code>num_gameweeks</code> <code>int</code> <p>The number of gameweeks to optimize over.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if a solution was found, False otherwise.</p> Source code in <code>fpl_solver/fpl_solver.py</code> <pre><code>def solve(\n    self,\n    budget: float,\n    max_players_per_team: int,\n    chip_allowances: dict,\n    num_gameweeks: int,\n) -&gt; bool:\n    \"\"\"\n    Solves the FPL optimization problem using PuLP.\n\n    Args:\n        budget (float): The maximum budget in millions of pounds.\n        max_players_per_team (int): The maximum number of players allowed from\n                                    any single Premier League team.\n        chip_allowances (dict): A dictionary specifying the maximum usage for each chip.\n        num_gameweeks (int): The number of gameweeks to optimize over.\n\n    Returns:\n        bool: True if a solution was found, False otherwise.\n    \"\"\"\n    self.problem = LpProblem(\"FPL Squad Multi-Week Optimization\", LpMaximize)\n\n    # Decision variables for player selection, indexed by player and gameweek\n    player_vars = LpVariable.dicts(\n        \"Player\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n    )\n    starting_xi_vars = LpVariable.dicts(\n        \"StartingXI\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n    )\n    captain_var = LpVariable.dicts(\n        \"Captain\", (self.player_data.index, range(num_gameweeks)), 0, 1, LpBinary\n    )\n\n    # Binary variables for chip usage, indexed by gameweek\n    use_bench_boost = LpVariable.dicts(\n        \"Use_Bench_Boost\", range(num_gameweeks), 0, 1, LpBinary\n    )\n    use_triple_captain = LpVariable.dicts(\n        \"Use_Triple_Captain\", range(num_gameweeks), 0, 1, LpBinary\n    )\n\n    # Transfer variables\n    transfer_in_vars = LpVariable.dicts(\n        \"Transfer_In\",\n        (self.player_data.index, range(1, num_gameweeks)),\n        0,\n        1,\n        LpBinary,\n    )\n    transfer_out_vars = LpVariable.dicts(\n        \"Transfer_Out\",\n        (self.player_data.index, range(1, num_gameweeks)),\n        0,\n        1,\n        LpBinary,\n    )\n\n    # Total transfers made in a gameweek (absolute count)\n    transfers_made = LpVariable.dicts(\n        \"Transfers_Made\", range(1, num_gameweeks), 0, None, LpInteger\n    )\n    # Free transfers available at the start of a gameweek\n    free_transfers_available = LpVariable.dicts(\n        \"Free_Transfers_Available\",\n        range(num_gameweeks),\n        0,\n        MAX_FREE_TRANSFERS_SAVED + 1,\n        LpInteger,\n    )\n    # Number of transfer hits taken in a gameweek\n    transfer_hits = LpVariable.dicts(\n        \"Transfer_Hits\", range(1, num_gameweeks), 0, None, LpInteger\n    )\n\n    # Auxiliary variables for linearizing chip effects\n    is_bench_player = LpVariable.dicts(\n        \"Is_Bench_Player\",\n        (self.player_data.index, range(num_gameweeks)),\n        0,\n        1,\n        LpBinary,\n    )\n    actual_bench_boost_points = LpVariable.dicts(\n        \"Actual_Bench_Boost_Points\",\n        (self.player_data.index, range(num_gameweeks)),\n        0,\n        None,\n        LpContinuous,\n    )\n    actual_triple_captain_bonus = LpVariable.dicts(\n        \"Actual_Triple_Captain_Bonus\",\n        (self.player_data.index, range(num_gameweeks)),\n        0,\n        None,\n        LpContinuous,\n    )\n\n    # --- Objective Function ---\n    total_objective_points = []\n\n    # Get the first gameweek number from the player data to correctly index expected_points_by_gw\n    first_gw_key = next(\n        iter(\n            self.player_data.loc[\n                self.player_data.index[0], \"expected_points_by_gw\"\n            ].keys()\n        )\n    )\n    current_gameweek_number_start = int(first_gw_key)\n\n    for w in range(num_gameweeks):\n        # The actual gameweek number (1-indexed)\n        gw_actual = current_gameweek_number_start + w\n\n        # Base expected points from the selected starting 11 for this gameweek\n        base_points_expression_gw = lpSum(\n            self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n            * starting_xi_vars[i][w]\n            for i in self.player_data.index\n        )\n        total_objective_points.append(base_points_expression_gw)\n\n        # Regular Captaincy points (additional 1x for captain)\n        captain_points_bonus_gw = lpSum(\n            self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n            * captain_var[i][w]\n            for i in self.player_data.index\n        )\n        total_objective_points.append(captain_points_bonus_gw)\n\n        # Define auxiliary variables and constraints for chips for each gameweek\n        for i in self.player_data.index:\n            # Use gameweek-specific player xP for chip calculations\n            player_xp = self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n\n            # Bench Boost auxiliary variables and constraints\n            self.problem += (\n                is_bench_player[i][w] &lt;= player_vars[i][w],\n                f\"IsBench_Squad_{i}_{w}\",\n            )\n            self.problem += (\n                is_bench_player[i][w] &lt;= 1 - starting_xi_vars[i][w],\n                f\"IsBench_NotStarter_{i}_{w}\",\n            )\n            self.problem += (\n                is_bench_player[i][w]\n                &gt;= player_vars[i][w] + (1 - starting_xi_vars[i][w]) - 1,\n                f\"IsBench_Logical_{i}_{w}\",\n            )\n\n            self.problem += (\n                actual_bench_boost_points[i][w]\n                &lt;= player_xp * is_bench_player[i][w],\n                f\"BenchBoost_Contr_1_{i}_{w}\",\n            )\n            self.problem += (\n                actual_bench_boost_points[i][w] &lt;= player_xp * use_bench_boost[w],\n                f\"BenchBoost_Contr_2_{i}_{w}\",\n            )\n            self.problem += (\n                actual_bench_boost_points[i][w]\n                &gt;= player_xp * (is_bench_player[i][w] + use_bench_boost[w] - 1),\n                f\"BenchBoost_Contr_3_{i}_{w}\",\n            )\n            self.problem += (\n                actual_bench_boost_points[i][w] &gt;= 0,\n                f\"BenchBoost_Contr_4_{i}_{w}\",\n            )\n\n            # Triple Captain auxiliary variables and constraints\n            # Changed player_xp * 2 to player_xp to reflect additional 1x bonus\n            self.problem += (\n                actual_triple_captain_bonus[i][w] &lt;= player_xp * captain_var[i][w],\n                f\"TripleCaptain_Contr_1_{i}_{w}\",\n            )\n            self.problem += (\n                actual_triple_captain_bonus[i][w]\n                &lt;= player_xp * use_triple_captain[w],\n                f\"TripleCaptain_Contr_2_{i}_{w}\",\n            )\n            self.problem += (\n                actual_triple_captain_bonus[i][w]\n                &gt;= player_xp * (captain_var[i][w] + use_triple_captain[w] - 1),\n                f\"TripleCaptain_Contr_3_{i}_{w}\",\n            )\n            self.problem += (\n                actual_triple_captain_bonus[i][w] &gt;= 0,\n                f\"TripleCaptain_Contr_4_{i}_{w}\",\n            )\n\n        # Add points from bench boost and triple captain bonus for this gameweek\n        total_bench_boost_points_gw = lpSum(\n            actual_bench_boost_points[i][w] for i in self.player_data.index\n        )\n        total_triple_captain_bonus_points_gw = lpSum(\n            actual_triple_captain_bonus[i][w] for i in self.player_data.index\n        )\n\n        total_objective_points.append(total_bench_boost_points_gw)\n        total_objective_points.append(total_triple_captain_bonus_points_gw)\n\n    # Subtract transfer hits from the total objective\n    total_objective_points.append(\n        -POINTS_PER_HIT * lpSum(transfer_hits[w] for w in range(1, num_gameweeks))\n    )\n\n    self.problem += (\n        lpSum(total_objective_points),\n        \"Total Expected Points Over Gameweeks\",\n    )\n\n    # --- Constraints ---\n\n    # Apply constraints for each gameweek\n    for w in range(num_gameweeks):\n        # 1. Select exactly 15 players for the squad\n        self.problem += (\n            lpSum(player_vars[i][w] for i in self.player_data.index) == 15,\n            f\"Total_Players_GW{w}\",\n        )\n\n        # 2. Squad position constraints (2 GKs, 5 DEFs, 5 MIDs, 3 FWDs)\n        gks = self.player_data[self.player_data[\"position\"] == \"GK\"].index\n        defs = self.player_data[self.player_data[\"position\"] == \"DEF\"].index\n        mids = self.player_data[self.player_data[\"position\"] == \"MID\"].index\n        fwds = self.player_data[self.player_data[\"position\"] == \"FWD\"].index\n\n        self.problem += (\n            lpSum(player_vars[i][w] for i in gks) == 2,\n            f\"Goalkeepers_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(player_vars[i][w] for i in defs) == 5,\n            f\"Defenders_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(player_vars[i][w] for i in mids) == 5,\n            f\"Midfielders_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(player_vars[i][w] for i in fwds) == 3,\n            f\"Forwards_Count_GW{w}\",\n        )\n\n        # 3. Budget constraint\n        # This applies to the cost of the squad for the current gameweek.\n        self.problem += (\n            lpSum(\n                self.player_data.loc[i, \"cost\"] * player_vars[i][w]\n                for i in self.player_data.index\n            )\n            &lt;= budget,\n            f\"Total_Budget_GW{w}\",\n        )\n\n        # 4. Maximum players per team constraint\n        for team in self.player_data[\"team\"].unique():\n            team_players = self.player_data[self.player_data[\"team\"] == team].index\n            self.problem += (\n                lpSum(player_vars[i][w] for i in team_players)\n                &lt;= max_players_per_team,\n                f\"Max_Players_from_{team}_GW{w}\",\n            )\n\n        # 5. Starting XI constraints\n        # 5.1 Select exactly 11 players for the starting XI\n        self.problem += (\n            lpSum(starting_xi_vars[i][w] for i in self.player_data.index) == 11,\n            f\"Total_Starting_XI_Players_GW{w}\",\n        )\n\n        # 5.2 A player can only be in the starting XI if they are in the squad\n        for i in self.player_data.index:\n            self.problem += (\n                starting_xi_vars[i][w] &lt;= player_vars[i][w],\n                f\"StartingXI_in_Squad_{i}_{w}\",\n            )\n\n        # 5.3 Starting XI position constraints (FPL allows flexible formations, so use minimums)\n        self.problem += (\n            lpSum(starting_xi_vars[i][w] for i in gks) == 1,\n            f\"Starting_Goalkeepers_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(starting_xi_vars[i][w] for i in defs) &gt;= 3,\n            f\"Min_Starting_Defenders_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(starting_xi_vars[i][w] for i in mids) &gt;= 2,\n            f\"Min_Starting_Midfielders_Count_GW{w}\",\n        )\n        self.problem += (\n            lpSum(starting_xi_vars[i][w] for i in fwds) &gt;= 1,\n            f\"Min_Starting_Forwards_Count_GW{w}\",\n        )\n\n        # 6. Captain Constraints\n        # 6.1 Select exactly one captain from the starting XI\n        self.problem += (\n            lpSum(captain_var[i][w] for i in self.player_data.index) == 1,\n            f\"One_Captain_GW{w}\",\n        )\n\n        # 6.2 A player can only be captain if they are in the starting XI\n        for i in self.player_data.index:\n            self.problem += (\n                captain_var[i][w] &lt;= starting_xi_vars[i][w],\n                f\"Captain_in_StartingXI_{i}_{w}\",\n            )\n\n        # --- Enforced Player Constraints---\n        for player_idx in self.enforced_player_indices:\n            self.problem += (\n                player_vars[player_idx][w] == 1,\n                f\"Enforce_Player_{self.player_data.loc[player_idx, 'name']}_GW{w}\",\n            )\n\n        for team, position in self.enforced_team_pos_requirements:\n            # Filter players for the current team and position\n            team_pos_players = self.player_data[\n                (self.player_data[\"team\"] == team)\n                &amp; (self.player_data[\"position\"] == position)\n            ].index\n            if not team_pos_players.empty:\n                self.problem += (\n                    lpSum(player_vars[i][w] for i in team_pos_players) &gt;= 1,\n                    f\"Enforce_One_{position}_from_{team}_GW{w}\",\n                )\n            else:\n                print(\n                    f\"Warning: No players found for enforced requirement: at least one {position} from {team} for GW{gw_actual}.\"\n                )\n\n    # --- Chip Usage Constraints (TOTAL usage over all gameweeks) ---\n    # These constraints should be outside the per-gameweek loop to avoid duplicates.\n    self.problem += (\n        lpSum(use_bench_boost[j] for j in range(num_gameweeks))\n        &lt;= chip_allowances.get(\"bench_boost\", 0),\n        f\"Max_Bench_Boost_Usage_Total\",\n    )\n    self.problem += (\n        lpSum(use_triple_captain[j] for j in range(num_gameweeks))\n        &lt;= chip_allowances.get(\"triple_captain\", 0),\n        f\"Max_Triple_Captain_Usage_Total\",\n    )\n\n    # --- Inter-Gameweek Constraints (Transfers and Transfer Rules) ---\n    # Initialize free transfers for GW0 (first gameweek of optimization horizon)\n    # This assumes the optimization starts at GW0, and it has INITIAL_FREE_TRANSFERS.\n    # If the model starts at an arbitrary GW, this would need to be an input.\n    self.problem += (\n        free_transfers_available[0] == INITIAL_FREE_TRANSFERS,\n        f\"Initial_Free_Transfers_GW0\",\n    )\n\n    for w in range(1, num_gameweeks):\n        # Calculate total transfers made in this gameweek\n        self.problem += (\n            transfers_made[w]\n            == lpSum(transfer_in_vars[i][w] for i in self.player_data.index),\n            f\"Transfers_Made_GW{w}\",\n        )\n        # Total transfers in must equal total transfers out for each gameweek after the first\n        self.problem += (\n            lpSum(transfer_in_vars[i][w] for i in self.player_data.index)\n            == lpSum(transfer_out_vars[i][w] for i in self.player_data.index),\n            f\"Transfers_In_Equals_Out_GW{w}\",\n        )\n\n        # Calculate free transfers available for the current gameweek (w)\n        # Free transfers for GW_w = min(free transfers from GW_w-1 - transfers made in GW_w + 1, MAX_FREE_TRANSFERS_SAVED + 1)\n        # The + 1 in MAX_FREE_TRANSFERS_SAVED + 1 is because MAX_FREE_TRANSFERS_SAVED implies how many can be *saved*,\n        # so if you save 1, you have 1 (current) + 1 (saved) = 2.\n        self.problem += (\n            free_transfers_available[w]\n            &lt;= free_transfers_available[w - 1] - transfers_made[w] + 1,\n            f\"Free_Transfers_Calc_1_GW{w}\",\n        )\n        self.problem += (\n            free_transfers_available[w] &lt;= MAX_FREE_TRANSFERS_SAVED + 1,\n            f\"Free_Transfers_Calc_2_GW{w}\",\n        )\n        self.problem += (\n            free_transfers_available[w] &gt;= 0,  # Cannot have negative free transfers\n            f\"Free_Transfers_Non_Negative_GW{w}\",\n        )\n\n        # Calculate transfer hits\n        # transfer_hits[w] = max(0, transfers_made[w] - free_transfers_available_at_start_of_gw_w)\n        # This needs to be linearized. If transfers_made[w] &gt; free_transfers_available[w-1], then hit.\n        # free_transfers_available[w-1] represents transfers available *before* making transfers for GW_w\n        self.problem += (\n            transfer_hits[w] &gt;= transfers_made[w] - free_transfers_available[w - 1],\n            f\"Transfer_Hits_Calc_1_GW{w}\",\n        )\n        self.problem += (\n            transfer_hits[w] &gt;= 0,\n            f\"Transfer_Hits_Calc_2_GW{w}\",\n        )\n\n        for i in self.player_data.index:\n            # Squad continuity: player_vars[i][w] (in squad at start of GW w)\n            #                 = player_vars[i][w-1] (in squad at start of GW w-1)\n            #                 - transfer_out_vars[i][w] (transferred out for GW w)\n            #                 + transfer_in_vars[i][w] (transferred in for GW w)\n            self.problem += (\n                player_vars[i][w]\n                == player_vars[i][w - 1]\n                - transfer_out_vars[i][w]\n                + transfer_in_vars[i][w],\n                f\"Squad_Continuity_{i}_GW{w}\",\n            )\n            # A player cannot be transferred in and out in the same gameweek\n            self.problem += (\n                transfer_in_vars[i][w] + transfer_out_vars[i][w] &lt;= 1,\n                f\"No_Simultaneous_Transfer_{i}_{w}\",\n            )\n\n    try:\n        # The solver is called with the GLPK_CMD solver\n        self.problem.solve(PULP_CBC_CMD(msg=0))  # msg=0 suppresses verbose output\n    except Exception as e:\n        print(f\"Error solving the problem: {e}\")\n        return False\n\n    if LpStatus[self.problem.status] == \"Optimal\":\n        print(\"Optimization successful! Optimal solution found.\")\n\n        self.selected_squad_history = {}\n        self.total_transfer_hits = 0\n        for w in range(num_gameweeks):\n            # The actual gameweek number (1-indexed)\n            gw_actual = current_gameweek_number_start + w\n\n            # Get selected players for the current gameweek\n            selected_squad_gw = self.player_data[\n                [player_vars[i][w].varValue == 1 for i in self.player_data.index]\n            ].copy()\n\n            # Get starter and captain info for this gameweek\n            is_starter_series_gw = pd.Series(\n                [\n                    starting_xi_vars[i][w].varValue == 1\n                    for i in self.player_data.index\n                ],\n                index=self.player_data.index,\n            )\n            is_captain_series_gw = pd.Series(\n                [captain_var[i][w].varValue == 1 for i in self.player_data.index],\n                index=self.player_data.index,\n            )\n\n            selected_squad_gw[\"is_starter\"] = is_starter_series_gw.loc[\n                selected_squad_gw.index\n            ]\n            selected_squad_gw[\"is_captain\"] = is_captain_series_gw.loc[\n                selected_squad_gw.index\n            ]\n\n            transfers_in_gw = 0\n            transfers_out_gw = 0\n            hits_gw = 0\n\n            # Store transfer details for gameweeks &gt; 0\n            if (\n                w &gt; 0\n            ):  # Check for transfers only from GW1 onwards (index 1 in 0-indexed loop)\n                transfer_in_flags = pd.Series(\n                    [\n                        transfer_in_vars[i][w].varValue == 1\n                        for i in self.player_data.index\n                    ],\n                    index=self.player_data.index,\n                )\n                transfer_out_flags = pd.Series(\n                    [\n                        transfer_out_vars[i][w].varValue == 1\n                        for i in self.player_data.index\n                    ],\n                    index=self.player_data.index,\n                )\n\n                selected_squad_gw[\"transfer_in\"] = transfer_in_flags.loc[\n                    selected_squad_gw.index\n                ]\n                selected_squad_gw[\"transfer_out\"] = transfer_out_flags.loc[\n                    selected_squad_gw.index\n                ]\n\n                transfers_in_gw = int(round(transfer_in_flags.sum()))\n                transfers_out_gw = int(round(transfer_out_flags.sum()))\n                hits_gw = int(round(transfer_hits[w].varValue))\n                self.total_transfer_hits += hits_gw\n            else:\n                selected_squad_gw[\"transfer_in\"] = False  # No transfers in for GW0\n                selected_squad_gw[\"transfer_out\"] = (\n                    False  # No transfers out for GW0\n                )\n\n            self.selected_squad_history[f\"GW{gw_actual}\"] = {\n                \"squad\": selected_squad_gw,\n                \"total_cost\": selected_squad_gw[\"cost\"].sum(),\n                \"expected_points_from_xi\": sum(\n                    self.player_data.loc[i, \"expected_points_by_gw\"][gw_actual]\n                    * starting_xi_vars[i][w].varValue\n                    for i in self.player_data.index\n                ),\n                \"bench_boost_used\": bool(use_bench_boost[w].varValue),\n                \"triple_captain_used\": bool(use_triple_captain[w].varValue),\n                \"total_bench_boost_points\": value(\n                    lpSum(\n                        actual_bench_boost_points[i][w]\n                        for i in self.player_data.index\n                    )\n                ),\n                \"total_triple_captain_bonus\": value(\n                    lpSum(\n                        actual_triple_captain_bonus[i][w]\n                        for i in self.player_data.index\n                    )\n                ),\n                \"transfers_in_count\": transfers_in_gw,\n                \"transfers_out_count\": transfers_out_gw,\n                \"transfer_hits\": hits_gw,  # New\n                \"free_transfers_available_next_gw\": (\n                    int(round(free_transfers_available[w].varValue))\n                    if w &lt; num_gameweeks - 1\n                    else 0\n                ),  # Free transfers available *after* this GW's transfers are made\n            }\n\n        # Overall totals\n        self.total_cost = self.selected_squad_history[\n            f\"GW{current_gameweek_number_start + num_gameweeks - 1}\"\n        ][\n            \"total_cost\"\n        ]  # Cost of final squad\n        self.total_expected_points = value(\n            self.problem.objective\n        )  # Total objective value from solver\n        self.used_chips = {\n            f\"GW{current_gameweek_number_start + w}\": {\n                \"bench_boost\": bool(use_bench_boost[w].varValue),\n                \"triple_captain\": bool(use_triple_captain[w].varValue),\n            }\n            for w in range(num_gameweeks)\n        }\n\n        return True\n    else:\n        print(f\"No optimal solution found. Status: {LpStatus[self.problem.status]}\")\n        self.selected_squad_history = {}\n        self.total_cost = 0\n        self.total_expected_points = 0\n        self.used_chips = {}\n        self.total_transfer_hits = 0\n        return False\n</code></pre>"},{"location":"autoapi/fpl_solver/fpl_xp_predictor/","title":"fpl_xp_predictor","text":""},{"location":"autoapi/fpl_solver/fpl_xp_predictor/#fpl_solver.fpl_xp_predictor.FPLPredictor","title":"<code>FPLPredictor</code>","text":"<p>Predictive algorithm for Expected Points (xP) in Fantasy Premier League, using real data from the FPL API.</p> Source code in <code>fpl_solver/fpl_xp_predictor.py</code> <pre><code>class FPLPredictor:\n    \"\"\"\n    Predictive algorithm for Expected Points (xP) in Fantasy Premier League,\n    using real data from the FPL API.\n    \"\"\"\n\n    def __init__(self, gameweeks_to_predict: int = 1):\n        \"\"\"\n        Initializes the FPLPredictor with default FPL point rules and\n        data structures, then fetches real data and calculates xP for all players.\n\n        Args:\n            gameweeks_to_predict (int): The number of upcoming gameweeks to calculate\n                                        expected points for. Default is 1 (next gameweek).\n        \"\"\"\n        if not isinstance(gameweeks_to_predict, int) or gameweeks_to_predict &lt; 1:\n            raise ValueError(\"gameweeks_to_predict must be a positive integer.\")\n        self.gameweeks_to_predict = gameweeks_to_predict\n\n        self.fpl_points = FPL_POINTS\n\n        self.players_data = {}\n        self.teams_data = {}\n        self.fixtures_data = {}\n        self.position_definitions = {\n            1: \"GK\",\n            2: \"DEF\",\n            3: \"MID\",\n            4: \"FWD\",\n        }\n        self.all_players_xp_calculated_data = (\n            []\n        )  # To store xP for all players for the optimizer\n\n        self._fetch_fpl_data()\n        self._calculate_all_players_xp()  # Calculate xP for all players after data is loaded\n\n    def _fetch_fpl_data(self):\n        \"\"\"Fetches initial data from the FPL API.\"\"\"\n        print(\"Fetching FPL data...\")\n        try:\n            # Fetch general data\n            static_data = requests.get(\n                \"https://fantasy.premierleague.com/api/bootstrap-static/\"\n            ).json()\n            # Fetch fixtures data\n            fixtures_data = requests.get(\n                \"https://fantasy.premierleague.com/api/fixtures/\"\n            ).json()\n\n            # Process players data\n            for element in static_data[\"elements\"]:\n                player_id = element[\"id\"]\n                self.players_data[player_id] = {\n                    \"name\": element[\"first_name\"] + \" \" + element[\"second_name\"],\n                    \"web_name\": element[\"web_name\"],\n                    \"team_id\": element[\"team\"],\n                    \"element_type\": element[\"element_type\"],\n                    \"position\": self.position_definitions.get(\n                        element[\"element_type\"], \"Unknown\"\n                    ),\n                    \"cost_pence\": element[\"now_cost\"],\n                    \"status\": element[\"status\"],\n                    \"news\": element[\"news\"],\n                    \"total_points\": element[\"total_points\"],\n                    \"minutes\": element[\"minutes\"],\n                    \"goals_scored\": element[\"goals_scored\"],\n                    \"assists\": element[\"assists\"],\n                    \"clean_sheets\": element[\"clean_sheets\"],\n                    \"goals_conceded\": element[\"goals_conceded\"],\n                    \"penalties_saved\": element[\"penalties_saved\"],\n                    \"penalties_missed\": element[\"penalties_missed\"],\n                    \"yellow_cards\": element[\"yellow_cards\"],\n                    \"red_cards\": element[\"red_cards\"],\n                    \"own_goals\": element[\"own_goals\"],\n                    \"saves\": element[\"saves\"],\n                    \"bonus\": element[\"bonus\"],\n                    \"bps\": element[\"bps\"],\n                    \"threat\": element[\"threat\"],\n                    \"creativity\": element[\"creativity\"],\n                    \"influence\": element[\"influence\"],\n                    \"form\": float(element[\"form\"]),\n                    \"points_per_game\": float(element[\"points_per_game\"]),\n                    \"value_season\": float(element[\"value_season\"]),\n                    \"value_form\": float(element[\"value_form\"]),\n                    \"ict_index\": float(element[\"ict_index\"]),\n                }\n\n            # --- Apply Player Exclusions ---\n            initial_player_count = len(self.players_data)\n            players_to_keep = {}\n            for player_id, player_info in self.players_data.items():\n                # Exclude by ID\n                if player_id in EXCLUDED_PLAYERS_BY_ID:\n                    print(\n                        f\"Excluding player by ID: {player_info['name']} (ID: {player_id})\"\n                    )\n                    continue\n\n                # Exclude by Name\n                if player_info[\"name\"] in EXCLUDED_PLAYERS_BY_NAME:\n                    print(\n                        f\"Excluding player by Name: {player_info['name']} (ID: {player_id})\"\n                    )\n                    continue\n\n                # Exclude by Team and Position\n                excluded_by_team_pos = False\n                for exclusion_rule in EXCLUDED_PLAYERS_BY_TEAM_AND_POSITION:\n                    team_name = self.teams_data.get(player_info[\"team_id\"], {}).get(\n                        \"name\"\n                    )\n                    if team_name == exclusion_rule.get(\"team\") and player_info[\n                        \"position\"\n                    ] == exclusion_rule.get(\"position\"):\n                        print(\n                            f\"Excluding player by Team/Position: {player_info['name']} ({team_name}, {player_info['position']})\"\n                        )\n                        excluded_by_team_pos = True\n                        break\n                if excluded_by_team_pos:\n                    continue\n\n                players_to_keep[player_id] = player_info\n\n            self.players_data = players_to_keep\n            print(\n                f\"Filtered {initial_player_count - len(self.players_data)} players. Remaining: {len(self.players_data)}\"\n            )\n\n            # Process teams data\n            for team in static_data[\"teams\"]:\n                self.teams_data[team[\"id\"]] = {\n                    \"name\": team[\"name\"],\n                    \"short_name\": team[\"short_name\"],\n                    \"strength\": team[\"strength\"],\n                    \"strength_overall_home\": team[\"strength_overall_home\"],\n                    \"strength_overall_away\": team[\"strength_overall_away\"],\n                    \"strength_attack_home\": team[\"strength_attack_home\"],\n                    \"strength_attack_away\": team[\"strength_attack_away\"],\n                    \"strength_defence_home\": team[\"strength_defence_home\"],\n                    \"strength_defence_away\": team[\"strength_defence_away\"],\n                }\n\n            # Process fixtures data\n            for fixture in fixtures_data:\n                self.fixtures_data[fixture[\"id\"]] = fixture\n\n            print(\"FPL data fetched successfully.\")\n\n        except requests.exceptions.RequestException as e:\n            print(f\"Error fetching FPL data: {e}\")\n            self.players_data = {}\n            self.teams_data = {}\n            self.fixtures_data = {}\n            print(\"Initialization failed due to data fetching error. Exiting.\")\n            sys.exit(1)\n        except Exception as e:\n            print(f\"An unexpected error occurred during data fetching: {e}\")\n            self.players_data = {}\n            self.teams_data = {}\n            self.fixtures_data = {}\n            print(\"Initialization failed due to unexpected error. Exiting.\")\n            sys.exit(1)\n\n    def _get_team_strength(self, team_id, is_home):\n        \"\"\"Get team strength based on home/away status.\"\"\"\n        team = self.teams_data.get(team_id, {})\n        if is_home:\n            return team.get(\"strength_overall_home\", 1000)  # Default if not found\n        return team.get(\"strength_overall_away\", 1000)  # Default if not found\n\n    def _predict_minutes(self, player_id):\n        \"\"\"\n        Predicts expected minutes for a player based on historical data.\n        More sophisticated logic for handling very low minute players.\n        \"\"\"\n        player = self.players_data.get(player_id)\n        if not player:\n            return 0.0\n\n        status = player[\"status\"]\n        news = player[\"news\"].lower()\n        minutes_played = player[\"minutes\"]\n\n        # 1. Unavailable players (injured, suspended, doubtful)\n        if status != \"a\" or any(\n            x in news\n            for x in [\n                \"injured\",\n                \"doubtful\",\n                \"suspension\",\n                \"red card\",\n                \"expected back\",\n            ]\n        ):\n            return 0.0\n\n        # 2. Players with significant minutes (starters/key rotation)\n        if minutes_played &gt;= MIN_MINUTES_THRESHOLD:\n            # Average minutes per game started (assuming most minutes come from starts)\n            # This is a heuristic; real FPL API doesn't give starts directly.\n            # We assume a player with &gt; MIN_MINUTES_THRESHOLD plays ~80-90 minutes when on pitch.\n            # So, (minutes_played / number_of_appearances) is a rough proxy.\n            # For simplicity, let's use a cap of 90 minutes.\n            if player[\"total_points\"] &gt; 0:  # Player has played at least one game\n                avg_minutes_per_appearance = minutes_played / (\n                    player[\"total_points\"] / player[\"points_per_game\"]\n                )\n                return min(avg_minutes_per_appearance, 90.0)\n            return 70.0  # Reasonable default for established player with points but no clear avg\n\n        # 3. Players with very low minutes (rarely play, new, youth)\n        if minutes_played &lt; VERY_LOW_MINUTES_THRESHOLD:\n            # If news suggests they might get a chance, assign default sub minutes.\n            # Otherwise, very low expected minutes or zero.\n            if any(x in news for x in [\"return imminent\", \"close to return\"]):\n                return DEFAULT_SUB_MINUTES  # Might get some minutes\n            return DEFAULT_UNKNOWN_PLAYER_MINUTES  # Very unlikely to play significant minutes\n\n        # 4. Players with some minutes but below significant threshold (regular subs)\n        return DEFAULT_SUB_MINUTES\n\n    def _calculate_expected_goals(self, team_attack_strength, opp_defence_strength):\n        \"\"\"\n        Calculates expected goals for a team based on its attack strength and\n        opponent's defensive strength. This is a simplified heuristic.\n        \"\"\"\n        # A simple ratio model: Higher attack strength and lower opponent defense means more goals\n        # Normalization factor can be adjusted based on average league goals\n        expected_goals = (\n            team_attack_strength / opp_defence_strength\n        ) * 1.5  # 1.5 is an arbitrary scaling factor\n        return max(0.0, expected_goals)\n\n    def _calculate_expected_conceded_goals(\n        self, team_defence_strength, opp_attack_strength\n    ):\n        \"\"\"\n        Calculates expected goals conceded by a team based on its defense strength\n        and opponent's attacking strength.\n        \"\"\"\n        # A simple ratio model: Higher opponent attack and lower team defense means more conceded goals\n        expected_conceded_goals = (\n            opp_attack_strength / team_defence_strength\n        ) * 1.5  # 1.5 is an arbitrary scaling factor\n        return max(0.0, expected_conceded_goals)\n\n    def calculate_xp_for_player(self, player_id, fixture_id):\n        \"\"\"\n        Calculates Expected Points (xP) for a single player in a given fixture.\n        Considers various factors: minutes, goals, assists, clean sheets, saves,\n        bonus points, and negative events, adjusted for fixture difficulty.\n        \"\"\"\n        player = self.players_data.get(player_id)\n        fixture = self.fixtures_data.get(fixture_id)\n\n        if not player or not fixture:\n            return {\"xp\": 0.0, \"reason\": \"Player or fixture data missing.\"}\n\n        # Handle unavailable players\n        if (\n            player[\"status\"] != \"a\"\n        ):  # 'd' for doubtful, 'i' for injured, 's' for suspended\n            return {\"xp\": 0.0, \"reason\": f\"Player status: {player['status']}\"}\n        if any(\n            x in player[\"news\"].lower()\n            for x in [\"injured\", \"doubtful\", \"suspension\", \"red card\"]\n        ):\n            return {\"xp\": 0.0, \"reason\": f\"Player news: {player['news']}\"}\n\n        # Predict minutes\n        expected_minutes = self._predict_minutes(player_id)\n        if expected_minutes &lt; 1.0:  # If expected to play very little or none\n            return {\"xp\": 0.0, \"reason\": \"Expected minutes too low.\"}\n\n        xp = 0.0\n        position = player[\"position\"]\n        # Use 'team_h' for home team ID\n        is_home_fixture = player[\"team_id\"] == fixture[\"team_h\"]\n\n        # Determine attacking and defensive strengths for the fixture\n        player_team_strength_attack = (\n            self.teams_data.get(fixture[\"team_h\"], {}).get(\n                \"strength_attack_home\"\n            )  # Use 'team_h'\n            if is_home_fixture\n            else self.teams_data.get(fixture[\"team_a\"], {}).get(\n                \"strength_attack_away\"\n            )  # Use 'team_a'\n        )\n        player_team_strength_defence = (\n            self.teams_data.get(fixture[\"team_h\"], {}).get(\n                \"strength_defence_home\"\n            )  # Use 'team_h'\n            if is_home_fixture\n            else self.teams_data.get(fixture[\"team_a\"], {}).get(\n                \"strength_defence_away\"\n            )  # Use 'team_a'\n        )\n        opponent_team_strength_attack = (\n            self.teams_data.get(fixture[\"team_a\"], {}).get(\n                \"strength_attack_away\"\n            )  # Use 'team_a'\n            if is_home_fixture\n            else self.teams_data.get(fixture[\"team_h\"], {}).get(\n                \"strength_attack_home\"\n            )  # Use 'team_h'\n        )\n        opponent_team_strength_defence = (\n            self.teams_data.get(fixture[\"team_a\"], {}).get(\n                \"strength_defence_away\"\n            )  # Use 'team_a'\n            if is_home_fixture\n            else self.teams_data.get(fixture[\"team_h\"], {}).get(\n                \"strength_defence_home\"\n            )  # Use 'team_h'\n        )\n\n        if None in [\n            player_team_strength_attack,\n            player_team_strength_defence,\n            opponent_team_strength_attack,\n            opponent_team_strength_defence,\n        ]:\n            # Fallback if strength data is missing (shouldn't happen with robust data fetch)\n            return {\"xp\": 0.0, \"reason\": \"Team strength data missing for fixture.\"}\n\n        # 1. Appearance points\n        if expected_minutes &gt;= 60:\n            xp += self.fpl_points[\"appearance_points_gte_60\"]\n        elif expected_minutes &gt; 0:\n            xp += self.fpl_points[\"appearance_points_lt_60\"]\n\n        # 2. Expected Goals (scaled by historical goals per 90 and opponent difficulty)\n        # Use player's form and total goals as a basis\n        goals_per_90_hist = (\n            (player[\"goals_scored\"] / player[\"minutes\"] * 90)\n            if player[\"minutes\"] &gt; 0\n            else 0.0\n        )\n        expected_team_goals = self._calculate_expected_goals(\n            player_team_strength_attack, opponent_team_strength_defence\n        )\n\n        expected_goals_player_contribution = (\n            (goals_per_90_hist / 90.0) * expected_minutes * (expected_team_goals / 1.5)\n        )  # Scale player's goal contribution by team's expected goals\n\n        if position == \"GK\":\n            xp += expected_goals_player_contribution * self.fpl_points[\"goal_gk\"]\n        elif position == \"DEF\":\n            xp += expected_goals_player_contribution * self.fpl_points[\"goal_def\"]\n        elif position == \"MID\":\n            xp += expected_goals_player_contribution * self.fpl_points[\"goal_mid\"]\n        elif position == \"FWD\":\n            xp += expected_goals_player_contribution * self.fpl_points[\"goal_fwd\"]\n\n        # 3. Expected Assists (scaled by historical assists per 90 and opponent difficulty)\n        assists_per_90_hist = (\n            (player[\"assists\"] / player[\"minutes\"] * 90)\n            if player[\"minutes\"] &gt; 0\n            else 0.0\n        )\n        # Assuming team's attacking strength correlates with assist opportunities\n        expected_assists_player_contribution = (\n            (assists_per_90_hist / 90.0)\n            * expected_minutes\n            * (expected_team_goals / 1.5)\n        )  # Similarly scale by team's expected goals\n        xp += expected_assists_player_contribution * self.fpl_points[\"assist_points\"]\n\n        # 4. Expected Clean Sheets (for GKs/DEFs/MIDs) and Conceded Goals deduction\n        expected_conceded = self._calculate_expected_conceded_goals(\n            player_team_strength_defence, opponent_team_strength_attack\n        )\n\n        # Probability of clean sheet\n        # Simplified: higher team defense / lower opponent attack -&gt; higher CS prob\n        # Use logistic or sigmoid for probability\n        cs_prob = 1.0 / (\n            1.0 + math.exp(expected_conceded - 1.0)\n        )  # Sigmoid centered at 1 goal\n\n        if position in [\"GK\", \"DEF\"]:\n            xp += cs_prob * self.fpl_points[\"clean_sheet_gk_def\"]\n\n            # Conceded goals deduction: Apply penalty for every 2 goals conceded *probability*\n            # For simplicity, calculate expected deduction: (expected_conceded / 2) * deduction\n            xp += (expected_conceded / 2.0) * self.fpl_points[\n                \"conceded_2_goals_deduction\"\n            ]\n        elif position == \"MID\":\n            xp += cs_prob * self.fpl_points[\"clean_sheet_mid\"]\n\n        # 5. Expected Saves (for GKs)\n        if position == \"GK\":\n            saves_per_90_hist = (\n                (player[\"saves\"] / player[\"minutes\"] * 90)\n                if player[\"minutes\"] &gt; 0\n                else 0.0\n            )\n            # Expected saves scaled by opponent's attacking strength (more attacking -&gt; more shots -&gt; more saves)\n            expected_saves_player_contribution = (\n                (saves_per_90_hist / 90.0)\n                * expected_minutes\n                * (opponent_team_strength_attack / player_team_strength_defence)\n            )\n            xp += (expected_saves_player_contribution / 3.0) * self.fpl_points[\n                \"saves_3_points\"\n            ]  # Using the new config point value\n\n            # Penalty saves (low probability, use historical rate)\n            penalty_saves_hist_per_game = (\n                player[\"penalties_saved\"] / (player[\"minutes\"] / 90.0)\n                if player[\"minutes\"] &gt; 0\n                else 0.0\n            )\n            xp += (\n                penalty_saves_hist_per_game\n                * (expected_minutes / 90.0)\n                * self.fpl_points[\"penalty_save_points\"]\n            )\n\n        # 6. Expected Bonus Points\n        # Use BPS (Bonus Points System) as a proxy. Scale player's average BPS by form and expected minutes.\n        bps_per_90_hist = (\n            (player[\"bps\"] / player[\"minutes\"] * 90) if player[\"minutes\"] &gt; 0 else 0.0\n        )\n        expected_bps = (bps_per_90_hist / 90.0) * expected_minutes * player[\"form\"]\n        xp += expected_bps * self.fpl_points[\"bonus_points_scaling_factor\"]\n\n        # 7. Minor Negative Events (Probabilistic)\n        # These are rare, so a simple probability based on expected minutes.\n        xp += (expected_minutes / 90.0) * (\n            self.fpl_points[\"yellow_card_deduction\"] * YELLOW_CARD_PROB\n            + self.fpl_points[\"red_card_deduction\"] * RED_CARD_PROB\n            + self.fpl_points[\"own_goal_deduction\"] * OWN_GOAL_PROB\n            + self.fpl_points[\"penalty_miss_deduction\"] * PENALTY_MISS_PROB\n        )\n\n        # 8. Defensive Contribution Points (for 2025/26 season heuristic)\n        # Assuming CBIT/CBIRT tracking\n        if position in [\"GK\", \"DEF\"]:\n            xp += CBIT_DEF_PROB * self.fpl_points[\"cbit_def_points\"]\n        elif position in [\"MID\", \"FWD\"]:\n            xp += CBIRT_MID_FWD_PROB * self.fpl_points[\"cbirt_mid_fwd_points\"]\n\n        return {\"xp\": round(xp, 2), \"reason\": \"Success\"}\n\n    def _calculate_all_players_xp(self):\n        \"\"\"\n        Calculates the Expected Points (xP) for all players over multiple upcoming gameweeks\n        and populates self.all_players_xp_calculated_data with xP per gameweek.\n        \"\"\"\n        print(\n            f\"Calculating xP for all players over {self.gameweeks_to_predict} gameweek(s)...\"\n        )\n\n        # Get all upcoming fixtures and sort them by gameweek\n        all_upcoming_fixtures_items = sorted(\n            [\n                (fid, fdict)\n                for fid, fdict in self.fixtures_data.items()\n                if not fdict[\"finished\"]\n            ],\n            key=lambda item: item[1][\"event\"],\n        )\n\n        if not all_upcoming_fixtures_items:\n            print(\"No upcoming fixtures found. Cannot calculate xP.\")\n            return\n\n        # Determine the current gameweek (the gameweek of the earliest upcoming fixture)\n        current_gameweek = all_upcoming_fixtures_items[0][1][\"event\"]\n        target_gameweeks = range(\n            current_gameweek, current_gameweek + self.gameweeks_to_predict\n        )\n\n        # Create a mapping of team_id_code to a list of their fixtures within the target gameweeks\n        team_fixtures_in_range = {team_code: [] for team_code in self.teams_data.keys()}\n        for fixture_id, fixture_data in all_upcoming_fixtures_items:\n            if fixture_data[\"event\"] in target_gameweeks:\n                home_team_code = fixture_data[\"team_h\"]\n                away_team_code = fixture_data[\"team_a\"]\n\n                team_fixtures_in_range[home_team_code].append(fixture_id)\n                team_fixtures_in_range[away_team_code].append(fixture_id)\n\n        # Calculate total xP for each player across the specified gameweeks\n        for player_id, player_data in self.players_data.items():\n            player_team_code = player_data[\"team_id\"]\n            player_position = player_data[\"position\"]\n\n            # Calculate xP for each relevant fixture and store by gameweek\n            expected_points_by_gw = {}\n            for fixture_id in team_fixtures_in_range.get(player_team_code, []):\n                fixture_gameweek = self.fixtures_data[fixture_id][\"event\"]\n                xp_result_single_gw = self.calculate_xp_for_player(\n                    player_id, fixture_id\n                )\n                if xp_result_single_gw and xp_result_single_gw[\"xp\"] is not None:\n                    if fixture_gameweek not in expected_points_by_gw:\n                        expected_points_by_gw[fixture_gameweek] = 0.0\n                    expected_points_by_gw[fixture_gameweek] += xp_result_single_gw[\"xp\"]\n\n            # Ensure all target gameweeks are present, even if xP is 0 for a given GW\n            for gw in target_gameweeks:\n                if gw not in expected_points_by_gw:\n                    expected_points_by_gw[gw] = 0.0\n\n            # Sort the dictionary by gameweek for consistent output\n            expected_points_by_gw = dict(sorted(expected_points_by_gw.items()))\n\n            # Prepare data for the optimizer\n            player_cost_m = player_data[\"cost_pence\"] / 10.0\n            team_name_full = self.teams_data.get(player_team_code, {}).get(\n                \"name\", \"Unknown Team\"\n            )\n\n            self.all_players_xp_calculated_data.append(\n                {\n                    \"name\": player_data[\"name\"],\n                    \"web_name\": player_data[\"web_name\"],\n                    \"team\": team_name_full,\n                    \"position\": player_position,\n                    \"cost\": player_cost_m,\n                    \"expected_points_by_gw\": expected_points_by_gw,  # Changed key and format\n                }\n            )\n        print(\"xP calculation for all players complete.\")\n\n    def get_upcoming_fixtures(self, limit=None):\n        \"\"\"\n        Returns a list of upcoming fixtures, sorted by gameweek and kickoff time.\n        Optionally limits the number of fixtures returned.\n        \"\"\"\n        upcoming = []\n        now = datetime.now()\n\n        # Sort all fixtures by gameweek and then by kickoff time\n        sorted_fixtures = sorted(\n            self.fixtures_data.values(),\n            key=lambda x: (\n                x.get(\"event\", 0),\n                x.get(\"kickoff_time\", \"9999-12-31T00:00:00Z\"),\n            ),\n        )\n\n        current_gameweek = None\n        for fixture_data in sorted_fixtures:\n            # Determine current gameweek from the earliest upcoming fixture\n            if not fixture_data[\"finished\"] and current_gameweek is None:\n                current_gameweek = fixture_data.get(\"event\", 0)\n\n            # Filter for upcoming fixtures within the prediction horizon\n            if (\n                fixture_data.get(\"event\", 0) &lt; current_gameweek  # Skip past gameweeks\n                or fixture_data.get(\"event\", 0)\n                &gt;= current_gameweek + self.gameweeks_to_predict\n            ):\n                continue  # Skip fixtures outside the prediction horizon\n\n            home_team_name = self.teams_data.get(\n                fixture_data[\"team_h\"], {}\n            ).get(  # Use 'team_h'\n                \"name\", \"Unknown\"\n            )\n            away_team_name = self.teams_data.get(\n                fixture_data[\"team_a\"], {}\n            ).get(  # Use 'team_a'\n                \"name\", \"Unknown\"\n            )\n\n            # Only add fixtures that are not finished\n            if not fixture_data[\"finished\"]:\n                upcoming.append(\n                    {\n                        \"fixture_id\": fixture_data[\"id\"],\n                        \"gameweek\": fixture_data.get(\"event\"),\n                        \"home_team_id\": fixture_data[\"team_h\"],  # Use 'team_h'\n                        \"away_team_id\": fixture_data[\"team_a\"],  # Use 'team_a'\n                        \"match\": f\"{home_team_name} vs {away_team_name}\",\n                        \"kickoff_time\": fixture_data.get(\"kickoff_time\"),\n                        \"home_team_difficulty\": fixture_data[\"team_h_difficulty\"],\n                        \"away_team_difficulty\": fixture_data[\"team_a_difficulty\"],\n                    }\n                )\n            if limit is not None and len(upcoming) &gt;= limit:\n                break\n        return upcoming\n\n    def get_players_for_optimizer(self):\n        \"\"\"\n        Returns the list of player data with calculated xP per gameweek,\n        formatted for the FPLOptimizer.\n        \"\"\"\n        return self.all_players_xp_calculated_data\n</code></pre>"},{"location":"autoapi/fpl_solver/fpl_xp_predictor/#fpl_solver.fpl_xp_predictor.FPLPredictor.__init__","title":"<code>__init__(gameweeks_to_predict=1)</code>","text":"<p>Initializes the FPLPredictor with default FPL point rules and data structures, then fetches real data and calculates xP for all players.</p> <p>Parameters:</p> Name Type Description Default <code>gameweeks_to_predict</code> <code>int</code> <p>The number of upcoming gameweeks to calculate                         expected points for. Default is 1 (next gameweek).</p> <code>1</code> Source code in <code>fpl_solver/fpl_xp_predictor.py</code> <pre><code>def __init__(self, gameweeks_to_predict: int = 1):\n    \"\"\"\n    Initializes the FPLPredictor with default FPL point rules and\n    data structures, then fetches real data and calculates xP for all players.\n\n    Args:\n        gameweeks_to_predict (int): The number of upcoming gameweeks to calculate\n                                    expected points for. Default is 1 (next gameweek).\n    \"\"\"\n    if not isinstance(gameweeks_to_predict, int) or gameweeks_to_predict &lt; 1:\n        raise ValueError(\"gameweeks_to_predict must be a positive integer.\")\n    self.gameweeks_to_predict = gameweeks_to_predict\n\n    self.fpl_points = FPL_POINTS\n\n    self.players_data = {}\n    self.teams_data = {}\n    self.fixtures_data = {}\n    self.position_definitions = {\n        1: \"GK\",\n        2: \"DEF\",\n        3: \"MID\",\n        4: \"FWD\",\n    }\n    self.all_players_xp_calculated_data = (\n        []\n    )  # To store xP for all players for the optimizer\n\n    self._fetch_fpl_data()\n    self._calculate_all_players_xp()  # Calculate xP for all players after data is loaded\n</code></pre>"},{"location":"autoapi/fpl_solver/fpl_xp_predictor/#fpl_solver.fpl_xp_predictor.FPLPredictor.calculate_xp_for_player","title":"<code>calculate_xp_for_player(player_id, fixture_id)</code>","text":"<p>Calculates Expected Points (xP) for a single player in a given fixture. Considers various factors: minutes, goals, assists, clean sheets, saves, bonus points, and negative events, adjusted for fixture difficulty.</p> Source code in <code>fpl_solver/fpl_xp_predictor.py</code> <pre><code>def calculate_xp_for_player(self, player_id, fixture_id):\n    \"\"\"\n    Calculates Expected Points (xP) for a single player in a given fixture.\n    Considers various factors: minutes, goals, assists, clean sheets, saves,\n    bonus points, and negative events, adjusted for fixture difficulty.\n    \"\"\"\n    player = self.players_data.get(player_id)\n    fixture = self.fixtures_data.get(fixture_id)\n\n    if not player or not fixture:\n        return {\"xp\": 0.0, \"reason\": \"Player or fixture data missing.\"}\n\n    # Handle unavailable players\n    if (\n        player[\"status\"] != \"a\"\n    ):  # 'd' for doubtful, 'i' for injured, 's' for suspended\n        return {\"xp\": 0.0, \"reason\": f\"Player status: {player['status']}\"}\n    if any(\n        x in player[\"news\"].lower()\n        for x in [\"injured\", \"doubtful\", \"suspension\", \"red card\"]\n    ):\n        return {\"xp\": 0.0, \"reason\": f\"Player news: {player['news']}\"}\n\n    # Predict minutes\n    expected_minutes = self._predict_minutes(player_id)\n    if expected_minutes &lt; 1.0:  # If expected to play very little or none\n        return {\"xp\": 0.0, \"reason\": \"Expected minutes too low.\"}\n\n    xp = 0.0\n    position = player[\"position\"]\n    # Use 'team_h' for home team ID\n    is_home_fixture = player[\"team_id\"] == fixture[\"team_h\"]\n\n    # Determine attacking and defensive strengths for the fixture\n    player_team_strength_attack = (\n        self.teams_data.get(fixture[\"team_h\"], {}).get(\n            \"strength_attack_home\"\n        )  # Use 'team_h'\n        if is_home_fixture\n        else self.teams_data.get(fixture[\"team_a\"], {}).get(\n            \"strength_attack_away\"\n        )  # Use 'team_a'\n    )\n    player_team_strength_defence = (\n        self.teams_data.get(fixture[\"team_h\"], {}).get(\n            \"strength_defence_home\"\n        )  # Use 'team_h'\n        if is_home_fixture\n        else self.teams_data.get(fixture[\"team_a\"], {}).get(\n            \"strength_defence_away\"\n        )  # Use 'team_a'\n    )\n    opponent_team_strength_attack = (\n        self.teams_data.get(fixture[\"team_a\"], {}).get(\n            \"strength_attack_away\"\n        )  # Use 'team_a'\n        if is_home_fixture\n        else self.teams_data.get(fixture[\"team_h\"], {}).get(\n            \"strength_attack_home\"\n        )  # Use 'team_h'\n    )\n    opponent_team_strength_defence = (\n        self.teams_data.get(fixture[\"team_a\"], {}).get(\n            \"strength_defence_away\"\n        )  # Use 'team_a'\n        if is_home_fixture\n        else self.teams_data.get(fixture[\"team_h\"], {}).get(\n            \"strength_defence_home\"\n        )  # Use 'team_h'\n    )\n\n    if None in [\n        player_team_strength_attack,\n        player_team_strength_defence,\n        opponent_team_strength_attack,\n        opponent_team_strength_defence,\n    ]:\n        # Fallback if strength data is missing (shouldn't happen with robust data fetch)\n        return {\"xp\": 0.0, \"reason\": \"Team strength data missing for fixture.\"}\n\n    # 1. Appearance points\n    if expected_minutes &gt;= 60:\n        xp += self.fpl_points[\"appearance_points_gte_60\"]\n    elif expected_minutes &gt; 0:\n        xp += self.fpl_points[\"appearance_points_lt_60\"]\n\n    # 2. Expected Goals (scaled by historical goals per 90 and opponent difficulty)\n    # Use player's form and total goals as a basis\n    goals_per_90_hist = (\n        (player[\"goals_scored\"] / player[\"minutes\"] * 90)\n        if player[\"minutes\"] &gt; 0\n        else 0.0\n    )\n    expected_team_goals = self._calculate_expected_goals(\n        player_team_strength_attack, opponent_team_strength_defence\n    )\n\n    expected_goals_player_contribution = (\n        (goals_per_90_hist / 90.0) * expected_minutes * (expected_team_goals / 1.5)\n    )  # Scale player's goal contribution by team's expected goals\n\n    if position == \"GK\":\n        xp += expected_goals_player_contribution * self.fpl_points[\"goal_gk\"]\n    elif position == \"DEF\":\n        xp += expected_goals_player_contribution * self.fpl_points[\"goal_def\"]\n    elif position == \"MID\":\n        xp += expected_goals_player_contribution * self.fpl_points[\"goal_mid\"]\n    elif position == \"FWD\":\n        xp += expected_goals_player_contribution * self.fpl_points[\"goal_fwd\"]\n\n    # 3. Expected Assists (scaled by historical assists per 90 and opponent difficulty)\n    assists_per_90_hist = (\n        (player[\"assists\"] / player[\"minutes\"] * 90)\n        if player[\"minutes\"] &gt; 0\n        else 0.0\n    )\n    # Assuming team's attacking strength correlates with assist opportunities\n    expected_assists_player_contribution = (\n        (assists_per_90_hist / 90.0)\n        * expected_minutes\n        * (expected_team_goals / 1.5)\n    )  # Similarly scale by team's expected goals\n    xp += expected_assists_player_contribution * self.fpl_points[\"assist_points\"]\n\n    # 4. Expected Clean Sheets (for GKs/DEFs/MIDs) and Conceded Goals deduction\n    expected_conceded = self._calculate_expected_conceded_goals(\n        player_team_strength_defence, opponent_team_strength_attack\n    )\n\n    # Probability of clean sheet\n    # Simplified: higher team defense / lower opponent attack -&gt; higher CS prob\n    # Use logistic or sigmoid for probability\n    cs_prob = 1.0 / (\n        1.0 + math.exp(expected_conceded - 1.0)\n    )  # Sigmoid centered at 1 goal\n\n    if position in [\"GK\", \"DEF\"]:\n        xp += cs_prob * self.fpl_points[\"clean_sheet_gk_def\"]\n\n        # Conceded goals deduction: Apply penalty for every 2 goals conceded *probability*\n        # For simplicity, calculate expected deduction: (expected_conceded / 2) * deduction\n        xp += (expected_conceded / 2.0) * self.fpl_points[\n            \"conceded_2_goals_deduction\"\n        ]\n    elif position == \"MID\":\n        xp += cs_prob * self.fpl_points[\"clean_sheet_mid\"]\n\n    # 5. Expected Saves (for GKs)\n    if position == \"GK\":\n        saves_per_90_hist = (\n            (player[\"saves\"] / player[\"minutes\"] * 90)\n            if player[\"minutes\"] &gt; 0\n            else 0.0\n        )\n        # Expected saves scaled by opponent's attacking strength (more attacking -&gt; more shots -&gt; more saves)\n        expected_saves_player_contribution = (\n            (saves_per_90_hist / 90.0)\n            * expected_minutes\n            * (opponent_team_strength_attack / player_team_strength_defence)\n        )\n        xp += (expected_saves_player_contribution / 3.0) * self.fpl_points[\n            \"saves_3_points\"\n        ]  # Using the new config point value\n\n        # Penalty saves (low probability, use historical rate)\n        penalty_saves_hist_per_game = (\n            player[\"penalties_saved\"] / (player[\"minutes\"] / 90.0)\n            if player[\"minutes\"] &gt; 0\n            else 0.0\n        )\n        xp += (\n            penalty_saves_hist_per_game\n            * (expected_minutes / 90.0)\n            * self.fpl_points[\"penalty_save_points\"]\n        )\n\n    # 6. Expected Bonus Points\n    # Use BPS (Bonus Points System) as a proxy. Scale player's average BPS by form and expected minutes.\n    bps_per_90_hist = (\n        (player[\"bps\"] / player[\"minutes\"] * 90) if player[\"minutes\"] &gt; 0 else 0.0\n    )\n    expected_bps = (bps_per_90_hist / 90.0) * expected_minutes * player[\"form\"]\n    xp += expected_bps * self.fpl_points[\"bonus_points_scaling_factor\"]\n\n    # 7. Minor Negative Events (Probabilistic)\n    # These are rare, so a simple probability based on expected minutes.\n    xp += (expected_minutes / 90.0) * (\n        self.fpl_points[\"yellow_card_deduction\"] * YELLOW_CARD_PROB\n        + self.fpl_points[\"red_card_deduction\"] * RED_CARD_PROB\n        + self.fpl_points[\"own_goal_deduction\"] * OWN_GOAL_PROB\n        + self.fpl_points[\"penalty_miss_deduction\"] * PENALTY_MISS_PROB\n    )\n\n    # 8. Defensive Contribution Points (for 2025/26 season heuristic)\n    # Assuming CBIT/CBIRT tracking\n    if position in [\"GK\", \"DEF\"]:\n        xp += CBIT_DEF_PROB * self.fpl_points[\"cbit_def_points\"]\n    elif position in [\"MID\", \"FWD\"]:\n        xp += CBIRT_MID_FWD_PROB * self.fpl_points[\"cbirt_mid_fwd_points\"]\n\n    return {\"xp\": round(xp, 2), \"reason\": \"Success\"}\n</code></pre>"},{"location":"autoapi/fpl_solver/fpl_xp_predictor/#fpl_solver.fpl_xp_predictor.FPLPredictor.get_players_for_optimizer","title":"<code>get_players_for_optimizer()</code>","text":"<p>Returns the list of player data with calculated xP per gameweek, formatted for the FPLOptimizer.</p> Source code in <code>fpl_solver/fpl_xp_predictor.py</code> <pre><code>def get_players_for_optimizer(self):\n    \"\"\"\n    Returns the list of player data with calculated xP per gameweek,\n    formatted for the FPLOptimizer.\n    \"\"\"\n    return self.all_players_xp_calculated_data\n</code></pre>"},{"location":"autoapi/fpl_solver/fpl_xp_predictor/#fpl_solver.fpl_xp_predictor.FPLPredictor.get_upcoming_fixtures","title":"<code>get_upcoming_fixtures(limit=None)</code>","text":"<p>Returns a list of upcoming fixtures, sorted by gameweek and kickoff time. Optionally limits the number of fixtures returned.</p> Source code in <code>fpl_solver/fpl_xp_predictor.py</code> <pre><code>def get_upcoming_fixtures(self, limit=None):\n    \"\"\"\n    Returns a list of upcoming fixtures, sorted by gameweek and kickoff time.\n    Optionally limits the number of fixtures returned.\n    \"\"\"\n    upcoming = []\n    now = datetime.now()\n\n    # Sort all fixtures by gameweek and then by kickoff time\n    sorted_fixtures = sorted(\n        self.fixtures_data.values(),\n        key=lambda x: (\n            x.get(\"event\", 0),\n            x.get(\"kickoff_time\", \"9999-12-31T00:00:00Z\"),\n        ),\n    )\n\n    current_gameweek = None\n    for fixture_data in sorted_fixtures:\n        # Determine current gameweek from the earliest upcoming fixture\n        if not fixture_data[\"finished\"] and current_gameweek is None:\n            current_gameweek = fixture_data.get(\"event\", 0)\n\n        # Filter for upcoming fixtures within the prediction horizon\n        if (\n            fixture_data.get(\"event\", 0) &lt; current_gameweek  # Skip past gameweeks\n            or fixture_data.get(\"event\", 0)\n            &gt;= current_gameweek + self.gameweeks_to_predict\n        ):\n            continue  # Skip fixtures outside the prediction horizon\n\n        home_team_name = self.teams_data.get(\n            fixture_data[\"team_h\"], {}\n        ).get(  # Use 'team_h'\n            \"name\", \"Unknown\"\n        )\n        away_team_name = self.teams_data.get(\n            fixture_data[\"team_a\"], {}\n        ).get(  # Use 'team_a'\n            \"name\", \"Unknown\"\n        )\n\n        # Only add fixtures that are not finished\n        if not fixture_data[\"finished\"]:\n            upcoming.append(\n                {\n                    \"fixture_id\": fixture_data[\"id\"],\n                    \"gameweek\": fixture_data.get(\"event\"),\n                    \"home_team_id\": fixture_data[\"team_h\"],  # Use 'team_h'\n                    \"away_team_id\": fixture_data[\"team_a\"],  # Use 'team_a'\n                    \"match\": f\"{home_team_name} vs {away_team_name}\",\n                    \"kickoff_time\": fixture_data.get(\"kickoff_time\"),\n                    \"home_team_difficulty\": fixture_data[\"team_h_difficulty\"],\n                    \"away_team_difficulty\": fixture_data[\"team_a_difficulty\"],\n                }\n            )\n        if limit is not None and len(upcoming) &gt;= limit:\n            break\n    return upcoming\n</code></pre>"}]}